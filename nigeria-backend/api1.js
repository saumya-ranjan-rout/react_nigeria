
const mysql = require('mysql');
const express = require("express");
const cors = require('cors');
const app = express();
const bcrypt = require('bcrypt');
const crypto = require('crypto');
const sqlString = require('sqlstring');
const multer = require('multer');
const csv = require('csv-parser');
const upload = multer({ dest: 'uploads/' });
const fs = require('fs');
const path = require('path');// ETA Nigeria
const jwt = require('jsonwebtoken');
const properties = require(`./properties.json`);

const environment = properties.env.environment || 'development';
const authenticateJWT = require('./middleware/authenticateJWT');
const config = require(`./config.${environment}.json`);

const swaggerUi = require('swagger-ui-express');
const swaggerSpec = require('./swagger');

const dbConfig = {
  host: config.database.host,
  user: config.database.username,
  password: config.database.password,
  port: config.database.port,
  database: config.database.databaseName,
  connectionLimit: 10,
};
const db = mysql.createConnection(dbConfig);
db.connect();

// Create a MySQL connection pool
const dbPool = mysql.createPool(dbConfig);

// Utility function to get a connection from the pool
const getPoolConnection = () => {
  return new Promise((resolve, reject) => {
    dbPool.getConnection((err, connection) => {
      if (err) {
        console.error('Error acquiring connection:', err);
        reject(err);
      } else {
        resolve(connection);
      }
    });
  });
};

// Utility function to execute a query
const executeQuery = (connection, sqlQuery, values) => {
  return new Promise((resolve, reject) => {
    connection.query(sqlQuery, values, (err, results) => {
      if (err) {
        reject(err);
      } else {
        resolve(results);
      }
    });
  });
};


// Function to begin a transaction
const beginTransaction = async (connection) => {
  await connection.beginTransaction();
};

// Function to commit a transaction
const commitTransaction = async (connection) => {
  await connection.commit();
};

// Function to rollback a transaction
const rollbackTransaction = async (connection) => {
  await connection.rollback();
};

module.exports = db;
app.use('/api-docs', swaggerUi.serve, swaggerUi.setup(swaggerSpec));
app.use(cors());
app.use(express.urlencoded({
    extended:true
}));
app.use(express.json());
// Increase the payload size limit to 10MB (adjust the limit as per your requirement)
app.use(express.json({ limit: '10mb' }));
app.use(express.urlencoded({ limit: '10mb', extended: true }));



const secretKey = config.auth.secretKey;

// API endpoint for login validation
app.post('/signin', async (req, res) => {
  const { email, password } = req.body;
  let connection;
  try {
    connection = await getPoolConnection();
    const user = await executeQuery(connection,'SELECT id,roleid,username,entryid,email,pass,production_type,category_type FROM geopos_users WHERE email = ? OR username = ?', [email, email]);
    
    if (user.length > 0) {
      const userId = `${user[0].id}`;
      const hashedPassword = hashPassword(password, userId);
      
      if (hashedPassword === user[0].pass) {
        const user_details = {
          id: user[0].id,
          roleid: user[0].roleid,
          username: user[0].username,
          entryid: user[0].entryid,
          email: user[0].email,
        };
        const token = jwt.sign(user_details, secretKey);
        res.json({ success: true, result: user, token: token });
      } else {
        res.json({ success: false, message: 'Invalid password' });
      }
    } else {
      res.json({ success: false, message: 'Invalid username' });
    }
  } catch (error) {
    console.error('An error occurred:', error);
    res.status(500).json({ success: false, message: 'An error occurred during login' });
  } finally {
    if (connection) {
      connection.release();
    }
  }
});


const configVars = {
  usePasswordHash: false,
  passwordHashOptions: {
    saltRounds: 10, // Adjust the number of salt rounds as needed
    // Other bcrypt options can be added here
  },
  hash: 'sha256', // Set your desired hash algorithm (e.g., 'sha256')
};

// Function to hash a password
function hashPassword(pass, userId) {
  if (configVars.usePasswordHash) {
    const saltRounds = configVars.passwordHashOptions.saltRounds || 10; // Set your desired salt rounds
    return bcrypt.hash(pass, saltRounds);
  } else {
    const salt = crypto.createHash('md5').update(userId).digest('hex'); // Calculate MD5 hash
    const hashAlgorithm = configVars.hash || 'sha256'; // Set your desired hash algorithm
    return crypto.createHash(hashAlgorithm).update(salt + pass).digest('hex');
  }  
}

// app.get('/getuserbyid/:id',  authenticateJWT,async (req, res) => {
//   const id = req.params.id
//   db.query('SELECT * FROM geopos_users WHERE id=?', [id], (err, result) => {
//     if (err) {
//       console.log(err)
//     }
//     res.send(result[0]); // Send only the name value from the result

//   })
// });

app.get('/getuserbyid/:id', authenticateJWT, async (req, res) => {
  const id = req.params.id; // Extract the ID parameter from the request URL
  let connection;
  try {
    // Get a connection from the pool
    connection = await getPoolConnection();
    const result = await executeQuery(connection,'SELECT name FROM geopos_users WHERE id=?', [id]);
    res.send(result[0]); // Send the first row of the query result as the response
  } catch (err) {
    console.error(err); // Log any errors that occur during the query
    res.status(500).send('Internal Server Error');     // Send an HTTP 500 response for any errors
  }finally {
    // Release the connection back to the pool
    if (connection) {
      connection.release();
      //console.log("Connection released");
    }
  }
});


// Database Connection
app.get("/db", authenticateJWT, async (req, res) => {
  let connection;
  try {
    // Get a connection from the connection pool
    connection = await getPoolConnection();

    // Execute the query
    const result = await executeQuery(connection, "SELECT * FROM geopos_users");

    // Sending the result back to the client
    res.send(result);
    console.log(result);
  } catch (err) {
    console.error(err);
    res.status(500).send("Internal Server Error");
  } finally {
    // Release the connection back to the pool
    if (connection) {
      connection.release();
    }
  }
});


//-------------------------QC Notification BELL-------------------------------------------//
//get notifications bell count
app.get('/getnotificationbellcount', authenticateJWT, async(req, res) => {
  let connection;
  try {
    // Get a connection from the pool
    connection = await getPoolConnection();
    
    const query = "SELECT * FROM qc_master";
    const results = await executeQuery(connection, query);

    let output = '';
    let count = 0;

    for (const data1 of results) {
      let col = '';

      if (data1.id === 1) {
        col = 'upper';
      } else if (data1.id === 2) {
        col = 'lower';
      } else if (data1.id === 3) {
        col = 'perheating';
      } else if (data1.id === 4) {
        col = 'machine_speed';
      } else if (data1.id === 5) {
        col = 'tension';
      } else if (data1.id === 6) {
        col = 'spreading';
      } else {
        continue; // Skip to the next iteration
      }

      
       const date = new Date().toLocaleDateString('en-GB', { timeZone: 'Africa/Lagos' });
      const parts = date.split('/');
      const formattedDay = parts[0].padStart(2, '0');
      const formattedMonth = parts[1].padStart(2, '0');
      const year = parts[2];
      const date1 = `${formattedDay}-${formattedMonth}-${year}`; 


      //const date1 = `03-10-2023`;
      const val = data1.value;

      const query1 = `SELECT * FROM geopos_operator WHERE date='${date1}' AND ${col} > ${val} ORDER BY id DESC LIMIT 2`;

      const res1 = await executeQuery(connection, query1);

      const num = res1.length;
      let str = '';

      if (num > 0) {
        str += `${data1.name} `;
        count++;
      }

      for (const row of res1) {
        str += `${row.zone}[ ${row.machine} ] -> ${row[col]} [ ${row.hr_start}-${row.hr_end} ], `;
      }

      if (str !== '') {
        output += str;
      }
    }

    // Include the count in the response
    const response = {
      count: count,
      output: output,
    };

    res.header('Content-Type', 'text/plain');
    res.send(JSON.stringify(response));
  } catch (error) {
    console.error('Error:', error);
    res.status(500).send('Internal Server Error');
  } finally {
    // Release the connection back to the pool
    if (connection) {
      connection.release();
      console.log('Connection released');
    }
  }
});
//-------------------------QC Notification BELL-------------------------------------------//

//-------------------------Data accuracy-------------------------------------------//
//get data accuracy 
app.post('/getdataaccuracy',  authenticateJWT, async (req, res) => {
  let connection;
  try{
    connection = await getPoolConnection();
  const roleid = req.body.roleid;
  const userid = req.body.userid;
  const date = new Date().toLocaleDateString('en-GB', { timeZone: 'Africa/Lagos' });
  const parts = date.split('/');
  const day = parts[0].padStart(2, '0');
  const month = parts[1].padStart(2, '0');
  const year = parts[2];
  const currentMonth = `${month}-${year}`;
  const currentDate = `${day}-${month}-${year}`;
  //console.log('Current Date:', currentDate);
  let whereConditions = [];
  whereConditions.push(`worker_timesheet.date_time = '${currentDate}'`);
  if (roleid == 3) {
    //whereConditions.push(`worker_timesheet.operator_id = '${userid}'`);
  }
  const whereClause = whereConditions.join(' AND ');
  
  
  const query = `
    SELECT worker_timesheet.*, item_masterr.item_description, section.section_name,
           ((HOUR1 + HOUR2 + HOUR3 + HOUR4 + HOUR5 + HOUR6 + HOUR7 + HOUR8 + HOUR9 + HOUR10 + HOUR11) / target) AS value_sum
    FROM worker_timesheet
    LEFT JOIN item_masterr ON item_masterr.id = worker_timesheet.product_name
    LEFT JOIN section ON section.id = worker_timesheet.section
    WHERE ${whereClause}
    GROUP BY worker_timesheet.date_time, worker_timesheet.entry_id, worker_timesheet.product_name,
             worker_timesheet.section, worker_timesheet.shift, worker_timesheet.line
    HAVING value_sum * 100 > 150;
  `;
  const results = await executeQuery(connection, query);
    const data = {
      timesheet: results,
      date: currentDate
    };
    res.json(data);

  }catch (error) {
    console.error('Error:', error);
    res.status(500).send('Internal Server Error');
  } finally {
    // Release the connection back to the pool
    if (connection) {
      connection.release();
      console.log('Connection released');
    }
  }
});

//get data accuracy search
app.post('/getdataaccuracysearch',  authenticateJWT,async (req, res) => {
  let connection;
  try{
  connection = await getPoolConnection();
  const roleid = req.body.roleid;
  const userid = req.body.userid;
  var product_name = req.body.product_id;
  var section = req.body.section_id;
  var shift = req.body.shift;
  var line_no = req.body.line_no;
  var day_night = req.body.day_night;
 
const fromdate = req.body.fromdate;
const fdParts = fromdate.split('-');
const fd = `${fdParts[2]}-${fdParts[1]}-${fdParts[0]}`;

const todate = req.body.todate;
const tdParts = todate.split('-');
const td = `${tdParts[2]}-${tdParts[1]}-${tdParts[0]}`;


const dateObj = new Date(fromdate);

const day = dateObj.getDate().toString().padStart(2, '0');
const month = (dateObj.getMonth() + 1).toString().padStart(2, '0');
const year = dateObj.getFullYear();

const convertedDate = `${day}-${month}-${year}`;

const dateObj1 = new Date(todate);
const day1 = dateObj1.getDate().toString().padStart(2, '0');
const month1 = (dateObj1.getMonth() + 1).toString().padStart(2, '0');
const year1 = dateObj1.getFullYear();

const convertedDate1 = `${day1}-${month1}-${year1}`;

console.log('fromdate:', fromdate);
console.log('todate:', todate);
console.log('Converted:', convertedDate);
console.log('Converted2:', convertedDate1);


const fd2 = Math.floor(new Date(fromdate).getTime() / 1000);
const td1 = Math.floor(new Date(todate).getTime() / 1000);
const fd1 = Math.floor(new Date(fd2 * 1000).setDate(new Date(fd2 * 1000).getDate() - 1) / 1000);

var newfd = fd1;
var newtd = td1;

  let whereConditions = [];

  if (fromdate !== '' && todate !== '' && fromdate !== undefined && todate !== undefined && fromdate != null && todate != null) {
    whereConditions.push(`worker_timesheet.time_stamp BETWEEN '${newfd}' AND '${newtd}'`);
  }
  else {
    res.status(400).json({ error: 'Invalid date range provided' });
    return;
  }

  if (product_name !== '' && product_name !== undefined && product_name != null) {
    whereConditions.push(`worker_timesheet.product_name = '${product_name}'`);
  }
  if (section !== '' && section !== undefined && section != null) {
    whereConditions.push(`worker_timesheet.section = '${section}'`);
  }
  if (shift !== '' && shift !== undefined && shift != null) {
    whereConditions.push(`worker_timesheet.shift = '${shift}'`);
  }
  if (line_no !== '' && line_no !== undefined && line_no != null) {
    whereConditions.push(`worker_timesheet.line = '${line_no}'`);
  }
  if (day_night !== '' && day_night !== undefined && day_night != null) {
    whereConditions.push(`worker_timesheet.day_night = '${day_night}'`);
  }

  if (roleid == 3) {
    //whereConditions.push(`worker_timesheet.operator_id = '${userid}'`);
  }
  const whereClause = whereConditions.join(' AND ');
  const query = `
   SELECT worker_timesheet.*, item_masterr.item_description, section.section_name,((HOUR1+HOUR2+HOUR3+HOUR4+HOUR5+HOUR6+HOUR7+HOUR8+HOUR9+HOUR10+HOUR11) / target) AS value_sum
                   FROM worker_timesheet
                   LEFT JOIN item_masterr ON item_masterr.id = worker_timesheet.product_name
                   LEFT JOIN section ON section.id = worker_timesheet.section
                   WHERE ${whereClause}
                   GROUP BY worker_timesheet.date_time,worker_timesheet.entry_id,worker_timesheet.product_name,worker_timesheet.section,worker_timesheet.shift,worker_timesheet.line HAVING (value_sum * 100) > 150`;
  const results = await executeQuery(connection, query);
  const data = {
    timesheet: results,
    product: product_name,
    line: line_no,
    fdate: convertedDate,
    tdate: convertedDate1,
    shift: shift,
    section: section
  };

  res.json(data);
}catch (error) {
  /**
   * Handle exceptions and send an appropriate response.
   * @throws {ForbiddenError} Will throw an error if the user is not authorized.
   * @throws {InternalServerError} Will throw an error if there's an issue with handling exceptions.
  */
  console.error('Error:', error.message);
  res.status(500).json({ success: false, message: 'An error occurred during fetch' });
} finally {
  // Release the connection back to the pool in case of success or error
  if (connection) {
    connection.release();
    //console.log("Connection released");
  }
}
});

//-------------------------Data accuracy-------------------------------------------//

//--------------------------DASHBOARD PAGE DATA ---------------------------//

//Get ota date
/**
 * @swagger
 * /otadate:
 *   get:
 *     summary: Get the latest employee OTA entry.
 *     description: Retrieves the latest entry from the employees_ota table.
 *     tags:
 *       - OTA
 *     security:
 *       - BearerAuth: []
 *     responses:
 *       200:
 *         description: Successful response with the latest OTA entry.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 id:
 *                   type: integer
 *                   description: ID of the OTA entry.
 *                   example: 1
 *                 employee_id:
 *                   type: integer
 *                   description: ID of the employee.
 *                   example: 1234
 *                 date:
 *                   type: string
 *                   format: date
 *                   description: Date of the OTA entry.
 *                   example: "2024-06-05"
 *                 hours:
 *                   type: integer
 *                   description: Number of hours for the OTA.
 *                   example: 4
 *       500:
 *         description: An error occurred while fetching the OTA entry.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 success:
 *                   type: boolean
 *                   example: false
 *                 message:
 *                   type: string
 *                   example: "An error occurred during fetch"
 *
 * @function
 * @name getLatestOTAEntry
 * @memberof module:Routes/OTA
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {ForbiddenError} Will throw an error if the user is not authorized.
 * @throws {InternalServerError} Will throw an error if there's an issue with handling exceptions.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
app.get("/otadate",  authenticateJWT, async(req, res) => {
  let connection;
  try{
    // Get a connection from the pool
    connection = await getPoolConnection();
    // Perform queries using the 'connection'
    const sqlQuery = 'SELECT * FROM employees_ota order by id asc limit 1';
    const result = await executeQuery(connection, sqlQuery);
    res.send(result);
  } catch (error) {
    /**
     * Handle exceptions and send an appropriate response.
     * @throws {ForbiddenError} Will throw an error if the user is not authorized.
     * @throws {InternalServerError} Will throw an error if there's an issue with handling exceptions.
    */
    console.error('Error:', error.message);
    res.status(500).json({ success: false, message: 'An error occurred during fetch' });
  } finally {
    // Release the connection back to the pool in case of success or error
    if (connection) {
      connection.release();
      //console.log("Connection released");
    }
  }
 
}); 

//Get ikeja date
/**
 * @swagger
 * /ikejadate:
 *   get:
 *     summary: Get the latest employee geopositioning entry.
 *     description: Retrieves the latest entry from the geopos_employees table.
 *     tags:
 *       - Geopositioning
 *     security:
 *       - BearerAuth: []
 *     responses:
 *       200:
 *         description: Successful response with the latest geopositioning entry.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 id:
 *                   type: integer
 *                   description: ID of the geopositioning entry.
 *                   example: 1
 *                 employee_id:
 *                   type: integer
 *                   description: ID of the employee.
 *                   example: 1234
 *                 latitude:
 *                   type: number
 *                   format: double
 *                   description: Latitude of the employee's location.
 *                   example: 6.5244
 *                 longitude:
 *                   type: number
 *                   format: double
 *                   description: Longitude of the employee's location.
 *                   example: 3.3792
 *                 timestamp:
 *                   type: string
 *                   format: date-time
 *                   description: Timestamp of the geopositioning entry.
 *                   example: "2024-06-05T12:30:00Z"
 *       500:
 *         description: An error occurred while fetching the geopositioning entry.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 success:
 *                   type: boolean
 *                   example: false
 *                 message:
 *                   type: string
 *                   example: "An error occurred during login"
 *
 * @function
 * @name getLatestGeopositioningEntry
 * @memberof module:Routes/Geopositioning
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {ForbiddenError} Will throw an error if the user is not authorized.
 * @throws {InternalServerError} Will throw an error if there's an issue with handling exceptions.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
app.get("/ikejadate",authenticateJWT,async (req, res) => {
  let connection;
  try{
     // Get a connection from the pool
     connection = await getPoolConnection();   
     // Execute the query with the connection
     const results = await executeQuery(connection,'SELECT * FROM geopos_employees order by id asc limit 1');
     res.send(results);
  } catch (error) {
    // Handle exceptions
    console.error('Error:', error.message);
    //res.status(500).json({ error: 'Internal Server Error' });
    res.status(500).json({ success: false, message: 'An error occurred during login' });
  } finally {
    // Release the connection back to the pool in case of success or error
    if (connection) {
      connection.release();
      //console.log("Connection released");
    }
  }

}); 


//Get ril total worker
/**
 * @swagger
 * /totalworkerril:
 *   get:
 *     summary: Get the total number of active workers for RIL on a specific date.
 *     description: Retrieves the total count of active workers for RIL (Reliance Industries Limited) on a specific date from the employees_ota table.
 *     tags:
 *       - Workers
 *     security:
 *       - BearerAuth: []
 *     responses:
 *       200:
 *         description: Successful response with the total count of active workers for RIL.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 totalWorkerCount:
 *                   type: integer
 *                   description: Total count of active workers for RIL.
 *                   example: 50
 *       500:
 *         description: An error occurred while fetching the total count of active workers for RIL.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 success:
 *                   type: boolean
 *                   example: false
 *                 message:
 *                   type: string
 *                   example: "Internal Server Error"
 *
 * @function
 * @name getTotalWorkerCountRIL
 * @memberof module:Routes/Workers
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with handling exceptions.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
app.get("/totalworkerril", authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();   
    const query = `
      SELECT * FROM employees_ota
      ORDER BY id ASC
      LIMIT 1;
    `;
    const results = await executeQuery(connection,query);

    if (results.length === 0) {
      //console.log('No records found');
      return;
    }

    const dt = results[0].date;
    const whereClause = `roleid = '1' AND passive_type = 'ACT' AND date = '${dt}' AND staff = 'RIL'`;

    const countQuery = `
      SELECT COUNT(*) AS totalWorkerCount
      FROM employees_ota
      WHERE ${whereClause};
    `;
  
    const countResults = await executeQuery(connection,countQuery);
    const totalCount = countResults[0].totalWorkerCount;
    //console.log('Total Worker Count:', totalCount);
    res.send(countResults);
  } catch (error) {
    console.error('Error:', error);
    res.status(500).send('Internal Server Error');
  }
  finally {
     // Release the connection back to the pool in case of success or error
     if (connection) {
       connection.release();
       //console.log("Connection released");
     }
   }
});

//Get ril present worker 
/**
 * @swagger
 * /presentworkerril:
 *   get:
 *     summary: Get the total number of present workers for RIL on a specific date.
 *     description: Retrieves the total count of present workers for RIL (Reliance Industries Limited) on a specific date from the employees_ota table.
 *     tags:
 *       - Workers
 *     security:
 *       - BearerAuth: []
 *     responses:
 *       200:
 *         description: Successful response with the total count of present workers for RIL.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 totalPresentCount:
 *                   type: integer
 *                   description: Total count of present workers for RIL.
 *                   example: 30
 *       500:
 *         description: An error occurred while fetching the total count of present workers for RIL.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 success:
 *                   type: boolean
 *                   example: false
 *                 message:
 *                   type: string
 *                   example: "An error occurred during login"
 *
 * @function
 * @name getTotalPresentWorkerCountRIL
 * @memberof module:Routes/Workers
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with handling exceptions.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
app.get("/presentworkerril", authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    const query = `
      SELECT * FROM employees_ota
      ORDER BY id ASC
      LIMIT 1;
    `;
    const results = await executeQuery(connection,query);

    if (results.length === 0) {
      //console.log('No records found');
      return;
    }

    const dt = results[0].date;
    const whereClause = `roleid = '1' AND passive_type = 'ACT' AND date = '${dt}' AND staff = 'RIL' AND status = 'P'`;

    const countQuery = `
      SELECT COUNT(*) AS totalPresentCount
      FROM employees_ota
      WHERE ${whereClause};
    `;
  
    const countResults = await executeQuery(connection,countQuery);
    const totalCount = countResults[0].totalPresentCount;
    //console.log('Total Present Worker Count:', totalCount);
    res.send(countResults);
  } catch (error) {
    // Handle exceptions
    console.error('Error:', error.message);
    //res.status(500).json({ error: 'Internal Server Error' });
    res.status(500).json({ success: false, message: 'An error occurred during login' });
  } finally {
    // Release the connection back to the pool
    if (connection) {
      connection.release();
      console.log('Connection released');
    }   
  }
});

//Get ril absent worker 
/**
 * @swagger
 * /absentworkerril:
 *   get:
 *     summary: Get the total number of absent workers for RIL on a specific date.
 *     description: Retrieves the total count of absent workers for RIL (Reliance Industries Limited) on a specific date from the employees_ota table.
 *     tags:
 *       - Workers
 *     security:
 *       - BearerAuth: []
 *     responses:
 *       200:
 *         description: Successful response with the total count of absent workers for RIL.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 totalAbsentCount:
 *                   type: integer
 *                   description: Total count of absent workers for RIL.
 *                   example: 20
 *       500:
 *         description: An error occurred while fetching the total count of absent workers for RIL.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 success:
 *                   type: boolean
 *                   example: false
 *                 message:
 *                   type: string
 *                   example: "Internal Server Error"
 *
 * @function
 * @name getTotalAbsentWorkerCountRIL
 * @memberof module:Routes/Workers
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with handling exceptions.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
app.get("/absentworkerril", authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();   
    const query = `
      SELECT * FROM employees_ota
      ORDER BY id ASC
      LIMIT 1;
    `;
    const results = await executeQuery(connection,query);

    if (results.length === 0) {
      //console.log('No records found');
      return;
    }

    const dt = results[0].date;
    const whereClause = `roleid = '1' AND passive_type = 'ACT' AND date = '${dt}' AND staff = 'RIL' AND status = 'A'`;

    const countQuery = `
      SELECT COUNT(*) AS totalAbsentCount
      FROM employees_ota
      WHERE ${whereClause};
    `;
  
    const countResults = await executeQuery(connection,countQuery);
    const totalCount = countResults[0].totalAbsentCount;
    //console.log('Total Absent Worker Count:', totalCount);
    res.send(countResults);
  } catch (error) {
    console.error('Error:', error);
    res.status(500).send('Internal Server Error');
  }finally {
    // Release the connection back to the pool in case of success or error
    if (connection) {
      connection.release();
      //console.log("Connection released");
    }
  }
});

//Get lorna total worker 
/**
 * @swagger
 * /totalworkerlorna:
 *   get:
 *     summary: Get the total number of workers for LORNA on a specific date.
 *     description: Retrieves the total count of workers for LORNA on a specific date from the employees_ota table.
 *     tags:
 *       - Workers
 *     security:
 *       - BearerAuth: []
 *     responses:
 *       200:
 *         description: Successful response with the total count of workers for LORNA.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 totalWorkerCount:
 *                   type: integer
 *                   description: Total count of workers for LORNA.
 *                   example: 50
 *       500:
 *         description: An error occurred while fetching the total count of workers for LORNA.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 success:
 *                   type: boolean
 *                   example: false
 *                 message:
 *                   type: string
 *                   example: "Internal Server Error"
 *
 * @function
 * @name getTotalWorkerCountLORNA
 * @memberof module:Routes/Workers
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with handling exceptions.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
app.get("/totalworkerlorna", authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    const query = `
      SELECT * FROM employees_ota
      ORDER BY id ASC
      LIMIT 1;
    `;
    const results = await executeQuery(connection,query);

    if (results.length === 0) {
      //console.log('No records found');
      return;
    }

    const dt = results[0].date;
    const whereClause = `roleid = '1' AND passive_type = 'ACT' AND date = '${dt}' AND staff = 'LORNA'`;

    const countQuery = `
      SELECT COUNT(*) AS totalWorkerCount
      FROM employees_ota
      WHERE ${whereClause};
    `;
  
    const countResults = await executeQuery(connection,countQuery);
    const totalCount = countResults[0].totalWorkerCount;
    //console.log('Total Worker Count:', totalCount);
    res.send(countResults);
  } catch (error) {
    console.error('Error:', error);
    res.status(500).send('Internal Server Error');
  } finally {
    // Release the connection back to the pool in case of success or error
    if (connection) {
      connection.release();
      //console.log("Connection released");
    }
  }
});


//Get lorna present worker 
/**
 * @swagger
 * /presentworkerlorna:
 *   get:
 *     summary: Get the total number of present workers for LORNA on a specific date.
 *     description: Retrieves the total count of present workers for LORNA (example company) on a specific date from the employees_ota table.
 *     tags:
 *       - Workers
 *     security:
 *       - BearerAuth: []
 *     responses:
 *       200:
 *         description: Successful response with the total count of present workers for LORNA.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 totalPresentCount:
 *                   type: integer
 *                   description: Total count of present workers for LORNA.
 *                   example: 30
 *       500:
 *         description: An error occurred while fetching the total count of present workers for LORNA.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 success:
 *                   type: boolean
 *                   example: false
 *                 message:
 *                   type: string
 *                   example: "Internal Server Error"
 *
 * @function
 * @name getTotalPresentWorkerCountLORNA
 * @memberof module:Routes/Workers
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with handling exceptions.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
app.get("/presentworkerlorna", authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();  
    const query = `
      SELECT * FROM employees_ota
      ORDER BY id ASC
      LIMIT 1;
    `;
    const results = await executeQuery(connection,query);

    if (results.length === 0) {
      //console.log('No records found');
      return;
    }

    const dt = results[0].date;
    const whereClause = `roleid = '1' AND passive_type = 'ACT' AND date = '${dt}' AND staff = 'LORNA' AND status = 'P'`;

    const countQuery = `
      SELECT COUNT(*) AS totalPresentCount
      FROM employees_ota
      WHERE ${whereClause};
    `;
  
    const countResults = await executeQuery(connection,countQuery);
    const totalCount = countResults[0].totalPresentCount;
    //console.log('Total Present Worker Count:', totalCount);
    res.send(countResults);
  } catch (error) {
    console.error('Error:', error);
    res.status(500).send('Internal Server Error');
  } finally {
    // Release the connection back to the pool in case of success or error
    if (connection) {
      connection.release();
      //console.log("Connection released");
    }
  }
});


//Get lorna absent worker 
/**
 * @swagger
 * /absentworkerlorna:
 *   get:
 *     summary: Get the total number of absent workers for LORNA on a specific date.
 *     description: Retrieves the total count of absent workers for LORNA (example company) on a specific date from the employees_ota table.
 *     tags:
 *       - Workers
 *     security:
 *       - BearerAuth: []
 *     responses:
 *       200:
 *         description: Successful response with the total count of absent workers for LORNA.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 totalAbsentCount:
 *                   type: integer
 *                   description: Total count of absent workers for LORNA.
 *                   example: 20
 *       500:
 *         description: An error occurred while fetching the total count of absent workers for LORNA.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 success:
 *                   type: boolean
 *                   example: false
 *                 message:
 *                   type: string
 *                   example: "Internal Server Error"
 *
 * @function
 * @name getTotalAbsentWorkerCountLORNA
 * @memberof module:Routes/Workers
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with handling exceptions.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
app.get("/absentworkerlorna", authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    const query = `
      SELECT * FROM employees_ota
      ORDER BY id ASC
      LIMIT 1;
    `;
    const results = await executeQuery(connection,query);

    if (results.length === 0) {
      //console.log('No records found');
      return;
    }

    const dt = results[0].date;
    const whereClause = `roleid = '1' AND passive_type = 'ACT' AND date = '${dt}' AND staff = 'LORNA' AND status = 'A'`;

    const countQuery = `
      SELECT COUNT(*) AS totalAbsentCount
      FROM employees_ota
      WHERE ${whereClause};
    `;
  
    const countResults = await executeQuery(connection,countQuery);
    const totalCount = countResults[0].totalAbsentCount;
    //console.log('Total Absent Worker Count:', totalCount);
    res.send(countResults);
  } catch (error) {
    console.error('Error:', error);
    res.status(500).send('Internal Server Error');
  } finally {
    // Release the connection back to the pool in case of success or error
    if (connection) {
      connection.release();
      //console.log("Connection released");
    }
  }
});

//Get ikeja total worker 
/**
 * @swagger
 * /totalworkerikeja:
 *   get:
 *     summary: Get the total number of workers in Ikeja on a specific date.
 *     description: Retrieves the total count of workers in Ikeja on a specific date from the geopos_employees table.
 *     tags:
 *       - Workers
 *     security:
 *       - BearerAuth: []
 *     responses:
 *       200:
 *         description: Successful response with the total count of workers in Ikeja.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 totalWorkerCount:
 *                   type: integer
 *                   description: Total count of workers in Ikeja.
 *                   example: 50
 *       500:
 *         description: An error occurred while fetching the total count of workers in Ikeja.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 success:
 *                   type: boolean
 *                   example: false
 *                 message:
 *                   type: string
 *                   example: "Internal Server Error"
 *
 * @function
 * @name getTotalWorkerCountIkeja
 * @memberof module:Routes/Workers
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with handling exceptions.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
app.get("/totalworkerikeja", authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    const query = `
      SELECT * FROM geopos_employees
      ORDER BY id ASC
      LIMIT 1;
    `;
    const results = await executeQuery(connection,query);

    if (results.length === 0) {
      //console.log('No records found');
      return;
    }

    const dt = results[0].date;
    const whereClause = `roleid = '1' AND passive_type = 'ACT' AND date = '${dt}'`;

    const countQuery = `
      SELECT COUNT(*) AS totalWorkerCount
      FROM geopos_employees
      WHERE ${whereClause};
    `;
  
    const countResults = await executeQuery(connection,countQuery);
    const totalCount = countResults[0].totalWorkerCount;
    //console.log('Total Worker Count:', totalCount);
    res.send(countResults);
  } catch (error) {
    console.error('Error:', error);
    res.status(500).send('Internal Server Error');
  } finally {
    // Release the connection back to the pool in case of success or error
    if (connection) {
      connection.release();
      //console.log("Connection released");
    }
  }
});
 

//Get ikeja present worker 
/**
 * @swagger
 * /presentworkerikeja:
 *   get:
 *     summary: Get the total number of present workers in Ikeja on a specific date.
 *     description: Retrieves the total count of present workers in Ikeja on a specific date from the geopos_employees table.
 *     tags:
 *       - Workers
 *     security:
 *       - BearerAuth: []
 *     responses:
 *       200:
 *         description: Successful response with the total count of present workers in Ikeja.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 totalPresentCount:
 *                   type: integer
 *                   description: Total count of present workers in Ikeja.
 *                   example: 30
 *       500:
 *         description: An error occurred while fetching the total count of present workers in Ikeja.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 success:
 *                   type: boolean
 *                   example: false
 *                 message:
 *                   type: string
 *                   example: "Internal Server Error"
 *
 * @function
 * @name getTotalPresentWorkerCountIkeja
 * @memberof module:Routes/Workers
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with handling exceptions.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
app.get("/presentworkerikeja", authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    const query = `
      SELECT * FROM geopos_employees
      ORDER BY id ASC
      LIMIT 1;
    `;
    const results = await executeQuery(connection,query);

    if (results.length === 0) {
      //console.log('No records found');
      return;
    }

    const dt = results[0].date;
    const whereClause = `roleid = '1' AND passive_type = 'ACT' AND date = '${dt}' AND status = 'P'`;

    const countQuery = `
      SELECT COUNT(*) AS totalPresentCount
      FROM geopos_employees
      WHERE ${whereClause};
    `;
  
    const countResults = await executeQuery(connection,countQuery);
    const totalCount = countResults[0].totalPresentCount;
    //console.log('Total Present Worker Count:', totalCount);
    res.send(countResults);
  } catch (error) {
    console.error('Error:', error);
    res.status(500).send('Internal Server Error');
  } finally {
    // Release the connection back to the pool in case of success or error
    if (connection) {
      connection.release();
      //console.log("Connection released");
    }
  }
});

//Get ikeja absent worker 
/**
 * @swagger
 * /absentworkerikeja:
 *   get:
 *     summary: Get the total number of absent workers in Ikeja on a specific date.
 *     description: Retrieves the total count of absent workers in Ikeja on a specific date from the geopos_employees table.
 *     tags:
 *       - Workers
 *     security:
 *       - BearerAuth: []
 *     responses:
 *       200:
 *         description: Successful response with the total count of absent workers in Ikeja.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 totalAbsentCount:
 *                   type: integer
 *                   description: Total count of absent workers in Ikeja.
 *                   example: 20
 *       500:
 *         description: An error occurred while fetching the total count of absent workers in Ikeja.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 success:
 *                   type: boolean
 *                   example: false
 *                 message:
 *                   type: string
 *                   example: "Internal Server Error"
 *
 * @function
 * @name getTotalAbsentWorkerCountIkeja
 * @memberof module:Routes/Workers
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with handling exceptions.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
app.get("/absentworkerikeja", authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    const query = `
      SELECT * FROM geopos_employees
      ORDER BY id ASC
      LIMIT 1;
    `;
    const results = await executeQuery(connection,query);

    if (results.length === 0) {
      //console.log('No records found');
      return;
    }

    const dt = results[0].date;
    const whereClause = `roleid = '1' AND passive_type = 'ACT' AND date = '${dt}' AND status = 'A'`;

    const countQuery = `
      SELECT COUNT(*) AS totalAbsentCount
      FROM geopos_employees
      WHERE ${whereClause};
    `;
  
    const countResults = await executeQuery(connection,countQuery);
    const totalCount = countResults[0].totalAbsentCount;
    //console.log('Total Absent Worker Count:', totalCount);
    res.send(countResults);
  } catch (error) {
    console.error('Error:', error);
    res.status(500).send('Internal Server Error');
  } finally {
    // Release the connection back to the pool in case of success or error
    if (connection) {
      connection.release();
      //console.log("Connection released");
    }
  }
});


//Get ril total operator
/**
 * @swagger
 * /totaloperatorril:
 *   get:
 *     summary: Get the total number of operators for RIL.
 *     description: Retrieves the total count of operators for RIL (example company) from the employees_ota table.
 *     tags:
 *       - Operators
 *     security:
 *       - BearerAuth: []
 *     responses:
 *       200:
 *         description: Successful response with the total count of operators for RIL.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 rilOpCount:
 *                   type: integer
 *                   description: Total count of operators for RIL.
 *                   example: 15
 *       500:
 *         description: An error occurred while fetching the total count of operators for RIL.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 success:
 *                   type: boolean
 *                   example: false
 *                 message:
 *                   type: string
 *                   example: "Internal Server Error"
 *
 * @function
 * @name getTotalOperatorCountRIL
 * @memberof module:Routes/Operators
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with handling exceptions.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
app.get("/totaloperatorril", authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    const query = `
      SELECT COUNT(*) AS rilOpCount
      FROM employees_ota
      WHERE roleid = '3' AND banned = '0' AND passive_type = 'ACT' AND staff = 'RIL';
    `;
  
    const results = await executeQuery(connection,query);
  
    const rilOpCount = results[0].rilOpCount;
    //console.log('RIL Operation Count:', rilOpCount);
    res.send(results);
  } catch (error) {
    console.error('Error:', error);
    res.status(500).send('Internal Server Error');
  } finally {
    // Release the connection back to the pool in case of success or error
    if (connection) {
      connection.release();
      //console.log("Connection released");
    }
  }
});


//Get lorna total operator
/**
 * @swagger
 * /totaloperatorlorna:
 *   get:
 *     summary: Get the total number of operators for LORNA.
 *     description: Retrieves the total count of operators for LORNA (example company) from the employees_ota table.
 *     tags:
 *       - Operators
 *     security:
 *       - BearerAuth: []
 *     responses:
 *       200:
 *         description: Successful response with the total count of operators for LORNA.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 lornaOpCount:
 *                   type: integer
 *                   description: Total count of operators for LORNA.
 *                   example: 10
 *       500:
 *         description: An error occurred while fetching the total count of operators for LORNA.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 success:
 *                   type: boolean
 *                   example: false
 *                 message:
 *                   type: string
 *                   example: "Internal Server Error"
 *
 * @function
 * @name getTotalOperatorCountLORNA
 * @memberof module:Routes/Operators
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with handling exceptions.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */    
app.get("/totaloperatorlorna", authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    const query = `
      SELECT COUNT(*) AS lornaOpCount
      FROM employees_ota
      WHERE roleid = 3
      AND passive_type = 'ACT'
      AND banned = 0
      AND staff = 'LORNA';
    `;

    const results = await executeQuery(connection,query);

    const lornaOpCount = results[0].lornaOpCount;
    // console.log('LORNA Operation Count:', lornaOpCount);
    res.send(results);
  } catch (error) {
    console.error('Error:', error);
    res.status(500).send('Internal Server Error');
  } finally {
    // Release the connection back to the pool in case of success or error
    if (connection) {
      connection.release();
      //console.log("Connection released");
    }
  }
});
 

//Get ikeja total operator
/**
 * @swagger
 * /totaloperatorikeja:
 *   get:
 *     summary: Get the total number of operators in Ikeja.
 *     description: Retrieves the total count of operators in Ikeja from the geopos_employees table.
 *     tags:
 *       - Operators
 *     security:
 *       - BearerAuth: []
 *     responses:
 *       200:
 *         description: Successful response with the total count of operators in Ikeja.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 ikejaOpCount:
 *                   type: integer
 *                   description: Total count of operators in Ikeja.
 *                   example: 25
 *       500:
 *         description: An error occurred while fetching the total count of operators in Ikeja.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 success:
 *                   type: boolean
 *                   example: false
 *                 message:
 *                   type: string
 *                   example: "Internal Server Error"
 *
 * @function
 * @name getTotalOperatorCountIkeja
 * @memberof module:Routes/Operators
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with handling exceptions.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
app.get("/totaloperatorikeja", authenticateJWT, async (req, res) => {
let connection;  
  try {
    connection = await getPoolConnection();
    const query = `
      SELECT COUNT(*) AS ikejaOpCount
      FROM geopos_employees
      WHERE roleid = '3' AND passive_type = 'ACT';
    `;

    const results = await executeQuery(connection,query);

    const ikejaOpCount = results[0].ikejaOpCount;
    // console.log('Ikeja Operation Count:', ikejaOpCount);
    res.send(results);
  } catch (error) {
    console.error('Error:', error);
    res.status(500).send('Internal Server Error');
  } finally {
    // Release the connection back to the pool in case of success or error
    if (connection) {
      connection.release();
      //console.log("Connection released");
    }
  }
});


//get ota direct expected day
/**
 * @swagger
 * /otadirectexpectedday:
 *   get:
 *     summary: Get the total count of employees with OTA Direct Expected Day shift.
 *     description: Retrieves the total count of employees with OTA Direct Expected Day shift from the employees_ota table.
 *     tags:
 *       - Employees
 *     security:
 *       - BearerAuth: []
 *     responses:
 *       200:
 *         description: Successful response with the total count of employees with OTA Direct Expected Day shift.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 otaDEDCount:
 *                   type: integer
 *                   description: Total count of employees with OTA Direct Expected Day shift.
 *                   example: 5
 *       500:
 *         description: An error occurred while fetching the total count of employees with OTA Direct Expected Day shift.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 success:
 *                   type: boolean
 *                   example: false
 *                 message:
 *                   type: string
 *                   example: "Internal Server Error"
 *
 * @function
 * @name getTotalOTADirectExpectedDay
 * @memberof module:Routes/Employees
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with handling exceptions.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
app.get("/otadirectexpectedday", authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    const query = `
      SELECT * FROM employees_ota WHERE shift = "DAY" ORDER BY id ASC LIMIT 1;
    `;
    const results = await executeQuery(connection,query);

    if (results.length === 0) {
      //console.log('No records found');
      return;
    }

    const dt = results[0].date;
    const whereClause = `roleid = '1' AND passive_type = 'ACT' AND shift = 'DAY' AND workertype = 'DIRECT' AND date = '${dt}'`;
    const countQuery = `
      SELECT COUNT(*) AS otaDEDCount
      FROM employees_ota
      WHERE ${whereClause};
    `;

    const countResults = await executeQuery(connection,countQuery);
    const totalCount = countResults[0].otaDEDCount;
    // console.log('OTA Direct Expected Day Count:', totalCount);
    res.send(countResults);
  } catch (error) {
    console.error('Error:', error);
    res.status(500).send('Internal Server Error');
  } finally {
    // Release the connection back to the pool in case of success or error
    if (connection) {
      connection.release();
      //console.log("Connection released");
    }
  }
});

//get ota direct present day
/**
 * @swagger
 * /otadirectpresentday:
 *   get:
 *     summary: Get the total count of employees with OTA Direct Present Day shift.
 *     description: Retrieves the total count of employees with OTA Direct Present Day shift from the employees_ota table.
 *     tags:
 *       - Employees
 *     security:
 *       - BearerAuth: []
 *     responses:
 *       200:
 *         description: Successful response with the total count of employees with OTA Direct Present Day shift.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 otaDPDCount:
 *                   type: integer
 *                   description: Total count of employees with OTA Direct Present Day shift.
 *                   example: 3
 *       500:
 *         description: An error occurred while fetching the total count of employees with OTA Direct Present Day shift.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 success:
 *                   type: boolean
 *                   example: false
 *                 message:
 *                   type: string
 *                   example: "Internal Server Error"
 *
 * @function
 * @name getTotalOTADirectPresentDay
 * @memberof module:Routes/Employees
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with handling exceptions.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
app.get("/otadirectpresentday", authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    const query = `
      SELECT * FROM employees_ota WHERE shift = "DAY" ORDER BY id ASC LIMIT 1;
    `;
    const results = await executeQuery(connection,query);

    if (results.length === 0) {
      //console.log('No records found');
      return;
    }

    const dt = results[0].date;
    const whereClause = `roleid = '1' AND passive_type = 'ACT' AND status = 'P' AND shift = 'DAY' AND workertype = 'DIRECT' AND date = '${dt}'`;
    const countQuery = `
      SELECT COUNT(*) AS otaDPDCount
      FROM employees_ota
      WHERE ${whereClause};
    `;

    const countResults = await executeQuery(connection,countQuery);
    const totalCount = countResults[0].otaDPDCount;
    //console.log('OTA Direct Present Day Count:', totalCount);
    res.send(countResults);
  } catch (error) {
    console.error('Error:', error);
    res.status(500).send('Internal Server Error');
  } finally {
    // Release the connection back to the pool in case of success or error
    if (connection) {
      connection.release();
      //console.log("Connection released");
    }
  }
});


//get ota direct absent day
/**
 * @swagger
 * /otadirectabsentday:
 *   get:
 *     summary: Get the total count of employees with OTA Direct Absent Day shift.
 *     description: Retrieves the total count of employees with OTA Direct Absent Day shift from the employees_ota table.
 *     tags:
 *       - Employees
 *     security:
 *       - BearerAuth: []
 *     responses:
 *       200:
 *         description: Successful response with the total count of employees with OTA Direct Absent Day shift.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 otaDADCount:
 *                   type: integer
 *                   description: Total count of employees with OTA Direct Absent Day shift.
 *                   example: 2
 *       500:
 *         description: An error occurred while fetching the total count of employees with OTA Direct Absent Day shift.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 success:
 *                   type: boolean
 *                   example: false
 *                 message:
 *                   type: string
 *                   example: "Internal Server Error"
 *
 * @function
 * @name getTotalOTADirectAbsentDay
 * @memberof module:Routes/Employees
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with handling exceptions.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
app.get("/otadirectabsentday", authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    const query = `
      SELECT * FROM employees_ota WHERE shift = "DAY" ORDER BY id ASC LIMIT 1;
    `;
    const results = await executeQuery(connection,query);

    if (results.length === 0) {
      //console.log('No records found');
      return;
    }

    const dt = results[0].date;
    const whereClause = `roleid = '1' AND passive_type = 'ACT' AND status = 'A' AND shift = 'DAY' AND workertype = 'DIRECT' AND date = '${dt}'`;
    const countQuery = `
      SELECT COUNT(*) AS otaDADCount
      FROM employees_ota
      WHERE ${whereClause};
    `;

    const countResults = await executeQuery(connection,countQuery);
    const totalCount = countResults[0].otaDADCount;
    //console.log('OTA Direct Absent Day Count:', totalCount);
    res.send(countResults);
  } catch (error) {
    console.error('Error:', error);
    res.status(500).send('Internal Server Error');
  } finally {
    // Release the connection back to the pool in case of success or error
    if (connection) {
      connection.release();
      //console.log("Connection released");
    }
  }
});


//get ota indirect expected day
/**
 * @swagger
 * /otaindirectexpectedday:
 *   get:
 *     summary: Get the total count of employees with OTA Indirect Expected Day shift.
 *     description: Retrieves the total count of employees with OTA Indirect Expected Day shift from the employees_ota table.
 *     tags:
 *       - Employees
 *     security:
 *       - BearerAuth: []
 *     responses:
 *       200:
 *         description: Successful response with the total count of employees with OTA Indirect Expected Day shift.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 otaIEDCount:
 *                   type: integer
 *                   description: Total count of employees with OTA Indirect Expected Day shift.
 *                   example: 5
 *       500:
 *         description: An error occurred while fetching the total count of employees with OTA Indirect Expected Day shift.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: "Internal Server Error"
 *
 * @function
 * @name getTotalOTAIndirectExpectedDay
 * @memberof module:Routes/Employees
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with executing the MySQL query.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
app.get('/otaindirectexpectedday', authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    const date = new Date().toLocaleDateString('en-GB', { timeZone: 'Africa/Lagos' });
    const parts = date.split('/');
    const formattedDay = parts[0].padStart(2, '0');
    const formattedMonth = parts[1].padStart(2, '0');
    const year = parts[2];
    const date1 = `${formattedDay}-${formattedMonth}-${year}`;

    const query = `
      SELECT COUNT(*) AS otaIEDCount
      FROM employees_ota
      WHERE roleid = '1'
        AND passive_type = 'ACT'
        AND shift = 'DAY'
        AND workertype = 'INDIRECT'
        AND date = ?;
    `;

    const results = await executeQuery(connection, query, [date1]);

    res.send(results);
  } catch (error) {
    console.error('Error executing MySQL query: ', error);
    res.status(500).json({ error: 'Internal Server Error' });
  } finally {
    if (connection) {
      connection.release();
    }
  }
});


/**
 * @swagger
 * /otaindirectexpectedday:
 *   get:
 *     summary: Get the total count of employees with OTA Indirect Expected Day shift.
 *     description: Retrieves the total count of employees with OTA Indirect Expected Day shift from the employees_ota table.
 *     tags:
 *       - Employees
 *     security:
 *       - BearerAuth: []
 *     responses:
 *       200:
 *         description: Successful response with the total count of employees with OTA Indirect Expected Day shift.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 otaIEDCount:
 *                   type: integer
 *                   description: Total count of employees with OTA Indirect Expected Day shift.
 *                   example: 5
 *       500:
 *         description: An error occurred while fetching the total count of employees with OTA Indirect Expected Day shift.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: "Internal Server Error"
 *
 * @function
 * @name getTotalOTAIndirectExpectedDay
 * @memberof module:Routes/Employees
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with executing the MySQL query.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
app.get('/otaindirectexpectedday', authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    const date = new Date().toLocaleDateString('en-GB', { timeZone: 'Africa/Lagos' });
    const parts = date.split('/');
    const formattedDay = parts[0].padStart(2, '0');
    const formattedMonth = parts[1].padStart(2, '0');
    const year = parts[2];
    const date1 = `${formattedDay}-${formattedMonth}-${year}`; 

    // Your SQL query
    const query = `
      SELECT COUNT(*) AS otaIEDCount
      FROM employees_ota
      WHERE roleid = '1'
        AND passive_type = 'ACT'
        AND shift = 'DAY'
        AND workertype = 'INDIRECT'
        AND date = ?;
    `;

    // Execute the query
    const results = await executeQuery(connection,query, [date1]);

    const totalCount = results[0].otaIEDCount;
    // console.log('OTA Indirect Expected Day Count:', totalCount);
    res.send(results);
  } catch (error) {
    console.error('Error executing MySQL query: ', error);
    res.status(500).json({ error: 'Internal Server Error' });
  } finally {
    // Release the connection back to the pool in case of success or error
    if (connection) {
      connection.release();
      //console.log("Connection released");
    }
  }
});


//get ota indirect present day
/**
 * @swagger
 * /otaindirectpresentday:
 *   get:
 *     summary: Get the total count of employees with OTA Indirect Present Day shift.
 *     description: Retrieves the total count of employees with OTA Indirect Present Day shift from the employees_ota table.
 *     tags:
 *       - Employees
 *     security:
 *       - BearerAuth: []
 *     responses:
 *       200:
 *         description: Successful response with the total count of employees with OTA Indirect Present Day shift.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 otaIPDCount:
 *                   type: integer
 *                   description: Total count of employees with OTA Indirect Present Day shift.
 *                   example: 5
 *       500:
 *         description: An error occurred while fetching the total count of employees with OTA Indirect Present Day shift.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: "Internal Server Error"
 *
 * @function
 * @name getTotalOTAIndirectPresentDay
 * @memberof module:Routes/Employees
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with executing the MySQL query.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
app.get('/otaindirectpresentday', authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();

    const date = new Date().toLocaleDateString('en-GB', { timeZone: 'Africa/Lagos' });
    const parts = date.split('/');
    const formattedDay = parts[0].padStart(2, '0');
    const formattedMonth = parts[1].padStart(2, '0');
    const year = parts[2];
    const date1 = `${formattedDay}-${formattedMonth}-${year}`; 

    // Your SQL query
    const query = `
      SELECT COUNT(*) as otaIPDCount
      FROM employees_ota
      WHERE roleid = '1'
        AND passive_type = 'ACT'
        AND status = 'P'
        AND shift = 'DAY'
        AND workertype = 'INDIRECT'
        AND date = ?;
    `;

    // Execute the query
    const results = await executeQuery(connection, query, [date1]);
    const totalCount = results[0].otaIPDCount;
    // console.log('OTA Indirect Present Day Count:', totalCount);
    res.send(results);
  } catch (error) {
    console.error('Error executing MySQL query: ', error);
    res.status(500).json({ error: 'Internal Server Error' });
  } finally {
    // Release the connection back to the pool in case of success or error
    if (connection) {
      connection.release();
      //console.log("Connection released");
    }
  }
});


 //get ota indirect absent day
 /**
 * @swagger
 * /otaindirectabsentday:
 *   get:
 *     summary: Get the total count of employees with OTA Indirect Absent Day shift.
 *     description: Retrieves the total count of employees with OTA Indirect Absent Day shift from the employees_ota table.
 *     tags:
 *       - Employees
 *     security:
 *       - BearerAuth: []
 *     responses:
 *       200:
 *         description: Successful response with the total count of employees with OTA Indirect Absent Day shift.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 otaIADCount:
 *                   type: integer
 *                   description: Total count of employees with OTA Indirect Absent Day shift.
 *                   example: 2
 *       500:
 *         description: An error occurred while fetching the total count of employees with OTA Indirect Absent Day shift.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: "Internal Server Error"
 *
 * @function
 * @name getTotalOTAIndirectAbsentDay
 * @memberof module:Routes/Employees
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with executing the MySQL query.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
 app.get('/otaindirectabsentday', authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    const date = new Date().toLocaleDateString('en-GB', { timeZone: 'Africa/Lagos' });
    const parts = date.split('/');
    const formattedDay = parts[0].padStart(2, '0');
    const formattedMonth = parts[1].padStart(2, '0');
    const year = parts[2];
    const date1 = `${formattedDay}-${formattedMonth}-${year}`; 

    // Your SQL query
    const query = `
      SELECT COUNT(*) as otaIADCount
      FROM employees_ota
      WHERE roleid = '1'
        AND passive_type = 'ACT'
        AND status = 'A'
        AND shift = 'DAY'
        AND workertype = 'INDIRECT'
        AND date = ?;
    `;

    // Execute the query
    const results = await executeQuery(connection, query, [date1]);
    const totalCount = results[0].otaIADCount;
    // console.log('OTA Indirect Absent Day Count:', totalCount);
    res.send(results);
  } catch (error) {
    console.error('Error executing MySQL query: ', error);
    res.status(500).json({ error: 'Internal Server Error' });
  } finally {
    // Release the connection back to the pool in case of success or error
    if (connection) {
      connection.release();
      //console.log("Connection released");
    }
  }
});


//get ota direct expected night
/**
 * @swagger
 * /otadirectexpectednight:
 *   get:
 *     summary: Get the total count of employees with OTA Direct Expected Night shift.
 *     description: Retrieves the total count of employees with OTA Direct Expected Night shift from the employees_ota table.
 *     tags:
 *       - Employees
 *     security:
 *       - BearerAuth: []
 *     responses:
 *       200:
 *         description: Successful response with the total count of employees with OTA Direct Expected Night shift.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 otaDENCount:
 *                   type: integer
 *                   description: Total count of employees with OTA Direct Expected Night shift.
 *                   example: 5
 *       500:
 *         description: An error occurred while fetching the total count of employees with OTA Direct Expected Night shift.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: "Internal Server Error"
 *
 * @function
 * @name getTotalOTADirectExpectedNight
 * @memberof module:Routes/Employees
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with executing the MySQL query.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
app.get("/otadirectexpectednight", authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    const query = `
      SELECT * FROM employees_ota WHERE shift = "NIGHT" ORDER BY id ASC LIMIT 1;
    `;
  
    const results = await executeQuery(connection,query);
  
    if (results.length === 0) {
      //console.log('No records found');
      return;
    }
  
    const dt = results[0].date;
  
    const whereClause = `roleid = '1' AND passive_type = 'ACT' AND shift = 'NIGHT' AND workertype = 'DIRECT' AND date = '${dt}'`;
    const countQuery = `
      SELECT COUNT(*) AS otaDENCount
      FROM employees_ota
      WHERE ${whereClause};
    `;
  
    const countResults = await executeQuery(connection,countQuery);
  
    const totalCount = countResults[0].otaDENCount;
    //console.log('OTA Direct Expected Night Count:', totalCount);
    res.send(countResults);
  } catch (error) {
    console.error('Error executing the query:', error);
    res.status(500).json({ error: 'Internal Server Error' });
  } finally {
    // Release the connection back to the pool in case of success or error
    if (connection) {
      connection.release();
      //console.log("Connection released");
    }
  }
});


//get ota direct present night
/**
 * @swagger
 * /otadirectpresentnight:
 *   get:
 *     summary: Get the total count of employees with OTA Direct Present Night shift.
 *     description: Retrieves the total count of employees with OTA Direct Present Night shift from the employees_ota table.
 *     tags:
 *       - Employees
 *     security:
 *       - BearerAuth: []
 *     responses:
 *       200:
 *         description: Successful response with the total count of employees with OTA Direct Present Night shift.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 otaDPNCount:
 *                   type: integer
 *                   description: Total count of employees with OTA Direct Present Night shift.
 *                   example: 5
 *       500:
 *         description: An error occurred while fetching the total count of employees with OTA Direct Present Night shift.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: "Internal Server Error"
 *
 * @function
 * @name getTotalOTADirectPresentNight
 * @memberof module:Routes/Employees
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with executing the MySQL query.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
app.get("/otadirectpresentnight", authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    const query = `
      SELECT * FROM employees_ota WHERE shift = "NIGHT" ORDER BY id ASC LIMIT 1;
    `;

    const results = await executeQuery(connection,query);

    if (results.length === 0) {
      //console.log('No records found');
      return;
    }

    const dt = results[0].date;

    const whereClause = `roleid = '1' AND passive_type = 'ACT' AND status = 'P' AND shift = 'NIGHT' AND workertype = 'DIRECT' AND date = '${dt}'`;
    const countQuery = `
      SELECT COUNT(*) AS otaDPNCount
      FROM employees_ota
      WHERE ${whereClause};
    `;

    const countResults = await executeQuery(connection,countQuery);

    const totalCount = countResults[0].otaDPNCount;
    //console.log('OTA Direct Present Night Count:', totalCount);
    res.send(countResults);
  } catch (error) {
    console.error('Error executing the query:', error);
    res.status(500).json({ error: 'Internal Server Error' });
  } finally {
    // Release the connection back to the pool in case of success or error
    if (connection) {
      connection.release();
      //console.log("Connection released");
    }
  }
});
 

//get ota direct absent night
/**
 * @swagger
 * /otadirectabsentnight:
 *   get:
 *     summary: Get the total count of employees with OTA Direct Absent Night shift.
 *     description: Retrieves the total count of employees with OTA Direct Absent Night shift from the employees_ota table.
 *     tags:
 *       - Employees
 *     security:
 *       - BearerAuth: []
 *     responses:
 *       200:
 *         description: Successful response with the total count of employees with OTA Direct Absent Night shift.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 otaDANCount:
 *                   type: integer
 *                   description: Total count of employees with OTA Direct Absent Night shift.
 *                   example: 3
 *       500:
 *         description: An error occurred while fetching the total count of employees with OTA Direct Absent Night shift.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: "Internal Server Error"
 *
 * @function
 * @name getTotalOTADirectAbsentNight
 * @memberof module:Routes/Employees
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with executing the MySQL query.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
app.get("/otadirectabsentnight", authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    const query = `
      SELECT * FROM employees_ota WHERE shift = "NIGHT" ORDER BY id ASC LIMIT 1;
    `;

    const results = await executeQuery(connection,query);

    if (results.length === 0) {
      //console.log('No records found');
      return;
    }

    const dt = results[0].date;

    const whereClause = `roleid = '1' AND passive_type = 'ACT' AND status = 'A' AND shift = 'NIGHT' AND workertype = 'DIRECT' AND date = '${dt}'`;
    const countQuery = `
      SELECT COUNT(*) AS otaDANCount
      FROM employees_ota
      WHERE ${whereClause};
    `;

    const countResults = await executeQuery(connection,countQuery);

    const totalCount = countResults[0].otaDANCount;
    // console.log('OTA Direct Absent Night Count:', totalCount);
    res.send(countResults);
  } catch (error) {
    console.error('Error executing the query:', error);
    res.status(500).json({ error: 'Internal Server Error' });
  } finally {
    // Release the connection back to the pool in case of success or error
    if (connection) {
      connection.release();
      //console.log("Connection released");
    }
  }
});


//get ota indirect expected night
/**
 * @swagger
 * /otaindirectexpectednight:
 *   get:
 *     summary: Get the total count of employees with OTA Indirect Expected Night shift.
 *     description: Retrieves the total count of employees with OTA Indirect Expected Night shift from the employees_ota table.
 *     tags:
 *       - Employees
 *     security:
 *       - BearerAuth: []
 *     responses:
 *       200:
 *         description: Successful response with the total count of employees with OTA Indirect Expected Night shift.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 otaIENCount:
 *                   type: integer
 *                   description: Total count of employees with OTA Indirect Expected Night shift.
 *                   example: 3
 *       500:
 *         description: An error occurred while fetching the total count of employees with OTA Indirect Expected Night shift.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: "Internal Server Error"
 *
 * @function
 * @name getTotalOTAIndirectExpectedNight
 * @memberof module:Routes/Employees
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with executing the MySQL query.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
app.get('/otaindirectexpectednight', authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    const date = new Date().toLocaleDateString('en-GB', { timeZone: 'Africa/Lagos' });
    const parts = date.split('/');
    const formattedDay = parts[0].padStart(2, '0');
    const formattedMonth = parts[1].padStart(2, '0');
    const year = parts[2];
    const date1 = `${formattedDay}-${formattedMonth}-${year}`; 

    // Your SQL query
    const query = `
      SELECT COUNT(*) AS otaIENCount
      FROM employees_ota
      WHERE roleid = '1'
        AND passive_type = 'ACT'
        AND shift = 'NIGHT'
        AND workertype = 'INDIRECT'
        AND date = ?;
    `;

    // Execute the query
    const results = await executeQuery(connection,query, [date1]);

    const totalCount = results[0].otaIENCount;
    // console.log('OTA Indirect Expected night Count:', totalCount);
    res.send(results);
  } catch (error) {
    console.error('Error executing MySQL query: ', error);
    res.status(500).json({ error: 'Internal Server Error' });
  } finally {
    // Release the connection back to the pool in case of success or error
    if (connection) {
      connection.release();
      //console.log("Connection released");
    }
  }
});


//get ota indirect present night
/**
 * @swagger
 * /otaindirectpresentnight:
 *   get:
 *     summary: Get the total count of employees with OTA Indirect Present Night shift.
 *     description: Retrieves the total count of employees with OTA Indirect Present Night shift from the employees_ota table.
 *     tags:
 *       - Employees
 *     security:
 *       - BearerAuth: []
 *     responses:
 *       200:
 *         description: Successful response with the total count of employees with OTA Indirect Present Night shift.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 otaIPNCount:
 *                   type: integer
 *                   description: Total count of employees with OTA Indirect Present Night shift.
 *                   example: 3
 *       500:
 *         description: An error occurred while fetching the total count of employees with OTA Indirect Present Night shift.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: "Internal Server Error"
 *
 * @function
 * @name getTotalOTAIndirectPresentNight
 * @memberof module:Routes/Employees
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with executing the MySQL query.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
app.get('/otaindirectpresentnight', authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    const date = new Date().toLocaleDateString('en-GB', { timeZone: 'Africa/Lagos' });
    const parts = date.split('/');
    const formattedDay = parts[0].padStart(2, '0');
    const formattedMonth = parts[1].padStart(2, '0');
    const year = parts[2];
    const date1 = `${formattedDay}-${formattedMonth}-${year}`; 

    // Your SQL query
    const query = `
      SELECT COUNT(*) as otaIPNCount
      FROM employees_ota
      WHERE roleid = '1'
        AND passive_type = 'ACT'
        AND status = 'P'
        AND shift = 'NIGHT'
        AND workertype = 'INDIRECT'
        AND date = ?;
    `;

    // Execute the query
    const results = await executeQuery(connection,query, [date1]);

    const totalCount = results[0].otaIPNCount;
    // console.log('OTA Indirect Present night Count:', totalCount);
    res.send(results);
  } catch (error) {
    console.error('Error executing MySQL query: ', error);
    res.status(500).json({ error: 'Internal Server Error' });
  } finally {
    // Release the connection back to the pool in case of success or error
    if (connection) {
      connection.release();
      //console.log("Connection released");
    }
  }
});

 //get ota indirect absent night
 /**
 * @swagger
 * /otaindirectabsentnight:
 *   get:
 *     summary: Get the total count of employees with OTA Indirect Absent Night shift.
 *     description: Retrieves the total count of employees with OTA Indirect Absent Night shift from the employees_ota table.
 *     tags:
 *       - Employees
 *     security:
 *       - BearerAuth: []
 *     responses:
 *       200:
 *         description: Successful response with the total count of employees with OTA Indirect Absent Night shift.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 otaIANCount:
 *                   type: integer
 *                   description: Total count of employees with OTA Indirect Absent Night shift.
 *                   example: 2
 *       500:
 *         description: An error occurred while fetching the total count of employees with OTA Indirect Absent Night shift.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: "Internal Server Error"
 *
 * @function
 * @name getTotalOTAIndirectAbsentNight
 * @memberof module:Routes/Employees
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with executing the MySQL query.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
 app.get('/otaindirectabsentnight', authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    const date = new Date().toLocaleDateString('en-GB', { timeZone: 'Africa/Lagos' });
    const parts = date.split('/');
    const formattedDay = parts[0].padStart(2, '0');
    const formattedMonth = parts[1].padStart(2, '0');
    const year = parts[2];
    const date1 = `${formattedDay}-${formattedMonth}-${year}`; 

    // Your SQL query
    const query = `
      SELECT COUNT(*) as otaIANCount
      FROM employees_ota
      WHERE roleid = '1'
        AND passive_type = 'ACT'
        AND status = 'A'
        AND shift = 'NIGHT'
        AND workertype = 'INDIRECT'
        AND date = ?;
    `;

    // Execute the query
    const results = await executeQuery(connection,query, [date1]);

    const totalCount = results[0].otaIANCount;
    // console.log('OTA Indirect Absent night Count:', totalCount);
    res.send(results);
  } catch (error) {
    console.error('Error executing MySQL query: ', error);
    res.status(500).json({ error: 'Internal Server Error' });
  } finally {
    // Release the connection back to the pool in case of success or error
    if (connection) {
      connection.release();
      //console.log("Connection released");
    }
  }
});



//get ikeja direct expected day
/**
 * @swagger
 * /ikejadirectexpectedday:
 *   get:
 *     summary: Get the total count of employees with IKEJA Direct Expected Day shift.
 *     description: Retrieves the total count of employees with IKEJA Direct Expected Day shift from the geopos_employees table.
 *     tags:
 *       - Employees
 *     security:
 *       - BearerAuth: []
 *     responses:
 *       200:
 *         description: Successful response with the total count of employees with IKEJA Direct Expected Day shift.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 ikejaDEDCount:
 *                   type: integer
 *                   description: Total count of employees with IKEJA Direct Expected Day shift.
 *                   example: 5
 *       500:
 *         description: An error occurred while fetching the total count of employees with IKEJA Direct Expected Day shift.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: "Internal Server Error"
 *
 * @function
 * @name getTotalIKEJADirectExpectedDay
 * @memberof module:Routes/Employees
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with executing the MySQL query.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
app.get("/ikejadirectexpectedday", authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    const query = `
      SELECT * FROM geopos_employees WHERE shift='DAY' ORDER BY id ASC LIMIT 1;
    `;

    const results = await executeQuery(connection,query);

    if (results.length === 0) {
      //console.log('No records found');
      return;
    }

    const dt = results[0].date;

    const whereClause = `roleid = '1' AND passive_type = 'ACT' AND shift = 'DAY' AND workertype = 'DIRECT' AND date = '${dt}'`;
    const countQuery = `
      SELECT COUNT(*) AS ikejaDEDCount
      FROM geopos_employees
      WHERE ${whereClause};
    `;

    const countResults = await executeQuery(connection,countQuery);

    const totalCount = countResults[0].ikejaDEDCount;
    // console.log('IKEJA Direct Expected Day Count:', totalCount);
    res.send(countResults);
  } catch (error) {
    console.error('Error executing the query:', error);
    res.status(500).json({ error: 'Internal Server Error' });
  } finally {
    // Release the connection back to the pool in case of success or error
    if (connection) {
      connection.release();
      //console.log("Connection released");
    }
  }
});


//get ikeja direct present day
/**
 * @swagger
 * /ikejadirectpresentday:
 *   get:
 *     summary: Get the total count of employees with IKEJA Direct Present Day shift.
 *     description: Retrieves the total count of employees with IKEJA Direct Present Day shift from the geopos_employees table.
 *     tags:
 *       - Employees
 *     security:
 *       - BearerAuth: []
 *     responses:
 *       200:
 *         description: Successful response with the total count of employees with IKEJA Direct Present Day shift.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 ikejaDPDCount:
 *                   type: integer
 *                   description: Total count of employees with IKEJA Direct Present Day shift.
 *                   example: 5
 *       500:
 *         description: An error occurred while fetching the total count of employees with IKEJA Direct Present Day shift.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: "Internal Server Error"
 *
 * @function
 * @name getTotalIKEJADirectPresentDay
 * @memberof module:Routes/Employees
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with executing the MySQL query.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
app.get("/ikejadirectpresentday", authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    const query = `
      SELECT * FROM geopos_employees WHERE shift = "DAY" ORDER BY id ASC LIMIT 1;
    `;

    const results = await executeQuery(connection,query);

    if (results.length === 0) {
      //console.log('No records found');
      return;
    }

    const dt = results[0].date;

    const whereClause = `roleid = '1' AND passive_type = 'ACT' AND status = 'P' AND shift = 'DAY' AND workertype = 'DIRECT' AND date = '${dt}'`;
    const countQuery = `
      SELECT COUNT(*) AS ikejaDPDCount
      FROM geopos_employees
      WHERE ${whereClause};
    `;

    const countResults = await executeQuery(connection,countQuery);

    const totalCount = countResults[0].ikejaDPDCount;
    // console.log('IKEJA Direct Present Day Count:', totalCount);
    res.send(countResults);
  } catch (error) {
    console.error('Error executing the query:', error);
    res.status(500).json({ error: 'Internal Server Error' });
  } finally {
      // Release the connection back to the pool in case of success or error
      if (connection) {
        connection.release();
        //console.log("Connection released");
      }
  }
});


//get ikeja direct absent day
/**
 * @swagger
 * /ikejadirectabsentday:
 *   get:
 *     summary: Get the total count of employees with IKEJA Direct Absent Day shift.
 *     description: Retrieves the total count of employees with IKEJA Direct Absent Day shift from the geopos_employees table.
 *     tags:
 *       - Employees
 *     security:
 *       - BearerAuth: []
 *     responses:
 *       200:
 *         description: Successful response with the total count of employees with IKEJA Direct Absent Day shift.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 ikejaDADCount:
 *                   type: integer
 *                   description: Total count of employees with IKEJA Direct Absent Day shift.
 *                   example: 3
 *       500:
 *         description: An error occurred while fetching the total count of employees with IKEJA Direct Absent Day shift.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: "Internal Server Error"
 *
 * @function
 * @name getTotalIKEJADirectAbsentDay
 * @memberof module:Routes/Employees
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with executing the MySQL query.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
app.get("/ikejadirectabsentday", authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    const query = `
      SELECT * FROM geopos_employees WHERE shift = "DAY" ORDER BY id ASC LIMIT 1;
    `;

    const results = await executeQuery(connection,query);

    if (results.length === 0) {
      //console.log('No records found');
      return;
    }

    const dt = results[0].date;

    const whereClause = `roleid = '1' AND passive_type = 'ACT' AND status = 'A' AND shift = 'DAY' AND workertype = 'DIRECT' AND date = '${dt}'`;
    const countQuery = `
      SELECT COUNT(*) AS ikejaDADCount
      FROM geopos_employees
      WHERE ${whereClause};
    `;

    const countResults = await executeQuery(connection,countQuery);

    const totalCount = countResults[0].ikejaDADCount;
    // console.log('IKEJA Direct Absent Day Count:', totalCount);
    res.send(countResults);
  } catch (error) {
    console.error('Error executing the query:', error);
    res.status(500).json({ error: 'Internal Server Error' });
  } finally {
      // Release the connection back to the pool in case of success or error
      if (connection) {
        connection.release();
        //console.log("Connection released");
      }
  }
});


//get ikeja indirect expected day
/**
 * @swagger
 * /ikejaindirectexpectedday:
 *   get:
 *     summary: Get the total count of employees with IKEJA Indirect Expected Day shift.
 *     description: Retrieves the total count of employees with IKEJA Indirect Expected Day shift from the geopos_employees table.
 *     tags:
 *       - Employees
 *     security:
 *       - BearerAuth: []
 *     responses:
 *       200:
 *         description: Successful response with the total count of employees with IKEJA Indirect Expected Day shift.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 ikejaIEDCount:
 *                   type: integer
 *                   description: Total count of employees with IKEJA Indirect Expected Day shift.
 *                   example: 5
 *       500:
 *         description: An error occurred while fetching the total count of employees with IKEJA Indirect Expected Day shift.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: "Internal Server Error"
 *
 * @function
 * @name getTotalIKEJAIndirectExpectedDay
 * @memberof module:Routes/Employees
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with executing the MySQL query.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
app.get('/ikejaindirectexpectedday', authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    const date = new Date().toLocaleDateString('en-GB', { timeZone: 'Africa/Lagos' });
    const parts = date.split('/');
    const formattedDay = parts[0].padStart(2, '0');
    const formattedMonth = parts[1].padStart(2, '0');
    const year = parts[2];
    const date1 = `${formattedDay}-${formattedMonth}-${year}`;

    // Your SQL query
    const query = `
      SELECT COUNT(*) AS ikejaIEDCount
      FROM geopos_employees
      WHERE roleid = '1'
        AND passive_type = 'ACT'
        AND shift = 'DAY'
        AND workertype = 'INDIRECT'
        AND date = ?;
    `;

    // Execute the query
    const results = await executeQuery(connection,query, [date1]);

    const totalCount = results[0].ikejaIEDCount;
    // console.log('IKEJA Indirect Expected Day Count:', totalCount);
    res.send(results);
  } catch (error) {
    console.error('Error executing MySQL query: ', error);
    res.status(500).json({ error: 'Internal Server Error' });
  } finally {
    // Release the connection back to the pool in case of success or error
    if (connection) {
      connection.release();
      //console.log("Connection released");
    }
  }
});


//get ikeja indirect present day
/**
 * @swagger
 * /ikejaindirectpresentday:
 *   get:
 *     summary: Get the total count of employees with IKEJA Indirect Present Day shift.
 *     description: Retrieves the total count of employees with IKEJA Indirect Present Day shift from the geopos_employees table.
 *     tags:
 *       - Employees
 *     security:
 *       - BearerAuth: []
 *     responses:
 *       200:
 *         description: Successful response with the total count of employees with IKEJA Indirect Present Day shift.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 ikejaIPDCount:
 *                   type: integer
 *                   description: Total count of employees with IKEJA Indirect Present Day shift.
 *                   example: 5
 *       500:
 *         description: An error occurred while fetching the total count of employees with IKEJA Indirect Present Day shift.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: "Internal Server Error"
 *
 * @function
 * @name getTotalIKEJAIndirectPresentDay
 * @memberof module:Routes/Employees
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with executing the MySQL query.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
app.get('/ikejaindirectpresentday',  authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    const date = new Date().toLocaleDateString('en-GB', { timeZone: 'Africa/Lagos' });
    const parts = date.split('/');
    const formattedDay = parts[0].padStart(2, '0');
    const formattedMonth = parts[1].padStart(2, '0');
    const year = parts[2];
    const date1 = `${formattedDay}-${formattedMonth}-${year}`; 

    // Your SQL query
    const query = `
      SELECT COUNT(*) as ikejaIPDCount
      FROM geopos_employees
      WHERE roleid = '1'
        AND passive_type = 'ACT'
        AND status = 'P'
        AND shift = 'DAY'
        AND workertype = 'INDIRECT'
        AND date = ?;
    `;

    // Execute the query
    const results = await executeQuery(connection, query, [date1]);

    const totalCount = results[0].ikejaIPDCount;
    // console.log('IKEJA Indirect Present Day Count:', totalCount);
    res.send(results);
  } catch (error) {
    console.error('Error executing MySQL query: ', error);
    res.status(500).json({ error: 'Internal Server Error' });
  } finally {
    // Release the connection back to the pool in case of success or error
    if (connection) {
      connection.release();
      //console.log("Connection released");
    }
  }
});


 //get ikeja indirect absent day
 /**
 * @swagger
 * /ikejaindirectabsentday:
 *   get:
 *     summary: Get the total count of employees with IKEJA Indirect Absent Day shift.
 *     description: Retrieves the total count of employees with IKEJA Indirect Absent Day shift from the geopos_employees table.
 *     tags:
 *       - Employees
 *     security:
 *       - BearerAuth: []
 *     responses:
 *       200:
 *         description: Successful response with the total count of employees with IKEJA Indirect Absent Day shift.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 ikejaIADCount:
 *                   type: integer
 *                   description: Total count of employees with IKEJA Indirect Absent Day shift.
 *                   example: 3
 *       500:
 *         description: An error occurred while fetching the total count of employees with IKEJA Indirect Absent Day shift.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: "Internal Server Error"
 *
 * @function
 * @name getTotalIKEJAIndirectAbsentDay
 * @memberof module:Routes/Employees
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with executing the MySQL query.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
 app.get('/ikejaindirectabsentday',  authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    const date = new Date().toLocaleDateString('en-GB', { timeZone: 'Africa/Lagos' });
    const parts = date.split('/');
    const formattedDay = parts[0].padStart(2, '0');
    const formattedMonth = parts[1].padStart(2, '0');
    const year = parts[2];
    const date1 = `${formattedDay}-${formattedMonth}-${year}`; 

    // Your SQL query
    const query = `
      SELECT COUNT(*) as ikejaIADCount
      FROM geopos_employees
      WHERE roleid = '1'
        AND passive_type = 'ACT'
        AND status = 'A'
        AND shift = 'DAY'
        AND workertype = 'INDIRECT'
        AND date = ?;
    `;

    // Execute the query
    const results = await executeQuery(connection,query, [date1]);

    const totalCount = results[0].ikejaIADCount;
    // console.log('IKEJA Indirect Absent Day Count:', totalCount);
    res.send(results);
  } catch (error) {
    console.error('Error executing MySQL query: ', error);
    res.status(500).json({ error: 'Internal Server Error' });
  } finally {
    // Release the connection back to the pool in case of success or error
    if (connection) {
      connection.release();
      //console.log("Connection released");
    }
  }
});


//get ikeja direct expected night
/**
 * @swagger
 * /ikejadirectexpectednight:
 *   get:
 *     summary: Get the total count of employees with IKEJA Direct Expected Night shift.
 *     description: Retrieves the total count of employees with IKEJA Direct Expected Night shift from the geopos_employees table.
 *     tags:
 *       - Employees
 *     security:
 *       - BearerAuth: []
 *     responses:
 *       200:
 *         description: Successful response with the total count of employees with IKEJA Direct Expected Night shift.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 ikejaDENCount:
 *                   type: integer
 *                   description: Total count of employees with IKEJA Direct Expected Night shift.
 *                   example: 3
 *       404:
 *         description: No records found for the specified criteria.
 *         content:
 *           text/plain:
 *             schema:
 *               type: string
 *               example: "No records found"
 *       500:
 *         description: An error occurred while fetching the total count of employees with IKEJA Direct Expected Night shift.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: "Internal Server Error"
 *
 * @function
 * @name getTotalIKEJADirectExpectedNight
 * @memberof module:Routes/Employees
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with executing the MySQL query.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
app.get("/ikejadirectexpectednight", authenticateJWT, async (req, res) => {
  let connection;

  try {
    connection = await getPoolConnection();
    const query = `
      SELECT * FROM geopos_employees WHERE shift = "NIGHT" ORDER BY id ASC LIMIT 1;
    `;

    // Execute the main query to get the relevant data
    const results = await executeQuery(connection,query);

    // Check if any records were found
    if (results.length === 0) {
      console.log('No records found');
      return res.status(404).send('No records found');
    }

    // Extract the date from the results
    const dt = results[0].date;

    // Construct the WHERE clause for counting
    const whereClause = `roleid = '1' AND passive_type = 'ACT' AND shift = 'NIGHT' AND workertype = 'DIRECT' AND date = '${dt}'`;
    const countQuery = `
      SELECT COUNT(*) AS ikejaDENCount
      FROM geopos_employees
      WHERE ${whereClause};
    `;

    // Execute the count query
    const countResults = await executeQuery(connection,countQuery);

    // Extract the total count from the count results
    const totalCount = countResults[0].ikejaDENCount;

    // Send the count results as response
    res.send(countResults);
  } catch (error) {
    // Handle errors
    console.error('Error executing the query:', error);
    res.status(500).send('Internal Server Error');
  } finally {
    // Release the connection back to the pool in case of success or error
    if (connection) {
      connection.release();
      //console.log("Connection released");
    }
  }
});



//get ikeja direct present night
/**
 * @swagger
 * /ikejadirectpresentnight:
 *   get:
 *     summary: Get the total count of employees with IKEJA Direct Present Night shift.
 *     description: Retrieves the total count of employees with IKEJA Direct Present Night shift from the geopos_employees table.
 *     tags:
 *       - Employees
 *     security:
 *       - BearerAuth: []
 *     responses:
 *       200:
 *         description: Successful response with the total count of employees with IKEJA Direct Present Night shift.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 ikejaDPNCount:
 *                   type: integer
 *                   description: Total count of employees with IKEJA Direct Present Night shift.
 *                   example: 3
 *       404:
 *         description: No records found for the specified criteria.
 *         content:
 *           text/plain:
 *             schema:
 *               type: string
 *               example: "No records found"
 *       500:
 *         description: An error occurred while fetching the total count of employees with IKEJA Direct Present Night shift.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: "Internal Server Error"
 *
 * @function
 * @name getTotalIKEJADirectPresentNight
 * @memberof module:Routes/Employees
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with executing the MySQL query.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
app.get("/ikejadirectpresentnight", authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    const query = `
      SELECT * FROM geopos_employees WHERE shift = "NIGHT" ORDER BY id ASC LIMIT 1;
    `;

    // Execute the main query to get the relevant data
    const results = await executeQuery(connection,query);

    // Check if any records were found
    if (results.length === 0) {
      console.log('No records found');
      return res.status(404).send('No records found');
    }

    // Extract the date from the results
    const dt = results[0].date;

    // Construct the WHERE clause for counting
    const whereClause = `roleid = '1' AND passive_type = 'ACT' AND status = 'P' AND shift = 'NIGHT' AND workertype = 'DIRECT' AND date = '${dt}'`;
    const countQuery = `
      SELECT COUNT(*) AS ikejaDPNCount
      FROM geopos_employees
      WHERE ${whereClause};
    `;

    // Execute the count query
    const countResults = await executeQuery(connection,countQuery);

    // Extract the total count from the count results
    const totalCount = countResults[0].ikejaDPNCount;

    // Send the count results as response
    res.send(countResults);
  } catch (error) {
    // Handle errors
    console.error('Error executing the query:', error);
    res.status(500).send('Internal Server Error');
  } finally {
    // Release the connection back to the pool in case of success or error
    if (connection) {
      connection.release();
      //console.log("Connection released");
    }
  }
});


//get ikeja direct absent night
/**
 * @swagger
 * /ikejadirectabsentnight:
 *   get:
 *     summary: Get the total count of employees with IKEJA Direct Absent Night shift.
 *     description: Retrieves the total count of employees with IKEJA Direct Absent Night shift from the geopos_employees table.
 *     tags:
 *       - Employees
 *     security:
 *       - BearerAuth: []
 *     responses:
 *       200:
 *         description: Successful response with the total count of employees with IKEJA Direct Absent Night shift.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 ikejaDANCount:
 *                   type: integer
 *                   description: Total count of employees with IKEJA Direct Absent Night shift.
 *                   example: 3
 *       404:
 *         description: No records found for the specified criteria.
 *         content:
 *           text/plain:
 *             schema:
 *               type: string
 *               example: "No records found"
 *       500:
 *         description: An error occurred while fetching the total count of employees with IKEJA Direct Absent Night shift.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: "Internal Server Error"
 *
 * @function
 * @name getTotalIKEJADirectAbsentNight
 * @memberof module:Routes/Employees
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with executing the MySQL query.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
app.get("/ikejadirectabsentnight", authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    // Query to retrieve data from the database
    const query = `
      SELECT * FROM geopos_employees WHERE shift = "NIGHT" ORDER BY id ASC LIMIT 1;
    `;

    // Execute the main query to get the relevant data
    const results = await executeQuery(connection,query);

    // Check if any records were found
    if (results.length === 0) {
      console.log('No records found');
      return res.status(404).send('No records found');
    }

    // Extract the date from the results
    const dt = results[0].date;

    // Construct the WHERE clause for counting
    const whereClause = `roleid = '1' AND passive_type = 'ACT' AND status = 'A' AND shift = 'NIGHT' AND workertype = 'DIRECT' AND date = '${dt}'`;
    const countQuery = `
      SELECT COUNT(*) AS ikejaDANCount
      FROM geopos_employees
      WHERE ${whereClause};
    `;

    // Execute the count query
    const countResults = await executeQuery(connection,countQuery);

    // Extract the total count from the count results
    const totalCount = countResults[0].ikejaDANCount;

    // Send the count results as response
    res.send(countResults);
  } catch (error) {
    // Handle errors
    console.error('Error executing the query:', error);
    res.status(500).send('Internal Server Error');
  } finally {
    // Release the connection back to the pool in case of success or error
    if (connection) {
      connection.release();
      //console.log("Connection released");
    }
  }
});


//get ikeja indirect expected night
/**
 * @swagger
 * /ikejaindirectexpectednight:
 *   get:
 *     summary: Get the total count of indirect employees expected in Ikeja at night.
 *     description: Retrieves the total count of indirect employees expected in Ikeja at night from the geopos_employees table.
 *     tags:
 *       - Employees
 *     security:
 *       - BearerAuth: []
 *     responses:
 *       200:
 *         description: Successful response with the total count of indirect employees expected in Ikeja at night.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 ikejaIENCount:
 *                   type: integer
 *                   description: Total count of indirect employees expected in Ikeja at night.
 *                   example: 5
 *       500:
 *         description: An error occurred while fetching the total count of indirect employees expected in Ikeja at night.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: "Internal Server Error"
 *
 * @function
 * @name getTotalIkejaIndirectExpectedNight
 * @memberof module:Routes/Employees
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with executing the MySQL query.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
app.get('/ikejaindirectexpectednight', authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    // Get the current date in the Africa/Lagos timezone
    const date = new Date().toLocaleDateString('en-GB', { timeZone: 'Africa/Lagos' });
    const parts = date.split('/');
    const formattedDay = parts[0].padStart(2, '0');
    const formattedMonth = parts[1].padStart(2, '0');
    const year = parts[2];
    const date1 = `${formattedDay}-${formattedMonth}-${year}`;

    // SQL query to count the number of indirect employees expected in Ikeja at night
    const query = `
      SELECT COUNT(*) AS ikejaIENCount
      FROM geopos_employees
      WHERE roleid = '1'
        AND passive_type = 'ACT'
        AND shift = 'NIGHT'
        AND workertype = 'INDIRECT'
        AND date = ?;
    `;

    // Execute the query
    const results = await executeQuery(connection, query, [date1]);

    // Extract the total count from the results
    const totalCount = results[0].ikejaIENCount;

    // Send the results as JSON response
    res.send(results);
  } catch (error) {
    // Handle errors
    console.error('Error executing MySQL query: ', error);
    res.status(500).json({ error: 'Internal Server Error' });
  } finally {
      // Release the connection back to the pool in case of success or error
      if (connection) {
        connection.release();
        //console.log("Connection released");
      }
    }
});


//get ikeja indirect present night
/**
 * @swagger
 * /ikejaindirectpresentnight:
 *   get:
 *     summary: Get the total count of indirect employees present in Ikeja at night.
 *     description: Retrieves the total count of indirect employees present in Ikeja at night from the geopos_employees table.
 *     tags:
 *       - Employees
 *     security:
 *       - BearerAuth: []
 *     responses:
 *       200:
 *         description: Successful response with the total count of indirect employees present in Ikeja at night.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 ikejaIPNCount:
 *                   type: integer
 *                   description: Total count of indirect employees present in Ikeja at night.
 *                   example: 5
 *       500:
 *         description: An error occurred while fetching the total count of indirect employees present in Ikeja at night.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: "Internal Server Error"
 *
 * @function
 * @name getTotalIkejaIndirectPresentNight
 * @memberof module:Routes/Employees
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with executing the MySQL query.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
app.get('/ikejaindirectpresentnight', authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    // Get the current date in the Africa/Lagos timezone
    const date = new Date().toLocaleDateString('en-GB', { timeZone: 'Africa/Lagos' });
    const parts = date.split('/');
    const formattedDay = parts[0].padStart(2, '0');
    const formattedMonth = parts[1].padStart(2, '0');
    const year = parts[2];
    const date1 = `${formattedDay}-${formattedMonth}-${year}`;

    // SQL query to count the number of indirect employees present in Ikeja at night
    const query = `
      SELECT COUNT(*) as ikejaIPNCount
      FROM geopos_employees
      WHERE roleid = '1'
        AND passive_type = 'ACT'
        AND status = 'P'
        AND shift = 'NIGHT'
        AND workertype = 'INDIRECT'
        AND date = ?;
    `;

    // Execute the query
    const results = await executeQuery(connection,query, [date1]);

    // Send the results as JSON response
    res.send(results);
  } catch (error) {
    // Handle errors
    console.error('Error executing MySQL query: ', error);
    res.status(500).json({ error: 'Internal Server Error' });
  } finally {
      // Release the connection back to the pool in case of success or error
      if (connection) {
        connection.release();
        //console.log("Connection released");
      }
    }
});


 //get ikeja indirect absent night
 /**
 * @swagger
 * /ikejaindirectabsentnight:
 *   get:
 *     summary: Get the total count of indirect employees absent in Ikeja at night.
 *     description: Retrieves the total count of indirect employees absent in Ikeja at night from the geopos_employees table.
 *     tags:
 *       - Employees
 *     security:
 *       - BearerAuth: []
 *     responses:
 *       200:
 *         description: Successful response with the total count of indirect employees absent in Ikeja at night.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 ikejaIANCount:
 *                   type: integer
 *                   description: Total count of indirect employees absent in Ikeja at night.
 *                   example: 3
 *       500:
 *         description: An error occurred while fetching the total count of indirect employees absent in Ikeja at night.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: "Internal Server Error"
 *
 * @function
 * @name getTotalIkejaIndirectAbsentNight
 * @memberof module:Routes/Employees
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with executing the MySQL query.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
 app.get('/ikejaindirectabsentnight', authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    // Get the current date in the Africa/Lagos timezone
    const date = new Date().toLocaleDateString('en-GB', { timeZone: 'Africa/Lagos' });
    const parts = date.split('/');
    const formattedDay = parts[0].padStart(2, '0');
    const formattedMonth = parts[1].padStart(2, '0');
    const year = parts[2];
    const date1 = `${formattedDay}-${formattedMonth}-${year}`;

    // SQL query to count the number of indirect employees absent in Ikeja at night
    const query = `
      SELECT COUNT(*) as ikejaIANCount
      FROM geopos_employees
      WHERE roleid = '1'
        AND passive_type = 'ACT'
        AND status = 'A'
        AND shift = 'NIGHT'
        AND workertype = 'INDIRECT'
        AND date = ?;
    `;

    // Execute the query
    const results = await executeQuery(connection,query, [date1]);

    // Send the results as JSON response
    res.send(results);
  } catch (error) {
    // Handle errors
    console.error('Error executing MySQL query: ', error);
    res.status(500).json({ error: 'Internal Server Error' });
  } finally {
    // Release the connection back to the pool in case of success or error
    if (connection) {
      connection.release();
      //console.log("Connection released");
    }
  }
});

  
//items row
/**
 * @swagger
 * /dashboard_total_item:
 *   get:
 *     summary: Get the total count of items in the dashboard.
 *     description: Retrieves the total count of items in the dashboard from the item_master table.
 *     tags:
 *       - Dashboard
 *     security:
 *       - BearerAuth: []
 *     responses:
 *       200:
 *         description: Successful response with the total count of items in the dashboard.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 totalItem:
 *                   type: integer
 *                   description: Total count of items in the dashboard.
 *                   example: 100
 *       500:
 *         description: An error occurred while fetching the total count of items in the dashboard.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: "Error fetching total items"
 *
 * @function
 * @name getTotalItemsDashboard
 * @memberof module:Routes/Dashboard
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with executing the MySQL query.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
app.get('/dashboard_total_item', authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    const result = await executeQuery(connection,'SELECT COUNT(*) as rowCount FROM item_master');
    const rowCount = result[0].rowCount;
    const response = {
      totalItem: rowCount,
    };
    res.send(response);
    console.log('Connected!');
  } catch (err) {
    console.error(err);
    res.status(500).send('Error fetching total items');
  } finally {
    if (connection) {
      connection.release();
      //console.log("Connection released");
    }
  }
});

//--------------------------DASHBOARD PAGE DATA ---------------------------//

//---------------------------COMPANY SETTINGS----------------------------//

//get company setting details
/**
 * @swagger
 * /company:
 *   get:
 *     summary: Get company information.
 *     description: Retrieves company information from the geopos_system table.
 *     tags:
 *       - Company
 *     security:
 *       - BearerAuth: []
 *     responses:
 *       200:
 *         description: Successful response with the company information.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 id:
 *                   type: integer
 *                   description: The ID of the company.
 *                   example: 1
 *                 name:
 *                   type: string
 *                   description: The name of the company.
 *                   example: "XYZ Corporation"
 *                 address:
 *                   type: string
 *                   description: The address of the company.
 *                   example: "123 Main Street, City, Country"
 *                 phone:
 *                   type: string
 *                   description: The phone number of the company.
 *                   example: "+1234567890"
 *       500:
 *         description: An error occurred while fetching company information.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: "Error fetching company information"
 *
 * @function
 * @name getCompanyInfo
 * @memberof module:Routes/Company
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with executing the MySQL query.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
app.get('/company', authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    // SQL query to retrieve company information
    const query = 'SELECT * FROM geopos_system WHERE id=?';
    // Execute the query
    const result = await executeQuery(connection,query, [1]);
    // Send the result as JSON response
    res.send(result[0]);
  } catch (error) {
    // Handle errors
    console.error('Error executing MySQL query: ', error);
    res.status(500).json({ error: 'Internal Server Error' });
  } finally {
    // Release the connection back to the pool in case of success or error
    if (connection) {
      connection.release();
      //console.log("Connection released");
    }
  }
});


//update company settings
/**
 * @swagger
 * /update_company:
 *   post:
 *     summary: Update company information.
 *     description: Update company information in the geopos_system table.
 *     tags:
 *       - Company
 *     security:
 *       - BearerAuth: []
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             properties:
 *               cname:
 *                 type: string
 *                 description: The name of the company.
 *                 example: "XYZ Corporation"
 *               phone:
 *                 type: string
 *                 description: The phone number of the company.
 *                 example: "+1234567890"
 *               email:
 *                 type: string
 *                 format: email
 *                 description: The email address of the company.
 *                 example: "info@example.com"
 *               address:
 *                 type: string
 *                 description: The address of the company.
 *                 example: "123 Main Street"
 *               city:
 *                 type: string
 *                 description: The city of the company's address.
 *                 example: "City"
 *               region:
 *                 type: string
 *                 description: The region of the company's address.
 *                 example: "Region"
 *               country:
 *                 type: string
 *                 description: The country of the company's address.
 *                 example: "Country"
 *               postbox:
 *                 type: string
 *                 description: The postbox of the company's address.
 *                 example: "12345"
 *               taxid:
 *                 type: string
 *                 description: The tax ID of the company.
 *                 example: "123456789"
 *               foundation:
 *                 type: string
 *                 format: date
 *                 
 *                 example: "2022-11-25"
 *     responses:
 *       200:
 *         description: Successfully updated company information.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 message:
 *                   type: string
 *                   example: "Record Updated successfully"
 *       400:
 *         description: Bad request - Missing required fields.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 message:
 *                   type: string
 *                   example: "All fields are required"
 *       404:
 *         description: Record not found or updated.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 message:
 *                   type: string
 *                   example: "Record not found or updated"
 *       500:
 *         description: An error occurred while updating company information.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 message:
 *                   type: string
 *                   example: "Error updating company record"
 *
 * @function
 * @name updateCompanyInfo
 * @memberof module:Routes/Company
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with executing the MySQL query.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
app.post('/update_company', authenticateJWT, async (req, res) => {
  const { cname, phone, email, address, city, region, country, postbox, taxid, foundation } = req.body;

  // Validate input data
  if (!cname || !phone || !email || !address || !city || !region || !country || !postbox || !taxid || !foundation) {
    return res.status(400).json({ message: 'All fields are required' });
  }

  // Convert the foundation date format from "25-11-2022" to "2022-11-25"
  const foundationParts = foundation.split('-');
  const convertedFoundation = `${foundationParts[2]}-${foundationParts[1]}-${foundationParts[0]}`;

  console.log('Received Data:');
  console.log('cname:', cname);
  console.log('phone:', phone);
  console.log('email:', email);
  console.log('address:', address);
  console.log('city:', city);
  console.log('region:', region);
  console.log('country:', country);
  console.log('postbox:', postbox);
  console.log('taxid:', taxid);
  console.log('foundation:', convertedFoundation);

  let connection;

  try {
    connection = await getPoolConnection(); // Assuming getPoolConnection is defined elsewhere
    const result = await executeQuery(connection, 'UPDATE geopos_system SET cname=?,phone=?,email=?,address=?,city=?,region=?,country=?,postbox=?,taxid=?,foundation=?  WHERE id = ?', [cname, phone, email, address, city, region, country, postbox, taxid, convertedFoundation, 1]);

    if (result.affectedRows === 0) {
      return res.status(404).json({ message: 'Record not found or updated' });
    }

    return res.status(200).json({ message: 'Record Updated successfully' });
  } catch (error) {
    console.error('Error updating company record:', error);
    return res.status(500).json({ message: 'Error updating company record' });
  } finally {
    // Release the connection back to the pool in case of success or error
    if (connection) {
      connection.release();
      //console.log("Connection released");
    }
  }
});


//Company profile upload
const storage1 = multer.diskStorage({
  destination: (req, file, cb) => {
    const uploadPath = path.resolve(__dirname, '../src/component/CompanyLogo')
    cb(null, uploadPath)
  },
  filename: (req, file, cb) => {
    const uniqueSuffix = Date.now() + '-' + Math.round(Math.random() * 1e9)
    const originalExtension = path.extname(file.originalname)
    cb(null, file.fieldname + '-' + uniqueSuffix + originalExtension)
  },
})

const upload_Path = multer({ storage: storage1 }) // Destination folder for file uploads

/**
 * @swagger
 * /company_profile:
 *   post:
 *     summary: Upload company profile picture.
 *     description: Upload a company profile picture to be stored in the geopos_system table.
 *     tags:
 *       - Company
 *     security:
 *       - BearerAuth: []
 *     requestBody:
 *       required: true
 *       content:
 *         multipart/form-data:
 *           schema:
 *             type: object
 *             properties:
 *               file:
 *                 type: string
 *                 format: binary
 *     responses:
 *       200:
 *         description: Successfully uploaded company profile picture.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 message:
 *                   type: string
 *                   example: "File uploaded successfully"
 *       500:
 *         description: An error occurred while uploading the file.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: "Error uploading file"
 *
 * @function
 * @name uploadCompanyProfile
 * @memberof module:Routes/Company
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with executing the MySQL query or uploading the file.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
app.post('/company_profile', upload_Path.single('file'), authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    const file = req.file;
    const { originalname } = file;

    // MySQL query to store file information
    const query = 'UPDATE geopos_system SET logo=? WHERE id = ?';
    const result = await executeQuery(connection, query, [originalname, 1]);

    console.log('File uploaded successfully');
    res.json({ message: 'File uploaded successfully' });
  } catch (error) {
    console.error('Error uploading file:', error);
    res.status(500).json({ error: 'Error uploading file' });
  } finally {
    // Release the connection back to the pool in case of success or error
    if (connection) {
      connection.release();
      //console.log("Connection released");
    }
  }
});


//---------------------------COMPANY SETTINGS----------------------------//

//-------------------------MASTER--------------------------------//

//QC Master
/**
 * @swagger
 * /getqc:
 *   get:
 *     summary: Retrieve QC records.
 *     description: Retrieve all Quality Control (QC) records from the database.
 *     tags:
 *       - Quality Control
 *     security:
 *       - BearerAuth: []
 *     responses:
 *       200:
 *         description: Successful response containing QC records.
 *         content:
 *           application/json:
 *             example:
 *               - id: 1
 *                 category_name: "Category 1"
 *               - id: 2
 *                 category_name: "Category 2"
 *       401:
 *         description: Unauthorized error.
 *         content:
 *           application/json:
 *             example:
 *               message: "You are not authorized to perform this action."
 *       500:
 *         description: Internal server error.
 *         content:
 *           application/json:
 *             example:
 *               error: "An error occurred while retrieving QC records."
 * 
 * @function
 * @name getQCRecords
 * @memberof module:Routes/Quality Control
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {UnauthorizedError} Will throw an error if the user is not authorized.
 * @throws {InternalServerError} Will throw an error if there's an issue retrieving QC records.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
//Get qc master data for datatables
app.get("/getqc", authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    const query = "SELECT * FROM qc_master";
    const result = await executeQuery(connection,query);
    
    res.send(result);
    console.log(result);
  } catch (error) {
    console.error('Error:', error);
    res.status(500).json({ error: 'An error occurred' });
  } finally {
    if (connection) {
      connection.release();
    }
  }
});


/**
 * @swagger
 * /editqc/{id}:
 *   get:
 *     summary: Get QC record by ID.
 *     description: Retrieve a Quality Control (QC) record from the database by its ID.
 *     tags:
 *       - Quality Control
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         description: ID of the QC record to retrieve.
 *         schema:
 *           type: integer
 *           format: int64
 *     responses:
 *       200:
 *         description: Successful response containing the QC record.
 *         content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/QCRecord'
 *       404:
 *         description: QC record not found.
 *         content:
 *           application/json:
 *             example:
 *               message: "QC not found"
 *       500:
 *         description: Internal server error.
 *         content:
 *           application/json:
 *             example:
 *               message: "Server error"
 *
 * @function
 * @name getQCById
 * @memberof module:Routes/Quality Control
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {NotFoundError} Will throw an error if the QC record with the specified ID is not found.
 * @throws {InternalServerError} Will throw an error if there's an issue retrieving the QC record.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */

//edit qc master
app.get("/editqc/:id", async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    const id = req.params.id;
    const query = "SELECT * FROM qc_master WHERE id = ?";
    const results = await executeQuery(connection,query, [id]);

    if (results.length > 0) {
      const qc = results[0];
      res.status(200).json(qc);
    } else {
      res.status(404).json({ message: 'QC not found' });
    }
  } catch (error) {
    console.error('Error:', error);
    res.status(500).json({ message: 'Server error' });
  } finally {
    if (connection) {
      connection.release();
    }
  }
});

/**
 * @swagger
 * /updateqc:
 *   post:
 *     summary: Update QC record.
 *     description: Update the name and value of a specific Quality Control (QC) record in the database.
 *     tags:
 *       - Quality Control
 *     security:
 *       - BearerAuth: []
 *     requestBody:
 *       description: JSON object containing the QC record details to be updated.
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             properties:
 *               id:
 *                 type: integer
 *                 format: int64
 *                 description: The ID of the QC record to update.
 *                 example: 1
 *               name:
 *                 type: string
 *                 description: The new name of the QC record.
 *                 example: "New QC Name"
 *               value:
 *                 type: string
 *                 description: The new value of the QC record.
 *                 example: "New QC Value"
 *     responses:
 *       200:
 *         description: Successful response indicating the QC record has been updated.
 *         content:
 *           application/json:
 *             example:
 *               message: "QC Name Updated Successfully."
 *       500:
 *         description: Internal server error.
 *         content:
 *           application/json:
 *             example:
 *               error: "An error occurred while updating the QC."
 *
 * @function
 * @name updateQC
 * @memberof module:Routes/Quality Control
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue updating the QC record.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
//update qc master
app.post("/updateqc", authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    const id = req.body.id;
    const qcname = req.body.name;
    const qcvalue = req.body.value;
    
    const sql = "UPDATE qc_master SET name = ?, value = ? WHERE id = ?";
    await executeQuery(connection,sql, [qcname, qcvalue, id]);

    res.json({ message: 'QC Name Updated Successfully.' });
  } catch (error) {
    console.error('Error:', error);
    res.status(500).json({ error: 'An error occurred while updating the QC.' });
  } finally {
    if (connection) {
      connection.release();
    }
  }
});


/**
 * @swagger
 * /additemcategory:
 *   post:
 *     summary: Add a new item category.
 *     description: Add a new item category to the database.
 *     tags:
 *       - Item Category
 *     security:
 *       - BearerAuth: []
 *     requestBody:
 *       description: JSON object containing the name of the item category to be added.
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             properties:
 *               category_name:
 *                 type: string
 *                 description: The name of the item category to be added.
 *                 example: "New Item Category"
 *     responses:
 *       200:
 *         description: Successful response indicating the item category has been added.
 *         content:
 *           application/json:
 *             example:
 *               message: "Item category added successfully."
 *       500:
 *         description: Internal server error.
 *         content:
 *           application/json:
 *             example:
 *               message: "Error adding item category"
 *
 * @function
 * @name addItemCategory
 * @memberof module:Routes/Item Category
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue adding the item category.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
//Add Item category
app.post("/additemcategory", authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    const name = req.body.category_name;
    const sql = "INSERT INTO item_category (category_name) VALUES (?)";
    await executeQuery(connection,sql, [name]);

    console.log('Connected!');
    res.json({ message: "Item category added successfully" });
  } catch (error) {
    console.error('Error:', error);
    res.status(500).json({ message: "Error adding item category" });
  } finally {
    if (connection) {
      connection.release();
    }
  }
});

/**
 * @swagger
 * /ic:
 *   get:
 *     summary: Retrieve item categories.
 *     description: Retrieve all item categories from the database.
 *     tags:
 *       - Item Category
 *     security:
 *       - BearerAuth: []
 *     responses:
 *       200:
 *         description: Successful response containing item categories.
 *         content:
 *           application/json:
 *             schema:
 *               type: array
 *               items:
 *                 type: object
 *                 properties:
 *                   id:
 *                     type: integer
 *                     format: int64
 *                     example: 1
 *                   category_name:
 *                     type: string
 *                     example: "Electronics"
 *       500:
 *         description: Internal server error.
 *         content:
 *           application/json:
 *             example:
 *               message: "Server error"
 *
 * @function
 * @name getItemCategories
 * @memberof module:Routes/Item Category
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue retrieving item categories.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
//Get Item categories for datatables
app.get("/ic", authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    const query = "SELECT * FROM item_category";
    const result = await executeQuery(connection,query);
    
    res.send(result);
    console.log(result);
  } catch (error) {
    console.error('Error:', error);
    res.status(500).json({ message: 'Server error' });
  } finally {
    if (connection) {
      connection.release();
    }
  }
});


/**
 * @swagger
 * /icnb:
 *   get:
 *     summary: Retrieve active item categories.
 *     description: Retrieve all active item categories from the database where status is '1'.
 *     tags:
 *       - Item Category
 *     security:
 *       - BearerAuth: []
 *     responses:
 *       200:
 *         description: Successful response containing active item categories.
 *         content:
 *           application/json:
 *             schema:
 *               type: array
 *               items:
 *                 type: object
 *                 properties:
 *                   id:
 *                     type: integer
 *                     format: int64
 *                     example: 1
 *                   category_name:
 *                     type: string
 *                     example: "Electronics"
 *                   status:
 *                     type: string
 *                     example: "1"
 *       500:
 *         description: Internal server error.
 *         content:
 *           application/json:
 *             example:
 *               message: "Server error"
 *
 * @function
 * @name getActiveItemCategories
 * @memberof module:Routes/Item Category
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue retrieving active item categories.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */

//Get Item categories for non braid
app.get("/icnb", authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    const query = "SELECT * FROM item_category WHERE status = ?";
    const result = await executeQuery(connection,query, ['1']);
    
    res.send(result);
    console.log(result);
  } catch (error) {
    console.error('Error:', error);
    res.status(500).json({ message: 'Server error' });
  } finally {
    if (connection) {
      connection.release();
    }
  }
});

/**
 * @swagger
 * /icf:
 *   get:
 *     summary: Retrieve item categories with item count.
 *     description: Retrieve all item categories from the database along with the count of items in each category.
 *     tags:
 *       - Item Category
 *     security:
 *       - BearerAuth: []
 *     responses:
 *       200:
 *         description: Successful response containing item categories and item counts.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 categories:
 *                   type: array
 *                   items:
 *                     type: object
 *                     properties:
 *                       category_name:
 *                         type: string
 *                         example: "Electronics"
 *                       item_count:
 *                         type: integer
 *                         example: 42
 *                 totalItems:
 *                   type: integer
 *                   example: 100
 *       500:
 *         description: Internal server error.
 *         content:
 *           application/json:
 *             example:
 *               error: "Internal server error"
 *
 * @function
 * @name getItemCategoriesWithCount
 * @memberof module:Routes/Item Category
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue retrieving item categories or item counts.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
//categories + item count
app.get("/icf", authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    const categoryQuery = "SELECT * FROM item_category";
    const categories = await executeQuery(connection,categoryQuery);

    const categoryItems = [];
    let totalItems = 0;

    for (const category of categories) {
      const itemCountQuery = "SELECT COUNT(*) AS item_count FROM item_masterr WHERE category_id = ?";
      const itemCountResult = await executeQuery(connection,itemCountQuery, [category.id]);

      const itemCount = itemCountResult[0].item_count;
      totalItems += itemCount;

      categoryItems.push({
        category_name: category.category_name,
        item_count: itemCount,
      });
    }

    res.json({
      categories: categoryItems,
      totalItems: totalItems,
    });
  } catch (error) {
    console.error('Error:', error);
    res.status(500).json({ error: "Internal server error" });
  } finally {
    if (connection) {
      connection.release();
    }
  }
});

/**
 * @swagger
 * /itemcategories:
 *   get:
 *     summary: Retrieve all item categories.
 *     description: Retrieve all item categories from the database.
 *     tags:
 *       - Item Category
 *     security:
 *       - BearerAuth: []
 *     responses:
 *       200:
 *         description: Successful response containing all item categories.
 *         content:
 *           application/json:
 *             schema:
 *               type: array
 *               items:
 *                 type: object
 *                 properties:
 *                   id:
 *                     type: integer
 *                     example: 1
 *                   category_name:
 *                     type: string
 *                     example: "Electronics"
 *       500:
 *         description: Internal server error.
 *         content:
 *           application/json:
 *             example:
 *               message: "Server error"
 *
 * @function
 * @name getItemCategories
 * @memberof module:Routes/Item Category
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue retrieving item categories.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
//Get Item categories for category dropdown in itemsubcategory add new page
app.get("/itemcategories", authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    const query = "SELECT id, category_name FROM item_category";
    const result = await executeQuery(connection,query);
    
    res.send(result);
    console.log(result);
    console.log('Connected!');
  } catch (error) {
    console.error('Error:', error);
    res.status(500).json({ message: 'Server error' });
  } finally {
    if (connection) {
      connection.release();
    }
  }
});

/**
 * @swagger
 * /additemsubcategory:
 *   post:
 *     summary: Add a new item subcategory.
 *     description: Add a new item subcategory to the database.
 *     tags:
 *       - Item Subcategory
 *     security:
 *       - BearerAuth: []
 *     requestBody:
 *       description: JSON object containing the category_id and subcategory_name to be added.
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             properties:
 *               category_id:
 *                 type: integer
 *                 example: 1
 *                 description: The ID of the category to which the subcategory belongs.
 *               subcategory_name:
 *                 type: string
 *                 example: "Laptops"
 *                 description: The name of the subcategory to be added.
 *     responses:
 *       200:
 *         description: Successful response indicating the item subcategory has been added.
 *         content:
 *           application/json:
 *             example:
 *               message: "Item Subcategory added successfully."
 *       500:
 *         description: Internal server error.
 *         content:
 *           application/json:
 *             example:
 *               message: "Error adding item subcategory"
 *
 * @function
 * @name addItemSubcategory
 * @memberof module:Routes/Item Subcategory
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue adding the item subcategory.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
//Add Item Subcategory
app.post("/additemsubcategory", authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    const cname = req.body.category_id;
    const scname = req.body.subcategory_name;
  
    const sql = "INSERT INTO item_subcategory (category_id, subcategory_name) VALUES (?, ?)";
    await executeQuery(connection, sql, [cname, scname]);

    console.log('Connected!');
    res.json({ message: "Item Subcategory added successfully" });
  } catch (error) {
    console.error('Error:', error);
    res.status(500).json({ message: "Error adding item subcategory" });
  } finally {
    if (connection) {
      connection.release();
    }
  }
});

/**
 * @swagger
 * /isc:
 *   get:
 *     summary: Retrieve all item subcategories.
 *     description: Retrieve all item subcategories from the database.
 *     tags:
 *       - Item Subcategory
 *     security:
 *       - BearerAuth: []
 *     responses:
 *       200:
 *         description: Successful response containing all item subcategories.
 *         content:
 *           application/json:
 *             schema:
 *               type: array
 *               items:
 *                 type: object
 *                 properties:
 *                   id:
 *                     type: integer
 *                     example: 1
 *                   category_id:
 *                     type: integer
 *                     example: 1
 *                   subcategory_name:
 *                     type: string
 *                     example: "Laptops"
 *       500:
 *         description: Internal server error.
 *         content:
 *           application/json:
 *             example:
 *               message: "Server error"
 *
 * @function
 * @name getAllItemSubcategories
 * @memberof module:Routes/Item Subcategory
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue retrieving item subcategories.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
  //Get Item subcategories for datatables
  app.get("/isc", authenticateJWT, async (req, res) => {
    let connection;
    try {
      connection = await getPoolConnection();
      const query = "SELECT * FROM item_subcategory";
      const result = await executeQuery(connection,query);
      
      res.send(result);
      console.log(result);
      console.log('Connected!');
    } catch (error) {
      console.error('Error:', error);
      res.status(500).json({ message: 'Server error' });
    } finally {
      if (connection) {
        connection.release();
      }
    }
  });
  

/**
 * @swagger
 * /addshift:
 *   post:
 *     summary: Add a new shift.
 *     description: Add a new shift to the database.
 *     tags:
 *       - Shift
 *     security:
 *       - BearerAuth: []
 *     requestBody:
 *       description: JSON object containing the shift name to be added.
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             properties:
 *               shift_name:
 *                 type: string
 *                 description: The name of the shift to be added.
 *                 example: "Morning Shift"
 *     responses:
 *       200:
 *         description: Successful response indicating the shift has been added.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 id:
 *                   type: integer
 *                   example: 1
 *                 name:
 *                   type: string
 *                   example: "Morning Shift"
 *       500:
 *         description: Internal server error.
 *         content:
 *           application/json:
 *             example:
 *               message: "An error occurred"
 *
 * @function
 * @name addShift
 * @memberof module:Routes/Shift
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue adding the shift.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */

//Shift
//add shift
app.post("/addshift", authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    const shname = req.body.shift_name;
    const sql = `INSERT INTO geopos_shift (name) VALUES (?)`;
    const result = await executeQuery(connection,sql, [shname]);
    
    res.send(result);
    console.log(result);
    console.log('Connected!');
  } catch (error) {
    console.error('Error:', error);
    res.status(500).json({ message: "An error occurred" });
  } finally {
    if (connection) {
      connection.release();
    }
  }
});

/**
 * @swagger
 * /getshift:
 *   get:
 *     summary: Get all shifts.
 *     description: Retrieve all shifts from the database.
 *     tags:
 *       - Shift
 *     security:
 *       - BearerAuth: []
 *     responses:
 *       200:
 *         description: Successful response with a list of shifts.
 *         content:
 *           application/json:
 *             schema:
 *               type: array
 *               items:
 *                 type: object
 *                 properties:
 *                   id:
 *                     type: integer
 *                     example: 1
 *                   name:
 *                     type: string
 *                     example: "Morning Shift"
 *       500:
 *         description: Internal server error.
 *         content:
 *           application/json:
 *             example:
 *               message: "An error occurred"
 *
 * @function
 * @name getShifts
 * @memberof module:Routes/Shift
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue retrieving the shifts.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
//Get Shifts for datatables
app.get("/getshift", authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    const query = "SELECT * FROM geopos_shift";
    const result = await executeQuery(connection,query);
    
    res.send(result);
    console.log(result);
  } catch (error) {
    console.error('Error:', error);
    res.status(500).json({ message: "An error occurred" });
  } finally {
    if (connection) {
      connection.release();
    }
  }
});
//Worker Type
/**
 * @swagger
 * /addworkertype:
 *   post:
 *     summary: Add a new worker type.
 *     description: Adds a new worker type to the database if it doesn't already exist.
 *     tags:
 *       - Worker Type
 *     security:
 *       - BearerAuth: []
 *     requestBody:
 *       description: JSON object containing the worker type name to be added.
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             properties:
 *               workertype_name:
 *                 type: string
 *                 description: The name of the worker type to be added.
 *                 example: "Electrician"
 *     responses:
 *       200:
 *         description: Successful response indicating the worker type has been added.
 *         content:
 *           application/json:
 *             example:
 *               message: "Worker Type added successfully"
 *       409:
 *         description: Conflict response indicating that the worker type already exists.
 *         content:
 *           application/json:
 *             example:
 *               message: "Error: Worker type already exists"
 *       500:
 *         description: Internal server error.
 *         content:
 *           application/json:
 *             example:
 *               message: "An error occurred"
 *
 * @function
 * @name addWorkerType
 * @memberof module:Routes/WorkerType
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with the database query or insertion.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
//Add Worker Type
  app.post("/addworkertype", authenticateJWT, async (req, res) => {
    let connection;
    try {
      connection = await getPoolConnection();
      const wtname = req.body.workertype_name;
  
      // Check if the worker type already exists
      const checkSql = `SELECT * FROM geopos_workertype WHERE name = ?`;
      const existingWorkerTypes = await executeQuery(connection,checkSql, [wtname]);
  
      if (existingWorkerTypes.length > 0) {
        // Worker type already exists
        res.status(409).json({ message: "Error: Worker type already exists" });
      } else {
        // Worker type does not exist, add it to the database
        const insertSql = `INSERT INTO geopos_workertype (name) VALUES (?)`;
        await executeQuery(connection,insertSql, [wtname]);
        res.status(200).json({ message: "Worker Type added successfully" });
      }
    } catch (error) {
      console.error('Error:', error);
      res.status(500).json({ message: "An error occurred" });
    } finally {
      if (connection) {
        connection.release();
      }
    }
  });
  
/**
 * @swagger
 * /getworkertype:
 *   get:
 *     summary: Retrieve all worker types.
 *     description: Fetches all worker types from the database.
 *     tags:
 *       - Worker Type
 *     security:
 *       - BearerAuth: []
 *     responses:
 *       200:
 *         description: Successful response with a list of all worker types.
 *         content:
 *           application/json:
 *             schema:
 *               type: array
 *               items:
 *                 type: object
 *                 properties:
 *                   id:
 *                     type: integer
 *                     example: 1
 *                   name:
 *                     type: string
 *                     example: "Electrician"
 *             example:
 *               - id: 1
 *                 name: "Electrician"
 *               - id: 2
 *                 name: "Plumber"
 *       500:
 *         description: Internal server error.
 *         content:
 *           application/json:
 *             example:
 *               message: "An error occurred"
 *
 * @function
 * @name getWorkerType
 * @memberof module:Routes/WorkerType
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with the database query.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
//Get Shifts for datatables
app.get("/getworkertype", authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    const query = "SELECT * FROM geopos_workertype";
    const result = await executeQuery(connection,query);
    
    res.send(result);
    console.log(result);
  } catch (error) {
    console.error('Error:', error);
    res.status(500).json({ message: "An error occurred" });
  } finally {
    if (connection) {
      connection.release();
    }
  }
});


//Employee Role
/**
 * @swagger
 * /getemployeerole:
 *   get:
 *     summary: Retrieve all employee roles.
 *     description: Fetches all employee roles from the database.
 *     tags:
 *       - Employee Role
 *     security:
 *       - BearerAuth: []
 *     responses:
 *       200:
 *         description: Successful response with a list of all employee roles.
 *         content:
 *           application/json:
 *             schema:
 *               type: array
 *               items:
 *                 type: object
 *                 properties:
 *                   id:
 *                     type: integer
 *                     example: 1
 *                   name:
 *                     type: string
 *                     example: "Manager"
 *             example:
 *               - id: 1
 *                 name: "Manager"
 *               - id: 2
 *                 name: "Technician"
 *       500:
 *         description: Internal server error.
 *         content:
 *           application/json:
 *             example:
 *               message: "An error occurred"
 *
 * @function
 * @name getEmployeeRole
 * @memberof module:Routes/EmployeeRole
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with the database query.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */

//Get Employee Role for datatables
app.get("/getemployeerole", authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    const query = "SELECT * FROM geopos_emptype";
    const result = await executeQuery(connection,query);
    
    res.send(result);
    console.log(result);
  } catch (error) {
    console.error('Error:', error);
    res.status(500).json({ message: "An error occurred" });
  } finally {
    if (connection) {
      connection.release();
    }
  }
});



//Color Master
/**
 * @swagger
 * /getcolor:
 *   get:
 *     summary: Retrieve active colors.
 *     description: Fetches all active colors from the color_master table where the status is '1'.
 *     tags:
 *       - Color
 *     security:
 *       - BearerAuth: []
 *     responses:
 *       200:
 *         description: Successful response with a list of active colors.
 *         content:
 *           application/json:
 *             schema:
 *               type: array
 *               items:
 *                 type: object
 *                 properties:
 *                   id:
 *                     type: integer
 *                     example: 1
 *                   color_name:
 *                     type: string
 *                     example: "Red"
 *                   status:
 *                     type: string
 *                     example: "1"
 *             example:
 *               - id: 1
 *                 color_name: "Red"
 *                 status: "1"
 *               - id: 2
 *                 color_name: "Blue"
 *                 status: "1"
 *       500:
 *         description: Internal server error.
 *         content:
 *           application/json:
 *             example:
 *               message: "An error occurred"
 *
 * @function
 * @name getColor
 * @memberof module:Routes/Color
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with the database query.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
//Get Color from database
app.get("/getcolor", authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    const query = "SELECT * FROM color_master WHERE status = '1'";
    const result = await executeQuery(connection,query);
    res.send(result);
    console.log(result);
    console.log('Connected!');
  } catch (error) {
    console.error('Error:', error);
    res.status(500).json({ message: "An error occurred" });
  } finally {
    if (connection) {
      connection.release();
    }
  }
});

/**
 * @swagger
 * /addcolor:
 *   post:
 *     summary: Add a new color.
 *     description: Adds a new color to the color_master table. If the color already exists and is active, it returns a conflict error.
 *     tags:
 *       - Color
 *     security:
 *       - BearerAuth: []
 *     requestBody:
 *       description: JSON object containing the color name to be added.
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             properties:
 *               color_name:
 *                 type: string
 *                 description: The name of the color to be added.
 *                 example: "Red"
 *     responses:
 *       200:
 *         description: Successful response indicating the color has been added.
 *         content:
 *           application/json:
 *             example:
 *               message: "Color added successfully"
 *       409:
 *         description: Conflict response indicating that the color name already exists.
 *         content:
 *           application/json:
 *             example:
 *               message: "Error: Color Name already exists"
 *       500:
 *         description: Internal server error.
 *         content:
 *           application/json:
 *             example:
 *               message: "An error occurred"
 *
 * @function
 * @name addColor
 * @memberof module:Routes/Color
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with the database query or insertion.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
// Add new color
app.post("/addcolor", authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    const colname = req.body.color_name;

    // Check if the color already exists
    const checkSql = `SELECT * FROM color_master WHERE color_name = ? AND status = '1'`;
    const existingColors = await executeQuery(connection,checkSql, [colname]);

    if (existingColors.length > 0) {
      // Color already exists
      res.status(409).json({ message: "Error: Color Name already exists" });
    } else {
      // Color does not exist, add it to the database
      const insertSql = `INSERT INTO color_master (color_name) VALUES (?)`;
      await executeQuery(connection,insertSql, [colname]);
      res.status(200).json({ message: "Color added successfully" });
    }
  } catch (error) {
    console.error('Error:', error);
    res.status(500).json({ message: "An error occurred" });
  } finally {
    if (connection) {
      connection.release();
    }
  }
});

/**
 * @swagger
 * /editcolor/{id}:
 *   get:
 *     summary: Get details of a color by ID.
 *     description: Retrieves the details of a specific color from the color_master table by its ID.
 *     tags:
 *       - Color
 *     security:
 *       - BearerAuth: []
 *     parameters:
 *       - name: id
 *         in: path
 *         required: true
 *         description: The ID of the color to retrieve.
 *         schema:
 *           type: integer
 *           example: 1
 *     responses:
 *       200:
 *         description: Successful response with the color details.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 id:
 *                   type: integer
 *                   example: 1
 *                 color_name:
 *                   type: string
 *                   example: "Red"
 *                 status:
 *                   type: string
 *                   example: "1"
 *       404:
 *         description: Not found response indicating that the color with the specified ID does not exist.
 *         content:
 *           application/json:
 *             example:
 *               message: 'Color not found'
 *       500:
 *         description: Internal server error.
 *         content:
 *           application/json:
 *             example:
 *               message: 'Server error'
 *
 * @function
 * @name editColor
 * @memberof module:Routes/Color
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with the database query.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
// GET request to fetch color data by ID
app.get("/editcolor/:id", authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    const id = req.params.id;
    // Construct the SQL query with a placeholder
    const query = 'SELECT * FROM color_master WHERE id = ?';

    // Execute the query with the id as a parameter
    const results = await executeQuery(connection,query, [id]);

    if (results.length > 0) {
      const section = results[0];
      res.status(200).json(section);
    } else {
      res.status(404).json({ message: 'Color not found' });
    }
  } catch (error) {
    console.error('Error executing query:', error);
    res.status(500).json({ message: 'Server error' });
  } finally {
    if (connection) {
      connection.release();
    }
  }
});

/**
 * @swagger
 * /updatecolor:
 *   post:
 *     summary: Update a color.
 *     description: Updates the name of a color in the color_master table.
 *     tags:
 *       - Color
 *     security:
 *       - BearerAuth: []
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             required:
 *               - id
 *               - colorname
 *             properties:
 *               id:
 *                 type: integer
 *                 description: ID of the color to update.
 *                 example: 1
 *               colorname:
 *                 type: string
 *                 description: New name for the color.
 *                 example: "Blue"
 *     responses:
 *       200:
 *         description: Color updated successfully.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 message:
 *                   type: string
 *                   example: "Color updated successfully"
 *       400:
 *         description: Color name already exists.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 message:
 *                   type: string
 *                   example: "Color name already exists."
 *       500:
 *         description: An error occurred while updating the color.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 message:
 *                   type: string
 *                   example: "An error occurred while updating the color."
 *
 * @function
 * @name updateColor
 * @memberof module:Routes/Color
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with the database query.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
// update color by ID
app.post("/updatecolor",  authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    const { id, colorname } = req.body;
    console.log('colorname:', colorname);

    // Check if the new color name already exists in the database
    const checkDuplicateSQL = `SELECT * FROM color_master WHERE color_name = ? AND status = '1'`;
    const duplicateResult = await executeQuery(connection,checkDuplicateSQL, [colorname]);

    if (duplicateResult.length > 0) {
      res.status(400).send({ message: "Color name already exists." });
    } else {
      const sql = `UPDATE color_master SET color_name = ? WHERE id = ?`;
      const result = await executeQuery(connection,sql, [colorname, id]);

      console.log(result);
      res.status(200).send({ message: "Color updated successfully" });
    }
  } catch (error) {
    console.error(error);
    res.status(500).send({ message: "An error occurred while updating the color." });
  } finally {
    if (connection) {
      connection.release();
    }
  }
});


/**
 * @swagger
 * /colordelete/{id}:
 *   delete:
 *     summary: Soft delete a color by ID.
 *     description: Soft deletes a color by setting its status to '0' in the color_master table.
 *     tags:
 *       - Color
 *     security:
 *       - BearerAuth: []
 *     parameters:
 *       - name: id
 *         in: path
 *         required: true
 *         description: The ID of the color to delete.
 *         schema:
 *           type: integer
 *           example: 1
 *     responses:
 *       200:
 *         description: Color deleted successfully.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 message:
 *                   type: string
 *                   example: "Color deleted successfully."
 *       500:
 *         description: An error occurred while deleting the color.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: "An error occurred while deleting the color."
 *
 * @function
 * @name deleteColor
 * @memberof module:Routes/Color
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with the database query.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */

// delete color by ID
app.delete("/colordelete/:id",  authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    const id = req.params.id;
    const query = "UPDATE color_master SET status='0' WHERE id = ?";
    const result = await executeQuery(connection,query, [id]);

    console.log(result);
    res.json({ message: 'Color deleted successfully.' });
  } catch (error) {
    console.error(error);
    res.status(500).json({ error: 'An error occurred while deleting the color.' });
  } finally {
    if (connection) {
      connection.release();
    }
  }
});



//Line Master
/**
 * @swagger
 * /getline:
 *   get:
 *     summary: Retrieve all active lines.
 *     description: Retrieves all entries from the line_master table where status is '1'.
 *     tags:
 *       - Line
 *     security:
 *       - BearerAuth: []
 *     responses:
 *       200:
 *         description: A list of active lines.
 *         content:
 *           application/json:
 *             schema:
 *               type: array
 *               items:
 *                 type: object
 *                 properties:
 *                   id:
 *                     type: integer
 *                     example: 1
 *                   line_name:
 *                     type: string
 *                     example: "Production Line 1"
 *                   status:
 *                     type: string
 *                     example: "1"
 *       500:
 *         description: An error occurred.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 message:
 *                   type: string
 *                   example: "An error occurred"
 *
 * @function
 * @name getLines
 * @memberof module:Routes/Line
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with the database query.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
//Get Line from database
app.get("/getline", authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    const query = "SELECT * FROM line_master WHERE status = '1'";
    const result = await executeQuery(connection,query);
    
    console.log(result);
    res.send(result);
  } catch (error) {
    console.error(error);
    res.status(500).send({ message: "An error occurred" });
  } finally {
    if (connection) {
      connection.release();
    }
  }
});

/**
 * @swagger
 * /addline:
 *   post:
 *     summary: Add a new line.
 *     description: Adds a new line to the line_master table.
 *     tags:
 *       - Line
 *     security:
 *       - BearerAuth: []
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             required:
 *               - line_name
 *             properties:
 *               line_name:
 *                 type: string
 *                 description: The name of the new line.
 *                 example: "Production Line 1"
 *     responses:
 *       200:
 *         description: Line added successfully.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 message:
 *                   type: string
 *                   example: "Line added successfully"
 *       409:
 *         description: Line name already exists.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 message:
 *                   type: string
 *                   example: "Error: Line name already exists"
 *       500:
 *         description: An error occurred.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 message:
 *                   type: string
 *                   example: "An error occurred"
 *
 * @function
 * @name addLine
 * @memberof module:Routes/Line
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with the database query.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
// Add new line
app.post("/addline",  authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    const linename = req.body.line_name;

    // Check if the line already exists
    const checkSql = `SELECT * FROM line_master WHERE line_name = ? AND status = '1'`;
    const existingLine = await executeQuery(connection,checkSql, [linename]);

    if (existingLine.length > 0) {
      // Line already exists
      res.status(409).send({ message: "Error: Line name already exists" });
    } else {
      // Line does not exist, add it to the database
      const insertSql = `INSERT INTO line_master (line_name) VALUES (?)`;
      await executeQuery(connection,insertSql, [linename]);

      res.status(200).send({ message: "Line added successfully" });
    }
  } catch (error) {
    console.error(error);
    res.status(500).send({ message: "An error occurred" });
  } finally {
    if (connection) {
      connection.release();
    }
  }
});

/**
 * @swagger
 * /editline/{id}:
 *   get:
 *     summary: Get details of a line by ID.
 *     description: Retrieves the details of a specific line from the line_master table by its ID.
 *     tags:
 *       - Line
 *     security:
 *       - BearerAuth: []
 *     parameters:
 *       - name: id
 *         in: path
 *         required: true
 *         description: The ID of the line to retrieve.
 *         schema:
 *           type: integer
 *           example: 1
 *     responses:
 *       200:
 *         description: Successful response with the line details.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 id:
 *                   type: integer
 *                   example: 1
 *                 line_name:
 *                   type: string
 *                   example: "Production Line 1"
 *                 status:
 *                   type: string
 *                   example: "1"
 *       404:
 *         description: Not found response indicating that the line with the specified ID does not exist.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 message:
 *                   type: string
 *                   example: "Line not found"
 *       500:
 *         description: Internal server error.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 message:
 *                   type: string
 *                   example: "Server error"
 *
 * @function
 * @name editLine
 * @memberof module:Routes/Line
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with the database query.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
// GET request to fetch color data by ID
app.get("/editline/:id", authenticateJWT, async (req, res) => {
  let connection;
  try {
   connection = await getPoolConnection();
    const id = req.params.id;
    // Construct the SQL query with a placeholder
    const query = 'SELECT * FROM line_master WHERE id = ?';

    // Execute the query with the id as a parameter
    const results = await executeQuery(connection,query, [id]);

    if (results.length > 0) {
      const lineData = results[0];
      res.status(200).json(lineData);
    } else {
      res.status(404).json({ message: 'Line not found' });
    }
  } catch (error) {
    console.error('Error executing query:', error);
    res.status(500).json({ message: 'Server error' });
  } finally {
    if (connection) {
      connection.release();
    }
  }
});

/**
 * @swagger
 * /updateline:
 *   post:
 *     summary: Update an existing line.
 *     description: Updates the name of an existing line in the line_master table.
 *     tags:
 *       - Line
 *     security:
 *       - BearerAuth: []
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             required:
 *               - id
 *               - linename
 *             properties:
 *               id:
 *                 type: integer
 *                 description: The ID of the line to update.
 *                 example: 1
 *               linename:
 *                 type: string
 *                 description: The new name for the line.
 *                 example: "Updated Production Line 1"
 *     responses:
 *       200:
 *         description: Line updated successfully.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 message:
 *                   type: string
 *                   example: "Line updated successfully"
 *       400:
 *         description: Line name already exists.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 message:
 *                   type: string
 *                   example: "Line name already exists."
 *       500:
 *         description: An error occurred while updating the line.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 message:
 *                   type: string
 *                   example: "An error occurred while updating the line."
 *
 * @function
 * @name updateLine
 * @memberof module:Routes/Line
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with the database query.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
// update color by ID
app.post("/updateline",  authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    const { id, linename } = req.body;
    console.log('linename:', linename);

    // Check if the new line name already exists in the database
    const checkDuplicateSQL = `SELECT * FROM line_master WHERE line_name = ? AND status = '1'`;
    const duplicateResult = await executeQuery(connection,checkDuplicateSQL, [linename]);

    if (duplicateResult.length > 0) {
      res.status(400).send({ message: "Line name already exists." });
    } else {
      const sql = `UPDATE line_master SET line_name = ? WHERE id = ?`;
      const result = await executeQuery(connection,sql, [linename, id]);
      
      console.log(result);
      res.status(200).send({ message: "Line updated successfully" });
    }
  } catch (error) {
    console.error(error);
    res.status(500).send({ message: "An error occurred while updating the line." });
  } finally {
    if (connection) {
      connection.end();
    }
  }
});

/**
 * @swagger
 * /linedelete/{id}:
 *   delete:
 *     summary: Soft delete a line by ID.
 *     description: Soft deletes a line by setting its status to '0' in the line_master table.
 *     tags:
 *       - Line
 *     security:
 *       - BearerAuth: []
 *     parameters:
 *       - name: id
 *         in: path
 *         required: true
 *         description: The ID of the line to delete.
 *         schema:
 *           type: integer
 *           example: 1
 *     responses:
 *       200:
 *         description: Line deleted successfully.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 message:
 *                   type: string
 *                   example: "Line deleted successfully."
 *       500:
 *         description: An error occurred while deleting the line.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: "An error occurred while deleting the line."
 *
 * @function
 * @name deleteLine
 * @memberof module:Routes/Line
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with the database query.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
// delete line by ID
app.delete("/linedelete/:id", authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    const id = req.params.id;
    const query = "UPDATE line_master SET status='0' WHERE id = ?";
    const result = await executeQuery(connection,query, [id]);
    
    console.log(result);
    res.json({ message: 'Line deleted successfully.' });
  } catch (error) {
    console.error(error);
    res.status(500).json({ error: 'An error occurred while deleting the line.' });
  } finally {
    if (connection) {
      connection.end();
    }
  }
});


//waste master
/**
 * @swagger
 * /getwaste:
 *   get:
 *     summary: Retrieve all active waste entries.
 *     description: Retrieves all entries from the geopos_wastemaster table where status is '1'.
 *     tags:
 *       - Waste
 *     security:
 *       - BearerAuth: []
 *     responses:
 *       200:
 *         description: A list of active waste entries.
 *         content:
 *           application/json:
 *             schema:
 *               type: array
 *               items:
 *                 type: object
 *                 properties:
 *                   id:
 *                     type: integer
 *                     example: 1
 *                   waste_name:
 *                     type: string
 *                     example: "Plastic Waste"
 *                   status:
 *                     type: string
 *                     example: "1"
 *       500:
 *         description: An error occurred.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 message:
 *                   type: string
 *                   example: "An error occurred"
 *
 * @function
 * @name getWaste
 * @memberof module:Routes/Waste
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with the database query.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
//Get waste from database
app.get("/getwaste", authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    const query = "SELECT * FROM geopos_wastemaster WHERE status = '1'";
    const result = await executeQuery(connection,query);
    
    console.log(result);
    res.send(result);
  } catch (error) {
    console.error(error);
    res.status(500).send({ message: "An error occurred" });
  } finally {
    if (connection) {
      connection.end();
    }
  }
});

/**
 * @swagger
 * /addwaste:
 *   post:
 *     summary: Add a new waste entry.
 *     description: Adds a new waste entry to the geopos_wastemaster table.
 *     tags:
 *       - Waste
 *     security:
 *       - BearerAuth: []
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             required:
 *               - waste_name
 *             properties:
 *               waste_name:
 *                 type: string
 *                 description: The name of the new waste entry.
 *                 example: "Plastic Waste"
 *     responses:
 *       200:
 *         description: Waste added successfully.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 message:
 *                   type: string
 *                   example: "Waste added successfully"
 *       409:
 *         description: Waste name already exists.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 message:
 *                   type: string
 *                   example: "Error: Waste name already exists"
 *       500:
 *         description: An error occurred.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 message:
 *                   type: string
 *                   example: "An error occurred"
 *
 * @function
 * @name addWaste
 * @memberof module:Routes/Waste
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with the database query.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
// Add new waste
app.post("/addwaste",  authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    const wastename = req.body.waste_name;

    // Check if the line already exists
    const checkSql = `SELECT * FROM geopos_wastemaster WHERE name = ?`;
    const existingWaste = await executeQuery(connection,checkSql, [wastename]);

    if (existingWaste.length > 0) {
      // Waste already exists
      res.status(409).send({ message: "Error: Waste name already exists" });
    } else {
      // Waste does not exist, add it to the database
      const insertSql = `INSERT INTO geopos_wastemaster (name) VALUES (?)`;
      await executeQuery(connection,insertSql, [wastename]);
      
      res.status(200).send({ message: "Waste added successfully" });
    }
  } catch (error) {
    console.error(error);
    res.status(500).send({ message: "An error occurred" });
  } finally {
    if (connection) {
      connection.end();
    }
  }
});

/**
 * @swagger
 * /editwaste/{id}:
 *   get:
 *     summary: Get details of a waste entry by ID.
 *     description: Retrieves the details of a specific waste entry from the geopos_wastemaster table by its ID.
 *     tags:
 *       - Waste
 *     security:
 *       - BearerAuth: []
 *     parameters:
 *       - name: id
 *         in: path
 *         required: true
 *         description: The ID of the waste entry to retrieve.
 *         schema:
 *           type: integer
 *           example: 1
 *     responses:
 *       200:
 *         description: Successful response with the waste entry details.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 id:
 *                   type: integer
 *                   example: 1
 *                 name:
 *                   type: string
 *                   example: "Plastic Waste"
 *                 status:
 *                   type: string
 *                   example: "1"
 *       404:
 *         description: Not found response indicating that the waste entry with the specified ID does not exist.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 message:
 *                   type: string
 *                   example: "Waste not found"
 *       500:
 *         description: Internal server error.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 message:
 *                   type: string
 *                   example: "Server error"
 *
 * @function
 * @name editWaste
 * @memberof module:Routes/Waste
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with the database query.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
// GET request to fetch waste data by ID
app.get("/editwaste/:id", authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    const id = req.params.id;
    // Construct the SQL query with a placeholder
    const query = 'SELECT * FROM geopos_wastemaster WHERE id = ?';

    // Execute the query with the id as a parameter
    const results = await executeQuery(connection,query, [id]);

    if (results.length > 0) {
      const wasteData = results[0];
      res.status(200).json(wasteData);
    } else {
      res.status(404).json({ message: 'Waste not found' });
    }
  } catch (error) {
    console.error('Error executing query:', error);
    res.status(500).json({ message: 'Server error' });
  } finally {
    if (connection) {
      connection.end();
    }
  }
});

/**
 * @swagger
 * /updatewaste:
 *   post:
 *     summary: Update an existing waste entry.
 *     description: Updates the name of an existing waste entry in the geopos_wastemaster table.
 *     tags:
 *       - Waste
 *     security:
 *       - BearerAuth: []
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             required:
 *               - id
 *               - wastename
 *             properties:
 *               id:
 *                 type: integer
 *                 description: The ID of the waste entry to update.
 *                 example: 1
 *               wastename:
 *                 type: string
 *                 description: The new name for the waste entry.
 *                 example: "Updated Plastic Waste"
 *     responses:
 *       200:
 *         description: Waste updated successfully.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 message:
 *                   type: string
 *                   example: "Waste updated successfully"
 *       400:
 *         description: Waste name already exists.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 message:
 *                   type: string
 *                   example: "Waste name already exists."
 *       500:
 *         description: An error occurred while updating the waste.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 message:
 *                   type: string
 *                   example: "An error occurred while updating the waste."
 *
 * @function
 * @name updateWaste
 * @memberof module:Routes/Waste
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with the database query.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
// update waste by ID
app.post("/updatewaste",  authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    const { id, wastename } = req.body;
    console.log('wastename:', wastename);

    // Check if the new waste name already exists in the database
    const checkDuplicateSQL = `SELECT * FROM geopos_wastemaster WHERE name = ? AND status = '1'`;
    const duplicateResult = await executeQuery(connection,checkDuplicateSQL, [wastename]);

    if (duplicateResult.length > 0) {
      res.status(400).send({ message: "Waste name already exists." });
      return;
    }

    const updateSQL = `UPDATE geopos_wastemaster SET name = ? WHERE id = ?`;
    const updateResult = await executeQuery(connection,updateSQL, [wastename, id]);

    console.log(updateResult);
    res.status(200).send({ message: "Waste updated successfully" });
  } catch (error) {
    console.error(error);
    res.status(500).send({ message: "An error occurred while updating the waste." });
  } finally {
    if (connection) {
      connection.release();
    }
  }
});


/**
 * @swagger
 * /wastedelete/{id}:
 *   delete:
 *     summary: Soft delete a waste entry by ID.
 *     description: Soft deletes a waste entry by setting its status to '0' in the geopos_wastemaster table.
 *     tags:
 *       - Waste
 *     security:
 *       - BearerAuth: []
 *     parameters:
 *       - name: id
 *         in: path
 *         required: true
 *         description: The ID of the waste entry to delete.
 *         schema:
 *           type: integer
 *           example: 1
 *     responses:
 *       200:
 *         description: Waste deleted successfully.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 message:
 *                   type: string
 *                   example: "Waste deleted successfully."
 *       500:
 *         description: An error occurred while processing the request.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: "An error occurred while processing your request."
 *
 * @function
 * @name deleteWaste
 * @memberof module:Routes/Waste
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with the database query.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
// delete waste by ID
app.delete("/wastedelete/:id",  authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    const id = req.params.id;
    const query = "UPDATE geopos_wastemaster SET status='0' WHERE id = ?";
    const result = await executeQuery(connection, query, [id]);

    console.log(result);
    res.json({ message: 'Waste deleted successfully.' });
  } catch (error) {
    console.error(error);
    res.status(500).json({ error: 'An error occurred while processing your request.' });
  } finally {
    if (connection) {
      connection.release();
    }
  }
});




//machine master

/**
 * @swagger
 * /getmachine:
 *   get:
 *     summary: Retrieve all active machines.
 *     description: Retrieves all active machines from the geopos_machine table.
 *     tags:
 *       - Machine
 *     security:
 *       - BearerAuth: []
 *     responses:
 *       200:
 *         description: A list of active machines.
 *         content:
 *           application/json:
 *             schema:
 *               type: array
 *               items:
 *                 type: object
 *                 properties:
 *                   id:
 *                     type: integer
 *                     example: 1
 *                   name:
 *                     type: string
 *                     example: "Machine 1"
 *                   status:
 *                     type: integer
 *                     example: 1
 *       500:
 *         description: An error occurred.
 *         content:
 *           application/json:
 *             example:
 *               message: 'An error occurred'
 *
 * @function
 * @name getMachine
 * @memberof module:Routes/Machine
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with the database query.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
//Get machine from database
app.get("/getmachine", authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    const query = "SELECT * FROM geopos_machine WHERE status = 1";
    const result = await executeQuery(connection, query);
    console.log(result);
    res.send(result);
  } catch (error) {
    console.error(error);
    res.status(500).send({ message: "An error occurred" });
  } finally {
    if (connection) {
      connection.release();
    }
  }
});



/**
 * @swagger
 * /addmachine:
 *   post:
 *     summary: Add a new machine.
 *     description: Adds a new machine to the geopos_machine table.
 *     tags:
 *       - Machine
 *     security:
 *       - BearerAuth: []
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             required:
 *               - zone
 *               - machine
 *             properties:
 *               zone:
 *                 type: string
 *                 description: The zone of the new machine.
 *                 example: "Zone A"
 *               machine:
 *                 type: string
 *                 description: The name of the new machine.
 *                 example: "Machine 1"
 *     responses:
 *       200:
 *         description: Machine added successfully.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 message:
 *                   type: string
 *                   example: "Machine added successfully"
 *       500:
 *         description: An error occurred while adding the machine.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 message:
 *                   type: string
 *                   example: "An error occurred"
 *
 * @function
 * @name addMachine
 * @memberof module:Routes/Machine
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with the database query.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
// Add new machine
app.post("/addmachine", authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    const { zone, machine } = req.body;

    // Log the values of zone and machine
    console.log("Zone:", zone);
    console.log("Machine:", machine);

    // Directly add the machine to the database without checking if it already exists
    const insertSql = `INSERT INTO geopos_machine (zone, machine) VALUES (?, ?)`;
    await executeQuery(connection,insertSql, [zone, machine]);

    res.status(200).send({ message: "Machine added successfully" });
  } catch (error) {
    console.error(error);
    res.status(500).send({ message: "An error occurred" });
  } finally {
    if (connection) {
      connection.release();
    }
  }
});


/**
 * @swagger
 * /editmachine/{id}:
 *   get:
 *     summary: Get details of a machine by ID.
 *     description: Retrieves the details of a specific machine from the geopos_machine table by its ID.
 *     tags:
 *       - Machine
 *     security:
 *       - BearerAuth: []
 *     parameters:
 *       - name: id
 *         in: path
 *         required: true
 *         description: The ID of the machine to retrieve.
 *         schema:
 *           type: integer
 *           example: 1
 *     responses:
 *       200:
 *         description: Successful response with the machine details.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 id:
 *                   type: integer
 *                   example: 1
 *                 zone:
 *                   type: string
 *                   example: "Zone A"
 *                 machine:
 *                   type: string
 *                   example: "Machine 1"
 *                 status:
 *                   type: integer
 *                   example: 1
 *       404:
 *         description: Failed to fetch machine data.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 message:
 *                   type: string
 *                   example: "Failed to fetch machine data"
 *       500:
 *         description: Internal server error.
 *         content:
 *           application/json:
 *             example:
 *               message: 'Server error'
 *
 * @function
 * @name editMachine
 * @memberof module:Routes/Machine
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with the database query.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
// GET request to fetch machine data by ID
app.get("/editmachine/:id", authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    const id = req.params.id;
    // Construct the SQL query with a placeholder
    const query = 'SELECT * FROM geopos_machine WHERE id = ?';

    // Execute the query with the id as a parameter
    const results = await executeQuery(connection,query, [id]);

    if (results.length > 0) {
      const machineData = results[0];
      res.status(200).json(machineData);
    } else {
      res.status(404).json({ message: 'Failed to fetch machine data' });
    }
  } catch (error) {
    console.error('Error executing query:', error);
    res.status(500).json({ message: 'Server error' });
  } finally {
    if (connection) {
      connection.release();
    }
  }
});


/**
 * @swagger
 * /updatemachine:
 *   post:
 *     summary: Update machine details.
 *     description: Updates the details of a machine in the geopos_machine table.
 *     tags:
 *       - Machine
 *     security:
 *       - BearerAuth: []
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             required:
 *               - id
 *               - zone
 *               - machine
 *             properties:
 *               id:
 *                 type: integer
 *                 description: The ID of the machine to update.
 *                 example: 1
 *               zone:
 *                 type: string
 *                 description: The new zone of the machine.
 *                 example: "Zone B"
 *               machine:
 *                 type: string
 *                 description: The new name of the machine.
 *                 example: "Machine 2"
 *     responses:
 *       200:
 *         description: Machine updated successfully.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 message:
 *                   type: string
 *                   example: "Machine updated successfully"
 *       500:
 *         description: An error occurred while updating the machine.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 message:
 *                   type: string
 *                   example: "An error occurred while updating the machine."
 *
 * @function
 * @name updateMachine
 * @memberof module:Routes/Machine
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with the database query.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
// update machine by ID
app.post("/updatemachine", authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    const { id, zone, machine } = req.body;

    // Log the values of zone and machine
    console.log("Zone:", zone);
    console.log("Machine:", machine);

    const sql = `UPDATE geopos_machine SET zone = ?, machine = ? WHERE id = ?`;
    const result = await executeQuery(connection,sql, [zone, machine, id]);
    
    console.log(result);
    res.status(200).send({ message: "Machine updated successfully" });
  } catch (error) {
    console.error(error);
    res.status(500).send({ message: "An error occurred while updating the machine." });
  } finally {
    if (connection) {
      connection.release();
    } 
  }
});

/**
 * @swagger
 * /machinedelete/{id}:
 *   delete:
 *     summary: Soft delete a machine by ID.
 *     description: Soft deletes a machine by setting its status to '0' in the geopos_machine table.
 *     tags:
 *       - Machine
 *     security:
 *       - BearerAuth: []
 *     parameters:
 *       - name: id
 *         in: path
 *         required: true
 *         description: The ID of the machine to delete.
 *         schema:
 *           type: integer
 *           example: 1
 *     responses:
 *       200:
 *         description: Machine deleted successfully.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 message:
 *                   type: string
 *                   example: "Machine deleted successfully."
 *       500:
 *         description: An error occurred while deleting the machine.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: "An error occurred while deleting the machine."
 *
 * @function
 * @name deleteMachine
 * @memberof module:Routes/Machine
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with the database query.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
// delete machine by ID
app.delete("/machinedelete/:id", authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    const id = req.params.id;
    const result = await executeQuery(connection,"UPDATE geopos_machine SET status='0' WHERE id = ?", [id]);
    console.log(result);
    res.json({ message: 'Machine deleted successfully.' });
  } catch (error) {
    console.error(error);
    res.status(500).json({ error: 'An error occurred while deleting the machine.' });
  } finally {
    if (connection) {
      connection.release();
    }
  }
});


//Plan vs Target
/**
 * @swagger
 * /get_default_planvstarget:
 *   get:
 *     summary: Get default plan vs target for the current date.
 *     description: Retrieves the default plan vs target data for the current date from the target_plan_ota table.
 *     tags:
 *       - DefaultPlanVsTarget
 *     security:
 *       - BearerAuth: []
 *     responses:
 *       200:
 *         description: Successful response with default plan vs target data.
 *         content:
 *           application/json:
 *             schema:
 *               type: array
 *               items:
 *                 type: object
 *                 properties:
 *                   id:
 *                     type: integer
 *                     description: The ID of the target plan vs target entry.
 *                     example: 1
 *                   date:
 *                     type: string
 *                     description: The date of the target plan vs target entry.
 *                     example: "2024-05-15"
 *                   item_code_id:
 *                     type: integer
 *                     description: The ID of the item code associated with the target plan vs target entry.
 *                     example: 12345
 *                   target_qty:
 *                     type: integer
 *                     description: The target quantity for the item code on the specified date.
 *                     example: 100
 *                   product_code:
 *                     type: string
 *                     description: The product code associated with the item code.
 *                     example: "PROD001"
 *                   product_des:
 *                     type: string
 *                     description: The product description associated with the item code.
 *                     example: "Product 1"
 *       500:
 *         description: Internal server error.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: "Internal Server Error"
 *
 * @function
 * @name getDefaultPlanVsTarget
 * @memberof module:Routes/DefaultPlanVsTarget
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with the database query.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
//Get default plan vs target for current date
app.get("/get_default_planvstarget", authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    const date = new Date().toLocaleDateString('en-GB', { timeZone: 'Africa/Lagos' });
    const parts = date.split('/');
    const day = parts[0].padStart(2, '0');
    const month = parts[1].padStart(2, '0');
    const year = parts[2];
    const currentDate = `${day}-${month}-${year}`;

    const query = `
      SELECT target_plan_ota.*, item_code.product_code, item_code.product_des
      FROM target_plan_ota
      LEFT JOIN item_code ON target_plan_ota.item_code_id = item_code.id
      WHERE target_plan_ota.date = ?`;

    const results = await executeQuery(connection,query, [currentDate]);

    res.send(results);
  } catch (error) {
    console.error(error);
    res.status(500).json({ error: 'Internal Server Error' });
  } finally {
    if (connection) {
      connection.end();
    }
  }
});

/**
 * @swagger
 * /get_search_planvstarget:
 *   post:
 *     summary: Get search results for plan vs target based on a specific date.
 *     description: Retrieves the plan vs target data for a specific date from the target_plan_ota table.
 *     tags:
 *       - PlanVsTarget
 *     security:
 *       - BearerAuth: []
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             required:
 *               - fromdate
 *             properties:
 *               fromdate:
 *                 type: string
 *                 format: date
 *                 description: The date to search plan vs target data for in the format "YYYY-MM-DD".
 *                 example: "2024-05-15"
 *     responses:
 *       200:
 *         description: Successful response with plan vs target data for the specified date.
 *         content:
 *           application/json:
 *             schema:
 *               type: array
 *               items:
 *                 type: object
 *                 properties:
 *                   id:
 *                     type: integer
 *                     description: The ID of the target plan vs target entry.
 *                     example: 1
 *                   date:
 *                     type: string
 *                     description: The date of the target plan vs target entry.
 *                     example: "2024-05-15"
 *                   item_code_id:
 *                     type: integer
 *                     description: The ID of the item code associated with the target plan vs target entry.
 *                     example: 12345
 *                   target_qty:
 *                     type: integer
 *                     description: The target quantity for the item code on the specified date.
 *                     example: 100
 *                   product_code:
 *                     type: string
 *                     description: The product code associated with the item code.
 *                     example: "PROD001"
 *                   product_des:
 *                     type: string
 *                     description: The product description associated with the item code.
 *                     example: "Product 1"
 *       500:
 *         description: Internal server error.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: "Internal Server Error"
 *
 * @function
 * @name getSearchPlanVsTarget
 * @memberof module:Routes/PlanVsTarget
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with the database query.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
//Get search plan vs target for date
app.post("/get_search_planvstarget", authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    const fromdate = req.body.fromdate;
    const fdParts = fromdate.split('-');
    const fd = `${fdParts[2]}-${fdParts[1]}-${fdParts[0]}`;

    const dateObj = new Date(fromdate);
    const day = dateObj.getDate().toString().padStart(2, '0');
    const month = (dateObj.getMonth() + 1).toString().padStart(2, '0');
    const year = dateObj.getFullYear();

    const convertedDate = `${day}-${month}-${year}`;
    console.log('Converted:', convertedDate);

    const query = `
      SELECT target_plan_ota.*, item_code.product_code, item_code.product_des
      FROM target_plan_ota
      LEFT JOIN item_code ON target_plan_ota.item_code_id = item_code.id
      WHERE target_plan_ota.date = ?`;

    const results = await executeQuery(connection,query, [convertedDate]);

    res.send(results);
  } catch (error) {
    console.error(error);
    res.status(500).json({ error: 'Internal Server Error' });
  } finally {
    if (connection) {
      connection.release();
    }
  }
});


/**
 * @swagger
 * /gettargetplan:
 *   get:
 *     summary: Get target plans.
 *     description: Retrieves target plans from the database, including item codes and descriptions.
 *     tags:
 *       - TargetPlan
 *     security:
 *       - BearerAuth: []
 *     responses:
 *       200:
 *         description: Successful response with target plans data.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 data:
 *                   type: array
 *                   items:
 *                     type: object
 *                     properties:
 *                       id:
 *                         type: integer
 *                         description: The ID of the item code.
 *                         example: 1
 *                       product_id:
 *                         type: integer
 *                         description: The ID of the product associated with the item code.
 *                         example: 101
 *                       product_code:
 *                         type: string
 *                         description: The product code associated with the item code.
 *                         example: "PROD001"
 *                       product_description:
 *                         type: string
 *                         description: The description of the product associated with the item code.
 *                         example: "Product 1"
 *       500:
 *         description: Internal server error.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: "Internal Server Error"
 *
 * @function
 * @name getTargetPlan
 * @memberof module:Routes/TargetPlan
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with the database query.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
// Define the GET endpoint for fetching section targets
app.get('/gettargetplan', authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    // Execute the SQL query to fetch section targets from the database
    const query = `
      SELECT item_code.*, item_masterr.item_description
      FROM item_code
      LEFT JOIN item_masterr ON item_code.product_id = item_masterr.id
    `;

    const results = await executeQuery(connection,query);

    // Return the section targets as the API response
    res.json({ data: results });
  } catch (error) {
    console.error('Error fetching target plans:', error);
    res.status(500).json({ error: 'Internal Server Error' });
  } finally {
    if (connection) {
      connection.release();
    }
  }
});
/**
 * @swagger
 * /addtargetplan:
 *   post:
 *     summary: Add or update target plans.
 *     description: Adds or updates target plans for items. If a target plan for an item on a specific date already exists, it will be updated; otherwise, a new target plan will be added.
 *     tags:
 *       - TargetPlan
 *     security:
 *       - BearerAuth: []
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: array
 *             items:
 *               type: object
 *               required:
 *                 - item
 *                 - target
 *                 - date
 *                 - time
 *               properties:
 *                 item:
 *                   type: integer
 *                   description: The ID of the item code.
 *                   example: 1
 *                 target:
 *                   type: integer
 *                   description: The target quantity for the item.
 *                   example: 100
 *                 date:
 *                   type: string
 *                   format: date
 *                   description: The date for the target plan in the format "YYYY-MM-DD".
 *                   example: "2024-05-15"
 *                 time:
 *                   type: string
 *                   format: date-time
 *                   description: The timestamp when the target plan was added or updated in the format "YYYY-MM-DDTHH:MM:SSZ".
 *                   example: "2024-05-15T10:30:00Z"
 *     responses:
 *       200:
 *         description: Target plans added/updated successfully.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 message:
 *                   type: string
 *                   example: "Target plans added/updated successfully"
 *       500:
 *         description: Internal server error.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: "Internal server error"
 *
 * @function
 * @name addTargetPlan
 * @memberof module:Routes/TargetPlan
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with the database query.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
//add target plan
app.post('/addtargetplan', authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    const itemSections = req.body;
    const item = itemSections.map((itemSection) => itemSection.item);
    const target = itemSections.map((itemSection) => itemSection.target);
    const date = itemSections.map((itemSection) => itemSection.date);
    const time = itemSections.map((itemSection) => itemSection.time);

    console.log('Received request body values:');
    console.log('item:', item);
    console.log('target:', target);
    console.log('date:', date);
    console.log('time:', time);

    let j = 0;
    let k = 0;
    let completedQueries = 0;

    const processQuery = async (index) => {
      if (index >= itemSections.length) {
        if (j > 0 || k > 0) {
          res.status(200).json({ message: 'Target plans added/updated successfully' });
        } else {
          res.status(500).json({ 'status': 'Error', 'message': 'Database error' });
        }
        return;
      }

      const { item, target, date, time } = itemSections[index];

      const data = {
        'item_code_id': item,
        'target_plan': target,
        'date': date,
        'timestamp': time
      };

      const results = await executeQuery(connection,`SELECT * FROM target_plan_ota WHERE item_code_id='${item}' AND date='${date}'`);

      if (results.length > 0) {
        const cid = results[0].id;
        await executeQuery(connection,`UPDATE target_plan_ota SET ? WHERE id='${cid}'`, data);
        j++;
      } else {
        await executeQuery(connection,'INSERT INTO target_plan_ota SET ?', data);
        k++;
      }
      
      completedQueries++;
      processQuery(completedQueries);
    };

    await processQuery(0);
  } catch (error) {
    console.error('Error:', error);
    res.status(500).json({ error: 'Internal server error' });
  } finally {
    if (connection) {
      connection.release();
      console.log('Connection released');
    }
  }
});

/**
 * @swagger
 * /weeklyplanview:
 *   get:
 *     summary: View weekly target plans.
 *     description: Retrieves the list of items with their target plans for the current week.
 *     tags:
 *       - TargetPlan
 *     security:
 *       - BearerAuth: []
 *     responses:
 *       200:
 *         description: Weekly target plans retrieved successfully.
 *         content:
 *           application/json:
 *             schema:
 *               type: array
 *               items:
 *                 type: object
 *                 properties:
 *                   productDescription:
 *                     type: string
 *                     description: The description of the product.
 *                     example: "Product ABC"
 *                   productId:
 *                     type: integer
 *                     description: The ID of the product.
 *                     example: 123
 *       500:
 *         description: Internal server error.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: "Internal server error"
 *
 * @function
 * @name weeklyPlanView
 * @memberof module:Routes/TargetPlan
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with the database query.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
// weekly plan view
app.get('/weeklyplanview', authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    const today = new Date();
    const dayOfWeek = today.getDay();
    const startOfWeek = new Date(today);
    startOfWeek.setDate(today.getDate() - dayOfWeek + 1);
    const endOfWeek = new Date(today);
    endOfWeek.setDate(today.getDate() - dayOfWeek + 7);

    const ws = Math.floor(startOfWeek.getTime() / 1000);
    const we = Math.floor(endOfWeek.getTime() / 1000);
    
    const mainQuery = `
      SELECT *
      FROM target_plan_ota
      WHERE (timestamp BETWEEN ${ws} AND ${we})
      AND item_code_id > 0
      GROUP BY item_code_id
    `;

    const rows = await executeQuery(connection,mainQuery);

    const result = [];

    for (const row of rows) {
      const productId = row.item_code_id;
      const productQuery = `
        SELECT *
        FROM item_code
        WHERE id = ${productId}
      `;

      const productRow = await executeQuery(connection,productQuery);

      const productDescription = productRow[0].product_des;
      result.push({ productDescription, productId });
    }

    res.json(result);
  } catch (err) {
    console.error('Error:', err);
    res.status(500).json({ error: 'Internal server error' });
  } finally {
    if (connection) {
      connection.release();
    }
  }
});

/**
 * @swagger
 * /targetplan/batchh:
 *   get:
 *     summary: Get batch target plans for a specific week.
 *     description: Retrieves batch target plans for a specific week.
 *     tags:
 *       - TargetPlan
 *     security:
 *       - BearerAuth: []
 *     responses:
 *       200:
 *         description: Batch target plans retrieved successfully.
 *         content:
 *           application/json:
 *             schema:
 *               type: array
 *               items:
 *                 type: object
 *                 properties:
 *                   values:
 *                     type: object
 *                     description: The target plan values for each date in the week.
 *                     example: { "01-05-2022": 100, "02-05-2022": 150, ... }
 *                   dates:
 *                     type: array
 *                     description: The dates in the week.
 *                     items:
 *                       type: string
 *                       example: "01-05-2022"
 *                   desc:
 *                     type: string
 *                     description: The description of the product.
 *                     example: "Product ABC"
 *       404:
 *         description: No data found for the specified week.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: "No data found"
 *       500:
 *         description: Internal server error.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: "An error occurred"
 *
 * @function
 * @name batchTargetPlan
 * @memberof module:Routes/TargetPlan
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with the database query.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
// target plan 
app.get('/targetplan/batchh',authenticateJWT,async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    const timezone = 'Africa/Lagos';

    const weekStart = new Date();
    weekStart.setDate(weekStart.getDate() - weekStart.getDay() + 1);
    const weekEnd = new Date(weekStart);
    weekEnd.setDate(weekStart.getDate() + 6);

    let from = '';
    let to = '';
    
    if (weekStart && weekEnd) {
      from = new Date(weekStart);
      to = new Date(weekEnd);
    }

    from.toLocaleString('en-US', { timeZone: timezone });
    to.toLocaleString('en-US', { timeZone: timezone });

    const period = [];
    const date = new Date(from);

    while (date <= to) {
      period.push(new Date(date));
      date.setDate(date.getDate() + 1);
    }
   
   

    // Function to format a date as "d-m-Y"
    
    const formatDate = (date) => {
      const day = String(date.getDate()).padStart(2, '0');
      const month = String(date.getMonth() + 1).padStart(2, '0');
      const year = date.getFullYear();
      return `${day}-${month}-${year}`;
    };
    
    const ws = formatDate(weekStart);
    const we = formatDate(weekEnd);
    console.log(ws,we);
    const fd2 = Math.floor((weekStart.getTime() - (24 * 60 * 60 * 1000)) / 1000);
    const td1 = Math.floor(new Date(weekEnd).getTime() / 1000);
    const formattedDates = period.map((date) => formatDate(date));
    // Fetch data for geopos_machine
    const zoneRows = await executeQuery(connection,`SELECT * FROM target_plan_ota
    WHERE timestamp BETWEEN ${fd2} AND ${td1}
      AND item_code_id > 0
    GROUP BY item_code_id`);

    if (zoneRows.length > 0) {
      const responseData = [];

      for (const zoneItem of zoneRows) {
        const pdata = zoneItem.item_code_id;
        const descPromise = executeQuery(connection,'SELECT * FROM item_code WHERE id = ?', [pdata]);
        
        const valuesByDate = {};
        const operatorPromises = formattedDates.map(async (formattedDate) => {
          try {
            const operatorRows = await executeQuery(connection,`
              SELECT * FROM target_plan_ota WHERE item_code_id = ? AND date = ?
            `, [pdata, formattedDate]);

            if (operatorRows.length > 0) {
              const count = operatorRows[0].target_plan;
              valuesByDate[formattedDate] = count;
              console.log(count);
            } else {
              valuesByDate[formattedDate] = '';
            }
          } catch (dbError) {
            console.error('Database Error:', dbError);
            valuesByDate[formattedDate] = 'Error fetching data';
          }
        });

      

        const descResult = await descPromise;
        const descValue = descResult[0].product_des;
   
        await Promise.all(operatorPromises); // Await all operator data fetching

        responseData.push({
          values: valuesByDate,
          dates: formattedDates,
          desc: descValue,
        });
      }

      res.json(responseData);
      //console.log(responseData);
    } else {
      res.status(404).json({ error: 'No data found' });
    }
  } catch (error) {
    console.error(error);
    res.status(500).json({ error: 'An error occurred' });
  } finally {
    if (connection) {
      connection.end();
    }
  }
});


/**
 * @swagger
 * /targetplan/{productId}:
 *   post:
 *     summary: Get target plans for a product for the current week.
 *     description: Retrieves target plans for a specific product for the current week.
 *     tags:
 *       - TargetPlan
 *     security:
 *       - BearerAuth: []
 *     parameters:
 *       - name: productId
 *         in: path
 *         required: true
 *         description: The ID of the product for which target plans are to be fetched.
 *         schema:
 *           type: integer
 *           example: 123
 *     responses:
 *       200:
 *         description: Target plans retrieved successfully.
 *         content:
 *           application/json:
 *             schema:
 *               type: array
 *               items:
 *                 type: object
 *                 properties:
 *                   date:
 *                     type: string
 *                     format: date
 *                     description: The date for which the target plan is retrieved.
 *                     example: "01-05-2022"
 *                   target:
 *                     type: number
 *                     description: The target plan value for the specified date.
 *                     example: 100
 *       500:
 *         description: Internal server error.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: "An error occurred while fetching target plan data"
 *
 * @function
 * @name getTargetPlan
 * @memberof module:Routes/TargetPlan
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with the database query.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
// Define the API endpoint
app.post('/targetplan/:productId', authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    const productId = req.params.productId;

    // Calculate date range
    const week_start = new Date();
    week_start.setDate(week_start.getDate() - week_start.getDay());
    const week_endd = new Date(week_start);
    week_endd.setDate(week_start.getDate() + 7);

    const period = [];
    let current = new Date(week_start);
    while (current <= week_endd) {
      period.push(current);
      current = new Date(current);
      current.setDate(current.getDate() + 1);
    }

    const targetPlanData = [];

    // Execute queries for each day in the period
    for (const dt of period) {
      const dtt = formatDate(dt); // Assuming formatDate function formats date as "d-m-Y"
      const time = dt.getTime();

      const query = `SELECT * FROM target_plan_ota WHERE item_code_id=? AND timestamp=?`;
      const results = await executeQuery(connection,query, [productId, time]);

      if (results.length > 0) {
        const target = results[0].target_plan;
        targetPlanData.push({ date: dtt, target: target });
      }
    }

    // Send the target plan data as a response
    res.json(targetPlanData);
  } catch (error) {
    console.error('An error occurred while fetching target plan data:', error);
    res.status(500).json({ error: 'An error occurred while fetching target plan data' });
  } finally {
    if (connection) {
      connection.end();
    }
  }
});


// Helper function to format date as "d-m-Y"
function formatDate(date) {
  const day = date.getDate();
  const month = date.getMonth() + 1;
  const year = date.getFullYear();
  return `${day}-${month}-${year}`;
}

/**
 * @swagger
 * /ptt:
 *   get:
 *     summary: Get target plans for each product for the current week.
 *     description: Retrieves target plans for each product for the current week, organized by product group and description.
 *     tags:
 *       - TargetPlan
 *     security:
 *       - BearerAuth: []
 *     responses:
 *       200:
 *         description: Target plans retrieved successfully.
 *         content:
 *           application/json:
 *             schema:
 *               type: array
 *               items:
 *                 type: object
 *                 properties:
 *                   item_group:
 *                     type: string
 *                     description: The group to which the product belongs.
 *                     example: "Group A"
 *                   item_description:
 *                     type: string
 *                     description: The description of the product.
 *                     example: "Product X"
 *                   day0:
 *                     type: string
 *                     description: The target plan for the first day of the week.
 *                     example: "100"
 *                   day1:
 *                     type: string
 *                     description: The target plan for the second day of the week.
 *                     example: "120"
 *                   day2:
 *                     type: string
 *                     description: The target plan for the third day of the week.
 *                     example: "110"
 *                   day3:
 *                     type: string
 *                     description: The target plan for the fourth day of the week.
 *                     example: "105"
 *                   day4:
 *                     type: string
 *                     description: The target plan for the fifth day of the week.
 *                     example: "95"
 *                   day5:
 *                     type: string
 *                     description: The target plan for the sixth day of the week.
 *                     example: "130"
 *                   day6:
 *                     type: string
 *                     description: The target plan for the seventh day of the week.
 *                     example: "115"
 *       500:
 *         description: Internal server error.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: "Error fetching data from the database"
 *
 * @function
 * @name getTargetPlansForCurrentWeek
 * @memberof module:Routes/TargetPlan
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with the database query.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
app.get("/ptt", authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection(); 
    const weekDatesArray = getAllWeekDates();
    console.log(weekDatesArray);

    const result = await executeQuery(connection,"SELECT target_plan.*, item_masterr.item_description, item_masterr.item_group FROM target_plan INNER JOIN item_masterr ON target_plan.product_id = item_masterr.id GROUP BY target_plan.product_id");

    let processedResult = [];
    let index = 0;

    const processNextRow = () => {
      if (index >= result.length) {
        // All rows processed, send the response
        res.send(processedResult);
        return;
      }

      const rowData = result[index];
      const processedRow = { item_group: rowData.item_group, item_description: rowData.item_description };

      let index2 = 0;
      const processNextDate = () => {
        if (index2 >= weekDatesArray.length) {
          // All dates for this row processed, move to the next row
          processedResult.push(processedRow);
          index++;
          processNextRow();
          return;
        }

        const currentDate = weekDatesArray[index2];

        executeQuery(connection,
          `SELECT plan FROM target_plan WHERE product_id = ? AND datetime = ?`,
          [rowData.product_id, currentDate]
        ).then((result2) => {
          const plan = result2.length > 0 ? result2[0].plan : "-";
          const dayKey = "day" + index2;
          processedRow[dayKey] = plan;

          index2++;
          processNextDate();
        }).catch((error) => {
          console.error(error);
          res.status(500).send("Error fetching data from the database");
        });
      };

      processNextDate();
    };

    processNextRow();
  } catch (error) {
    console.error(error);
    res.status(500).send("Error fetching data from the database");
  } finally {
    if (connection) {
      connection.end();
    }
  }
});


// Function to get all the dates of the current week (Monday to Sunday) in DD-MM-YYYY format
function getAllWeekDates() {
  const now = new Date();
  const currentDayOfWeek = now.getDay();
  const startOfWeek = new Date(now);
  const offsetToMonday = currentDayOfWeek === 0 ? -6 : 1 - currentDayOfWeek;
  startOfWeek.setDate(now.getDate() + offsetToMonday);
  const weekDates = [];

  const options = { day: '2-digit', month: '2-digit', year: 'numeric' };
  const hyphenSeparator = '-';

  for (let i = 0; i < 7; i++) {
    const currentDate = new Date(startOfWeek);
    currentDate.setDate(startOfWeek.getDate() + i);
    const formattedDate = currentDate.toLocaleDateString(undefined, options)
      .split('/').join(hyphenSeparator);
    weekDates.push(formattedDate);
  }

  return weekDates;
}


/**
 * @swagger
 * /planvstargetdelete/{id}:
 *   delete:
 *     summary: Delete a plan vs target entry by ID.
 *     description: Deletes a plan vs target entry from the database using its ID.
 *     tags:
 *       - Plan vs Target
 *     security:
 *       - BearerAuth: []
 *     parameters:
 *       - name: id
 *         in: path
 *         required: true
 *         description: The ID of the plan vs target entry to delete.
 *         schema:
 *           type: integer
 *           example: 1
 *     responses:
 *       200:
 *         description: Plan vs target deleted successfully.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 message:
 *                   type: string
 *                   example: "Plan vs target deleted successfully."
 *       500:
 *         description: An error occurred while deleting the plan vs target entry.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: "An error occurred while deleting the plan vs target."
 *
 * @function
 * @name deletePlanVsTargetEntry
 * @memberof module:Routes/PlanVsTarget
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with the database query.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */

// delete plan vs target by ID
app.delete("/planvstargetdelete/:id", authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    const id = req.params.id;
    const result = await executeQuery(connection,"DELETE FROM target_plan_ota WHERE id = ?", [id]);
    console.log(result);
    res.json({ message: 'Plan vs target deleted successfully.' });
  } catch (error) {
    console.error('An error occurred while deleting the plan vs target:', error);
    res.status(500).json({ error: 'An error occurred while deleting the plan vs target.' });
  } finally {
    if (connection) {
      connection.release();
    }
  }
});



//Section
/**
 * @swagger
 * /section:
 *   get:
 *     summary: Retrieve active sections.
 *     description: Retrieves a list of active sections from the database.
 *     tags:
 *       - Section
 *     security:
 *       - BearerAuth: []
 *     responses:
 *       200:
 *         description: A list of active sections.
 *         content:
 *           application/json:
 *             schema:
 *               type: array
 *               items:
 *                 type: object
 *                 properties:
 *                   id:
 *                     type: integer
 *                     description: The section ID.
 *                     example: 1
 *                   name:
 *                     type: string
 *                     description: The name of the section.
 *                     example: Section A
 *                   status:
 *                     type: string
 *                     description: The status of the section.
 *                     example: Active
 *       500:
 *         description: An error occurred while fetching sections.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: An error occurred while fetching sections
 *
 * @function
 * @name getSections
 * @memberof module:Routes/Section
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with the database query.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
//Fetch Section data from section table to view in datatable
app.get("/section", authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    const query = "SELECT * FROM section WHERE status = '1'";
    const result = await executeQuery(connection,query);
    res.send(result);
    console.log(result);
    console.log('Connected!');
  } catch (error) {
    console.error('An error occurred while fetching sections:', error);
    res.status(500).json({ error: 'An error occurred while fetching sections' });
  } finally {
    if (connection) {
      connection.release();
    }
  }
});

/**
 * @swagger
 * /getsectiontype:
 *   get:
 *     summary: Retrieve section types.
 *     description: Retrieves a list of section types from the database.
 *     tags:
 *       - Section
 *     security:
 *       - BearerAuth: []
 *     responses:
 *       200:
 *         description: A list of section types.
 *         content:
 *           application/json:
 *             schema:
 *               type: array
 *               items:
 *                 type: object
 *                 properties:
 *                   id:
 *                     type: integer
 *                     description: The section type ID.
 *                     example: 1
 *                   name:
 *                     type: string
 *                     description: The name of the section type.
 *                     example: Type A
 *                   description:
 *                     type: string
 *                     description: The description of the section type.
 *                     example: This is type A
 *                   status:
 *                     type: string
 *                     description: The status of the section type.
 *                     example: Active
 *       500:
 *         description: An error occurred while fetching section types.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: An error occurred while fetching section types
 *
 * @function
 * @name getSectionTypes
 * @memberof module:Routes/Section
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with the database query.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */

//get section type
app.get("/getsectiontype", authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    const query = "SELECT * FROM item_category";
    const result = await executeQuery(connection,query);
    res.send(result);
    console.log(result);
  } catch (error) {
    console.error('An error occurred while fetching section types:', error);
    res.status(500).json({ error: 'An error occurred while fetching section types' });
  } finally {
    if (connection) {
      connection.release();
    }
  }
});



//Add Section
app.post("/addsection", authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    const { section_name, target_unit, section_type } = req.body;

    // Check if the section already exists
    const checkSql = `SELECT * FROM section WHERE section_name = ? AND status = '1' `;
    const existingSections = await executeQuery(connection,checkSql, [section_name]);

    if (existingSections.length > 0) {
      // Section already exists
      res.status(409).send({ message: "Error: Section already exists" });
    } else {
      // Section does not exist, add it to the database
      const insertSql = `INSERT INTO section (section_name, target_unit, section_type) VALUES (?, ?, ?)`;
      await executeQuery(connection,insertSql, [section_name, target_unit, section_type]);
      res.status(200).send({ message: "Section added successfully" });
    }
  } catch (error) {
    console.error('An error occurred while adding the section:', error);
    res.status(500).send({ message: "An error occurred while adding the section" });
  } finally {
    if (connection) {
      connection.release();
    }
  }
});


  
  /**
 * @swagger
 * /getsection/{id}:
 *   get:
 *     summary: Get section by ID.
 *     description: Retrieves a section from the database based on its ID.
 *     tags:
 *       - Section
 *     security:
 *       - BearerAuth: []
 *     parameters:
 *       - name: id
 *         in: path
 *         required: true
 *         description: The ID of the section to retrieve.
 *         schema:
 *           type: integer
 *           example: 1
 *     responses:
 *       200:
 *         description: Section retrieved successfully.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 id:
 *                   type: integer
 *                   description: The ID of the section.
 *                   example: 1
 *                 section_name:
 *                   type: string
 *                   description: The name of the section.
 *                   example: Section A
 *                 target_unit:
 *                   type: string
 *                   description: The target unit of the section.
 *                   example: Units
 *                 section_type:
 *                   type: integer
 *                   description: The ID of the section type.
 *                   example: 1
 *                 status:
 *                   type: string
 *                   description: The status of the section.
 *                   example: active
 *       404:
 *         description: Section not found.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 message:
 *                   type: string
 *                   example: Section not found
 *       500:
 *         description: Server error.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 message:
 *                   type: string
 *                   example: Server error
 *
 * @function
 * @name getSectionById
 * @memberof module:Routes/Section
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with the database query.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */

   // GET request to fetch section data by ID
   app.get("/getsection/:id", authenticateJWT, async (req, res) => {
    let connection;
    try {
      connection = await getPoolConnection();
      const id = req.params.id;
      // Construct the SQL query with a placeholder
      const query = 'SELECT * FROM section WHERE id = ?';
  
      // Execute the query with the id as a parameter
      const results = await executeQuery(connection,query, [id]);
  
      if (results.length > 0) {
        const section = results[0];
        res.status(200).json(section);
      } else {
        res.status(404).json({ message: 'Section not found' });
      }
    } catch (error) {
      console.error('Error executing query:', error);
      res.status(500).json({ message: 'Server error' });
    } finally {
      if (connection) {
        connection.end();
      }
    }
  });
  
/**
 * @swagger
 * /updatesection:
 *   post:
 *     summary: Update a section.
 *     description: Update a section's details in the database.
 *     tags:
 *       - Section
 *     security:
 *       - BearerAuth: []
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             properties:
 *               id:
 *                 type: integer
 *                 description: The ID of the section to update.
 *                 example: 1
 *               section_name:
 *                 type: string
 *                 description: The updated name of the section.
 *                 example: Section A
 *               target_unit:
 *                 type: string
 *                 description: The updated target unit of the section.
 *                 example: Units
 *               section_type:
 *                 type: integer
 *                 description: The updated ID of the section type.
 *                 example: 1
 *     responses:
 *       200:
 *         description: Section updated successfully.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 message:
 *                   type: string
 *                   example: Section updated successfully.
 *       400:
 *         description: Section name already exists.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: Section name already exists.
 *       500:
 *         description: An error occurred while updating the section.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: An error occurred while updating the section.
 *
 * @function
 * @name updateSection
 * @memberof module:Routes/Section
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with the database query.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */

// update section by ID
app.post("/updatesection", authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    const { id, section_name, target_unit, section_type } = req.body;

    // Check if the new section name already exists in the database
    const checkDuplicateSQL = `SELECT * FROM section WHERE section_name = ? AND status = '1' `;
    const duplicateResult = await executeQuery(connection,checkDuplicateSQL, [section_name]);

    if (duplicateResult.length > 0) {
      res.status(400).json({ error: 'Section name already exists.' });
    } else {
      const sql = `UPDATE section SET section_name=?, target_unit=?, section_type=? WHERE id=?`;
      const result = await executeQuery(connection,sql, [section_name, target_unit, section_type, id]);
      console.log(result);
      res.json({ message: 'Section updated successfully.' });
    }
  } catch (error) {
    console.error('An error occurred while updating the section:', error);
    res.status(500).json({ error: 'An error occurred while updating the section.' });
  } finally {
    if (connection) {
      connection.release();
    }
  }
});

/**
 * @swagger
 * /sectiondelete/{id}:
 *   delete:
 *     summary: Soft delete a section by ID.
 *     description: Soft deletes a section by setting its status to '0' in the database.
 *     tags:
 *       - Section
 *     security:
 *       - BearerAuth: []
 *     parameters:
 *       - name: id
 *         in: path
 *         required: true
 *         description: The ID of the section to delete.
 *         schema:
 *           type: integer
 *           example: 1
 *     responses:
 *       200:
 *         description: Section deleted successfully.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 message:
 *                   type: string
 *                   example: Section deleted successfully.
 *       500:
 *         description: An error occurred while deleting the section.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: An error occurred while deleting the section.
 *
 * @function
 * @name deleteSection
 * @memberof module:Routes/Section
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with the database query.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */

// delete section by ID
app.delete("/sectiondelete/:id", authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    const id = req.params.id;
    const result = await executeQuery(connection,"UPDATE section SET status='0' WHERE id = ?", [id]);
    console.log(result);
    res.json({ message: 'Section deleted successfully.' });
  } catch (error) {
    console.error('An error occurred while deleting the section:', error);
    res.status(500).json({ error: 'An error occurred while deleting the section.' });
  } finally {
    if (connection) {
      connection.release();
    }
  }
});

 

//Item Master
/**
 * @swagger
 * /getitemmaster:
 *   get:
 *     summary: Get all items from the item master table.
 *     description: Retrieves all items from the item master table along with their category names.
 *     tags:
 *       - Item Master
 *     security:
 *       - BearerAuth: []
 *     responses:
 *       200:
 *         description: An array of items from the item master table.
 *         content:
 *           application/json:
 *             schema:
 *               type: array
 *               items:
 *                 type: object
 *                 properties:
 *                   id:
 *                     type: integer
 *                     description: The ID of the item.
 *                     example: 1
 *                   item_code:
 *                     type: string
 *                     description: The item code.
 *                     example: ITEM001
 *                   item_description:
 *                     type: string
 *                     description: The description of the item.
 *                     example: Item 1
 *                   category_name:
 *                     type: string
 *                     description: The name of the category to which the item belongs.
 *                     example: Category 1
 *       500:
 *         description: An error occurred while fetching item master data.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: An error occurred while fetching item master.
 *
 * @function
 * @name getItemMaster
 * @memberof module:Routes/ItemMaster
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with the database query.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
//Get Item Master for datatables
app.get("/getitemmaster", authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    const query = `
      SELECT item_masterr.*, item_category.category_name
      FROM item_masterr
      LEFT JOIN item_category ON item_masterr.category_id = item_category.id
    `;
    const result = await executeQuery(connection,query);
    res.json(result);
    console.log(result);
  } catch (error) {
    console.error('An error occurred while fetching item master:', error);
    res.status(500).json({ error: "An error occurred while fetching item master" });
  } finally {
    if (connection) {
      connection.release();
    }
  }
});

/**
 * @swagger
 * /getsectiontarget:
 *   get:
 *     summary: Get section targets.
 *     description: Retrieves section targets from the database.
 *     tags:
 *       - Section
 *     security:
 *       - BearerAuth: []
 *     responses:
 *       200:
 *         description: An array of section targets.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 data:
 *                   type: array
 *                   items:
 *                     type: object
 *                     properties:
 *                       id:
 *                         type: integer
 *                         description: The ID of the section.
 *                         example: 1
 *                       section_name:
 *                         type: string
 *                         description: The name of the section.
 *                         example: Section 1
 *                       target_unit:
 *                         type: string
 *                         description: The target unit of the section.
 *                         example: Unit 1
 *                       section_type:
 *                         type: string
 *                         description: The type of the section.
 *                         example: Type 1
 *       500:
 *         description: An error occurred while fetching section targets.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: Internal Server Error
 *
 * @function
 * @name getSectionTargets
 * @memberof module:Routes/Section
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with the database query.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
//Get Sections Targets for Add New Item Master 
app.get('/getsectiontarget', authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    // Execute the SQL query to fetch section targets from the database
    const results = await executeQuery(connection,'SELECT * FROM section WHERE status = ?', ['1']);
    // Return the section targets as the API response
    res.json({ data: results });
  } catch (error) {
    console.error('Error fetching section targets:', error);
    res.status(500).json({ error: 'Internal Server Error' });
  } finally {
    if (connection) {
      connection.release();
    }
  }
});

/**
 * @swagger
 * /getcategories:
 *   get:
 *     summary: Get all item categories.
 *     description: Retrieves all item categories from the database.
 *     tags:
 *       - Item
 *     security:
 *       - BearerAuth: []
 *     responses:
 *       200:
 *         description: An array of item categories.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 data:
 *                   type: array
 *                   items:
 *                     type: object
 *                     properties:
 *                       id:
 *                         type: integer
 *                         description: The ID of the item category.
 *                         example: 1
 *                       category_name:
 *                         type: string
 *                         description: The name of the item category.
 *                         example: Category 1
 *       500:
 *         description: An error occurred while fetching item categories.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: Internal Server Error
 *
 * @function
 * @name getAllItemCategories
 * @memberof module:Routes/Item
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with the database query.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */

//Fetch categories and subcategories in add item master
app.get('/getcategories', authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    // Fetch all categories
    const results = await executeQuery(connection,'SELECT * FROM item_category');

    const categories = results.map((category) => ({
      id: category.id,
      category_name: category.category_name,
      // Include other properties if necessary
    }));

    res.json({ data: categories });
  } catch (error) {
    console.error('Failed to fetch categories:', error);
    res.status(500).json({ error: 'Failed to fetch categories' });
  } finally {
    if (connection) {
      connection.release();
    }
  }
});

/**
 * @swagger
 * /getcatsubcat/{category_id}:
 *   get:
 *     summary: Get subcategories by category ID.
 *     description: Retrieves subcategories based on the provided category ID from the database.
 *     tags:
 *       - Item
 *     security:
 *       - BearerAuth: []
 *     parameters:
 *       - name: category_id
 *         in: path
 *         required: true
 *         description: The ID of the category to fetch subcategories for.
 *         schema:
 *           type: integer
 *           example: 1
 *     responses:
 *       200:
 *         description: An array of subcategories.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 data:
 *                   type: array
 *                   items:
 *                     type: object
 *                     properties:
 *                       id:
 *                         type: integer
 *                         description: The ID of the subcategory.
 *                         example: 1
 *                       subcategory_name:
 *                         type: string
 *                         description: The name of the subcategory.
 *                         example: Subcategory 1
 *       500:
 *         description: An error occurred while fetching subcategories.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: Internal Server Error
 *
 * @function
 * @name getSubcategoriesByCategoryId
 * @memberof module:Routes/Item
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with the database query.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */

//get subcategories based on category value
app.get('/getcatsubcat/:category_id', authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    const categoryId = req.params.category_id;

    // Fetch subcategories based on the provided category_id
    const results = await executeQuery(connection,'SELECT * FROM item_subcategory WHERE category_id = ?', [categoryId]);

    const subcategories = results.map((subcategory) => ({
      id: subcategory.id,
      subcategory_name: subcategory.subcategory_name,
      // Include other properties if necessary
    }));

    res.json({ data: subcategories });
  } catch (error) {
    console.error('Failed to fetch subcategories:', error);
    res.status(500).json({ error: 'Failed to fetch subcategories' });
  } finally {
    if (connection) {
      connection.release();
    }
  }
});

/**
 * @swagger
 * /getcatsection/{category_id}:
 *   get:
 *     summary: Get sections by category ID.
 *     description: Retrieves sections based on the provided category ID from the database.
 *     tags:
 *       - Item
 *     security:
 *       - BearerAuth: []
 *     parameters:
 *       - name: category_id
 *         in: path
 *         required: true
 *         description: The ID of the category to fetch sections for.
 *         schema:
 *           type: integer
 *           example: 1
 *     responses:
 *       200:
 *         description: An array of sections.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 data:
 *                   type: array
 *                   items:
 *                     $ref: '#/components/schemas/Section'
 *       404:
 *         description: Category not found.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: Category not found.
 *       500:
 *         description: An error occurred while fetching category and items.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: Internal Server Error
 *
 * @function
 * @name getSectionsByCategoryId
 * @memberof module:Routes/Item
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {NotFoundError} Will throw an error if the category is not found.
 * @throws {InternalServerError} Will throw an error if there's an issue with the database query.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */

//get sections based on category value
app.get('/getcatsection/:category_id', authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    const categoryId = req.params.category_id;

    const getCategoryQuery = 'SELECT * FROM item_category WHERE id = ?';
    const categoryResults = await executeQuery(connection,getCategoryQuery, [categoryId]);

    if (categoryResults.length > 0) {
      const category_name = categoryResults[0].category_name;
      console.log('Category Name:', category_name);

      const getItemsQuery = 'SELECT * FROM section WHERE section_type = ? OR section_type = ? AND status = ?';
      const itemResults = await executeQuery(connection,getItemsQuery, [category_name, 'ALL', '1']);

      console.log('Items in this category:', itemResults);
      res.json({ data: itemResults });
    } else {
      console.log('Category not found');
      res.status(404).json({ error: 'Category not found.' });
    }
  } catch (error) {
    console.error('Error fetching category and items:', error);
    res.status(500).json({ error: 'An error occurred while fetching category and items.' });
  } finally {
    if (connection) {
      connection.release();
    }
  }
});



/**
 * @swagger
 * /additemmaster:
 *   post:
 *     summary: Add a new item master record.
 *     description: Add a new item master record to the database along with section-wise targets.
 *     tags:
 *       - Item
 *     security:
 *       - BearerAuth: []
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             properties:
 *               category_id:
 *                 type: integer
 *                 description: The ID of the category to which the item belongs.
 *               item_group:
 *                 type: string
 *                 description: The group to which the item belongs.
 *               item_description:
 *                 type: string
 *                 description: The description of the item.
 *               tppp:
 *                 type: string
 *                 description: The TPPP (Total Packing Production per Pack).
 *               net_weight:
 *                 type: string
 *                 description: The net weight of the item.
 *               targeted_waste:
 *                 type: string
 *                 description: The targeted waste percentage for the item.
 *               sectionWiseTargets:
 *                 type: array
 *                 items:
 *                   type: object
 *                   properties:
 *                     section:
 *                       type: string
 *                       description: The name of the section.
 *                     target:
 *                       type: string
 *                       description: The target for the section.
 *                     sectionid:
 *                       type: integer
 *                       description: The ID of the section.
 *     responses:
 *       200:
 *         description: Item added successfully.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 status:
 *                   type: string
 *                   example: Success
 *                 message:
 *                   type: string
 *                   example: Item added successfully
 *       400:
 *         description: Invalid request or missing data.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 status:
 *                   type: string
 *                   example: Error
 *                 message:
 *                   type: string
 *                   example: sectionWiseTargets not found or not in the expected format.
 *       409:
 *         description: Item already exists.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 status:
 *                   type: string
 *                   example: Error
 *                 message:
 *                   type: string
 *                   example: Item already exists
 *       500:
 *         description: Failed to add item.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 status:
 *                   type: string
 *                   example: Error
 *                 message:
 *                   type: string
 *                   example: An error occurred while adding the item
 *
 * @function
 * @name addItemMaster
 * @memberof module:Routes/Item
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {BadRequestError} Will throw an error if the request is invalid or missing data.
 * @throws {ConflictError} Will throw an error if the item already exists.
 * @throws {InternalServerError} Will throw an error if there's an issue with adding the item to the database.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */

//add item master
app.post('/additemmaster', authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    const {
      category_id,
      item_group,
      item_description,
      tppp,
      net_weight,
      targeted_waste,
    } = req.body;

    const sectionWiseTargets = req.body.sectionWiseTargets;

    if (!sectionWiseTargets || !Array.isArray(sectionWiseTargets)) {
      console.log('sectionWiseTargets not found or not in the expected format.');
      return res.status(400).json({ status: 'Error', message: 'sectionWiseTargets not found or not in the expected format.' });
    }

    const sections = [];
    const targets = [];
    const sectionids = [];

    sectionWiseTargets.forEach((item) => {
      if (item && item.section) {
        sections.push(item.section);
        targets.push(item.target);
        sectionids.push(item.sectionid);
      }
    });

    console.log('Sections:', sections);
    console.log('Targets:', targets);
    console.log('sectionids:', sectionids);

    const date = new Date().toLocaleDateString('en-GB', { timeZone: 'Africa/Lagos' });
    const parts = date.split('/');
    const day = parts[0].padStart(2, '0');
    const month = parts[1].padStart(2, '0');
    const year = parts[2];
    const currentMonth = `${month}-${year}`;
    const currentDate = `${day}-${month}-${year}`;

    const data = {
      category_id: category_id,
      item_group: item_group,
      item_description: item_description,
      tppp: tppp,
      net_weight: net_weight,
      targeted_waste: targeted_waste,
    };

    const existingItems = await executeQuery(connection,`SELECT * FROM item_masterr WHERE item_description = '${item_description}'`);

    if (existingItems.length > 0) {
      return res.status(409).json({ status: 'Error', message: 'Item already exists' });
    }

    const insertItemResult = await executeQuery(connection,'INSERT INTO item_masterr SET ?', data);

    if (sections.length > 0) {
      const lastInsertedItemIdResult = await executeQuery(connection,'SELECT * FROM item_masterr ORDER BY id DESC LIMIT 1');
      const opid = lastInsertedItemIdResult[0].id;
      console.log('OPId:', opid);

      for (let index = 0; index < sections.length; index++) {
        const section = sections[index];
        const sectionId = sectionids[index];
        const target = targets[index];

        if (!section) {
          console.log(`Invalid section at index ${index} in sectionWiseTargets array.`);
          return res.status(400).send({ message: "Invalid sectionWiseTargets array in the request." });
        }

        const existingSectionResult = await executeQuery(connection,`SELECT * FROM item_section_ota WHERE item_id='${opid}' AND section_id='${section}'`);

        if (existingSectionResult.length > 0) {
          const cid = existingSectionResult[0].id;
          console.log('cid:', cid);
          const datau = {
            target: target,
            utarget: utarget[index],
          };

          await executeQuery(connection,'UPDATE item_section_ota SET ? WHERE id = ?', [datau, cid]);
        } else {
          const data1 = {
            item_id: opid,
            section_id: sectionId,
            target: target,
          };

          await executeQuery(connection,'INSERT INTO item_section_ota SET ?', data1);
        }
      }
    }

    return res.status(200).json({ status: 'Success', message: 'Item added successfully' });
  } catch (error) {
    console.error('Error adding item:', error);
    return res.status(500).json({ status: 'Error', message: 'Failed to add item' });
  } finally {
    if (connection) {
      connection.release();
    }
  }
});
/**
 * @swagger
 * /additemmaster:
 *   post:
 *     summary: Add a new item master record.
 *     description: Add a new item master record to the database along with section-wise targets.
 *     tags:
 *       - Item
 *     security:
 *       - BearerAuth: []
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             properties:
 *               category_id:
 *                 type: integer
 *                 description: The ID of the category to which the item belongs.
 *               item_group:
 *                 type: string
 *                 description: The group to which the item belongs.
 *               item_description:
 *                 type: string
 *                 description: The description of the item.
 *               tppp:
 *                 type: string
 *                 description: The TPPP (Total Packing Production per Pack).
 *               net_weight:
 *                 type: string
 *                 description: The net weight of the item.
 *               targeted_waste:
 *                 type: string
 *                 description: The targeted waste percentage for the item.
 *               sectionWiseTargets:
 *                 type: array
 *                 items:
 *                   type: object
 *                   properties:
 *                     section:
 *                       type: string
 *                       description: The name of the section.
 *                     target:
 *                       type: string
 *                       description: The target for the section.
 *                     sectionid:
 *                       type: integer
 *                       description: The ID of the section.
 *     responses:
 *       200:
 *         description: Item added successfully.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 status:
 *                   type: string
 *                   example: Success
 *                 message:
 *                   type: string
 *                   example: Item added successfully
 *       400:
 *         description: Invalid request or missing data.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 status:
 *                   type: string
 *                   example: Error
 *                 message:
 *                   type: string
 *                   example: sectionWiseTargets not found or not in the expected format.
 *       409:
 *         description: Item already exists.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 status:
 *                   type: string
 *                   example: Error
 *                 message:
 *                   type: string
 *                   example: Item already exists
 *       500:
 *         description: Failed to add item.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 status:
 *                   type: string
 *                   example: Error
 *                 message:
 *                   type: string
 *                   example: An error occurred while adding the item
 *
 * @function
 * @name addItemMaster
 * @memberof module:Routes/Item
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {BadRequestError} Will throw an error if the request is invalid or missing data.
 * @throws {ConflictError} Will throw an error if the item already exists.
 * @throws {InternalServerError} Will throw an error if there's an issue with adding the item to the database.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */

//add item sections
app.post('/additemsections', authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    const itemSections = req.body;

    const sql = 'INSERT INTO item_section_moz (item_id, section_id, target, utarget) VALUES ?';

    // Extract the values from itemSections array
    const values = itemSections.map((itemSection) => [
      itemSection.item_id, // Use null if item_id is undefined
      itemSection.section_id,
      itemSection.target,
      itemSection.utarget,
    ]);

    // Execute the query with the values using the executeQuery function
    const result = await executeQuery(connection,sql, [values]);

    console.log('Item sections inserted successfully');
    res.status(200).json({ message: 'Item sections added successfully' });
  } catch (error) {
    console.error('Error adding item sections:', error);
    res.status(500).json({ error: 'Failed to add item sections' });
  } finally {
    if (connection) {
      connection.release();
    }
  }
});
/**
 * @swagger
 * /getsections/{itemId}:
 *   get:
 *     summary: Get sections for a specific item.
 *     description: Retrieve sections associated with a specific item from the database.
 *     tags:
 *       - Section
 *     security:
 *       - BearerAuth: []
 *     parameters:
 *       - in: path
 *         name: itemId
 *         description: The ID of the item to fetch sections for.
 *         required: true
 *         schema:
 *           type: integer
 *     responses:
 *       200:
 *         description: Sections fetched successfully.
 *         content:
 *           application/json:
 *             schema:
 *               type: array
 *               items:
 *                 type: object
 *                 properties:
 *                   id:
 *                     type: integer
 *                     description: The ID of the section.
 *                   section_name:
 *                     type: string
 *                     description: The name of the section.
 *                   target_unit:
 *                     type: string
 *                     description: The target unit for the section.
 *                   target:
 *                     type: string
 *                     description: The target for the section.
 *       500:
 *         description: Internal server error.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 message:
 *                   type: string
 *                   example: An error occurred while fetching sections.
 * @function
 * @name getSectionsForItem
 * @memberof module:Routes/Section
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with fetching sections from the database.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */

// API endpoint to fetch sections and targets
app.get('/getsections/:itemId', authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    const itemId = req.params.itemId;
    console.log('Received ID:', itemId);

    // Fetch sections data from the item_section_moz table
    const query = `
      SELECT item_section_ota.*, section.section_name, section.target_unit
      FROM item_section_ota
      LEFT JOIN section ON item_section_ota.section_id = section.id
      WHERE item_section_ota.item_id = "${itemId}"
    `;

    const results = await executeQuery(connection,query);

    const sections = results.map((row) => ({
      id: row.id,
      section_name: row.section_name,
      target_unit: row.target_unit,
      target: row.target,
    }));

    res.json(sections);
  } catch (error) {
    console.error('Error fetching sections:', error);
    res.sendStatus(500);
  } finally {
    if (connection) {
      connection.release();
    }
  }
});


/**
 * @swagger
 * /addsectionitemmaster/{itemId}:
 *   post:
 *     summary: Add section to item master.
 *     description: Add a section to the item master in the database.
 *     tags:
 *       - Section
 *     security:
 *       - BearerAuth: []
 *     parameters:
 *       - in: path
 *         name: itemId
 *         description: The ID of the item to add the section to.
 *         required: true
 *         schema:
 *           type: integer
 *       - in: body
 *         name: section
 *         description: The section details to add.
 *         required: true
 *         schema:
 *           type: object
 *           properties:
 *             section:
 *               type: integer
 *               description: The ID of the section to add.
 *             target:
 *               type: string
 *               description: The target for the section.
 *     responses:
 *       200:
 *         description: Section added successfully.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 message:
 *                   type: string
 *                   example: Section added successfully.
 *       409:
 *         description: Conflict - Section already exists for the item.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 message:
 *                   type: string
 *                   
 *       500:
 *         description: Internal server error.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 message:
 *                   type: string
 *                   example: An error occurred
 * @function
 * @name addSectionToItemMaster
 * @memberof module:Routes/Section
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {ConflictError} Will throw a conflict error if the section already exists for the item.
 * @throws {InternalServerError} Will throw an error if there's an issue with adding the section to the item master.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */

//add new section to item_master product
app.post('/addsectionitemmaster/:itemId', authenticateJWT, async (req, res) => {
  const itemId = req.params.itemId;
  const { section, target } = req.body;

  console.log('Received ID:', itemId);
 let connection;
  try {
    connection = await getPoolConnection();
    const checkSql = `SELECT * FROM item_section_ota WHERE item_id = ? AND section_id = ?`;
    const existingSection = await executeQuery(connection,checkSql, [itemId, section]);

    if (existingSection.length > 0) {
      // Section already exists
      res.status(409).send({ message: "Error: Section already exists" });
    } else {
      // Section does not exist, add it to the database
      const insertSql = `INSERT INTO item_section_ota (item_id, section_id, target) VALUES (?, ?, ?)`;
      await executeQuery(connection,insertSql, [itemId, section, target]);
      res.status(200).send({ message: "Section added successfully" });
    }
  } catch (error) {
    console.log(error);
    res.status(500).send({ message: "An error occurred" });
  } finally {
    if (connection) {
      connection.release();  
    }
  }
});


/**
 * @swagger
 * /getsectionandtarget/{itemId}:
 *   get:
 *     summary: Get section and target for item.
 *     description: Retrieve the section name, target unit, and target for the specified item.
 *     tags:
 *       - Section
 *     security:
 *       - BearerAuth: []
 *     parameters:
 *       - in: path
 *         name: itemId
 *         description: The ID of the item to retrieve section and target for.
 *         required: true
 *         schema:
 *           type: integer
 *     responses:
 *       200:
 *         description: Section and target retrieved successfully.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 sectionName:
 *                   type: string
 *                   description: The name of the section.
 *                   example: Section Name
 *                 targetUnit:
 *                   type: string
 *                   description: The unit of the target.
 *                   example: kg
 *                 target:
 *                   type: string
 *                   description: The target value.
 *                   example: 100
 *       404:
 *         description: Section and target not found for the item.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   description: Error message indicating the section and target were not found.
 *                   example: Section and target not found
 *       500:
 *         description: Internal server error.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 message:
 *                   type: string
 *                   example: An error occurred
 * @function
 * @name getSectionAndTargetForItem
 * @memberof module:Routes/Section
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {NotFoundError} Will throw a not found error if the section and target are not found for the item.
 * @throws {InternalServerError} Will throw an error if there's an issue with fetching the section and target.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */

//get section,unit and target to update 
app.get('/getsectionandtarget/:itemId', authenticateJWT, async (req, res) => {
  const itemId = req.params.itemId;
 let connection;
  try {
    connection = await getPoolConnection();
    // Fetch section name, target unit, and target from the Section and item_section_moz tables
    const query = `
      SELECT s.section_name, s.target_unit, ism.target
      FROM item_section_ota ism
      INNER JOIN section s ON ism.section_id = s.id
      WHERE ism.id = ?
      LIMIT 1
    `;

    const results = await executeQuery(connection,query, [itemId]);

    if (results.length === 0) {
      // Handle the case where no section and target is found for the itemId
      res.status(404).json({ error: 'Section and target not found' });
      return;
    }

    const sectionName = results[0].section_name;
    const targetUnit = results[0].target_unit;
    const target = results[0].target;

    res.json({ sectionName, targetUnit, target });
  } catch (error) {
    console.error('Error fetching section and target:', error);
    res.sendStatus(500);
  } finally {
    if (connection) {
      connection.end();
    }
  }
});


/**
 * @swagger
 * /updatesectiontarget:
 *   post:
 *     summary: Update section target value.
 *     description: Update the target value for a section.
 *     tags:
 *       - Section
 *     security:
 *       - BearerAuth: []
 *     requestBody:
 *       description: ID of the section and the updated target value.
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             properties:
 *               id:
 *                 type: integer
 *                 description: The ID of the section.
 *               updatedtarget:
 *                 type: string
 *                 description: The updated target value.
 *                 example: 100
 *     responses:
 *       200:
 *         description: Target value updated successfully.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 message:
 *                   type: string
 *                   example: Target value updated successfully.
 *       500:
 *         description: Internal server error.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: An error occurred while updating the target value.
 * @function
 * @name updateSectionTarget
 * @memberof module:Routes/Section
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with updating the target value.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */

// Update target value API endpoint
app.post('/updatesectiontarget', authenticateJWT, async (req, res) => {
  const itemId = req.body.id;
  const updatedTarget = req.body.updatedtarget;

  const query = 'UPDATE item_section_ota SET target = ? WHERE id = ?';
  let connection;
  try {
    connection = await getPoolConnection();
    await executeQuery(connection,query, [updatedTarget, itemId]);
    res.json({ message: 'Target value updated successfully.' });
  } catch (error) {
    console.error('Error updating target value:', error);
    res.status(500).json({ error: 'An error occurred while updating the target value.' });
  } finally {
    if (connection) {
      connection.end();
    }
  }
});


/**
 * @swagger
 * /getcolors:
 *   get:
 *     summary: Get colors.
 *     description: Retrieve a list of colors from the database.
 *     tags:
 *       - Colors
 *     security:
 *       - BearerAuth: []
 *     responses:
 *       200:
 *         description: A list of colors.
 *         content:
 *           application/json:
 *             schema:
 *               type: array
 *               items:
 *                 type: object
 *                 properties:
 *                   id:
 *                     type: integer
 *                     description: The ID of the color.
 *                   color_name:
 *                     type: string
 *                     description: The name of the color.
 *                   hex_code:
 *                     type: string
 *                     description: The hexadecimal code of the color.
 *       500:
 *         description: Internal server error.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 message:
 *                   type: string
 *                   example: An error occurred
 * @function
 * @name getColors
 * @memberof module:Routes/Colors
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with fetching colors.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */

//Get Color for dropdown
app.get("/getcolors", authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    const result = await executeQuery(connection,"SELECT * FROM color_master");
    res.send(result);
    console.log(result);
    console.log('Connected!');
  } catch (error) {
    console.log(error);
    res.status(500).send({ message: "An error occurred" });
  } finally {
    if (connection) {
      connection.end();
    }
  }
});
 

/**
 * @swagger
 * /getdata/{itemId}:
 *   get:
 *     summary: Get data for a specific item.
 *     description: Retrieve data for a specific item from the database.
 *     tags:
 *       - Item Data
 *     security:
 *       - BearerAuth: []
 *     parameters:
 *       - in: path
 *         name: itemId
 *         required: true
 *         description: The ID of the item to retrieve data for.
 *         schema:
 *           type: integer
 *     responses:
 *       200:
 *         description: Data for the specified item.
 *         content:
 *           application/json:
 *             schema:
 *               type: array
 *               items:
 *                 type: object
 *                 properties:
 *                   id:
 *                     type: integer
 *                     description: The ID of the item.
 *                   item_code:
 *                     type: string
 *                     description: The item code.
 *                   product_id:
 *                     type: integer
 *                     description: The ID of the product.
 *                   color_id:
 *                     type: integer
 *                     description: The ID of the color.
 *                   item_group:
 *                     type: string
 *                     description: The group of the item.
 *                   item_description:
 *                     type: string
 *                     description: The description of the item.
 *                   color_name:
 *                     type: string
 *                     description: The name of the color.
 *       500:
 *         description: Internal server error.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 message:
 *                   type: string
 *                   example: An error occurred
 * @function
 * @name getDataForItem
 * @memberof module:Routes/ItemData
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with fetching data for the item.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */

//get color and products code and product description
app.get("/getdata/:itemId", authenticateJWT, async (req, res) => {
  const itemId = req.params.itemId;

  const sql = `
    SELECT item_code.*, item_masterr.item_group, item_masterr.item_description, color_master.color_name
    FROM item_code
    LEFT JOIN item_masterr ON item_code.product_id = item_masterr.id
    LEFT JOIN color_master ON item_code.color_id = color_master.id
    WHERE item_code.product_id = ?
  `;
 let connection;
  try {
    connection = await getPoolConnection();
    const result = await executeQuery(connection,sql, [itemId]);
    res.send(result);
    console.log(result);
    console.log('Connected!');
  } catch (error) {
    console.log(error);
    res.status(500).send({ message: "An error occurred" });
  } finally {
    if (connection) {
      connection.end();
    }
  }
});
 

// add an item color to the item_code table
app.post('/additemcolor/:itemId', authenticateJWT, async (req, res) => {
  const itemId = req.params.itemId;
  const code = req.body.code;
  const desc = req.body.desc;
  const color = req.body.color;

  const date = new Date().toLocaleDateString('en-GB', { timeZone: 'Africa/Lagos' });
  const parts = date.split('/');
  const day = parts[0].padStart(2, '0');
  const month = parts[1].padStart(2, '0');
  const year = parts[2];
  const currentDate = `${day}-${month}-${year}`;

  console.error('currentDate:', currentDate);
 let connection;
  try {
    connection = await getPoolConnection();
    // Check if the color already exists
    const checkSql = `SELECT * FROM item_code WHERE product_id="${itemId}" AND product_code="${code}"`;
    const existingColors = await executeQuery(connection,checkSql);
    
    if (existingColors.length > 0) {
      // Color already exists
      res.status(409).send({ message: "Error: Color already exists" });
    } else {
      // Color does not exist, add it to the database
      const insertSql = `INSERT INTO item_code (product_code, product_des, color_id, date, product_id) VALUES ("${code}", "${desc}", "${color}", "${currentDate}", "${itemId}")`;
      await executeQuery(connection,insertSql);
      res.status(200).send({ message: "Color added successfully" });
    }
  } catch (error) {
    console.log(error);
    res.status(500).send({ message: "An error occurred" });
  } finally {
    if (connection) {
      connection.release();
    }
  }
});

/**
 * @swagger
 * /additemcolor/{itemId}:
 *   post:
 *     summary: Add color for an item.
 *     description: Add a new color for a specific item in the database.
 *     tags:
 *       - Item Data
 *     security:
 *       - BearerAuth: []
 *     parameters:
 *       - in: path
 *         name: itemId
 *         required: true
 *         description: The ID of the item to add the color to.
 *         schema:
 *           type: integer
 *       - in: body
 *         name: colorData
 *         description: The color data to be added.
 *         required: true
 *         schema:
 *           type: object
 *           properties:
 *             code:
 *               type: string
 *               description: The code of the color.
 *             desc:
 *               type: string
 *               description: The description of the color.
 *             color:
 *               type: integer
 *               description: The ID of the color.
 *     responses:
 *       200:
 *         description: Color added successfully.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 message:
 *                   type: string
 *                   example: Color added successfully
 *       400:
 *         description: Bad request. The color already exists for the item.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 message:
 *                   type: string
 *                   
 *       500:
 *         description: Internal server error.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 message:
 *                   type: string
 *                   example: An error occurred
 * @function
 * @name addItemColor
 * @memberof module:Routes/ItemData
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with adding the color for the item.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */

//getitemcode data
app.get('/getitemcodedata/:itemId', authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    const itemId = req.params.itemId;
    const query = 'SELECT * FROM item_code WHERE id = ?';

    // Execute the parameterized query using executeQuery function
    const results = await executeQuery(connection,query, [itemId]);

    res.json(results);
  } catch (error) {
    console.error('Error fetching item data:', error);
    res.status(500).json({ error: 'Failed to fetch item data' });
  } finally {
    if (connection) {
      connection.release();
    }
  }
});

/**
 * @swagger
 * /updateitemcolor/{itemId}:
 *   post:
 *     summary: Update color for an item.
 *     description: Update the color details for a specific item in the database.
 *     tags:
 *       - Item Data
 *     security:
 *       - BearerAuth: []
 *     parameters:
 *       - in: path
 *         name: itemId
 *         required: true
 *         description: The ID of the item to update the color for.
 *         schema:
 *           type: integer
 *       - in: body
 *         name: colorData
 *         description: The updated color data.
 *         required: true
 *         schema:
 *           type: object
 *           properties:
 *             product_code:
 *               type: string
 *               description: The code of the color.
 *             product_des:
 *               type: string
 *               description: The description of the color.
 *             color_id:
 *               type: integer
 *               description: The ID of the color.
 *     responses:
 *       200:
 *         description: ItemMaster Color updated successfully.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 message:
 *                   type: string
 *                   example: ItemMaster Color updated successfully
 *       500:
 *         description: Internal server error.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: Failed to update ItemMaster Color
 * @function
 * @name updateItemColor
 * @memberof module:Routes/ItemData
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with updating the color for the item.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */

// Update item color route
app.post('/updateitemcolor/:itemId', authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    const itemId = req.params.itemId;
    const { product_code, product_des, color_id } = req.body;

    // Perform the update operation in your MySQL database
    const updateQuery = 'UPDATE item_code SET product_code = ?, product_des = ?, color_id = ? WHERE id = ?';
    const updateValues = [product_code, product_des, color_id, itemId];

    await executeQuery(connection,updateQuery, updateValues);

    console.log('ItemMaster Color updated');
    res.status(200).json({ message: 'ItemMaster Color updated successfully' });
  } catch (error) {
    console.error('Error updating item color:', error);
    res.status(500).json({ error: 'Failed to update ItemMaster Color' });
  } finally {
    if (connection) {
      connection.release();
    }
  }
});

/**
 * @swagger
 * /deleteitemcode/{id}:
 *   delete:
 *     summary: Delete item code.
 *     description: Delete the item code entry from the database.
 *     tags:
 *       - Item Data
 *     security:
 *       - BearerAuth: []
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         description: The ID of the item code to delete.
 *         schema:
 *           type: integer
 *     responses:
 *       200:
 *         description: Item code deleted successfully.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 message:
 *                   type: string
 *                   example: Deleted Successfully
 *       500:
 *         description: Internal server error.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: An error occurred while deleting the item_code.
 * @function
 * @name deleteItemCode
 * @memberof module:Routes/ItemData
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with deleting the item code.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */

// DELETE route for deleting an item by ID
app.delete('/deleteitemcode/:id', authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    const itemId = req.params.id;
    const query = 'DELETE FROM item_code WHERE id = ?';

    // Execute the query to delete the item_code
    await executeQuery(connection,query, [itemId]);

    console.log('Item code deleted successfully');
    res.json({ message: 'Deleted Successfully' });
  } catch (error) {
    console.error('Error deleting item code:', error);
    res.status(500).json({ error: 'An error occurred while deleting the item_code.' });
  } finally {
    if (connection) {
      connection.release();
    }
  }
});

/**
 * @swagger
 * /edititemmaster/{itemId}:
 *   get:
 *     summary: Get item details for editing.
 *     description: Retrieve details of an item for editing based on the item ID.
 *     tags:
 *       - Item Data
 *     security:
 *       - BearerAuth: []
 *     parameters:
 *       - in: path
 *         name: itemId
 *         required: true
 *         description: The ID of the item to edit.
 *         schema:
 *           type: integer
 *     responses:
 *       200:
 *         description: Item details retrieved successfully.
 *         content:
 *           application/json:
 *             schema:
 *               type: array
 *               items:
 *                 $ref: '#/components/schemas/Item'
 *       500:
 *         description: Internal server error.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: Internal Server Error
 * components:
 *   schemas:
 *     Item:
 *       type: object
 *       properties:
 *         id:
 *           type: integer
 *           description: The unique identifier for the item.
 *         item_group:
 *           type: string
 *           description: The item group.
 *         item_description:
 *           type: string
 *           description: The description of the item.
 *         tppp:
 *           type: number
 *           description: The tppp of the item.
 *         net_weight:
 *           type: number
 *           description: The net weight of the item.
 *         targeted_waste:
 *           type: number
 *           description: The targeted waste of the item.
 *       required:
 *         - id
 *         - item_group
 *         - item_description
 *         - tppp
 *         - net_weight
 *         - targeted_waste
 * @function
 * @name getItemForEdit
 * @memberof module:Routes/ItemData
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with retrieving item details for editing.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */

//edit itemmaster
app.get('/edititemmaster/:itemId', authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    const itemId = req.params.itemId;
    const query = 'SELECT * FROM item_masterr WHERE id = ?';

    // Execute the parameterized query and handle the result
    const results = await executeQuery(connection,query, [itemId]);
    res.json(results);
  } catch (error) {
    console.error('Error in /edititemmaster/:itemId endpoint:', error);
    res.status(500).json({ error: 'Internal Server Error' });
  } finally {
    if (connection) {
      connection.release();
    }
  }
});


/**
 * @swagger
 * /updateitemmaster/{itemId}:
 *   post:
 *     summary: Update item details.
 *     description: Update details of an item based on the provided item ID.
 *     tags:
 *       - Item Data
 *     security:
 *       - BearerAuth: []
 *     parameters:
 *       - in: path
 *         name: itemId
 *         required: true
 *         description: The ID of the item to update.
 *         schema:
 *           type: integer
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             $ref: '#/components/schemas/UpdateItemRequest'
 *     responses:
 *       200:
 *         description: Item details updated successfully.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 message:
 *                   type: string
 *                   example: ItemMaster updated successfully
 *       500:
 *         description: Internal server error.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: Failed to update ItemMaster
 * components:
 *   schemas:
 *     UpdateItemRequest:
 *       type: object
 *       properties:
 *         category_id:
 *           type: integer
 *           description: The ID of the category to which the item belongs.
 *         item_group:
 *           type: string
 *           description: The group of the item.
 *         item_description:
 *           type: string
 *           description: The description of the item.
 *         tppp:
 *           type: number
 *           description: The tppp of the item.
 *         net_weight:
 *           type: number
 *           description: The net weight of the item.
 *         targeted_waste:
 *           type: number
 *           description: The targeted waste of the item.
 *       required:
 *         - category_id
 *         - item_group
 *         - item_description
 *         - tppp
 *         - net_weight
 *         - targeted_waste
 * @function
 * @name updateItemMaster
 * @memberof module:Routes/ItemData
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with updating item details.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */

//update itemmaster
app.post('/updateitemmaster/:itemId', authenticateJWT, async (req, res) => {
  const itemId = req.params.itemId;
  const { category_id, item_group, item_description, tppp, net_weight, targeted_waste } = req.body;
 let connection;
  try {
    connection = await getPoolConnection();
    // Perform database update operation using the provided data
    const query = 'UPDATE item_masterr SET category_id = ?, item_group = ?, item_description = ?, tppp = ?, net_weight = ?, targeted_waste = ? WHERE id = ?';
    const values = [category_id, item_group, item_description, tppp, net_weight, targeted_waste, itemId];

    await executeQuery(connection,query, values);

    console.log('ItemMaster updated successfully');
    res.json({ message: 'ItemMaster updated successfully' });
  } catch (error) {
    console.error('Error updating item:', error);
    res.status(500).json({ error: 'Failed to update ItemMaster' });
  } finally {
    if (connection) {
      connection.release();
    }
  }
});


/**
 * @swagger
 * /itemmasterdelete/{id}:
 *   delete:
 *     summary: Delete item master and related data.
 *     description: Deletes item master record and its related data (item codes and section targets) based on the provided item ID.
 *     tags:
 *       - Item Data
 *     security:
 *       - BearerAuth: []
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         description: The ID of the item to delete.
 *         schema:
 *           type: integer
 *     responses:
 *       200:
 *         description: Item master and related data deleted successfully.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 message:
 *                   type: string
 *                   example: Item Master and Related Data Deleted Successfully
 *       500:
 *         description: Internal server error.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: An error occurred while deleting item master and related data.
 * @function
 * @name deleteItemMaster
 * @memberof module:Routes/ItemData
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with deleting item master and related data.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */

// delete itemmaster by ID
app.delete("/itemmasterdelete/:id", authenticateJWT, async (req, res) => {
  const id = req.params.id;
  const queries = [
    'DELETE FROM item_masterr WHERE id = ?',
    'DELETE FROM item_code WHERE product_id = ?',
    'DELETE FROM item_section_ota WHERE item_id = ?',
  ];
 let connection;
  try {
    connection = await getPoolConnection()
    // Delete item_masterr
    await executeQuery(connection,queries[0], [id]);

    // Delete item_code
    await executeQuery(connection,queries[1], [id]);

    // Delete item_section_ota
    await executeQuery(connection,queries[2], [id]);

    res.json({ message: 'Item Master and Related Data Deleted Successfully' });
  } catch (error) {
    console.error(error);
    res.status(500).json({ error: 'An error occurred while deleting item master and related data.' });
  } finally {
    if (connection) {
      connection.release();
    }
  }
});


/**
 * @swagger
 * /delete_target/{id}:
 *   delete:
 *     summary: Delete item section target.
 *     description: Deletes an item section target based on the provided target ID.
 *     tags:
 *       - Item Data
 *     security:
 *       - BearerAuth: []
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         description: The ID of the item section target to delete.
 *         schema:
 *           type: integer
 *     responses:
 *       200:
 *         description: Item section target deleted successfully.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 status:
 *                   type: string
 *                   example: Success
 *                 message:
 *                   type: string
 *                   example: Deleted Successfully
 *       400:
 *         description: Invalid request.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 status:
 *                   type: string
 *                   example: Error
 *                 message:
 *                   type: string
 *                   example: Invalid Request
 *       500:
 *         description: Internal server error.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 status:
 *                   type: string
 *                   example: Error
 *                 message:
 *                   type: string
 *                   example: Internal Server Error
 * @function
 * @name deleteItemSectionTarget
 * @memberof module:Routes/ItemData
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with deleting the item section target.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */

// delete target
app.delete('/delete_target/:id', authenticateJWT, async (req, res) => {
  const id = req.params.id;
  let connection;
  try {
    connection = await getPoolConnection();
    if (!id) {
      return res.status(400).json({ status: 'Error', message: 'Invalid Request' });
    }

    const query = 'DELETE FROM item_section_ota WHERE id = ?';
    await executeQuery(connection,query, [id]);

    res.json({ status: 'Success', message: 'Deleted Successfully' });
  } catch (error) {
    console.error('Error executing MySQL query:', error);
    res.status(500).json({ status: 'Error', message: 'Internal Server Error' });
  } finally {
    if (connection) {
      connection.release();
    }
  }
});


//-------------------------MASTER--------------------------------//

//----------------------------HRM--------------------------------//
//ADMIN START
/**
 * @swagger
 * /admin:
 *   get:
 *     summary: Retrieve admin data
 *     description: Retrieves admin data based on role and employee IDs.
 *     tags:
 *       - Admin
 *     security:
 *       - BearerAuth: []
 *     responses:
 *       200:
 *         description: Successfully retrieved admin data.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 data:
 *                   type: array
 *                   items:
 *                     type: object
 *                     properties:
 *                       id:
 *                         type: integer
 *                         example: 1
 *                       roleid:
 *                         type: integer
 *                         example: 5
 *                       roleName:
 *                         type: string
 *                         example: 'Admin'
 *       500:
 *         description: Internal server error.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 status:
 *                   type: string
 *                   example: Error
 *                 message:
 *                   type: string
 *                   example: Internal Server Error
 * @function
 * @name getAdminData
 * @memberof module:Routes/Admin
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue retrieving admin data.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
//Admin List
app.get('/admin', authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    const roleid = 5; // Implement your logic to get the role ID
    const empId = 9; // Implement your logic to get the employee ID

    let query;
    if (roleid === 5 && empId === 9) {
      query = 'SELECT gu.*, get.name as roleName FROM geopos_users gu JOIN geopos_emptype get ON gu.roleid = get.id WHERE gu.roleid = 5 AND gu.id != ? ORDER BY gu.id DESC';
    } else {
      query = 'SELECT geopos_users.*, geopos_emptype.name as roleName FROM geopos_users LEFT JOIN geopos_emptype ON geopos_users.roleid = geopos_emptype.id WHERE geopos_users.id = ? AND geopos_users.roleid = ? ORDER BY geopos_users.id DESC';
    }

    const results = await executeQuery(connection, query, [empId]);

    console.log('Query Results:', results); // Log the results to the console

    res.status(200).json({ data: results }); // Send the response with the array directly under the "data" key
  } catch (error) {
    console.error('Error executing MySQL query:', error);
    res.status(500).json({ error: 'Internal Server Error' });
  } finally {
    // Release the connection back to the pool in case of success or error
    if (connection) {
      connection.release();
      //console.log("Connection released");
    }
  }
});

//add admin
app.post('/addnewadmin1', authenticateJWT ,async (req, res) => {
  //const { entryid, email, password, name } = req.body;
  const entryid = req.body.entryid;
  const email = req.body.email;
  let password = req.body.password || '123456'; // Default password if not provided
  const name = req.body.name;
  const roleid = '5';
  const production_type = 'both';
  const category_type = 'both';

  console.log('EntryId:', entryid);
  console.log('Email:', email);
  console.log('Password:', password);
  console.log('Name:', name);
  console.log('RoleId:', roleid);

  if (roleid < 4) {
    return res.json({ status: 'Error', message: 'Unauthorized' });
  }

  const query = `
    SELECT * FROM geopos_users 
    WHERE entryid = ? OR email = ?
  `;

  const updateQuery = `
    UPDATE geopos_users
    SET entryid = ?, name = ?, roleid = '5', production_type = 'both', category_type = 'both'
    WHERE id = ?
  `;

  db.query(query, [entryid, email], async (err, result) => {
    if (err) {
      console.error('MySQL query error:', err);
      return res.json({ status: 'Error', message: 'Database error' });
    }

    if (result.length > 0) {
      return res.json({ status: 'Error', message: 'EntryId or Email Already Exist' });
    } else {
      const newUser = {
        email: email,
        pass: await hashPassword1(password, entryid),
        username: email,
        name: name,
      };

      console.log('newUser:',newUser);

      db.query('INSERT INTO geopos_users SET ?', newUser, async (err, result) => {
        if (err) {
          console.error('MySQL insert error:', err);
          return res.json({ status: 'Error', message: 'Database error' });
        }

        const nuid = result.insertId;

        if (nuid > 0) {
          const userId = result.insertId;

          db.query(updateQuery, [entryid, name, userId], async (err, updateResult) => {
            if (err) {
              console.error('MySQL update error:', err);
              return res.json({ status: 'Error', message: 'Error updating user' });
            }

            console.log('Admin added and updated successfully:', newUser);

            return res.json({ status: 'Success', message: 'Admin added successfully' });
          });
        } else {
          return res.json({ status: 'Error', message: 'Error creating user' });
        }
      });
    }
  });
});
// Function to hash a password
async function hashPassword1(password, entryid) {
  if (configVars.usePasswordHash) {
    const saltRounds = configVars.passwordHashOptions.saltRounds || 10;
    return bcrypt.hash(password, saltRounds);
  } else {
    const salt = crypto.createHash('md5').update(entryid  || '').digest('hex');
    const hashAlgorithm = configVars.hash || 'sha256';
    return crypto.createHash(hashAlgorithm).update(salt + password).digest('hex');
  }
}
/**
 * @swagger
 * /addnewadmin:
 *   post:
 *     summary: Add a new admin user
 *     description: Adds a new admin user with provided entry ID, email, password, and name. If the password is not provided, a default password '123456' is used.
 *     tags:
 *       - Admin
 *     security:
 *       - BearerAuth: []
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             properties:
 *               entryid:
 *                 type: integer
 *                 description: The entry ID of the new admin user.
 *                 example: 101
 *               email:
 *                 type: string
 *                 description: The email of the new admin user.
 *                 example: 'admin@example.com'
 *               password:
 *                 type: string
 *                 description: The password for the new admin user.
 *                 example: 'password123'
 *               name:
 *                 type: string
 *                 description: The name of the new admin user.
 *                 example: 'John Doe'
 *     responses:
 *       200:
 *         description: Admin user added successfully.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 status:
 *                   type: string
 *                   example: Success
 *                 message:
 *                   type: string
 *                   example: Admin added successfully
 *       400:
 *         description: Invalid request or unauthorized access.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 status:
 *                   type: string
 *                   example: Error
 *                 message:
 *                   type: string
 *                   example: Unauthorized or Invalid Request
 *       500:
 *         description: Internal server error.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 status:
 *                   type: string
 *                   example: Error
 *                 message:
 *                   type: string
 *                   example: Internal Server Error
 * @function
 * @name addNewAdmin
 * @memberof module:Routes/Admin
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue adding the admin user.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
app.post('/addnewadmin', authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    const entryid = req.body.entryid;
    const email = req.body.email;
    let password = req.body.password || '123456'; // Default password if not provided
    const name = req.body.name;
    const roleid = '5';
    const production_type = 'both';
    const category_type = 'both';

    console.log('EntryId:', entryid);
    console.log('Email:', email);
    console.log('Password:', password);
    console.log('Name:', name);
    console.log('RoleId:', roleid);

    if (roleid < 4) {
      return res.json({ status: 'Error', message: 'Unauthorized' });
    }

    // Get the current date
    const currentDate = new Date();

    // Function to format the date in 'Y-m-d H:i:s' format
    const formatDate = (date) => {
      const year = date.getFullYear();
      const month = String(date.getMonth() + 1).padStart(2, '0');
      const day = String(date.getDate()).padStart(2, '0');
      const hours = String(date.getHours()).padStart(2, '0');
      const minutes = String(date.getMinutes()).padStart(2, '0');
      const seconds = String(date.getSeconds()).padStart(2, '0');

      return `${year}-${month}-${day} ${hours}:${minutes}:${seconds}`;
    };

    // Format the current date in 'Y-m-d H:i:s' format
    const formattedDate = formatDate(currentDate);

    const query = `
      SELECT * FROM geopos_users 
      WHERE entryid = ? OR email = ?
    `;

    const result = await executeQuery(connection,query, [entryid, email]);

    if (result.length > 0) {
      return res.json({ status: 'Error', message: 'EntryId or Email Already Exist' });
    }

    const hashedPassword = await hashPassword1(password, entryid); // Hash password using entryid

    const newUser = {
      email: email,
      pass: hashedPassword,
      username: email,
      name: name,
      date_created: formattedDate,
    };

    console.log('newUser:', newUser);

    const insertQuery = 'INSERT INTO geopos_users SET ?';
    const insertResult = await executeQuery(connection, insertQuery, newUser);

    const nuid = insertResult.insertId;
    console.log('nuid:', nuid);

    if (nuid > 0) {
      const userId = insertResult.insertId;
      console.log('userId:', userId);

      // Hash password using userId when updating
      const hashedPasswordForUpdate = await hashPassword2(password, userId);

      const updateQuery = `
        UPDATE geopos_users
        SET entryid = ?, pass = ?, name = ?, roleid = '5', production_type = 'both', category_type = 'both'
        WHERE id = ?
      `;

      await executeQuery(connection,updateQuery, [entryid, hashedPasswordForUpdate, name, userId]);

      console.log('Admin added and updated successfully:', newUser);

      return res.json({ status: 'Success', message: 'Admin added successfully' });
    } else {
      return res.json({ status: 'Error', message: 'Error creating user' });
    }
  } catch (error) {
    console.error('Error:', error);
    return res.json({ status: 'Error', message: 'Internal Server Error' });
  } finally {
    // Release the connection back to the pool in case of success or error
    if (connection) {
      connection.release();
      //console.log("Connection released");
    }
  }
});


// Function to hash a password
function hashPassword2(pass, userId) {
  userId = String(userId); // Ensure userId is a string
  if (configVars.usePasswordHash) {
    const saltRounds = configVars.passwordHashOptions.saltRounds || 10;
    return bcrypt.hash(pass, saltRounds);
  } else {
    const salt = crypto.createHash('md5').update(userId).digest('hex');
    const hashAlgorithm = configVars.hash || 'sha256';
    return crypto.createHash(hashAlgorithm).update(salt + pass).digest('hex');
  }
}
/**
 * @swagger
 * /admin_data_single/{id}:
 *   get:
 *     summary: Retrieve single admin data
 *     description: Fetches details of a single admin user based on the provided user ID.
 *     tags:
 *       - Admin
 *     security:
 *       - BearerAuth: []
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         description: The ID of the admin user to retrieve.
 *         schema:
 *           type: integer
 *           example: 1
 *     responses:
 *       200:
 *         description: Admin user data retrieved successfully.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 id:
 *                   type: integer
 *                   example: 1
 *                 email:
 *                   type: string
 *                   example: 'admin@example.com'
 *                 username:
 *                   type: string
 *                   example: 'admin'
 *                 name:
 *                   type: string
 *                   example: 'John Doe'
 *                 date_created:
 *                   type: string
 *                   format: date-time
 *                   example: '2024-05-16 14:33:26'
 *       404:
 *         description: Admin not found.
 *         content:
 *           text/plain:
 *             schema:
 *               type: string
 *               example: Admin not found
 *       500:
 *         description: Internal server error.
 *         content:
 *           text/plain:
 *             schema:
 *               type: string
 *               example: Internal Server Error
 * @function
 * @name getSingleAdminData
 * @memberof module:Routes/Admin
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue fetching the admin user data.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
//Get admin data single 
app.get('/admin_data_single/:id', authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    const id = req.params.id;
    const query = 'SELECT * FROM geopos_users WHERE id=?';
    
    const result = await executeQuery(connection,query, [id]);

    if (result.length > 0) {
      res.send(result[0]); // Send only the first result
    } else {
      res.status(404).send("Admin not found");
    }
  } catch (error) {
    console.error('Error:', error);
    res.status(500).send("Internal Server Error");
  } finally {
    // Release the connection back to the pool in case of success or error
    if (connection) {
      connection.release();
      //console.log("Connection released");
    }
  }
});

/**
 * @swagger
 * /get_admin_role/{id}:
 *   get:
 *     summary: Get admin role details
 *     description: Fetches the details of the admin user's role based on the provided user ID.
 *     tags:
 *       - Admin
 *     security:
 *       - BearerAuth: []
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         description: The ID of the admin user whose role details to retrieve.
 *         schema:
 *           type: integer
 *           example: 1
 *     responses:
 *       200:
 *         description: Admin role details retrieved successfully.
 *         content:
 *           application/json:
 *             schema:
 *               type: array
 *               items:
 *                 type: object
 *                 properties:
 *                   id:
 *                     type: integer
 *                     example: 1
 *                   name:
 *                     type: string
 *                     example: 'Admin'
 *                        
 *       500:
 *         description: Internal server error.
 *         content:
 *           text/plain:
 *             schema:
 *               type: string
 *               example: Internal Server Error
 * @function
 * @name getAdminRoleDetails
 * @memberof module:Routes/Admin
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue fetching the admin role details.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
//Get admin Role
app.get('/get_admin_role/:id', authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    const id = req.params.id;
    const query = `
      SELECT u.*, r.* 
      FROM geopos_users u 
      LEFT JOIN geopos_emptype r ON u.roleid = r.id 
      WHERE u.id = ?
    `;
  
    const result = await executeQuery(connection,query, [id]);
    res.send(result);
  } catch (error) {
    console.error('Error:', error);
    res.status(500).send("Internal Server Error");
  } finally {
    // Release the connection back to the pool in case of success or error
    if (connection) {
      connection.release();
      //console.log("Connection released");
    }
  }
});

/**
 * @swagger
 * /update_admin:
 *   post:
 *     summary: Update admin user details
 *     description: Updates the name of an admin user based on the provided user ID.
 *     tags:
 *       - Admin
 *     security:
 *       - BearerAuth: []
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             properties:
 *               id:
 *                 type: integer
 *                 description: The ID of the admin user to update.
 *                 example: 1
 *               name:
 *                 type: string
 *                 description: The new name for the admin user.
 *                 example: 'John Doe'
 *     responses:
 *       200:
 *         description: Admin user details updated successfully.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 status:
 *                   type: string
 *                   example: Success
 *                 message:
 *                   type: string
 *                   example: UPDATED
 *       400:
 *         description: Bad request - missing required parameters.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 status:
 *                   type: string
 *                   example: Error
 *                 message:
 *                   type: string
 *                   example: Missing required parameters
 *       404:
 *         description: Admin user not found.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 status:
 *                   type: string
 *                   example: Error
 *                 message:
 *                   type: string
 *                   example: Employee not found
 *       500:
 *         description: Internal server error.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 status:
 *                   type: string
 *                   example: Error
 *                 message:
 *                   type: string
 *                   example: Internal Server Error
 * @function
 * @name updateAdminDetails
 * @memberof module:Routes/Admin
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue updating the admin user details.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
// Route for updating admin
app.post('/update_admin', authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    // Check if required parameters are provided
    if (!req.body.id || !req.body.name) {
      return res.status(400).json({ status: 'Error', message: 'Missing required parameters' });
    }

    const sql = 'UPDATE geopos_users SET name = ? WHERE id = ?';
    const values = [req.body.name, req.body.id];

    // Execute the query
    const result = await executeQuery(connection,sql, values);

    if (result.affectedRows > 0) {
      return res.status(200).json({ status: 'Success', message: 'UPDATED' });
    } else {
      return res.status(404).json({ status: 'Error', message: 'Employee not found' });
    }
  } catch (error) {
    console.error('Error updating employee admin:', error);
    return res.status(500).json({ status: 'Error', message: 'Internal Server Error' });
  } finally {
    // Release the connection back to the pool in case of success or error
    if (connection) {
      connection.release();
      //console.log("Connection released");
    }
  }
});

/**
 * @swagger
 * /admin_data_username/{id}:
 *   get:
 *     summary: Get admin data by username
 *     description: Fetches details of an admin user based on the provided username.
 *     tags:
 *       - Admin
 *     security:
 *       - BearerAuth: []
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         description: The entry ID of the admin user to retrieve.
 *         schema:
 *           type: integer
 *           example: 101
 *     responses:
 *       200:
 *         description: Admin data retrieved successfully.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 status:
 *                   type: string
 *                   example: Success
 *                 data:
 *                   type: array
 *                   items:
 *                     type: object
 *                     properties:
 *                       id:
 *                         type: integer
 *                         example: 1
 *                       email:
 *                         type: string
 *                         example: 'admin@example.com'
 *                       username:
 *                         type: string
 *                         example: 'admin'
 *                       name:
 *                         type: string
 *                         example: 'John Doe'
 *                      
 *       404:
 *         description: Admin not found.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 status:
 *                   type: string
 *                   example: Error
 *                 message:
 *                   type: string
 *                   example: Admin not found
 *       500:
 *         description: Internal server error.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 status:
 *                   type: string
 *                   example: Error
 *                 message:
 *                   type: string
 *                   example: Internal Server Error
 * @function
 * @name getAdminDataByUsername
 * @memberof module:Routes/Admin
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue fetching the admin user data by username.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
//Get admin username single
app.get('/admin_data_username/:id', authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    const id = req.params.id;
    // Execute the query asynchronously
    const result = await executeQuery(connection,'SELECT * FROM geopos_users WHERE entryid=?', id);

    // Check if the result is empty
    if (result.length === 0) {
      return res.status(404).json({ status: 'Error', message: 'Admin not found' });
    }

    // Return the full result as a JSON response
    return res.status(200).json({ status: 'Success', data: result });
  } catch (error) {
    console.error('Error fetching admin data:', error);
    return res.status(500).json({ status: 'Error', message: 'Internal Server Error' });
  } finally {
    // Release the connection back to the pool in case of success or error
    if (connection) {
      connection.release();
      //console.log("Connection released");
    }
  }
});

/**
 * @swagger
 * /admin_change_password:
 *   post:
 *     summary: Change admin password
 *     description: Changes the password of an admin user based on the provided entry ID and admin ID.
 *     tags:
 *       - Admin
 *     security:
 *       - BearerAuth: []
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             properties:
 *               confirmPassword:
 *                 type: string
 *                 description: The new password to set.
 *                 example: 'newPassword123'
 *               entryid:
 *                 type: integer
 *                 description: The entry ID of the admin user.
 *                 example: 101
 *               adminid:
 *                 type: integer
 *                 description: The admin ID of the admin user.
 *                 example: 1
 *     responses:
 *       200:
 *         description: Admin password changed successfully.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 message:
 *                   type: string
 *                   example: Record updated successfully
 *       404:
 *         description: Record not found.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 message:
 *                   type: string
 *                   example: Record not updated
 *       500:
 *         description: Internal server error.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 message:
 *                   type: string
 *                   example: Error changing password
 * @function
 * @name changeAdminPassword
 * @memberof module:Routes/Admin
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue changing the admin password.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
// Admin change password
app.post('/admin_change_password', authenticateJWT, async (req, res) => {
  const { confirmPassword, entryid, adminid } = req.body;
  console.log('adminid:', adminid);
 let connection;
  try {
    connection = await getPoolConnection();
    // Hash the password asynchronously
    const hashedPassword = await hashPassword2(confirmPassword, adminid);

    // Update the password in the database
    const result = await executeQuery(connection,'UPDATE geopos_users SET pass=? WHERE entryid = ?', [hashedPassword, entryid]);

    // Check if the record was updated
    if (result.affectedRows === 0) {
      return res.status(404).json({ message: 'Record not updated' });
    }

    // Return success message if the record was updated successfully
    return res.status(200).json({ message: 'Record updated successfully' });
  } catch (error) {
    console.error('Error changing password:', error);
    return res.status(500).json({ message: 'Error changing password' });
  } finally {
    // Release the connection back to the pool in case of success or error
    if (connection) {
      connection.release();
      //console.log("Connection released");
    }
  }
});

/**
 * @swagger
 * /admin_delete/{id}:
 *   delete:
 *     summary: Delete admin user
 *     description: Deletes an admin user based on the provided ID.
 *     tags:
 *       - Admin
 *     security:
 *       - BearerAuth: []
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         description: The ID of the admin user to delete.
 *         schema:
 *           type: integer
 *           example: 1
 *     responses:
 *       200:
 *         description: Admin user deleted successfully.
 *         content:
 *           text/plain:
 *             schema:
 *               type: string
 *               example: Data Deleted successfully
 *       404:
 *         description: Admin user not found.
 *         content:
 *           text/plain:
 *             schema:
 *               type: string
 *               example: Record not found
 *       500:
 *         description: Internal server error.
 *         content:
 *           text/plain:
 *             schema:
 *               type: string
 *               example: Error deleting record
 * @function
 * @name deleteAdminUser
 * @memberof module:Routes/Admin
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue deleting the admin user.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
//Delete admin
app.delete('/admin_delete/:id', authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    const id = req.params.id; // ID will be a string here
    console.log(id, '----------------');

    // Execute the delete query asynchronously
    const result = await executeQuery(connection,'DELETE FROM geopos_users WHERE id = ?', [id]);

    // Check if any rows were affected by the delete operation
    if (result.affectedRows === 0) {
      return res.status(404).send('Record not found');
    }

    // Return success response
    return res.status(200).send('Data Deleted successfully');
  } catch (error) {
    console.error('Error deleting admin data:', error);
    return res.status(500).send('Error deleting record');
  } finally {
    // Release the connection back to the pool in case of success or error
    if (connection) {
      connection.release();
      //console.log("Connection released");
    }
  }
});

//ADD EMPLOYEE

// Endpoint for adding an employee
app.post('/addemployee', (req, res) => {
  const {
    name,
    entryid,
    workertype,
    shift,
    etype,
    site,
    ctype,
    product_name,
    line,
    section,
    staff,
    zone,
    machine,
    fdate
  } = req.body;

  console.log('Name:', name);
  console.log('Entry ID:', entryid);
  console.log('Worker Type:', workertype);
  console.log('Shift:', shift);
  console.log('Employee Type:', etype);
  console.log('Site:', site);
  console.log('Type:', ctype);
  console.log('Product Name:', product_name);
  console.log('Line:', line);
  console.log('Section:', section);
  console.log('Staff:', staff);
  console.log('Zone:', zone);
  console.log('Machine:', machine);
  console.log('Join Date:', fdate);

  const date1 = fdate;
  const fdParts = date1.split('-');
  const fd = `${fdParts[2]}-${fdParts[1]}-${fdParts[0]}`;

  const dateObj = new Date(date1);
  const day = dateObj.getDate().toString().padStart(2, '0');
  const month = (dateObj.getMonth() + 1).toString().padStart(2, '0');
  const year = dateObj.getFullYear();

  const date = `${day}-${month}-${year}`;
  const date2 = `${month}-${year}`;

  const fd2 = Math.floor(new Date(date1).getTime() / 1000);
  var dayy1 = fd2;

  const originalDate = new Date(fdate);

  const year1 = originalDate.getFullYear();
  const month1 = String(originalDate.getMonth() + 1).padStart(2, '0');
  const day1 = String(originalDate.getDate()).padStart(2, '0');
  const hour = '12';
  const minute = '00';
  const second = '00';

  const date3 = `${year1}-${month1}-${day1} ${hour}:${minute}:${second}`;
  console.log('Join Date:', date3);

  const curdate = new Date().toLocaleDateString('en-GB', { timeZone: 'Africa/Lagos' });
  const parts = curdate.split('/');
  const formattedDay = parts[0].padStart(2, '0');
  const formattedMonth = parts[1].padStart(2, '0');
  const year2 = parts[2];
  const cdate = `${formattedDay}-${formattedMonth}-${year2}`;

  const tags = machine.split(',');
  const num_tags = tags.length - 1;
  const emp_count = (num_tags === 0) ? 0 : (1 / num_tags);
  const empcount = parseFloat(emp_count.toFixed(4)); // Round to 4 decimal places
  console.log('empcount:', empcount.toFixed(4)); // Display with 4 decimal places

  // Create data object with additional roleid parameter
  const data = {
    name: name,
    entryid: entryid,
    workertype: workertype,
    shift: shift,
    employee_type: etype,
    site: site,
    category_type: ctype,
    product: product_name,
    line: line,
    section_id: section,
    zone: zone,
    machine: machine,
    emp_count: empcount,
    date: cdate,
    joindate: date3,
    staff: staff,
    roleid: 1 // Add roleid parameter with value 1
  };

   // Create data object with additional roleid parameter
   const data1 = {
    name: name,
    entryid: entryid,
    workertype: workertype,
    shift: shift,
    employee_type: etype,
    site: site,
    category_type: ctype,
    product: product_name,
    line: line,
    section_id: section,
    zone: zone,
    machine: machine,
    emp_count: empcount,
    date: cdate,
    joindate: date3,
    staff: staff, 
  };

  // Check if entryid exists
  db.query(`SELECT * FROM ${site === 'ota' ? 'employees_ota' : 'geopos_employees'} WHERE entryid = ?`, [entryid], (error, results) => {
    if (error) {
      console.error('Error checking entryid:', error);
      res.status(500).json({ status: 'Error', message: 'Internal server error' });
      return;
    }

    if (results.length > 0) {
      res.status(400).json({ status: 'Error', message: 'Sorry, Entryid Already Exist!!!' });
    } else {
      // Insert new employee
      const insertQuery = (site === 'ota') ?
        'INSERT INTO employees_ota SET ?' :
        'INSERT INTO geopos_employees SET ?';

      db.query(insertQuery, data, (err, result) => {
        if (err) {
          console.error('Error adding employee:', err);
          res.status(500).json({ status: 'Error', message: 'Internal server error' });
          return;
        }
        res.status(200).json({ status: 'Success', message: 'Employee added successfully' });
      });
    }
  });
});


//IKEJA START
/**
 * @swagger
 * /ikeja/operator_data_view:
 *   get:
 *     summary: Get operator data view for Ikeja.
 *     description: Retrieves operator data from the geopos_employees, geopos_users, and geopos_emptype tables.
 *     tags:
 *       - Operator Data
 *     security:
 *       - BearerAuth: []
 *     responses:
 *       200:
 *         description: Successful response with the operator data.
 *         content:
 *           application/json:
 *             schema:
 *               type: array
 *               items:
 *                 type: object
 *                 properties:
 *                   id:
 *                     type: integer
 *                     description: The ID of the employee.
 *                     example: 1
 *                   name:
 *                     type: string
 *                     description: The name of the employee.
 *                     example: "John Doe"
 *                   entryid:
 *                     type: integer
 *                     description: The entry ID of the employee.
 *                     example: 1001
 *                   roleid:
 *                     type: integer
 *                     description: The role ID of the employee.
 *                     example: 3
 *                   email:
 *                     type: string
 *                     description: The email of the employee.
 *                     example: "mailto:johndoe@example.com"
 *                   loc:
 *                     type: string
 *                     description: The location of the employee.
 *                     example: "Ikeja"
 *                   empname:
 *                     type: string
 *                     description: The name of the employee type.
 *                     example: "Operator"
 *                   banned:
 *                     type: integer
 *                     description: The banned status of the user.
 *                     example: 0
 *       500:
 *         description: An error occurred while fetching operator data.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: "Internal Server Error"
 *
 * @function
 * @name getIkejaOperatorDataView
 * @memberof module:Routes/OperatorData
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with executing the MySQL query.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
//Get operator data 
app.get('/ikeja/operator_data_view', authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    const query = `
      SELECT geopos_employees.*, geopos_users.banned, geopos_users.roleid, geopos_users.email, geopos_users.loc, geopos_emptype.name AS empname
      FROM geopos_employees
      LEFT JOIN geopos_users ON geopos_employees.entryid = geopos_users.entryid
      LEFT JOIN geopos_emptype ON geopos_employees.roleid = geopos_emptype.id
      WHERE geopos_users.roleid = ?
      AND geopos_users.production_type = ?
      AND geopos_users.banned = ?
      ORDER BY geopos_users.name ASC
    `;
    
    // Execute the query asynchronously
    const result = await executeQuery(connection, query, ['3', 'ikeja', '0']);

    res.send(result);
  } catch (error) {
    console.error('Error fetching operator data:', error);
    res.status(500).json({ error: 'Internal Server Error' });
  } finally {
    // Release the connection back to the pool in case of success or error
    if (connection) {
      connection.release();
      // console.log("Connection released");
    }
  }
});


/**
 * @swagger
 * /ikeja/getMachines/{id}:
 *   get:
 *     summary: Get machines by zone ID
 *     description: Retrieves machines based on the provided zone ID.
 *     tags:
 *       - Machines
 *     security:
 *       - BearerAuth: []
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         description: The ID of the zone to retrieve machines from.
 *         schema:
 *           type: integer
 *           example: 1
 *     responses:
 *       200:
 *         description: Machines retrieved successfully.
 *         content:
 *           text/plain:
 *             schema:
 *               type: string
 *               example: 'Machine1, Machine2, Machine3'
 *       404:
 *         description: No machines found for the provided zone ID.
 *         content:
 *           text/plain:
 *             schema:
 *               type: string
 *               example: ''
 *       500:
 *         description: Internal server error.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: Internal Server Error
 * @function
 * @name getMachinesByZoneID
 * @memberof module:Routes/Machines
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue fetching the machines by zone ID.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
//get machines data
app.get('/ikeja/getMachines/:id', authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    const id = req.params.id;
    const query = 'SELECT machine FROM geopos_machine WHERE zone = ?';
    
    // Execute the query asynchronously
    const result = await executeQuery(connection,query, id);

    if (result.length > 0) {
      res.send(result[0].machine); // Send only the name value from the result
    } else {
      res.send('');
    }
  } catch (error) {
    console.error('Error fetching machines:', error);
    res.status(500).json({ error: 'Internal Server Error' });
  } finally {
    // Release the connection back to the pool in case of success or error
    if (connection) {
      connection.release();
      //console.log("Connection released");
    }
  }
});

/**
 * @swagger
 * /ikeja/add_operator:
 *   post:
 *     summary: Add operator
 *     description: Adds a new operator to the system.
 *     tags:
 *       - Operators
 *     security:
 *       - BearerAuth: []
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             properties:
 *               name:
 *                 type: string
 *                 description: The name of the operator.
 *               username:
 *                 type: string
 *                 description: The username of the operator.
 *               email:
 *                 type: string
 *                 description: The email address of the operator.
 *               entryid:
 *                 type: string
 *                 description: The entry ID of the operator.
 *               password:
 *                 type: string
 *                 description: The password of the operator. If not provided, a default password ('123456') will be used.
 *               workertype:
 *                 type: string
 *                 description: The type of worker.
 *               shift:
 *                 type: string
 *                 description: The shift of the operator.
 *               zone:
 *                 type: string
 *                 description: The zone of the operator.
 *               machiness:
 *                 type: string
 *                 description: The machines operated by the operator (comma-separated).
 *               type:
 *                 type: string
 *                 description: The type of operator.
 *     responses:
 *       200:
 *         description: Operator added successfully.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 message:
 *                   type: string
 *                   example: Record inserted successfully
 *       404:
 *         description: Record not inserted.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 message:
 *                   type: string
 *                   example: Record not inserted
 *       500:
 *         description: Internal server error.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 message:
 *                   type: string
 *                   example: Error inserting record
 * @function
 * @name addOperator
 * @memberof module:Routes/Operators
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue adding the operator.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
//add operator data submit
app.post('/ikeja/add_operator',  authenticateJWT, (req, res) => {
  const name = req.body.name;
  const username = req.body.username;
  const email = req.body.email;
  const entryid = req.body.entryid;
  const pass = req.body.password !== "" ? req.body.password : '123456';
  const worktyp = req.body.workertype;
  const shift = req.body.shift;
  const zone = req.body.zone;
  const machine = req.body.machiness;
  const type = req.body.type;
  const roleid = '3';
  // Get the current date
  const date = new Date().toLocaleDateString('en-GB', {
    day: '2-digit',
    month: '2-digit',
    year: 'numeric',
  }).replace(/\//g, '-');
  //date time
  const currentDate = new Date();

  // Function to format the date in 'Y-m-d H:i:s' format
  const formatDate = (date) => {
    const year = date.getFullYear();
    const month = String(date.getMonth() + 1).padStart(2, '0');
    const day = String(date.getDate()).padStart(2, '0');
    const hours = String(date.getHours()).padStart(2, '0');
    const minutes = String(date.getMinutes()).padStart(2, '0');
    const seconds = String(date.getSeconds()).padStart(2, '0');

    return `${year}-${month}-${day} ${hours}:${minutes}:${seconds}`;
  };

  // Format the current date in 'Y-m-d H:i:s' format
  const formattedDate = formatDate(currentDate);

  const tags = machine.split(',');
  const numTags = tags.length - 1;
  const empCount = (1 / numTags).toFixed(4);

  const rowcheck = `SELECT * FROM geopos_users WHERE entryid="${entryid}"`;
  const rowcheck1 = `SELECT * FROM geopos_employees WHERE entryid="${entryid}"`;
  const rowcheck2 = `SELECT * FROM geopos_users WHERE email="${email}" OR username="${username}" OR name="${name}"`;

  db.query(rowcheck, function (err, result) {
    const id = result.id;
    if (result.length > 0) {
      res.status(200).json({status: 409, message: 'Entry Id already Exists'});
    } else {
      db.query(rowcheck2, function (err, resultt) {
        if (resultt.length > 0) {
          // Handle if email, username, or name already exists
        } else {
          db.query(
            'INSERT INTO geopos_users (email, username, name, entryid, date_created) VALUES (?, ?, ?, ?, ?)',
            [email, username, name, entryid, formattedDate],
            (err, result) => {
              if (err) {
                // Handle error
                console.error("Error occurred:", err);
              } else {
                if (result && result.insertId) {
                  const userId = result.insertId;
                  console.log("Insertion successful. Inserted user ID:", userId);

                  db.query(rowcheck1, function (err, resultt1) {
                    if (resultt1.length > 0) {
                      if(type=='BRAID'){
                        db.query(
                          'UPDATE geopos_employees SET roleid=?, workertype=?, shift=?, zone=?, machine=?, emp_count=?, section_id=? , category_type=? WHERE entryid=?',
                          [roleid, worktyp, shift, zone, machine, empCount,'0',type, entryid],
                          (err2, result2) => {
                            if (result2) {
                              const userIdAsString = userId.toString(); // Convert the number to a string
                              console.log("userIdAsString1:", userIdAsString);
                              const hashedPassword = hashPassword(pass, userIdAsString);
                              db.query(
                                'UPDATE geopos_users SET roleid=?, name=?, production_type=?, category_type=?,pass=? WHERE entryid=?',
                                [roleid, name, 'ikeja', type, hashedPassword, entryid],
                                (err3, result3) => {
                                  if (err3) {
                                    res.status(500).json({ status:500,message: 'Error updated record' })
                                  } else if (result3.affectedRows === 0) {
                                    res.status(404).json({status:404, message: 'Record not updated' })
                                  } else {
                                    res.status(200).json({message: 'Record updated successfully' })
                                  }
                                },
                              )
                            }
                          },
                        )
                      }else{
                        // Handle other cases if needed
                      }
                    }else{
                      if(type=='BRAID'){
                        db.query(
                          'INSERT INTO geopos_employees (username,entryid,email,name,roleid,workertype,shift,zone,machine,emp_count,passive_type,date,category_type) VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?)',
                          [username, entryid, email, name, roleid, worktyp,shift, zone, machine, empCount,'ACT',date,type],
                          (err22, result22) => {
                            if (result22) {
                              const userIdAsString = userId.toString(); // Convert the number to a string
                              console.log("userIdAsString2:", userIdAsString);
                              const hashedPassword = hashPassword(pass, userIdAsString);
                              console.log("hashedPassword:", hashedPassword);
                              //console.log("SQL Query:", 'UPDATE geopos_users SET roleid=?, name=?, production_type=?, category_type=?, pass=? WHERE entryid=?', [roleid, name, 'ikeja', type, entryid, hashedPassword]);
                              db.query(
                                'UPDATE geopos_users SET roleid=?, name=?, production_type=?, category_type=?, pass=? WHERE entryid=?',
                                [roleid, name, 'ikeja', type, hashedPassword, entryid],
                                (err22, result222) => {
                                  if (err22) {
                                    res.status(500).json({ status:500,message: 'Error inserted record' })
                                  } else if (result222.affectedRows === 0) {
                                    res.status(404).json({status:404, message: 'Record not inserted' })
                                  } else {
                                    res.status(200).json({ message: 'Record inserted successfully' })
                                  }
                                },
                              )
                            }
                          },
                        )
                      }else{
                        db.query(
                          'INSERT INTO geopos_employees (username,entryid,email,name,roleid,workertype,shift,date,category_type) VALUES (?,?,?,?,?,?,?,?,?)',
                          [username, entryid, email, name, roleid, worktyp,shift,date,type],
                          (err22, result222) => {
                            if (result222) {
                              const userIdAsString = userId.toString(); // Convert the number to a string
                              console.log("userIdAsString3:", userIdAsString);
                              const hashedPassword = hashPassword(pass, userIdAsString);
                              db.query(
                                'UPDATE geopos_users SET roleid=?, name=?, production_type=?, category_type=?, pass=? WHERE entryid=?',
                                [roleid, name, 'ikeja', type, hashedPassword, entryid],
                                (err222, result2222) => {
                                  if (err222) {
                                    res.status(500).json({ status:500 ,message: 'Error inserted record' })
                                  } else if (result2222.affectedRows === 0) {
                                    res.status(404).json({ status:404 ,message: 'Record not inserted' })
                                  } else {
                                    res.status(200).json({ message: 'Record inserted successfully' })
                                  }
                                },
                              )
                            }
                          },
                        )
                      }
                    }
                  })
                } else {
                  // Query was successful but no auto-increment ID was generated
                  console.log("Insertion successful but no auto-increment ID generated.");
                }
              }
            }
          );
        }
      });
    }
  });
});

/**
 * @swagger
 * /ikeja/getConvertdata/{id}:
 *   get:
 *     summary: Get converted data by ID
 *     description: Retrieves converted data based on the provided ID.
 *     tags:
 *       - Conversion
 *     security:
 *       - BearerAuth: []
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         description: The ID of the converted data to retrieve.
 *         schema:
 *           type: integer
 *           example: 1
 *     responses:
 *       200:
 *         description: Converted data retrieved successfully.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 // Define properties of the converted data object here
 *       500:
 *         description: Internal server error.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: Failed to fetch item data
 * @function
 * @name getConvertedDataByID
 * @memberof module:Routes/Conversion
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue fetching the converted data by ID.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
//getconvert data of category
app.get('/ikeja/getConvertdata/:id', authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    const id = req.params.id;
    const query = 'SELECT * FROM geopos_employees WHERE id=?';
    const result = await executeQuery(connection, query, [id]);
    res.json(result[0]);
  } catch (error) {
    console.error('Error fetching shift data:', error);
    res.status(500).json({ error: 'Failed to fetch item data' });
  } finally {
    if (connection) {
      connection.release();
      //console.log("Connection released");
    }
  }
});
/**
 * @swagger
 * /ikeja/category_convert_op:
 *   post:
 *     summary: Convert operator category for Ikeja.
 *     description: Updates operator category information for Ikeja based on provided parameters.
 *     tags:
 *       - Ikeja
 *     security:
 *       - BearerAuth: []
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             properties:
 *               id:
 *                 type: string
 *                 description: The ID of the operator.
 *               entryid:
 *                 type: string
 *                 description: The entry ID of the operator.
 *               workertype:
 *                 type: string
 *                 description: The worker type of the operator.
 *               shift:
 *                 type: string
 *                 description: The shift of the operator.
 *               zone:
 *                 type: string
 *                 description: The zone of the operator.
 *               machiness:
 *                 type: string
 *                 description: The machines associated with the operator (comma-separated).
 *               typ:
 *                 type: string
 *                 description: The category type of the operator.
 *     responses:
 *       200:
 *         description: Operator category converted successfully.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 message:
 *                   type: string
 *                   example: Record updated successfully
 *       404:
 *         description: Record not found or not updated.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 message:
 *                   type: string
 *                   example: Record not updated
 *       500:
 *         description: Internal server error.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 message:
 *                   type: string
 *                   example: Error converting operator category
 * @function
 * @name convertOperatorCategory
 * @memberof module:Routes/Ikeja
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue converting operator category.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
//add operator category convert data submit
app.post('/ikeja/category_convert_op', authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    const { id, entryid, workertype, shift, zone, machiness, typ } = req.body;

    const tags = machiness.split(',');
    const numTags = tags.length - 1;
    const empCount = (1 / numTags).toFixed(4);

    const rowcheck = `SELECT * FROM geopos_employees WHERE id="${id}"`;

    const [result] = await executeQuery(connection,rowcheck);

    if (result.length > 0) {
      let typeQuery, typeParams;

      if (typ === 'NBRAID') {
        typeQuery = `UPDATE geopos_employees SET workertype=?, shift=?, zone=?, machine=?, emp_count=?, section_id=?, category_type=? WHERE entryid=?`;
        typeParams = [workertype, shift, '', '', '', '0', typ, entryid];
      } else {
        typeQuery = `UPDATE geopos_employees SET workertype=?, shift=?, zone=?, machine=?, emp_count=?, section_id=?, category_type=?, product=?, line=? WHERE entryid=?`;
        typeParams = [workertype, shift, zone, machiness, empCount, '0', typ, '', '', entryid];
      }

      const [result1] = await executeQuery(connection,typeQuery, typeParams);

      if (result1) {
        const [userResult] = await executeQuery(connection,'SELECT * FROM geopos_users WHERE entryid=?', [entryid]);
        const eid = userResult.length > 0 ? userResult[0].id : null;

        const [result2] = await executeQuery(connection,'UPDATE geopos_users SET category_type=? WHERE id=?', [typ, eid]);

        if (result2.affectedRows === 0) {
          return res.status(404).json({ message: 'Record not updated' });
        }

        if (typ !== 'NBRAID') {
          await executeQuery(connection,'DELETE FROM operator_assign_ikeja WHERE operator_id=?', [eid]);
        }

        return res.status(200).json({ message: 'Record updated successfully' });
      }
    }
  } catch (error) {
    console.error('Error converting operator category:', error);
    return res.status(500).json({ message: 'Error converting operator category' });
  } finally {
    if (connection) {
      connection.release();
      //console.log("Connection released");
    }
  }
});
/**
 * @swagger
 * /ikeja/operator_data_single/{id}:
 *   get:
 *     summary: Get data of a single operator for Ikeja.
 *     description: Retrieves data of a single operator for Ikeja based on the provided operator ID.
 *     tags:
 *       - Ikeja
 *     security:
 *       - BearerAuth: []
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         description: The ID of the operator.
 *         schema:
 *           type: string
 *     responses:
 *       200:
 *         description: Successfully retrieved operator data.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 id:
 *                   type: integer
 *                   example: 1
 *                
 *       404:
 *         description: Operator not found.
 *         content:
 *           text/plain:
 *             schema:
 *               type: string
 *               example: Operator not found
 *       500:
 *         description: Internal server error.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 message:
 *                   type: string
 *                   example: Internal Server Error
 * @function
 * @name getSingleOperatorData
 * @memberof module:Routes/Ikeja
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue fetching operator data.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
//Get operator data single 
app.get('/ikeja/operator_data_single/:id', authenticateJWT, async (req, res) => {
 
  let connection;
  try {
    connection = await getPoolConnection();
    const id = req.params.id;
    const query = 'SELECT * FROM geopos_employees WHERE id = ?';
    const result = await executeQuery(connection,query, [id]);

    if (result.length > 0) {
      res.send(result[0]); // Send only the name value from the result
    } else {
      res.status(404).send("Operator not found");
    }
  } catch (error) {
    console.error('Error fetching operator data:', error);
    res.status(500).json({ error: 'Failed to fetch operator data' });
  }
  finally {
    if (connection) {
      connection.release();
      //console.log("Connection released");
    }
  }
});


/**
 * @swagger
 * /ikeja/getzone:
 *   get:
 *     summary: Get zones for Ikeja.
 *     description: Retrieves zones for Ikeja.
 *     tags:
 *       - Ikeja
 *     security:
 *       - BearerAuth: []
 *     responses:
 *       200:
 *         description: Successfully retrieved zones.
 *         content:
 *           application/json:
 *             schema:
 *               type: array
 *               items:
 *                 type: object
 *                 properties:
 *                   // Add properties based on your database schema
 *       500:
 *         description: Internal server error.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 message:
 *                   type: string
 *                   example: Internal Server Error
 * @function
 * @name getZones
 * @memberof module:Routes/Ikeja
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue fetching zones.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
//get zone
app.get('/ikeja/getzone', authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    const result = await executeQuery(connection, 'SELECT * FROM geopos_machine');

    res.send(result); // Send the entire result
  } catch (error) {
    console.error('Error fetching zones:', error);
    res.status(500).json({ message: 'Internal Server Error' });
  } finally {
    if (connection) {
      connection.release();
      //console.log("Connection released");
    }
  }
});

/**
 * @swagger
 * /ikeja/getuserid/{id}:
 *   get:
 *     summary: Get user by entry ID for Ikeja.
 *     description: Retrieves user information by entry ID for Ikeja.
 *     tags:
 *       - Ikeja
 *     security:
 *       - BearerAuth: []
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         description: The entry ID of the user.
 *         schema:
 *           type: string
 *     responses:
 *       200:
 *         description: Successfully retrieved user information.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 id:
 *                   type: integer
 *                   example: 1
 *                
 *       404:
 *         description: User not found.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 message:
 *                   type: string
 *                   example: User not found
 *       500:
 *         description: Internal server error.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 message:
 *                   type: string
 *                   example: Internal Server Error
 * @function
 * @name getUserByID
 * @memberof module:Routes/Ikeja
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue fetching user by entry ID.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
//get user id
app.get('/ikeja/getuserid/:id', authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    const id = req.params.id;
    const result = await executeQuery('SELECT * FROM geopos_users WHERE entryid=?', [id]);

    if (result.length > 0) {
      res.send(result[0]); // Send the first row of the result
    } else {
      res.status(404).json({ message: 'User not found' });
    }
  } catch (error) {
    console.error('Error fetching user by entry id:', error);
    res.status(500).json({ message: 'Internal Server Error' });
  } finally {
    if (connection) {
      connection.release();
      //console.log("Connection released");
    }
  } 
});

/**
 * @swagger
 * /ikeja/getItems/{id}:
 *   get:
 *     summary: Get items assigned to an operator for Ikeja.
 *     description: Retrieves items assigned to an operator for Ikeja based on the provided operator ID.
 *     tags:
 *       - Ikeja
 *     security:
 *       - BearerAuth: []
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         description: The ID of the operator.
 *         schema:
 *           type: string
 *     responses:
 *       200:
 *         description: Successfully retrieved items assigned to the operator.
 *         content:
 *           application/json:
 *             schema:
 *               type: array
 *               items:
 *                 type: object
 *                 properties:
 *                   // Add properties based on your database schema
 *       500:
 *         description: Internal server error.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 message:
 *                   type: string
 *                   example: Internal Server Error
 * @function
 * @name getItemsForOperator
 * @memberof module:Routes/Ikeja
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue fetching items for the operator.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
//get ikeja items
app.get('/ikeja/getItems/:id', authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    const id = req.params.id;
    const result = await executeQuery(connection,'SELECT * FROM operator_assign_ikeja WHERE operator_id=?', [id]);

    res.send(result); // Send the result directly
  } catch (error) {
    console.error('Error fetching items for operator:', error);
    res.status(500).json({ message: 'Internal Server Error' });
  } finally {
    if (connection) {
      connection.release();
      //console.log("Connection released");
    }
  }
});


/**
 * @swagger
 * /ikeja/add_zone:
 *   post:
 *     summary: Add or update zone for an operator in Ikeja.
 *     description: Adds or updates zone for an operator in Ikeja based on provided parameters.
 *     tags:
 *       - Ikeja
 *     security:
 *       - BearerAuth: []
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             properties:
 *               id:
 *                 type: string
 *                 description: The ID of the operator.
 *               zone:
 *                 type: string
 *                 description: The zone to add or update.
 *               machiness:
 *                 type: string
 *                 description: The machines associated with the zone.
 *     responses:
 *       200:
 *         description: Record added or updated successfully.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 message:
 *                   type: string
 *                   example: Record inserted successfully
 *       500:
 *         description: Internal server error.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 message:
 *                   type: string
 *                   example: Internal Server Error
 * @function
 * @name addOrUpdateZone
 * @memberof module:Routes/Ikeja
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue adding or updating zone.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
//submit zone data
app.post("/ikeja/add_zone", authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    const { id, zone, machiness } = req.body;

    const options = { timeZone: 'Africa/Lagos', day: 'numeric', month: 'numeric', year: 'numeric' };
    const currentTime = new Date().toLocaleString('en-US', options);
    const [date, month, year] = currentTime.split('/');
    const formattedDate = `${date.padStart(2, '0')}-${month.padStart(2, '0')}-${year}`;

    const rowcheck = `SELECT * FROM operator_assign_ikeja WHERE zone=? AND operator_id=?`;
    const result = await executeQuery(connection,rowcheck, [zone, id]);

    if (result.length > 0) {
      await executeQuery(connection,
        'UPDATE operator_assign_ikeja SET machine=? WHERE operator_id=? AND zone=?',
        [machiness, id, zone]
      );
      res.status(200).json({ message: 'Record updated successfully' });
    } else {
      await executeQuery(connection,
        'INSERT INTO operator_assign_ikeja (operator_id, zone, machine, date_time, category_type) VALUES (?, ?, ?, ?, ?)',
        [id, zone, machiness, formattedDate, 'BRAID']
      );
      res.status(200).json({ message: 'Record inserted successfully' });
    }
  } catch (error) {
    console.error('Error adding zone:', error);
    res.status(500).json({ message: 'Internal Server Error' });
  } finally {
    if (connection) {
      connection.release();
      //console.log("Connection released");
    }
  }
});


/**
 * @swagger
 * /ikeja/item_zone_delete/{id}:
 *   delete:
 *     summary: Delete item zone for an operator in Ikeja.
 *     description: Deletes item zone for an operator in Ikeja based on the provided zone ID.
 *     tags:
 *       - Ikeja
 *     security:
 *       - BearerAuth: []
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         description: The ID of the item zone to delete.
 *         schema:
 *           type: string
 *     responses:
 *       200:
 *         description: Item zone deleted successfully.
 *         content:
 *           text/plain:
 *             schema:
 *               type: string
 *               example: Data deleted successfully
 *       404:
 *         description: Record not found.
 *         content:
 *           text/plain:
 *             schema:
 *               type: string
 *               example: Record not found
 *       500:
 *         description: Internal server error.
 *         content:
 *           text/plain:
 *             schema:
 *               type: string
 *               example: Internal Server Error
 * @function
 * @name deleteItemZone
 * @memberof module:Routes/Ikeja
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue deleting item zone.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
//operator zone Delete i
app.delete('/ikeja/item_zone_delete/:id', authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    const id = req.params.id;
    const result = await executeQuery(connection,'DELETE FROM operator_assign_ikeja WHERE id= ?', id);
    
    if (result.affectedRows > 0) {
      res.status(200).send('Data deleted successfully');
    } else {
      res.status(404).send('Record not found');
    }
  } catch (error) {
    console.error('Error deleting record:', error);
    res.status(500).send('Internal Server Error');
  } finally {
    if (connection) {
      connection.release();
      //console.log("Connection released");
    }
  }
});


/**
 * @swagger
 * /ikeja/getlinemaster:
 *   get:
 *     summary: Get line master data for Ikeja.
 *     description: Retrieves line master data for Ikeja.
 *     tags:
 *       - Ikeja
 *     security:
 *       - BearerAuth: []
 *     responses:
 *       200:
 *         description: Successfully retrieved line master data.
 *         content:
 *           application/json:
 *             schema:
 *               type: array
 *               items:
 *                 type: object
 *                 properties:
 *                   // Add properties based on your database schema
 *       500:
 *         description: Internal server error.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 message:
 *                   type: string
 *                   example: Internal Server Error
 * @function
 * @name getLineMasterData
 * @memberof module:Routes/Ikeja
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue fetching line master data.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
//get Line master
app.get('/ikeja/getlinemaster', authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    const result = await executeQuery(connection,'SELECT * FROM line_master WHERE status=?', ['1']);
    res.send(result);
  } catch (error) {
    console.error('Error fetching line master data:', error);
    res.status(500).json({ message: 'Internal Server Error' });
  } finally {
    if (connection) {
      connection.release();
      //console.log("Connection released");
    }
  }
});


/**
 * @swagger
 * /ikeja/getSection:
 *   get:
 *     summary: Get sections for Ikeja.
 *     description: Retrieves sections for Ikeja.
 *     tags:
 *       - Ikeja
 *     security:
 *       - BearerAuth: []
 *     responses:
 *       200:
 *         description: Successfully retrieved sections.
 *         content:
 *           application/json:
 *             schema:
 *               type: array
 *               items:
 *                 type: object
 *                 properties:
 *                   // Add properties based on your database schema
 *       500:
 *         description: Internal server error.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 message:
 *                   type: string
 *                   example: Internal Server Error
 * @function
 * @name getSections
 * @memberof module:Routes/Ikeja
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue fetching sections.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
//get Line master
app.get('/ikeja/getSection', authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    const result = await executeQuery(connection,'SELECT * FROM section WHERE status=?', ['1']);
    res.send(result);
  } catch (error) {
    console.error('Error fetching sections:', error);
    res.status(500).json({ message: 'Internal Server Error' });
  } finally {
    if (connection) {
      connection.release();
      //console.log("Connection released");
    }
  }
});

/**
 * @swagger
 * /ikeja/getSectionitem/{id}:
 *   get:
 *     summary: Get section items for an operator in Ikeja.
 *     description: Retrieves section items for an operator in Ikeja based on the provided operator ID.
 *     tags:
 *       - Ikeja
 *     security:
 *       - BearerAuth: []
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         description: The ID of the operator.
 *         schema:
 *           type: string
 *     responses:
 *       200:
 *         description: Successfully retrieved section items for the operator.
 *         content:
 *           application/json:
 *             schema:
 *               type: array
 *               items:
 *                 type: object
 *                 properties:
 *                   // Add properties based on your database schema
 *       500:
 *         description: Internal server error.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 message:
 *                   type: string
 *                   example: Error fetching data from MySQL
 * @function
 * @name getSectionItemsForOperator
 * @memberof module:Routes/Ikeja
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue fetching section items for the operator.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
//get operator section data
app.get('/ikeja/getSectionitem/:id', authenticateJWT, async (req, res) => {
  const operatorId = req.params.id;
  let connection;
  try {
    connection = await getPoolConnection();
    const query = `
      SELECT operator_assign_ikeja.*, section.section_name
      FROM operator_assign_ikeja
      LEFT JOIN section ON operator_assign_ikeja.section = section.id
      WHERE operator_assign_ikeja.operator_id = ?
    `;
    
    const result = await executeQuery(connection,query, [operatorId]);
    res.json(result);
  } catch (error) {
    console.error('Error fetching data from MySQL:', error);
    res.status(500).json({ message: 'Error fetching data from MySQL' });
  } finally {
    if (connection) {
      connection.release();
      //console.log("Connection released");
    }
  }
});

/**
 * @swagger
 * /ikeja/addSectionOp:
 *   post:
 *     summary: Add section assignment for an operator in Ikeja.
 *     description: Adds section assignment for an operator in Ikeja based on provided parameters.
 *     tags:
 *       - Ikeja
 *     security:
 *       - BearerAuth: []
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             properties:
 *               id:
 *                 type: string
 *                 description: The ID of the operator.
 *               shift:
 *                 type: string
 *                 description: The shift for the assignment.
 *               line:
 *                 type: string
 *                 description: The line for the assignment.
 *               section:
 *                 type: string
 *                 description: The section to assign.
 *     responses:
 *       200:
 *         description: Record inserted successfully or already assigned to the same operator or other.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 message:
 *                   type: string
 *                   example: Record inserted successfully
 *       404:
 *         description: Record not inserted.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 message:
 *                   type: string
 *                   example: Record not inserted
 *       500:
 *         description: Internal server error.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 message:
 *                   type: string
 *                   example: Error inserting record
 * @function
 * @name addSectionAssignmentForOperator
 * @memberof module:Routes/Ikeja
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue adding section assignment for the operator.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
//submit section op  data
app.post("/ikeja/addSectionOp", authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    const { id, shift, line, section } = req.body;

    // Get current date
    const options = { timeZone: 'Africa/Lagos', day: '2-digit', month: '2-digit', year: 'numeric' };
    const currentTime = new Date().toLocaleString('en-US', options);
    const [date, month, year] = currentTime.split('/');
    const formattedDate = `${date.padStart(2, '0')}-${month.padStart(2, '0')}-${year}`;

    // Check if the section is already assigned to the operator for the given shift and line
    const rowcheck = `SELECT * FROM operator_assign_ikeja WHERE section=? AND line=? AND shift=?`;
    const existingAssignment = await executeQuery(connection,rowcheck, [section, line, shift]);

    if (existingAssignment.length > 0) {
      return res.status(200).json({ message: 'Already assigned to the same operator or other' });
    }

    // Insert the new section assignment
    const insertQuery = 'INSERT INTO operator_assign_ikeja (operator_id, section, line, shift, date_time, category_type) VALUES (?, ?, ?, ?, ?, ?)';
    const result = await executeQuery(connection,insertQuery, [id, section, line, shift, formattedDate, 'NBRAID']);

    if (result.affectedRows === 0) {
      return res.status(404).json({ message: 'Record not inserted' });
    }

    return res.status(200).json({ message: 'Record inserted successfully' });
  } catch (error) {
    console.error('Error inserting record:', error);
    return res.status(500).json({ message: 'Error inserting record' });
  } finally {
    if (connection) {
      connection.release();
      //console.log("Connection released");
    }
  }
});


/**
 * @swagger
 * /ikeja/delete_section_assign/{id}:
 *   delete:
 *     summary: Delete section assignment for an operator in Ikeja.
 *     description: Deletes section assignment for an operator in Ikeja based on the provided assignment ID.
 *     tags:
 *       - Ikeja
 *     security:
 *       - BearerAuth: []
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         description: The ID of the section assignment to delete.
 *         schema:
 *           type: string
 *     responses:
 *       200:
 *         description: Section assignment deleted successfully.
 *         content:
 *           text/plain:
 *             schema:
 *               type: string
 *               example: Data deleted successfully
 *       404:
 *         description: Record not found.
 *         content:
 *           text/plain:
 *             schema:
 *               type: string
 *               example: Record not found
 *       500:
 *         description: Internal server error.
 *         content:
 *           text/plain:
 *             schema:
 *               type: string
 *               example: Error deleting record
 * @function
 * @name deleteSectionAssignmentForOperator
 * @memberof module:Routes/Ikeja
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue deleting section assignment for the operator.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */

  //assign section Delete 
  app.delete('/ikeja/delete_section_assign/:id', authenticateJWT, async (req, res) => {
    let connection;
    try {
      connection = await getPoolConnection();
      const id = req.params.id;

      // Delete the section assignment based on the provided ID
      const result = await executeQuery(connection,'DELETE FROM operator_assign_ikeja WHERE id = ?', [id]);
  
      if (result.affectedRows === 0) {
        return res.status(404).send('Record not found');
      }
  
      return res.status(200).send('Data deleted successfully');
    } catch (error) {
      console.error('Error deleting record:', error);
      return res.status(500).send('Error deleting record');
    } finally {
      if (connection) {
        connection.release();
        //console.log("Connection released");
      }
    }
  });
  
  /**
 * @swagger
 * /ikeja/get_users/{id}:
 *   get:
 *     summary: Get users in Ikeja production type with specific role excluding a user.
 *     description: Retrieves users in Ikeja production type with specific role excluding a user based on the provided user ID.
 *     tags:
 *       - Ikeja
 *     security:
 *       - BearerAuth: []
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         description: The ID of the user to exclude from the results.
 *         schema:
 *           type: string
 *     responses:
 *       200:
 *         description: Successfully retrieved users.
 *         content:
 *           application/json:
 *             schema:
 *               type: array
 *               items:
 *                 type: object
 *                 properties:
 *                    Add properties based on your database schema
 *       500:
 *         description: Internal server error.
 *         content:
 *           text/plain:
 *             schema:
 *               type: string
 *               example: Internal Server Error
 * @function
 * @name getUsersInIkejaProductionType
 * @memberof module:Routes/Ikeja
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue fetching users.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
   
  //Get all users
  app.get('/ikeja/get_users/:id', authenticateJWT, async (req, res) => {
    let connection;
    try {
      connection = await getPoolConnection();
      const id = req.params.id;
      // Retrieve users from the database based on the specified criteria and excluding the provided user ID
      const result = await executeQuery(connection,
        'SELECT * FROM geopos_users WHERE roleid = ? AND production_type = ? AND banned = ? AND category_type = ? AND id != ?',
        ['3', 'ikeja', '0', 'NBRAID', id]
      );
  
      res.send(result);
    } catch (error) {
      console.error('Error executing MySQL query:', error);
      res.status(500).send('Internal Server Error');
    } finally {
      if (connection) {
        connection.release();
        //console.log("Connection released");
      }
    }
  });
  
  /**
 * @swagger
 * /ikeja/assign_check:
 *   get:
 *     summary: Check operator assignments in Ikeja.
 *     description: Checks operator assignments in Ikeja based on the provided query parameters.
 *     tags:
 *       - Ikeja
 *     security:
 *       - BearerAuth: []
 *     parameters:
 *       - in: query
 *         name: where
 *         schema:
 *           type: string
 *         required: true
 *         description: The WHERE clause for the SQL query.
 *     responses:
 *       200:
 *         description: Successfully retrieved operator assignments based on the query.
 *         content:
 *           application/json:
 *             schema:
 *               type: array
 *               items:
 *                 type: object
 *                 properties:
 *                   // Add properties based on your database schema
 *       500:
 *         description: Internal server error.
 *         content:
 *           text/plain:
 *             schema:
 *               type: string
 *               example: Internal Server Error
 * @function
 * @name checkOperatorAssignments
 * @memberof module:Routes/Ikeja
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue executing the MySQL query.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
  //Operator section exit check
  app.get('/ikeja/assign_check', authenticateJWT, async (req, res) => {
    let connection;
    try {
      connection = await getPoolConnection();
      const { where } = req.query;
  
      // Execute the query with the dynamic WHERE clause
      const result = await executeQuery(connection,`SELECT * FROM operator_assign_ikeja WHERE ${where}`);
  
      res.send(result);
    } catch (error) {
      console.error('Error executing MySQL query:', error);
      res.status(500).send('Internal Server Error');
    } finally {
      if (connection) {
        connection.release();
        //console.log("Connection released");
      }
    }
  });
  

  /**
 * @swagger
 * /ikeja/update_assign_operator/{id}:
 *   get:
 *     summary: Update operator assignment in Ikeja.
 *     description: Updates operator assignment in Ikeja based on the provided user ID and query parameters.
 *     tags:
 *       - Ikeja
 *     security:
 *       - BearerAuth: []
 *     parameters:
 *       - in: path
 *         name: id
 *         schema:
 *           type: string
 *         required: true
 *         description: The ID of the operator to update assignment for.
 *       - in: query
 *         name: where
 *         schema:
 *           type: string
 *         required: true
 *         description: The WHERE clause for the SQL query.
 *     responses:
 *       200:
 *         description: Record updated successfully.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 message:
 *                   type: string
 *                   example: Record Updated successfully
 *       404:
 *         description: Record not updated.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 message:
 *                   type: string
 *                   example: Record not Updated
 *       500:
 *         description: Internal server error.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 message:
 *                   type: string
 *                   example: Error updating record
 * @function
 * @name updateOperatorAssignment
 * @memberof module:Routes/Ikeja
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue updating operator assignment.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
  //update assign operator
  app.get('/ikeja/update_assign_operator/:id', authenticateJWT, async (req, res) => {
    let connection;
    try {
      connection = await getPoolConnection();
      const { where } = req.query;
      const userId = req.params.id;
  
      // Execute the UPDATE query with the provided user ID and dynamic WHERE clause
      const result = await executeQuery(connection,`UPDATE operator_assign_ikeja SET operator_id = ${userId} WHERE ${where}`);
  
      if (result.affectedRows === 0) {
        res.status(404).json({ message: 'Record not Updated' });
      } else {
        res.status(200).json({ message: 'Record Updated successfully' });
      }
    } catch (error) {
      console.error('Error updating operator assignment:', error);
      res.status(500).json({ message: 'Error updating record' });
    } finally {
      if (connection) {
        connection.release();
        //console.log("Connection released");
      }
    }
  });
  
  /**
 * @swagger
 * /ikeja/update_operator:
 *   post:
 *     summary: Update operator information in Ikeja.
 *     description: Updates operator information in Ikeja based on the provided parameters.
 *     tags:
 *       - Ikeja
 *     security:
 *       - BearerAuth: []
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             properties:
 *               name:
 *                 type: string
 *                 description: The name of the operator.
 *               entryid:
 *                 type: string
 *                 description: The entry ID of the operator.
 *               worktyp:
 *                 type: string
 *                 description: The work type of the operator.
 *               shift:
 *                 type: string
 *                 description: The shift of the operator.
 *               section_id:
 *                 type: string
 *                 description: The section ID of the operator.
 *               id:
 *                 type: string
 *                 description: The ID of the operator.
 *     responses:
 *       200:
 *         description: Operator record updated successfully.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 message:
 *                   type: string
 *                   example: Record Updated successfully
 *       404:
 *         description: User record not updated.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 message:
 *                   type: string
 *                   example: User record not updated
 *       500:
 *         description: Internal server error.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 message:
 *                   type: string
 *                   example: Error updating record
 * @function
 * @name updateOperatorInformation
 * @memberof module:Routes/Ikeja
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue updating operator information.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
// Update operator 
app.post('/ikeja/update_operator', authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    const { name, entryid, worktyp, shift, section_id, id } = req.body;

    // Update geopos_employees table
    const updateEmployeeQuery = `
      UPDATE geopos_employees 
      SET entryid=?, name=?, workertype=?, shift=?, section_id=? 
      WHERE id = ?
    `;
    await executeQuery(connection,updateEmployeeQuery, [entryid, name, worktyp, shift, section_id, id]);

    // Update geopos_users table
    const updateUserQuery = 'UPDATE geopos_users SET name=? WHERE entryid=?';
    const userUpdateResult = await executeQuery(connection,updateUserQuery, [name, entryid]);

    if (userUpdateResult.affectedRows === 0) {
      res.status(404).json({ message: 'User record not updated' });
    } else {
      res.status(200).json({ message: 'Record Updated successfully' });
    }
  } catch (error) {
    console.error('Error updating operator:', error);
    res.status(500).json({ message: 'Error updating record' });
  } finally {
    if (connection) {
      connection.release();
      //console.log("Connection released");
    }
  }
});


/**
 * @swagger
 * /ikeja/operator_data_username/{id}:
 *   get:
 *     summary: Get operator data by ID with username in Ikeja.
 *     description: Retrieves operator data including username in Ikeja based on the provided operator ID.
 *     tags:
 *       - Ikeja
 *     security:
 *       - BearerAuth: []
 *     parameters:
 *       - in: path
 *         name: id
 *         schema:
 *           type: string
 *         required: true
 *         description: The ID of the operator.
 *     responses:
 *       200:
 *         description: Operator data retrieved successfully.
 *         content:
 *           application/json:
 *             schema:
 *               type: array
 *               items:
 *                 type: object
 *                 properties:
 *                   // Add properties based on your database schema
 *       404:
 *         description: Operator not found.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 message:
 *                   type: string
 *                   example: Operator not found
 *       500:
 *         description: Internal server error.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 message:
 *                   type: string
 *                   example: Internal Server Error
 * @function
 * @name getOperatorDataByUsername
 * @memberof module:Routes/Ikeja
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue fetching operator data.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
//Get operator username single
app.get('/ikeja/operator_data_username/:id', authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    const id = req.params.id;
    console.log('id:', id);

    // Execute the SQL query to fetch operator data based on ID
    const result = await executeQuery(connection,'SELECT * FROM geopos_employees JOIN geopos_users ON geopos_employees.entryid = geopos_users.entryid WHERE geopos_employees.id=?', [id]);

    // Check if any data was retrieved
    if (result.length === 0) {
      res.status(404).json({ message: 'Operator not found' });
    } else {
      res.json(result); // Sending the full result as JSON
    }
  } catch (error) {
    console.error('Error fetching operator data:', error);
    res.status(500).json({ message: 'Internal Server Error' });
  } finally {
    if (connection) {
      connection.release();
      //console.log("Connection released");
    }
  }
});

/**
 * @swagger
 * /ikeja/change_password:
 *   post:
 *     summary: Change user password in Ikeja.
 *     description: Changes user password in Ikeja based on the provided user ID and new password.
 *     tags:
 *       - Ikeja
 *     security:
 *       - BearerAuth: []
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             properties:
 *               newPassword:
 *                 type: string
 *                 description: The new password for the user.
 *               id:
 *                 type: string
 *                 description: The ID of the user.
 *     responses:
 *       200:
 *         description: Password updated successfully.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 message:
 *                   type: string
 *                   example: Record updated successfully
 *       404:
 *         description: Record not updated.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 message:
 *                   type: string
 *                   example: Record not updated
 *       500:
 *         description: Internal server error.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 message:
 *                   type: string
 *                   example: Error updating password
 * @function
 * @name changePassword
 * @memberof module:Routes/Ikeja
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue updating the password.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
//Operator change password
app.post('/ikeja/change_password', authenticateJWT, async (req, res) => {
  const { newPassword, id } = req.body; // Destructure newPassword and id from req.body
  console.log("uid", id);
  let connection;
  try {
    connection = await getPoolConnection();
    // Convert the user ID to a string
    const userId = `${id}`;
    // Hash the new password
    const hashedPassword = hashPassword(newPassword, userId);
    console.log("userId :", userId);
    console.log("hashedPassword :", hashedPassword);
    
    // Prepare the SQL query to update the password
    const query = `UPDATE geopos_users SET pass = ? WHERE id = ?`;
    
    // Execute the SQL query asynchronously
    const result = await executeQuery(connection,query, [hashedPassword, id]);
    
    // Check if any rows were affected
    if (result.affectedRows === 0) {
      res.status(404).json({ message: 'Record not updated' });
    } else {
      res.status(200).json({ message: 'Record updated successfully' });
    }
  } catch (error) {
    console.error('Error updating password:', error);
    res.status(500).json({ message: 'Error updating password' });
  } finally {
    if (connection) {
      connection.release();
      //console.log("Connection released");
    }
  }
});


/**
 * @swagger
 * /ikeja/operator_delete/{id}:
 *   delete:
 *     summary: Delete operator in Ikeja.
 *     description: Deletes an operator in Ikeja based on the provided operator ID.
 *     tags:
 *       - Ikeja
 *     security:
 *       - BearerAuth: []
 *     parameters:
 *       - in: path
 *         name: id
 *         schema:
 *           type: string
 *         required: true
 *         description: The ID of the operator to delete.
 *     responses:
 *       200:
 *         description: Operator deleted successfully.
 *         content:
 *           application/json:
 *             schema:
 *               type: string
 *               example: Data Deleted successfully
 *       404:
 *         description: Operator not found.
 *         content:
 *           application/json:
 *             schema:
 *               type: string
 *               example: Record not found
 *       500:
 *         description: Internal server error.
 *         content:
 *           application/json:
 *             schema:
 *               type: string
 *               example: Error deleting record
 * @function
 * @name deleteOperator
 * @memberof module:Routes/Ikeja
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue deleting the operator.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
//Delete operator
app.delete('/ikeja/operator_delete/:id', authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    const id = req.params.id; // ID will be a string here

    // Check if the operator exists
    const employeesResult = await executeQuery(connection,'SELECT * FROM geopos_employees WHERE entryid = ?', id);
    if (employeesResult.length === 0) {
      return res.status(404).send('Record not found');
    }

    const employeeId = employeesResult[0].id; // Assuming 'id' is the column name for employee ID

    // Delete operator assignment
    await executeQuery(connection,'DELETE FROM operator_assign_ikeja WHERE operator_id = ?', employeeId);

    // Delete employee
    await querexecuteQueryyAsync(connection,'DELETE FROM geopos_employees WHERE entryid = ?', id);

    // Delete user
    await executeQuery(connection,'DELETE FROM geopos_users WHERE entryid = ?', id);

    res.status(200).send('Data Deleted successfully');
  } catch (error) {
    console.error("Error occurred:", error);
    res.status(500).send('Error deleting record');
  } finally {
    if (connection) {
      connection.release();
      //console.log("Connection released");
    }
  }
});

/**
 * @swagger
 * /ikeja/get_operator_assign_list:
 *   get:
 *     summary: Get list of operator assignments in Ikeja.
 *     description: Retrieves a list of operator assignments in Ikeja with additional information about the operators.
 *     tags:
 *       - Ikeja
 *     security:
 *       - BearerAuth: []
 *     responses:
 *       200:
 *         description: List of operator assignments retrieved successfully.
 *         content:
 *           application/json:
 *             schema:
 *               type: array
 *               items:
 *                 type: object
 *                 properties:
 *                   id:
 *                     type: integer
 *                     description: The ID of the operator assignment.
 *                   operator_id:
 *                     type: integer
 *                     description: The ID of the operator.
 *                   zone:
 *                     type: string
 *                     description: The zone assigned to the operator.
 *                   machine:
 *                     type: string
 *                     description: The machine assigned to the operator.
 *                   date_time:
 *                     type: string
 *                     format: date-time
 *                     description: The date and time of the assignment.
 *                   category_type:
 *                     type: string
 *                     description: The category type of the assignment.
 *                   entryid:
 *                     type: string
 *                     description: The entry ID of the operator.
 *                   roleid:
 *                     type: integer
 *                     description: The role ID of the operator.
 *                   name:
 *                     type: string
 *                     description: The name of the operator.
 *       500:
 *         description: Internal server error.
 *         content:
 *           application/json:
 *             schema:
 *               type: string
 *               example: Error fetching operator assignments
 * @function
 * @name getOperatorAssignList
 * @memberof module:Routes/Ikeja
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue fetching the operator assignments.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */

//get all assign worker list
app.get('/ikeja/get_operator_assign_list', authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    const query = `SELECT operator_assign_ikeja.*, geopos_users.entryid, geopos_users.roleid, geopos_users.name
                   FROM operator_assign_ikeja
                   LEFT JOIN geopos_users ON operator_assign_ikeja.operator_id = geopos_users.id
                   WHERE operator_assign_ikeja.category_type = ?`;

    const result = await executeQuery(connection,query, ['BRAID']);

    res.send(result);
  } catch (error) {
    console.error("Error occurred:", error);
    res.status(500).send('Error fetching operator assignments');
  } finally {
    if (connection) {
      connection.release();
      //console.log("Connection released");
    }
  }
});



/**
 * @swagger
 * /ikeja/delete_assign_list/{id}:
 *   delete:
 *     summary: Delete operator assignment in Ikeja.
 *     description: Deletes an operator assignment in Ikeja based on the provided assignment ID.
 *     tags:
 *       - Ikeja
 *     security:
 *       - BearerAuth: []
 *     parameters:
 *       - in: path
 *         name: id
 *         schema:
 *           type: integer
 *         required: true
 *         description: The ID of the operator assignment to delete.
 *     responses:
 *       200:
 *         description: Operator assignment deleted successfully.
 *         content:
 *           application/json:
 *             schema:
 *               type: string
 *               example: Delete successfully
 *       404:
 *         description: Operator assignment not found.
 *         content:
 *           application/json:
 *             schema:
 *               type: string
 *               example: Not Deleted
 *       500:
 *         description: Internal server error.
 *         content:
 *           application/json:
 *             schema:
 *               type: string
 *               example: Error deleting record
 * @function
 * @name deleteAssignList
 * @memberof module:Routes/Ikeja
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue deleting the operator assignment.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
//Delete assign braid and nonbraid list
app.delete('/ikeja/delete_assign_list/:id', authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    const id = req.params.id;
    const result = await executeQuery(connection,'DELETE FROM operator_assign_ikeja WHERE id = ?', id);

    if (result.affectedRows === 0) {
      res.status(404).send('Not Deleted');
    } else {
      res.status(200).send('Delete successfully');
    }
  } catch (error) {
    console.error("Error occurred:", error);
    res.status(500).send('Error deleting record');
  }  finally {
    if (connection) {
      connection.release();
      //console.log("Connection released");
    }
  }
});


/**
 * @swagger
 * /ikeja/get_operator_nbraid_assign_list:
 *   get:
 *     summary: Get operator assignments for NBRAID category in Ikeja.
 *     description: Retrieves operator assignments for NBRAID category in Ikeja.
 *     tags:
 *       - Ikeja
 *     security:
 *       - BearerAuth: []
 *     responses:
 *       200:
 *         description: Operator assignments fetched successfully.
 *         content:
 *           application/json:
 *             schema:
 *               type: array
 *               items:
 *                 type: object
 *                 properties:
 *                   id:
 *                     type: integer
 *                   operator_id:
 *                     type: integer
 *                   section:
 *                     type: integer
 *                   line:
 *                     type: string
 *                   shift:
 *                     type: string
 *                   date_time:
 *                     type: string
 *                     format: date-time
 *                   category_type:
 *                     type: string
 *                   entryid:
 *                     type: string
 *                   roleid:
 *                     type: integer
 *                   name:
 *                     type: string
 *                   section_name:
 *                     type: string
 *       500:
 *         description: Internal server error.
 *         content:
 *           application/json:
 *             schema:
 *               type: string
 *               example: Error fetching operator assignments
 * @function
 * @name getOperatorNBRAIDAssignList
 * @memberof module:Routes/Ikeja
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue fetching operator assignments.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
//get all assign worker list nonbraid
app.get('/ikeja/get_operator_nbraid_assign_list', authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    const query = `SELECT operator_assign_ikeja.*, geopos_users.entryid, geopos_users.roleid, geopos_users.name, section.section_name
                   FROM operator_assign_ikeja
                   LEFT JOIN geopos_users ON operator_assign_ikeja.operator_id = geopos_users.id
                   LEFT JOIN section ON operator_assign_ikeja.section = section.id
                   WHERE operator_assign_ikeja.category_type = ?`;

    const result = await executeQuery(connection, query, ['NBRAID']);

    res.send(result);
  } catch (error) {
    console.error("Error occurred:", error);
    res.status(500).send('Error fetching operator assignments');
  } finally {
    if (connection) {
      connection.release();
      //console.log("Connection released");
    }
  }
});
        

//Change shift operator//
/**
 * @swagger
 * /ikeja/getEmployees:
 *   get:
 *     summary: Get employees in Ikeja production unit.
 *     description: Retrieves employees in the Ikeja production unit with their respective roles and status.
 *     tags:
 *       - Ikeja
 *     security:
 *       - BearerAuth: []
 *     responses:
 *       200:
 *         description: Employees fetched successfully.
 *         content:
 *           application/json:
 *             schema:
 *               type: array
 *               items:
 *                 type: object
 *                 properties:
 *                   id:
 *                     type: integer
 *                   entryid:
 *                     type: string
 *                   name:
 *                     type: string
 *                   roleid:
 *                     type: integer
 *                   role:
 *                     type: string
 *                   email:
 *                     type: string
 *                   loc:
 *                     type: string
 *                   banned:
 *                     type: integer
 *       500:
 *         description: Internal server error.
 *         content:
 *           application/json:
 *             schema:
 *               type: string
 *               example: Internal Server Error
 * @function
 * @name getEmployees
 * @memberof module:Routes/Ikeja
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue fetching employees.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
// Get employee  data
app.get('/ikeja/getEmployees', authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    let query =
      `SELECT geopos_employees.*, geopos_users.banned, geopos_users.roleid, geopos_users.email, geopos_users.loc, geopos_emptype.name AS role
      FROM geopos_employees
      LEFT JOIN geopos_emptype ON geopos_employees.roleid = geopos_emptype.id
      LEFT JOIN geopos_users ON geopos_employees.entryid = geopos_users.entryid
      WHERE geopos_users.roleid = ? AND geopos_users.production_type = ? AND geopos_users.banned = ?`;

    const result = await executeQuery(connection,query, ['3', 'ikeja', 0]);

    res.send(result);
  } catch (error) {
    console.error("Error occurred:", error);
    res.status(500).send('Internal Server Error');
  } finally {
    if (connection) {
      connection.release();
      //console.log("Connection released");
    }
  }
});

/**
 * @swagger
 * /ikeja/changeshift_entryid:
 *   post:
 *     summary: Change shift for multiple employees.
 *     description: Change the shift for multiple employees identified by their entry IDs.
 *     tags:
 *       - Ikeja
 *     security:
 *       - BearerAuth: []
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             properties:
 *               entryIds:
 *                 type: array
 *                 items:
 *                   type: string
 *                 description: Array of entry IDs for the employees to update.
 *     responses:
 *       200:
 *         description: Shifts changed successfully.
 *         content:
 *           application/json:
 *             schema:
 *               type: array
 *               items:
 *                 type: object
 *                 properties:
 *                   entryid:
 *                     type: string
 *       500:
 *         description: Internal server error.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: Internal Server Error
 * @function
 * @name changeshift_entryid
 * @memberof module:Routes/Ikeja
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue changing the shift.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
//get changez shift employee entryid
app.post('/ikeja/changeshift_entryid', authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    const { entryIds } = req.body;
    const entryIdsArray = Array.isArray(entryIds) ? entryIds : [entryIds];

    // Use the IN operator in the SQL query to check for multiple entryid values
    const query = 'SELECT entryid FROM geopos_employees WHERE id IN (?)';

    const results = await executeQuery(connection,query, [entryIdsArray]);

    res.json(results);
  } catch (error) {
    console.error("Error occurred:", error);
    res.status(500).json({ error: 'Internal Server Error' });
  } finally {
    if (connection) {
      connection.release();
      //console.log("Connection released");
    }
  }
});


/**
 * @swagger
 * /ikeja/update_shift:
 *   post:
 *     summary: Update shift for multiple employees.
 *     description: Updates the shift for multiple employees based on their employee IDs.
 *     tags:
 *       - Ikeja
 *     security:
 *       - BearerAuth: []
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             properties:
 *               shift:
 *                 type: string
 *               entryIds:
 *                 type: string
 *             example:
 *               shift: "Morning"
 *               entryIds: "123,456,789"
 *     responses:
 *       200:
 *         description: Details updated successfully.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 status:
 *                   type: string
 *                   example: Success
 *                 message:
 *                   type: string
 *                   example: Details updated successfully.
 *       400:
 *         description: Bad request.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 status:
 *                   type: string
 *                   example: Error
 *                 message:
 *                   type: string
 *                   example: Shift and entryIds are required.
 *       500:
 *         description: Internal server error.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 status:
 *                   type: string
 *                   example: Error
 *                 message:
 *                   type: string
 *                   example: Internal Server Error
 * @function
 * @name updateShift
 * @memberof module:Routes/Ikeja
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {BadRequest} Will throw an error if shift and entryIds are not provided.
 * @throws {InternalServerError} Will throw an error if there's an issue updating shift.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
// check all entryids and update shift
app.post('/ikeja/update_shift', authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    const { shift, entryIds } = req.body;

    if (!shift || !entryIds) {
      return res.status(400).json({ status: 'Error', message: 'Shift and entryIds are required.' });
    }

    const entryIdsArray = entryIds.split(',');

    // Query to check if the employee with the given entryId exists
    const checkQuery = 'SELECT id FROM geopos_employees WHERE id = ? ';

    // Query to update data for each entryId
    const updateQuery = 'UPDATE geopos_employees SET shift = ? WHERE id = ?';

    for (const entryId of entryIdsArray) {
      const [checkResult] = await executeQuery(connection,checkQuery, [entryId]);

      if (checkResult) {
        // Employee exists, update the data
        await executeQuery(connection,updateQuery, [shift, entryId]);
        console.log(`Data updated for entryId: ${entryId}`);
      } else {
        // Employee does not exist, log the message
        console.log(`Employee not found for entryId: ${entryId}`);
      }
    }

    res.json({ status: 'Success', message: 'Details updated successfully.' });
  } catch (error) {
    console.error('Error updating data:', error);
    res.status(500).json({ status: 'Error', message: 'Internal Server Error' });
  } finally {
    if (connection) {
      connection.release();
      //console.log("Connection released");
    }
  }
});

//Employee
/**
 * @swagger
 * /ikeja/get_employeess:
 *   get:
 *     summary: Get employees data.
 *     description: Retrieves data of employees with specific criteria.
 *     tags:
 *       - Ikeja
 *     security:
 *       - BearerAuth: []
 *     responses:
 *       200:
 *         description: Retrieved employees data successfully.
 *         content:
 *           application/json:
 *             schema:
 *               type: array
 *               items:
 *                 type: object
 *                 properties:
 *                   id:
 *                     type: integer
 *                   name:
 *                     type: string
 *                   roleid:
 *                     type: integer
 *                   section_name:
 *                     type: string
 *                   role:
 *                     type: string
 *                 example:
 *                   id: 1
 *                   name: John Doe
 *                   roleid: 1
 *                   section_name: Section A
 *                   role: Supervisor
 *       500:
 *         description: Internal server error.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 message:
 *                   type: string
 *                   example: Error retrieving records
 * @function
 * @name getEmployees
 * @memberof module:Routes/Ikeja
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue retrieving records.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
//Employee Default data search
app.get('/ikeja/get_employeess', authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    const query = `
      SELECT geopos_employees.*, section.section_name, geopos_emptype.name AS role
      FROM geopos_employees
      LEFT JOIN geopos_emptype ON geopos_employees.roleid = geopos_emptype.id
      LEFT JOIN section ON geopos_employees.section_id = section.id
      WHERE (geopos_employees.roleid != '3' AND geopos_employees.roleid != '5')
        AND geopos_employees.passive_type = 'ACT'
        AND geopos_employees.category_type = 'BRAID';
    `;

    const result = await executeQuery(connection,query);

    res.json(result);
  } catch (error) {
    console.error("Error occurred:", error);
    res.status(500).json({ message: 'Error retrieving records' });
  } finally {
    if (connection) {
      connection.release();
      //console.log("Connection released");
    }
  }
});

/**
 * @swagger
 * /ikeja/get_employees:
 *   get:
 *     summary: Get employees data based on dynamic criteria.
 *     description: Retrieves data of employees based on dynamic query criteria.
 *     tags:
 *       - Ikeja
 *     security:
 *       - BearerAuth: []
 *     parameters:
 *       - in: query
 *         name: where
 *         schema:
 *           type: string
 *         required: true
 *         description: Dynamic WHERE clause for SQL query.
 *     responses:
 *       200:
 *         description: Retrieved employees data successfully.
 *         content:
 *           application/json:
 *             schema:
 *               type: array
 *               items:
 *                 type: object
 *                 properties:
 *                   id:
 *                     type: integer
 *                   name:
 *                     type: string
 *                   roleid:
 *                     type: integer
 *                   section_name:
 *                     type: string
 *                   role:
 *                     type: string
 *                 example:
 *                   id: 1
 *                   name: John Doe
 *                   roleid: 1
 *                   section_name: Section A
 *                   role: Supervisor
 *       500:
 *         description: Internal server error.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 message:
 *                   type: string
 *                   example: Error retrieving records
 * @function
 * @name getEmployees
 * @memberof module:Routes/Ikeja
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue retrieving records.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
//Employee filter data search
app.get('/ikeja/get_employees', authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    const { where } = req.query;

    const query = `
      SELECT geopos_employees.*, section.section_name, geopos_emptype.name AS role
      FROM geopos_employees
      LEFT JOIN geopos_emptype ON geopos_employees.roleid = geopos_emptype.id
      LEFT JOIN section ON geopos_employees.section_id = section.id
      WHERE ${where}
    `;

    const result = await executeQuery(connection,query);

    res.json(result);
  } catch (error) {
    console.error("Error occurred:", error);
    res.status(500).json({ message: 'Error retrieving records' });
  } finally {
    if (connection) {
      connection.release();
      //console.log("Connection released");
    }
  }
});

/**
 * @swagger
 * /ikeja/get_role/{id}:
 *   get:
 *     summary: Get role by ID.
 *     description: Retrieves the role details based on the provided role ID.
 *     tags:
 *       - Ikeja
 *     security:
 *       - BearerAuth: []
 *     parameters:
 *       - in: path
 *         name: id
 *         schema:
 *           type: integer
 *         required: true
 *         description: The ID of the role to retrieve.
 *     responses:
 *       200:
 *         description: Retrieved role details successfully.
 *         content:
 *           application/json:
 *             schema:
 *               type: array
 *               items:
 *                 type: object
 *                 properties:
 *                   id:
 *                     type: integer
 *                   name:
 *                     type: string
 *                   description:
 *                     type: string
 *                 example:
 *                   id: 1
 *                   name: Supervisor
 *                   description: Oversees operations in a section
 *       404:
 *         description: Role not found.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 message:
 *                   type: string
 *                   example: Role not found
 *       500:
 *         description: Internal server error.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 message:
 *                   type: string
 *                   example: Error retrieving role
 * @function
 * @name getRoleById
 * @memberof module:Routes/Ikeja
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue retrieving the role.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
//Get user Role
app.get('/ikeja/get_role/:id', authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    const id = req.params.id;
    const query = 'SELECT * FROM geopos_emptype WHERE id=?';
    const result = await executeQuery(connection,query, [id]);
    res.send(result);
  } catch (error) {
    console.error('Error occurred:', error);
    res.status(500).json({ message: 'Error retrieving role' });
  } finally {
    if (connection) {
      connection.release();
      //console.log("Connection released");
    }
  }
});

/**
 * @swagger
 * /ikeja/update_employee:
 *   post:
 *     summary: Update employee details.
 *     description: Updates the details of an employee based on the provided information.
 *     tags:
 *       - Ikeja
 *     security:
 *       - BearerAuth: []
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             properties:
 *               name:
 *                 type: string
 *                 example: John Doe
 *               entryid:
 *                 type: string
 *                 example: E123
 *               worktyp:
 *                 type: string
 *                 example: Full-time
 *               shift:
 *                 type: string
 *                 example: Morning
 *               section_id:
 *                 type: integer
 *                 example: 1
 *               roleid:
 *                 type: integer
 *                 example: 2
 *               zone:
 *                 type: string
 *                 example: A1
 *               id:
 *                 type: integer
 *                 example: 5
 *               machiness:
 *                 type: string
 *                 example: "Machine1,Machine2"
 *     responses:
 *       200:
 *         description: Record updated successfully.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 message:
 *                   type: string
 *                   example: Record updated successfully
 *       404:
 *         description: Record not found.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 message:
 *                   type: string
 *                   example: Record not updated
 *       500:
 *         description: Internal server error.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 message:
 *                   type: string
 *                   example: Error updating record
 * @function
 * @name updateEmployee
 * @memberof module:Routes/Ikeja
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue updating the record.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
//Update employee
app.post('/ikeja/update_employee', authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    const { name, entryid, worktyp, shift, section_id, roleid, zone, id, machiness } = req.body;
    const machine = machiness || ''; // In case machiness is not provided, set it to an empty string
    const tags = machine.split(',');
    const numTags = tags.length - 1;
    const empCount = (1 / numTags).toFixed(4);
    
    const query = `
      UPDATE geopos_employees 
      SET entryid=?, name=?, workertype=?, shift=?, section_id=?, zone=?, machine=?, emp_count=?
      WHERE id = ?
    `;
    const result = await executeQuery(connection,query, [entryid, name, worktyp, shift, section_id, zone, machine, empCount, id]);

    if (result.affectedRows === 0) {
      res.status(404).json({ message: 'Record not updated' });
    } else {
      res.status(200).json({ message: 'Record updated successfully' });
    }
  } catch (error) {
    console.error('Error:', error);
    res.status(500).json({ message: 'Error updating record' });
  } finally {
    if (connection) {
      connection.release();
      //console.log("Connection released");
    }
  }
});

/**
 * @swagger
 * /ikeja/update_employee_nbraid:
 *   post:
 *     summary: Update non-braided employee details and record changes in product lines and sections.
 *     description: Updates the details of a non-braided employee and inserts a record of changes in the change_product table.
 *     tags:
 *       - Ikeja
 *     security:
 *       - BearerAuth: []
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             properties:
 *               name:
 *                 type: string
 *                 example: John Doe
 *               entryid:
 *                 type: string
 *                 example: E123
 *               worktyp:
 *                 type: string
 *                 example: Full-time
 *               shift:
 *                 type: string
 *                 example: Morning
 *               section_id:
 *                 type: integer
 *                 example: 1
 *               usection_id:
 *                 type: integer
 *                 example: 2
 *               roleid:
 *                 type: integer
 *                 example: 2
 *               line:
 *                 type: string
 *                 example: Line1
 *               uline:
 *                 type: string
 *                 example: Line2
 *               id:
 *                 type: integer
 *                 example: 5
 *     responses:
 *       200:
 *         description: Record updated successfully.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 message:
 *                   type: string
 *                   example: Record Updated successfully
 *       404:
 *         description: Record not updated.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 message:
 *                   type: string
 *                   example: Record not Updated
 *       500:
 *         description: Internal server error.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 message:
 *                   type: string
 *                   example: Error updating employee record
 * @function
 * @name updateEmployeeNBraid
 * @memberof module:Routes/Ikeja
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue updating the record.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
//update employee nbraid data
app.post('/ikeja/update_employee_nbraid', authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    const { name, entryid, worktyp, shift, section_id, usection_id, roleid, line, uline, id } = req.body;

    console.log(req.body);

    const updateEmployeeQuery = 'UPDATE geopos_employees SET name=?, workertype=?, shift=?, section_id=?, line=?, roleid=? WHERE id = ?';
    const insertChangeProductQuery = 'INSERT INTO change_product (entryid, emp_id, line_old, line_new, section_old, section_new) VALUES (?,?,?,?,?,?)';

    const updateEmployeeResult = await executeQuery(connection,updateEmployeeQuery, [name, worktyp, shift, usection_id, uline, roleid, id]);

    if (updateEmployeeResult.affectedRows === 0) {
      console.log('Record not Updated');
      return res.status(404).json({ message: 'Record not Updated' });
    }

    const insertChangeProductResult = await executeQuery(connection,insertChangeProductQuery, [entryid, id, line, uline, section_id, usection_id]);

    if (insertChangeProductResult.affectedRows === 0) {
      console.log('User record not updated');
      return res.status(404).json({ message: 'User record not updated' });
    }

    console.log('Record Updated successfully');
    res.status(200).json({ message: 'Record Updated successfully' });
  } catch (error) {
    console.error('Error updating employee record:', error);
    res.status(500).json({ message: 'Error updating employee record' });
  } finally {
    if (connection) {
      connection.release();
      //console.log("Connection released");
    }
  }
});

/**
 * @swagger
 * /ikeja/delete_user/{id}:
 *   delete:
 *     summary: Delete a user by ID.
 *     description: Deletes a user from the geopos_employees table based on the provided user ID.
 *     tags:
 *       - Ikeja
 *     security:
 *       - BearerAuth: []
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: integer
 *         description: The ID of the user to delete.
 *     responses:
 *       200:
 *         description: Data deleted successfully.
 *         content:
 *           text/plain:
 *             schema:
 *               type: string
 *               example: Data deleted successfully
 *       404:
 *         description: Record not found.
 *         content:
 *           text/plain:
 *             schema:
 *               type: string
 *               example: Record not found
 *       500:
 *         description: Internal Server Error.
 *         content:
 *           text/plain:
 *             schema:
 *               type: string
 *               example: Internal Server Error
 * @function
 * @name deleteUser
 * @memberof module:Routes/Ikeja
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue deleting the record.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
//Delete employee 
app.delete('/ikeja/delete_user/:id', authenticateJWT, async (req, res) => {
  const id = req.params.id;
  let connection;
  try {
    connection = await getPoolConnection();
    const result = await executeQuery(connection,'DELETE FROM geopos_employees WHERE id = ?', [id]);
    if (result.affectedRows > 0) {
      res.status(200).send('Data deleted successfully');
    } else {
      res.status(404).send('Record not found');
    }
  } catch (error) {
    console.error('Error deleting record:', error);
    res.status(500).send('Internal Server Error');
  } finally {
    if (connection) {
      connection.release();
      //console.log("Connection released");
    }
  }
});

/**
 * @swagger
 * /ikeja/changeEmpToOp:
 *   post:
 *     summary: Change an employee to an operator.
 *     description: This endpoint changes the role of an employee to an operator, updates the employee's details, and creates a corresponding user account.
 *     tags:
 *       - Ikeja
 *     security:
 *       - BearerAuth: []
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             required:
 *               - entryid
 *               - unm
 *               - password
 *               - rlid
 *               - name
 *               - workertype
 *               - shift
 *               - zone
 *               - machine
 *               - category_type
 *             properties:
 *               entryid:
 *                 type: string
 *                 description: The entry ID of the employee.
 *               unm:
 *                 type: string
 *                 description: The username for the new operator.
 *               password:
 *                 type: string
 *                 description: The password for the new operator.
 *               rlid:
 *                 type: integer
 *                 description: The role ID for the new operator.
 *               name:
 *                 type: string
 *                 description: The name of the new operator.
 *               workertype:
 *                 type: string
 *                 description: The workertype of the new operator.
 *               shift:
 *                 type: string
 *                 description: The shift of the new operator.
 *               zone:
 *                 type: string
 *                 description: The zone of the new operator.
 *               machine:
 *                 type: string
 *                 description: The machine assigned to the new operator.
 *               category_type:
 *                 type: string
 *                 description: The category type of the new operator.
 *     responses:
 *       200:
 *         description: Record updated successfully.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 message:
 *                   type: string
 *                   example: Record updated successfully
 *       404:
 *         description: Record not inserted or updated.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 message:
 *                   type: string
 *                   example: Record not inserted or Record not updated
 *       500:
 *         description: Internal Server Error.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 message:
 *                   type: string
 *                   example: Internal Server Error
 * @function
 * @name changeEmpToOp
 * @memberof module:Routes/Ikeja
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue inserting or updating records.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
//employee to operator change
app.post('/ikeja/changeEmpToOp', authenticateJWT, async (req, res) => {
  const { entryid, unm: username, password: pass, rlid: roleid, name, workertype: worktyp, shift, zone, machine, category_type: type } = req.body;
 let connection;
  try {
    connection = await getPoolConnection();
    // Insert new user
    const resultInsertUser = await executeQuery(connection,
      'INSERT INTO geopos_users (username, entryid, email, name, roleid) VALUES (?, ?, ?, ?, ?)',
      [username, entryid, username, name, roleid]
    );

    if (resultInsertUser.affectedRows === 0) {
      return res.status(404).json({ message: 'Record not inserted' });
    }

    const userId = resultInsertUser.insertId;
    console.log("Insertion successful. Inserted user ID:", userId);

    // Update employee to operator
    const resultUpdateEmployee = await executeQuery(connection,
      'UPDATE geopos_employees SET roleid=?, workertype=?, shift=?, zone=?, machine=?, emp_count=?, section_id=?, category_type=? WHERE entryid=?',
      [roleid, worktyp, shift, zone, machine, empCount, '0', type, entryid]
    );

    if (resultUpdateEmployee.affectedRows === 0) {
      return res.status(404).json({ message: 'Record not updated' });
    }

    const userIdAsString = userId.toString();
    const hashedPassword = hashPassword(pass, userIdAsString);

    // Update user details
    const resultUpdateUser = await executeQuery(connection,
      'UPDATE geopos_users SET entryid=?, name=?, roleid=?, production_type=?, category_type=?, pass=? WHERE entryid=?',
      [entryid, name, roleid, 'ikeja', type, hashedPassword, entryid]
    );

    if (resultUpdateUser.affectedRows === 0) {
      return res.status(404).json({ message: 'Record not updated' });
    }

    res.status(200).json({ message: 'Record updated successfully' });
  } catch (error) {
    console.error('Error inserting or updating records:', error);
    res.status(500).json({ message: 'Internal Server Error' });
  } finally {
    if (connection) {
      connection.release();
      //console.log("Connection released");
    }
  }
});

// Ikeja transfer Employees
app.post('/ikejaemployeetransfer', async (req, res) => {
  let connection;
  try {

    const {
      entryid,
      name,
      category_type,
      joindate,
      workertype,
      employee_type,
      shift,
      product,
      line,
      section_id,
      zone,
      machine,
      emp_count,
      staff,
      dept,
    } = req.body;
  
    // Log the received data to console
    console.log('Received data:', req.body);

    // Format joindate to MySQL datetime format
    const joindateFormatted = new Date(joindate).toISOString().slice(0, 19).replace('T', ' ');

     const date = new Date().toLocaleDateString('en-GB', { timeZone: 'Africa/Lagos' });
  const parts = date.split('/');
  const formattedDay = parts[0].padStart(2, '0');
  const formattedMonth = parts[1].padStart(2, '0');
  const year = parts[2];
  const date1 = `${formattedDay}-${formattedMonth}-${year}`;

    // Data object to be inserted into employees_ota table
    const data = {
      entryid: entryid,
      name: name,
      category_type: category_type,
      joindate: joindateFormatted,
      workertype: workertype,
      employee_type: employee_type,
      shift: shift,
      product: product,
      line: line,
      section_id: section_id,
      zone: zone,
      machine: machine,
      emp_count: emp_count,
      staff: staff,
      dept: dept,
      date: date1,
      site: 'ota',
    };

     // Log the received data to console
     console.log('Data:', data);

    // Check if entryid already exists in employees_ota table
    const entryExists = await entryidExists(entryid, 'ota');
    if (entryExists) {
      return res.status(400).json({ status: 'Error', message: 'Sorry, Entryid Already Exist!!!' });
    }

    // Start a MySQL connection from the pool
    connection = await getPoolConnection();

    try {
      // Begin transaction (for atomicity)
      connection = await getPoolConnection();

      

      // Insert data into employees_ota table
      await connection.query('INSERT INTO employees_ota SET ?', data);

      // Delete corresponding record from geopos_employees table
      await connection.query('DELETE FROM geopos_employees WHERE entryid = ?', [entryid]);

      // Commit transaction
      await connection.commit();

      // Send success response
      res.json({ status: 'Success', message: `User Profile transferred successfully! Please refresh the page!` });
    } catch (error) {
      // Rollback transaction in case of error
      await connection.rollback();
      throw error;
    } finally {
      // Release the connection back to the pool
      connection.release();
    }
  } catch (error) {
    console.error('Error transferring user profile:', error);
    res.status(500).json({ status: 'Error', message: 'Failed to transfer user profile!' });
  }
});

// OTA transfer Employees
app.post('/otaemployeetransfer', async (req, res) => {
  let connection;
  try {

    const {
      entryid,
      name,
      category_type,
      joindate,
      workertype,
      employee_type,
      shift,
      product,
      line,
      section_id,
      zone,
      machine,
      emp_count,
      staff,
      dept,
    } = req.body;
  
    // Log the received data to console
    console.log('Received data:', req.body);

    // Format joindate to MySQL datetime format
    const joindateFormatted = new Date(joindate).toISOString().slice(0, 19).replace('T', ' ');

     const date = new Date().toLocaleDateString('en-GB', { timeZone: 'Africa/Lagos' });
      const parts = date.split('/');
      const formattedDay = parts[0].padStart(2, '0');
      const formattedMonth = parts[1].padStart(2, '0');
      const year = parts[2];
      const date1 = `${formattedDay}-${formattedMonth}-${year}`;

    // Data object to be inserted into employees_ota table
    const data = {
      entryid: entryid,
      name: name,
      category_type: category_type,
      joindate: joindateFormatted,
      workertype: workertype,
      employee_type: employee_type,
      shift: shift,
      product: product,
      line: line,
      section_id: section_id,
      zone: zone,
      machine: machine,
      emp_count: emp_count,
      dept: dept,
      date: date1,
      roleid: '1',
      site: 'ikeja',
    };

     // Log the received data to console
     console.log('Data:', data);

    // Check if entryid already exists in employees_ota table
    const entryExists = await entryidExists(entryid, 'ikeja');
    if (entryExists) {
      return res.status(400).json({ status: 'Error', message: 'Sorry, Entryid Already Exist!!!' });
    }

    // Start a MySQL connection from the pool
    connection = await getPoolConnection();

    try {
      // Begin transaction (for atomicity)
      connection = await getPoolConnection();

      

      // Insert data into employees_ota table
      await connection.query('INSERT INTO geopos_employees SET ?', data);

      // Delete corresponding record from geopos_employees table
      await connection.query('DELETE FROM employees_ota WHERE entryid = ?', [entryid]);

      // Commit transaction
      await connection.commit();

      // Send success response
      res.json({ status: 'Success', message: `User Profile transferred successfully! Please refresh the page!` });
    } catch (error) {
      // Rollback transaction in case of error
      await connection.rollback();
      throw error;
    } finally {
      // Release the connection back to the pool
      connection.release();
    }
  } catch (error) {
    console.error('Error transferring user profile:', error);
    res.status(500).json({ status: 'Error', message: 'Failed to transfer user profile!' });
  }
});


//check entryid exists or not
async function entryidExists(entryid, site) {
  const table = (site === 'ota') ? 'employees_ota' : 'geopos_employees';
  let connection;
  
  try {
    connection = await getPoolConnection();
    const result = await connection.query(`SELECT * FROM ${table} WHERE entryid = ?`, [entryid]);
    
    if (result && Array.isArray(result) && result.length > 0) {
      const [rows] = result;
      return rows.length > 0;
    } else {
      return false; // No rows found
    }
  } catch (error) {
    console.error('Error querying database:', error);
    throw error; // Throw the error to handle it further up the call stack
  } finally {
    if (connection) {
      connection.release();
    }
  }
}





/**
 * @swagger
 * /ikeja/get_employeess_nbraid_date:
 *   get:
 *     summary: Retrieve the first employee record ordered by ID in ascending order.
 *     description: This endpoint retrieves the first employee record from the `geopos_employees` table, ordered by ID in ascending order.
 *     tags:
 *       - Ikeja
 *     security:
 *       - BearerAuth: []
 *     responses:
 *       200:
 *         description: Successfully retrieved the employee record.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 id:
 *                   type: integer
 *                   description: The ID of the employee.
 *                 entryid:
 *                   type: string
 *                   description: The entry ID of the employee.
 *                 name:
 *                   type: string
 *                   description: The name of the employee.
 *                 roleid:
 *                   type: integer
 *                   description: The role ID of the employee.
 *                 workertype:
 *                   type: string
 *                   description: The workertype of the employee.
 *                 shift:
 *                   type: string
 *                   description: The shift of the employee.
 *                 section_id:
 *                   type: integer
 *                   description: The section ID of the employee.
 *                 zone:
 *                   type: string
 *                   description: The zone of the employee.
 *                 machine:
 *                   type: string
 *                   description: The machine assigned to the employee.
 *                 emp_count:
 *                   type: number
 *                   description: The employee count.
 *                 category_type:
 *                   type: string
 *                   description: The category type of the employee.
 *       404:
 *         description: No records found.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 message:
 *                   type: string
 *                   example: No records found
 *       500:
 *         description: Internal Server Error.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 message:
 *                   type: string
 *                   example: Internal Server Error
 * @function
 * @name getEmployeessNbraidDate
 * @memberof module:Routes/Ikeja
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue retrieving records.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
//Employee Default date
app.get('/ikeja/get_employeess_nbraid_date', authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    const query = 'SELECT * FROM geopos_employees ORDER BY id ASC LIMIT 1';
    const result = await executeQuery(connection,query);

    if (result.length === 0) {
      return res.status(404).json({ message: 'No records found' });
    }

    res.json(result[0]);
  } catch (error) {
    console.error('Error retrieving records:', error);
    res.status(500).json({ message: 'Internal Server Error' });
  } finally {
    if (connection) {
      connection.release();
      //console.log("Connection released");
    }
  }
});

/**
 * @swagger
 * /ikeja/get_employeess_nbraid:
 *   get:
 *     summary: Retrieve active employees with the NBRAID category type.
 *     description: This endpoint retrieves active employee records from the `geopos_employees` table with a category type of 'NBRAID', excluding those with a role ID of '3'. It includes related data from `geopos_emptype`, `section`, and `item_masterr` tables.
 *     tags:
 *       - Ikeja
 *     security:
 *       - BearerAuth: []
 *     responses:
 *       200:
 *         description: Successfully retrieved the employee records.
 *         content:
 *           application/json:
 *             schema:
 *               type: array
 *               items:
 *                 type: object
 *                 properties:
 *                   id:
 *                     type: integer
 *                     description: The ID of the employee.
 *                   entryid:
 *                     type: string
 *                     description: The entry ID of the employee.
 *                   name:
 *                     type: string
 *                     description: The name of the employee.
 *                   roleid:
 *                     type: integer
 *                     description: The role ID of the employee.
 *                   workertype:
 *                     type: string
 *                     description: The workertype of the employee.
 *                   shift:
 *                     type: string
 *                     description: The shift of the employee.
 *                   section_id:
 *                     type: integer
 *                     description: The section ID of the employee.
 *                   zone:
 *                     type: string
 *                     description: The zone of the employee.
 *                   machine:
 *                     type: string
 *                     description: The machine assigned to the employee.
 *                   emp_count:
 *                     type: number
 *                     description: The employee count.
 *                   passive_type:
 *                     type: string
 *                     description: The passive type of the employee.
 *                   category_type:
 *                     type: string
 *                     description: The category type of the employee.
 *                   product:
 *                     type: integer
 *                     description: The product ID associated with the employee.
 *                   section_name:
 *                     type: string
 *                     description: The name of the section.
 *                   item_description:
 *                     type: string
 *                     description: The description of the item.
 *                   role:
 *                     type: string
 *                     description: The role of the employee.
 *       500:
 *         description: Internal Server Error.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 message:
 *                   type: string
 *                   example: Internal Server Error
 * @function
 * @name getEmployeesNBraid
 * @memberof module:Routes/Ikeja
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue retrieving records.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
//Nonbraid Employee Defulte data search
app.get('/ikeja/get_employeess_nbraid', authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    const query = `
      SELECT geopos_employees.*, section.section_name, item_masterr.item_description, geopos_emptype.name as role
      FROM geopos_employees
      LEFT JOIN geopos_emptype ON geopos_employees.roleid = geopos_emptype.id
      LEFT JOIN section ON geopos_employees.section_id = section.id
      LEFT JOIN item_masterr ON geopos_employees.product = item_masterr.id
      WHERE geopos_employees.roleid != '3'
        AND geopos_employees.passive_type = 'ACT'
        AND geopos_employees.category_type = 'NBRAID';
    `;
    const result = await executeQuery(connection,query);

    res.json(result);
  } catch (error) {
    console.error('Error retrieving records:', error);
    res.status(500).json({ message: 'Internal Server Error' });
  } finally {
    if (connection) {
      connection.release();
      //console.log("Connection released");
    }
  }
});

/**
 * @swagger
 * /ikeja/get_employees_nbraid:
 *   get:
 *     summary: Get employees with NBRAID role in Ikeja.
 *     description: Retrieves employees with NBRAID role in Ikeja based on the provided query.
 *     tags:
 *       - Ikeja
 *     security:
 *       - BearerAuth: []
 *     parameters:
 *       - in: query
 *         name: where
 *         schema:
 *           type: string
 *         required: true
 *         description: The WHERE clause of the SQL query to filter employees.
 *     responses:
 *       200:
 *         description: Employees retrieved successfully.
 *         content:
 *           application/json:
 *             schema:
 *               type: array
 *               items:
 *                 type: object
 *                 properties:
 *                   // Add properties based on your database schema
 *       500:
 *         description: Internal server error.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 message:
 *                   type: string
 *                   example: Internal Server Error
 * @function
 * @name getEmployeesNBRAID
 * @memberof module:Routes/Ikeja
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue retrieving employees.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
//Nonbraid Employee filter data search
app.get('/ikeja/get_employees_nbraid', authenticateJWT, async (req, res) => {
  const { where } = req.query;
 let connection;
  try {
    connection = await getPoolConnection();
    let query = `
      SELECT geopos_employees.*, section.section_name, geopos_emptype.name as role
      FROM geopos_employees
      LEFT JOIN geopos_emptype ON geopos_employees.roleid = geopos_emptype.id
      LEFT JOIN section ON geopos_employees.section_id = section.id
      WHERE ${where}
    `;
    const result = await executeQuery(connection,query);

    res.json(result);
  } catch (error) {
    console.error('Error retrieving records:', error);
    res.status(500).json({ message: 'Internal Server Error' });
  } finally {
    if (connection) {
      connection.release();
      //console.log("Connection released");
    }
  }
});


//Change zone

/**
 * @swagger
 * /ikeja/getZonedata:
 *   get:
 *     summary: Get zone data in Ikeja.
 *     description: Retrieves zone data in Ikeja based on specific conditions.
 *     tags:
 *       - Ikeja
 *     security:
 *       - BearerAuth: []
 *     responses:
 *       200:
 *         description: Zone data retrieved successfully.
 *         content:
 *           application/json:
 *             schema:
 *               type: array
 *               items:
 *                 type: object
 *                 properties:
 *                   // Define properties based on your database schema
 *       500:
 *         description: Internal server error.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 message:
 *                   type: string
 *                   example: Internal Server Error
 * @function
 * @name getZoneData
 * @memberof module:Routes/Ikeja
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue retrieving zone data.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
// Get zone data default view
app.get('/ikeja/getZonedata', authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    let query =
      `SELECT geopos_employees.*, section.section_name, geopos_emptype.name as role
      FROM geopos_employees
      LEFT JOIN geopos_emptype ON geopos_employees.roleid = geopos_emptype.id
      LEFT JOIN section ON geopos_employees.section_id = section.id
      WHERE (geopos_employees.roleid != '3' AND geopos_employees.roleid != '5') 
      AND geopos_employees.passive_type = 'ACT' 
      AND geopos_employees.category_type = 'BRAID'`;

    const result = await executeQuery(connection,query);
    res.send(result);
  } catch (error) {
    console.error('Error retrieving employee data:', error);
    res.status(500).json({ message: 'Internal Server Error' });
  } finally {
    if (connection) {
      connection.release();
      //console.log("Connection released");
    }
  }
});

/**
 * @swagger
 * /ikeja/get_zonedata_search:
 *   get:
 *     summary: Get zone data in Ikeja based on search criteria.
 *     description: Retrieves zone data in Ikeja based on the provided search criteria.
 *     tags:
 *       - Ikeja
 *     security:
 *       - BearerAuth: []
 *     parameters:
 *       - in: query
 *         name: where
 *         schema:
 *           type: string
 *         required: true
 *         description: The WHERE clause of the SQL query to filter zone data.
 *     responses:
 *       200:
 *         description: Zone data retrieved successfully.
 *         content:
 *           application/json:
 *             schema:
 *               type: array
 *               items:
 *                 type: object
 *                 properties:
 *                   // Define properties based on your database schema
 *       500:
 *         description: Internal server error.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 message:
 *                   type: string
 *                   example: Internal Server Error
 * @function
 * @name getZoneDataSearch
 * @memberof module:Routes/Ikeja
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue retrieving zone data.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
// Get zone data search  view
app.get('/ikeja/get_zonedata_search', authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    const { where } = req.query;
    let query =
      `SELECT geopos_employees.*, section.section_name, geopos_emptype.name as role
      FROM geopos_employees
      LEFT JOIN geopos_emptype ON geopos_employees.roleid = geopos_emptype.id
      LEFT JOIN section ON geopos_employees.section_id = section.id
      WHERE ${where}`;

    const result = await executeQuery(connection,query);
    res.send(result);
  } catch (error) {
    console.error('Error retrieving employee data:', error);
    res.status(500).json({ message: 'Internal Server Error' });
  } finally {
    if (connection) {
      connection.release();
      //console.log("Connection released");
    }
  }
});

/**
 * @swagger
 * /ikeja/update_multiple_zone:
 *   post:
 *     summary: Update multiple zone information for employees.
 *     description: Updates the zone information for multiple employees in the Ikeja zone.
 *     tags:
 *       - Ikeja
 *     security:
 *       - BearerAuth: []
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             properties:
 *               shift:
 *                 type: string
 *               entryIds:
 *                 type: string
 *               section_id:
 *                 type: integer
 *               zone:
 *                 type: string
 *               machines:
 *                 type: string
 *     responses:
 *       200:
 *         description: Details updated successfully.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 status:
 *                   type: string
 *                   example: Success
 *                 message:
 *                   type: string
 *                   example: Details updated successfully.
 *       500:
 *         description: Internal server error.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 status:
 *                   type: string
 *                   example: Error
 *                 message:
 *                   type: string
 *                   example: Internal Server Error
 * @function
 * @name updateMultipleZone
 * @memberof module:Routes/Ikeja
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue updating multiple zones.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
// Change zone braid multiple entry id wise zone update
app.post('/ikeja/update_multiple_zone', authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    const { shift, entryIds, section_id, zone, machines } = req.body;
    const options = {
      timeZone: 'Africa/Lagos',
      day: '2-digit',
      month: '2-digit',
      year: 'numeric',
      hour: '2-digit',
      minute: '2-digit',
      second: '2-digit'
    };
    const currentTime = new Date().toLocaleString('en-US', options);

    const [datePart, timePart] = currentTime.split(', ');
    const [month, date, year] = datePart.split('/');
    const [time, amPm] = timePart.split(' ');
    const [hours, minutes, seconds] = time.split(':');
    const tdate = `${date.padStart(2, '0')}-${month.padStart(2, '0')}-${year} ${hours}:${minutes}:${seconds}`;

    const tags = machines.split(',');
    const numTags = tags.length - 1;
    const empCount = (1 / numTags).toFixed(4);

    const entryIdsArray = entryIds.split(',');

    const checkQuery = 'SELECT * FROM geopos_employees WHERE id = ? ';
    const InsertQuery =
      'INSERT INTO geopos_changezonemachine (zone_old,machine_old,zone_new,machine_new,shift_old,section_old,shift_new,section_new,emp_id,entry_id,date_time) VALUES (?,?,?,?,?,?,?,?,?,?,?)';
    const updateQuery =
      'UPDATE geopos_employees SET zone=?,machine=?,emp_count=?,shift=?,section_id=? WHERE id = ?';

    let processedCount = 0;

    for (const entryId of entryIdsArray) {
      const checkValues = [entryId];
      const checkResult = await executeQuery(connection,checkQuery, checkValues);

      if (checkResult.length === 1) {
        const {
          entryid,
          zone: zone_old,
          machine: machine_old,
          shift: shift_old,
          section_id: section_old,
          id
        } = checkResult[0];

        const insertValues = [
          zone_old,
          machine_old,
          zone,
          machines,
          shift_old,
          section_old,
          shift,
          section_id,
          id,
          entryid,
          tdate
        ];

        await executeQuery(connection,InsertQuery, insertValues);
        const updateValue = [zone, machines, empCount, shift, section_id, id];
        await executeQuery(connection,updateQuery, updateValue);

        processedCount++;
        console.log(`Data updated for entryId: ${entryId}`);
      } else {
        processedCount++;
        console.log(`Employee not found for entryId: ${entryId}`);
      }
    }

    if (processedCount === entryIdsArray.length) {
      res.json({ status: 'Success', message: 'Details updated successfully.' });
    }
  } catch (error) {
    console.error('Error updating multiple zones:', error);
    res.status(500).json({ status: 'Error', message: 'Internal Server Error' });
  } finally {
    if (connection) {
      connection.release();
      //console.log("Connection released");
    }
  }
});


/**
 * @swagger
 * /ikeja/update_multiple_zone_to_nbraid:
 *   post:
 *     summary: Update multiple zone information to NBRAID category for employees.
 *     description: Updates the zone information to NBRAID category for multiple employees in the Ikeja zone.
 *     tags:
 *       - Ikeja
 *     security:
 *       - BearerAuth: []
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             properties:
 *               entryIds:
 *                 type: string
 *               line:
 *                 type: string
 *               section_id:
 *                 type: integer
 *     responses:
 *       200:
 *         description: Details updated successfully.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 status:
 *                   type: string
 *                   example: Success
 *                 message:
 *                   type: string
 *                   example: Details updated successfully.
 *       500:
 *         description: Internal server error.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 status:
 *                   type: string
 *                   example: Error
 *                 message:
 *                   type: string
 *                   example: Internal Server Error
 * @function
 * @name updateMultipleZoneToNBRAID
 * @memberof module:Routes/Ikeja
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue updating multiple zones to NBRAID category.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
// change zone braid to nbraid assign 
app.post('/ikeja/update_multiple_zone_to_nbraid', authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    const { entryIds, line, section_id } = req.body;
    const entryIdsArray = entryIds.split(',');
    const checkQuery = 'SELECT * FROM geopos_employees WHERE id = ? ';
    const updateQuery =
      'UPDATE geopos_employees SET zone=?,machine=?,emp_count=?,line=?,section_id=?,category_type=? WHERE id = ?';
    let processedCount = 0;

    for (const entryId of entryIdsArray) {
      const checkValues = [entryId];
      const checkResult = await executeQuery(connection,checkQuery, checkValues);

      if (checkResult.length === 1) {
        const { id } = checkResult[0];
        const updateValue = ['', '', '', line, section_id, 'NBRAID', id];
        await executeQuery(connection,updateQuery, updateValue);
        processedCount++;
        console.log(`Data updated for entryId: ${entryId}`);
      } else {
        processedCount++;
        console.log(`Employee not found for entryId: ${entryId}`);
      }
    }

    if (processedCount === entryIdsArray.length) {
      res.json({ status: 'Success', message: 'Details updated successfully.' });
    }
  } catch (error) {
    console.error('Error updating multiple zones to NBRAID:', error);
    res.status(500).json({ status: 'Error', message: 'Internal Server Error' });
  } finally {
    if (connection) {
      connection.release();
      //console.log("Connection released");
    }
  }
});


/**
 * @swagger
 * /ikeja/getZonedataNbraid:
 *   get:
 *     summary: Get zone data for NBRAID category employees.
 *     description: Retrieves zone data for employees with the NBRAID category in the Ikeja zone.
 *     tags:
 *       - Ikeja
 *     security:
 *       - BearerAuth: []
 *     responses:
 *       200:
 *         description: Zone data for NBRAID category employees.
 *         content:
 *           application/json:
 *             schema:
 *               type: array
 *               items:
 *                 type: object
 *                 properties:
 *                   id:
 *                     type: integer
 *                     description: The employee ID.
 *                   name:
 *                     type: string
 *                     description: The name of the employee.
 *                   role:
 *                     type: string
 *                     description: The role of the employee.
 *                   section_name:
 *                     type: string
 *                     description: The name of the section.
 *                   item_description:
 *                     type: string
 *                     description: The description of the item.
 *       500:
 *         description: Internal server error.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 message:
 *                   type: string
 *                   example: Internal Server Error
 * @function
 * @name getZoneDataForNBRAID
 * @memberof module:Routes/Ikeja
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue fetching zone data for NBRAID category employees.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
// Get zone nbraid data default view
app.get('/ikeja/getZonedataNbraid', authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    const query = `
      SELECT geopos_employees.*, section.section_name, item_masterr.item_description, geopos_emptype.name as role
      FROM geopos_employees
      LEFT JOIN geopos_emptype ON geopos_employees.roleid = geopos_emptype.id
      LEFT JOIN section ON geopos_employees.section_id = section.id
      LEFT JOIN item_masterr ON geopos_employees.product = item_masterr.id
      WHERE geopos_employees.roleid != '3' AND geopos_employees.passive_type = 'ACT' AND geopos_employees.category_type = 'NBRAID'
    `;
    
    const result = await executeQuery(connection,query);
    res.send(result);
  } catch (error) {
    console.error('Error fetching data for NBRAID employees:', error);
    res.status(500).send('Internal Server Error');
  } finally {
    if (connection) {
      connection.release();
      //console.log("Connection released");
    }
  }
});

/**
 * @swagger
 * /ikeja/get_zoneNbraid_search:
 *   get:
 *     summary: Get zone data for NBRAID category employees with search filters.
 *     description: Retrieves zone data for NBRAID category employees in the Ikeja zone based on specified search filters.
 *     tags:
 *       - Ikeja
 *     security:
 *       - BearerAuth: []
 *     parameters:
 *       - in: query
 *         name: where
 *         schema:
 *           type: string
 *         required: true
 *         description: The WHERE clause for filtering the results.
 *     responses:
 *       200:
 *         description: Zone data for NBRAID category employees matching the search criteria.
 *         content:
 *           application/json:
 *             schema:
 *               type: array
 *               items:
 *                 type: object
 *                 properties:
 *                   id:
 *                     type: integer
 *                     description: The employee ID.
 *                   name:
 *                     type: string
 *                     description: The name of the employee.
 *                   role:
 *                     type: string
 *                     description: The role of the employee.
 *                   section_name:
 *                     type: string
 *                     description: The name of the section.
 *       500:
 *         description: Internal server error.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 message:
 *                   type: string
 *                   example: Internal Server Error
 * @function
 * @name getZoneDataForNBRAIDWithSearch
 * @memberof module:Routes/Ikeja
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue fetching zone data for NBRAID category employees with search filters.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
// Get zone nbraid data search view
app.get('/ikeja/get_zoneNbraid_search', authenticateJWT, async (req, res) => {
  let connection; 
  try {
    connection = await getPoolConnection();
    const { where } = req.query;
    const query = `
      SELECT geopos_employees.*, section.section_name, geopos_emptype.name as role
      FROM geopos_employees
      LEFT JOIN geopos_emptype ON geopos_employees.roleid = geopos_emptype.id
      LEFT JOIN section ON geopos_employees.section_id = section.id
      WHERE ${where}
    `;
    
    const result = await executeQuery(connection,query);
    res.send(result);
  } catch (error) {
    console.error('Error fetching data for NBRAID employees:', error);
    res.status(500).send('Internal Server Error');
  } finally {
    if (connection) {
      connection.release();
      //console.log("Connection released");
    }
  }
});

/**
 * @swagger
 * /ikeja/update_multiple_zone_nbraid:
 *   post:
 *     summary: Update multiple employees in NBRAID category with new zone and section.
 *     description: Updates multiple employees in the NBRAID category with new zone and section based on provided entry IDs.
 *     tags:
 *       - Ikeja
 *     security:
 *       - BearerAuth: []
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             properties:
 *               entryIds:
 *                 type: string
 *                 description: Comma-separated list of entry IDs for the employees to update.
 *               line:
 *                 type: string
 *                 description: The new line for the employees.
 *               section_id:
 *                 type: integer
 *                 description: The new section ID for the employees.
 *     responses:
 *       200:
 *         description: Details updated successfully.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 status:
 *                   type: string
 *                   example: Success
 *                 message:
 *                   type: string
 *                   example: Details updated successfully.
 *       500:
 *         description: Internal server error.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 status:
 *                   type: string
 *                   example: Error
 *                 message:
 *                   type: string
 *                   example: Internal Server Error
 * @function
 * @name updateMultipleEmployeesInNBRAID
 * @memberof module:Routes/Ikeja
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue updating multiple employees in NBRAID category with new zone and section.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
// Entryids wise machine data update Nbraid
app.post('/ikeja/update_multiple_zone_nbraid', authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    const { entryIds, line, section_id } = req.body;
    const entryIdsArray = entryIds.split(',');
    const checkQuery = 'SELECT * FROM geopos_employees WHERE id = ? ';
    const InsertQuery = 'INSERT INTO change_product (emp_id, entryid, line_old, line_new, section_old, section_new) VALUES (?, ?, ?, ?, ?, ?)';
    const updateQuery = 'UPDATE geopos_employees SET line=?, section_id=? WHERE id = ?';
    let processedCount = 0;

    for (const entryId of entryIdsArray) {
      const [checkResult] = await executeQuery(connection,checkQuery, [entryId]);

      if (checkResult) {
        const { id, entryid, line: line_old, section_id: section_old } = checkResult;
        const insertValues = [id, entryid, line_old, line, section_old, section_id];

        await executeQuery(connection,InsertQuery, insertValues);
        await executeQuery(connection,updateQuery, [line, section_id, id]);

        processedCount++;
        console.log(`Data updated for entryId: ${entryId}`);

        if (processedCount === entryIdsArray.length) {
          res.json({ status: 'Success', message: 'Details updated successfully.' });
        }
      } else {
        processedCount++;
        console.log(`Employee not found for entryId: ${entryId}`);

        if (processedCount === entryIdsArray.length) {
          res.json({ status: 'Success', message: 'Details updated successfully.' });
        }
      }
    }
  } catch (error) {
    console.error('Error updating multiple employees in NBRAID category:', error);
    res.status(500).json({ status: 'Error', message: 'Internal Server Error' });
  } finally {
    if (connection) {
      connection.release();
      //console.log("Connection released");
    }
  }
});

/**
 * @swagger
 * /ikeja/update_multiple_zone_braid:
 *   post:
 *     summary: Update multiple employees in BRAID category with new zone and section.
 *     description: Updates multiple employees in the BRAID category with new zone and section based on provided entry IDs.
 *     tags:
 *       - Ikeja
 *     security:
 *       - BearerAuth: []
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             properties:
 *               shift:
 *                 type: string
 *                 description: The new shift for the employees.
 *               entryIds:
 *                 type: string
 *                 description: Comma-separated list of entry IDs for the employees to update.
 *               section_id:
 *                 type: integer
 *                 description: The new section ID for the employees.
 *               zone:
 *                 type: string
 *                 description: The new zone for the employees.
 *               machines:
 *                 type: string
 *                 description: Comma-separated list of machines for the employees.
 *     responses:
 *       200:
 *         description: Details updated successfully.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 status:
 *                   type: string
 *                   example: Success
 *                 message:
 *                   type: string
 *                   example: Details updated successfully.
 *       500:
 *         description: Internal server error.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 status:
 *                   type: string
 *                   example: Error
 *                 message:
 *                   type: string
 *                   example: Internal Server Error
 * @function
 * @name updateMultipleEmployeesInBRAID
 * @memberof module:Routes/Ikeja
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue updating multiple employees in BRAID category with new zone and section.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
// Entryids wise zone braid update
app.post('/ikeja/update_multiple_zone_braid', authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    const { shift, entryIds, section_id, zone, machines } = req.body;
    const tags = machines.split(',');
    const numTags = tags.length - 1;
    const empCount = (1 / numTags).toFixed(4);
    const entryIdsArray = entryIds.split(',');
    const checkQuery = 'SELECT * FROM geopos_employees WHERE id = ? ';
    const updateQuery = 'UPDATE geopos_employees SET zone=?, machine=?, emp_count=?, line=?, shift=?, section_id=?, category_type=? WHERE id = ?';
    let processedCount = 0;

    for (const entryId of entryIdsArray) {
      const [checkResult] = await executeQuery(connection,checkQuery, [entryId]);
      
      if (checkResult) {
        const { id } = checkResult;
        const updateValues = [zone, machines, empCount, '', shift, section_id, 'BRAID', id];
        
        await executeQuery(connection,updateQuery, updateValues);
        processedCount++;
        console.log(`Data updated for entryId: ${entryId}`);
      } else {
        processedCount++;
        console.log(`Employee not found for entryId: ${entryId}`);
      }

      if (processedCount === entryIdsArray.length) {
        res.json({ status: 'Success', message: 'Details updated successfully.' });
      }
    }
  } catch (error) {
    console.error('Error updating multiple employees in BRAID category:', error);
    res.status(500).json({ status: 'Error', message: 'Internal Server Error' });
  } finally {
    if (connection) {
      connection.release();
      //console.log("Connection released");
    }
  }
});


//Change Shift //
/**
 * @swagger
 * /ikeja/getShiftdata:
 *   get:
 *     summary: Retrieve active employees' shift data.
 *     description: Fetches shift data for active employees, excluding those with specific role IDs (3 and 5).
 *     tags:
 *       - Ikeja
 *     security:
 *       - BearerAuth: []
 *     responses:
 *       200:
 *         description: Successfully retrieved shift data.
 *         content:
 *           application/json:
 *             schema:
 *               type: array
 *               items:
 *                 type: object
 *                 properties:
 *                   id:
 *                     type: integer
 *                     description: The employee ID.
 *                     example: 1
 *                   entryid:
 *                     type: string
 *                     description: The employee entry ID.
 *                     example: EMP123
 *                   name:
 *                     type: string
 *                     description: The employee name.
 *                     example: John Doe
 *                   roleid:
 *                     type: integer
 *                     description: The role ID of the employee.
 *                     example: 2
 *                   shift:
 *                     type: string
 *                     description: The employee shift.
 *                     example: Day
 *                   section_id:
 *                     type: integer
 *                     description: The section ID the employee is assigned to.
 *                     example: 1
 *                   passive_type:
 *                     type: string
 *                     description: The passive type of the employee.
 *                     example: ACT
 *                   category_type:
 *                     type: string
 *                     description: The category type of the employee.
 *                     example: BRAID
 *                   section_name:
 *                     type: string
 *                     description: The name of the section.
 *                     example: Production
 *                   role:
 *                     type: string
 *                     description: The role name of the employee.
 *                     example: Operator
 *       500:
 *         description: Internal Server Error.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 status:
 *                   type: string
 *                   example: Error
 *                 message:
 *                   type: string
 *                   example: Internal Server Error
 * @function
 * @name getShiftData
 * @memberof module:Routes/Ikeja
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue retrieving the shift data.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
// Get shift data default view
app.get('/ikeja/getShiftdata', authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    const query =
      `SELECT geopos_employees.*, section.section_name, geopos_emptype.name AS role
      FROM geopos_employees
      LEFT JOIN geopos_emptype ON geopos_employees.roleid = geopos_emptype.id
      LEFT JOIN section ON geopos_employees.section_id = section.id
      WHERE (geopos_employees.roleid != '3' AND geopos_employees.roleid != '5') 
      AND geopos_employees.passive_type = 'ACT'`;

    const result = await executeQuery(connection,query);

    res.send(result);
    console.log(result, '---------------');
  } catch (error) {
    console.error(error);
    res.status(500).send('Internal Server Error');
  } finally {
    if (connection) {
      connection.release();
      //console.log("Connection released");
    }
  }
});

 
/**
 * @swagger
 * /ikeja/get_shiftdata_search:
 *   get:
 *     summary: Retrieve shift data with search criteria.
 *     description: Retrieve employee shift data based on the specified search criteria in the query parameter.
 *     tags:
 *       - Shift Data
 *     security:
 *       - BearerAuth: []
 *     parameters:
 *       - in: query
 *         name: where
 *         required: true
 *         description: SQL WHERE clause to filter the results.
 *         schema:
 *           type: string
 *           example: roleid=1 AND section_id=2
 *     responses:
 *       200:
 *         description: Successfully retrieved shift data.
 *         content:
 *           application/json:
 *             schema:
 *               type: array
 *               items:
 *                 type: object
 *                 properties:
 *                   id:
 *                     type: integer
 *                   name:
 *                     type: string
 *                   roleid:
 *                     type: integer
 *                   section_id:
 *                     type: integer
 *                   section_name:
 *                     type: string
 *                   role:
 *                     type: string
 *       500:
 *         description: Internal server error.
 *         content:
 *           application/json:
 *             schema:
 *               type: string
 *               example: Internal Server Error
 * @function
 * @name getShiftDataSearch
 * @memberof module:Routes/ShiftData
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with retrieving the shift data.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */

// Get shift data search  view
app.get('/ikeja/get_shiftdata_search', authenticateJWT, async (req, res) => {
 let connection;
  try {
    connection = await getPoolConnection();
    const { where } = req.query;
    const query =
      `SELECT geopos_employees.*, section.section_name, geopos_emptype.name AS role
      FROM geopos_employees
      LEFT JOIN geopos_emptype ON geopos_employees.roleid = geopos_emptype.id
      LEFT JOIN section ON geopos_employees.section_id = section.id
      WHERE ${where}`;
      
    const result = await executeQuery(connection,query);
    res.send(result);
  } catch (error) {
    console.error(error);
    res.status(500).send('Internal Server Error');
  } finally {
    if (connection) {
      connection.release();
      //console.log("Connection released");
    }
  }
});

/**
 * @swagger
 * /ikeja/update_multiple_shift:
 *   post:
 *     summary: Update multiple employee shifts.
 *     description: Update the shift of multiple employees based on the provided entry IDs and new shift value.
 *     tags:
 *       - Shift Management
 *     security:
 *       - BearerAuth: []
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             properties:
 *               shift:
 *                 type: string
 *                 description: The new shift value to update for the employees.
 *               entryIds:
 *                 type: string
 *                 description: Comma-separated list of entry IDs of the employees whose shifts need to be updated.
 *     responses:
 *       200:
 *         description: Successfully updated employee shifts.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 status:
 *                   type: string
 *                   example: Success
 *                 message:
 *                   type: string
 *                   example: Details updated successfully.
 *       500:
 *         description: Internal server error.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 status:
 *                   type: string
 *                   example: Error
 *                 message:
 *                   type: string
 *                   example: Internal Server Error
 * @function
 * @name updateMultipleShifts
 * @memberof module:Routes/ShiftManagement
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with updating the employee shifts.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */

// Multiple shift data update
app.post('/ikeja/update_multiple_shift', authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    const { shift, entryIds } = req.body;
    const entryIdsArray = entryIds.split(',');
    const checkQuery = 'SELECT * FROM geopos_employees WHERE id = ? ';
    const updateQuery = 'UPDATE geopos_employees SET shift=? WHERE id = ?';
    let processedCount = 0;

    for (const entryId of entryIdsArray) {
      const checkValues = [entryId];
      const [checkResult] = await executeQuery(connection,checkQuery, checkValues);

      if (!checkResult) {
        processedCount++;
        console.log(`Employee not found for entryId: ${entryId}`);
        if (processedCount === entryIdsArray.length) {
          return res.json({ status: 'Success', message: 'Details updated successfully.' });
        }
      } else {
        const id = checkResult.id;
        const updateValues = [shift, id];
        await executeQuery(connection,updateQuery, updateValues);
        processedCount++;
        console.log(`Data updated for entryId: ${entryId}`);
        if (processedCount === entryIdsArray.length) {
          return res.json({ status: 'Success', message: 'Details updated successfully.' });
        }
      }
    }
  } catch (error) {
    console.error('Error updating multiple shifts:', error);
    res.status(500).json({ status: 'Error', message: 'Internal Server Error' });
  } finally {
    if (connection) {
      connection.release();
      //console.log("Connection released");
    }
  }
});


//Change worker type

/**
 * @swagger
 * /ikeja/get_workerdata_search:
 *   get:
 *     summary: Get worker data based on search criteria.
 *     description: Retrieve worker data based on the provided search criteria.
 *     tags:
 *       - Worker Management
 *     security:
 *       - BearerAuth: []
 *     parameters:
 *       - in: query
 *         name: where
 *         schema:
 *           type: string
 *         required: true
 *         description: The SQL WHERE clause to filter the worker data.
 *     responses:
 *       200:
 *         description: Worker data retrieved successfully.
 *         content:
 *           application/json:
 *             schema:
 *               type: array
 *               items:
 *                 $ref: '#/components/schemas/Worker'
 *       500:
 *         description: Internal server error.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: Internal Server Error
 * @function
 * @name getWorkerDataSearch
 * @memberof module:Routes/WorkerManagement
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with fetching worker data.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */

// Get worker data search  view
app.get('/ikeja/get_workerdata_search', authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    const { where } = req.query;
    const query = `
      SELECT geopos_employees.*, section.section_name, geopos_emptype.name AS role
      FROM geopos_employees
      LEFT JOIN geopos_emptype ON geopos_employees.roleid = geopos_emptype.id
      LEFT JOIN section ON geopos_employees.section_id = section.id
      WHERE ${where}
    `;
    
    const [result] = await executeQuery(connection,query);
    res.send(result);
  } catch (error) {
    console.error('Error fetching worker data:', error);
    res.status(500).send('Internal Server Error');
  } finally {
    if (connection) {
      connection.release();
      //console.log("Connection released");
    }
  }
});

/**
 * @swagger
 * /ikeja/update_multiple_workertype:
 *   post:
 *     summary: Update workertype for multiple employees
 *     description: Update the workertype for multiple employees based on their entryIds.
 *     tags:
 *       - Worker Management
 *     security:
 *       - BearerAuth: []
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             properties:
 *               wtype:
 *                 type: string
 *                 description: The new workertype to assign to the employees.
 *               entryIds:
 *                 type: string
 *                 description: Comma-separated list of entryIds for the employees to update.
 *             example:
 *               wtype: 'Full-time'
 *               entryIds: '1,2,3'
 *     responses:
 *       200:
 *         description: Workertype updated successfully for the specified employees.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 status:
 *                   type: string
 *                   example: Success
 *                 message:
 *                   type: string
 *                   example: Details updated successfully.
 *       500:
 *         description: Internal server error.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 status:
 *                   type: string
 *                   example: Error
 *                 message:
 *                   type: string
 *                   example: Internal Server Error
 * @function
 * @name updateMultipleWorkertype
 * @memberof module:Routes/WorkerManagement
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with updating workertype.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */

// Multiple workertype data update
app.post('/ikeja/update_multiple_workertype', authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    const { wtype, entryIds } = req.body;
    const entryIdsArray = entryIds.split(',');
    const checkQuery = 'SELECT * FROM geopos_employees WHERE id = ?';
    const updateQuery = 'UPDATE geopos_employees SET workertype = ? WHERE id = ?';
    let processedCount = 0;

    for (const entryId of entryIdsArray) {
      const checkValues = [entryId];
      const [checkResult] = await executeQuery(connection,checkQuery, checkValues);

      if (checkResult) {
        const { id } = checkResult;
        const updateValues = [wtype, id];
        await executeQuery(connection,updateQuery, updateValues);
        processedCount++;
        console.log(`Data updated for entryId: ${entryId}`);
      } else {
        console.log(`Employee not found for entryId: ${entryId}`);
      }
    }

    if (processedCount === entryIdsArray.length) {
      res.json({ status: 'Success', message: 'Details updated successfully.' });
    }
  } catch (error) {
    console.error('Error updating workertype:', error);
    res.status(500).json({ status: 'Error', message: 'Internal Server Error' });
  } finally {
    if (connection) {
      connection.release();
      //console.log("Connection released");
    }
  }
});
     

//Employee FDA
/**
 * @swagger
 * /ikeja/getEmployeeFdaData:
 *   get:
 *     summary: Get FDA (Full-time, Direct, Active) employee data
 *     description: Retrieve FDA employee data for the past three months.
 *     tags:
 *       - Employee Management
 *     security:
 *       - BearerAuth: []
 *     responses:
 *       200:
 *         description: FDA employee data retrieved successfully.
 *         content:
 *           application/json:
 *             schema:
 *               type: array
 *               items:
 *                 $ref: '#/components/schemas/EmployeeFdaData'
 *       500:
 *         description: Internal server error.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 message:
 *                   type: string
 *                   example: Internal Server Error
 *                 error:
 *                   type: string
 *                   example: Error message describing the encountered error.
 * @function
 * @name getEmployeeFdaData
 * @memberof module:Routes/EmployeeManagement
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with fetching employee FDA data.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
// Get employee fda data default view
app.get('/ikeja/getEmployeeFdaData', authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    const today = new Date();
    const dateThreeMonthsAgo = new Date(today);
    dateThreeMonthsAgo.setMonth(today.getMonth() - 3);
    const firstDayOfCurrentMonth = new Date(today.getFullYear(), today.getMonth(), 1);

    const query =
      `SELECT geopos_employees_attrition.*
      FROM geopos_employees_attrition
      WHERE STR_TO_DATE(exitdate, "%d-%m-%Y") >= ? 
        AND STR_TO_DATE(exitdate, "%d-%m-%Y") < ?;`;
    const values = [dateThreeMonthsAgo, firstDayOfCurrentMonth];

    const result = await executeQuery(connection, query, values);
    res.send(result);
    console.log(result, '---------------');
  } catch (error) {
    console.error('Error fetching employee FDA data:', error);
    res.status(500).send('Internal Server Error');
  } finally {
    if (connection) {
      connection.release();
      //console.log("Connection released");
    }
  }
});
                   
//------------------IKEJA END----------------------//

//------------------OTA START----------------------//


//Supervisor data
app.get('/ota/supervisor_data_view', (req, res) => {
  const query = `
    SELECT supervisor_assign.*, section.section_name, employees_ota.name
    FROM supervisor_assign
    LEFT JOIN employees_ota ON supervisor_assign.entryid = employees_ota.entryid
    LEFT JOIN section ON supervisor_assign.section = section.id
    WHERE supervisor_assign.site = 'ota'
  `;

  db.query(query, (err, results) => {
    if (err) {
      console.error('Error executing query: ' + err.stack);
      res.status(500).json({ error: 'An error occurred' });
      return;
    }
    res.json({ timesheet: results });
  });
});

// Get Supervisor details
app.get('/supervisor_details', (req, res) => {
  const query = "SELECT * FROM employees_ota WHERE roleid IN (1, 3) AND passive_type='ACT'";
  
  db.query(query, (err, results) => {
    if (err) {
      console.error('Error executing query: ' + err.stack);
      res.status(500).json({ error: 'An error occurred' });
      return;
    }
    res.json(results);
  });
});

//add new supervisor
app.post('/addsupervisorota', (req, res) => {
  const { supervisor, shift, section, line_no } = req.body;
  console.log("Supervisor:", supervisor);
  console.log("Shift:", shift);
  console.log("Section:", section);
  console.log("Line:", line_no);
  const date = new Date().toLocaleDateString('en-GB', { timeZone: 'Africa/Lagos' });
  const parts = date.split('/');
  const formattedDay = parts[0].padStart(2, '0');
  const formattedMonth = parts[1].padStart(2, '0');
  const year = parts[2];
  const date1 = `${formattedDay}-${formattedMonth}-${year}`;
  const currentDate = new Date(); // Get current date and time
  const timestampInSeconds = Math.floor(currentDate.getTime() / 1000); // Get timestamp in seconds

  // Log timestamp for debugging
  console.log('Timestamp:', timestampInSeconds);
  
  const productlist = [];
  let prodindex = 0;
  let totalIterations = line_no.length * section.length; // Total iterations needed

  line_no.forEach((lineValue) => {
    section.forEach((sectionValue) => {
      const data = {
        entryid: supervisor,
        section: sectionValue,
        shift: shift,
        date: date1,
        line: lineValue,
        category_type: 'NBRAID',
        timestamp: timestampInSeconds,
        site: 'ota'
      };
  
      console.log("Data to be inserted:", data); // Log data before insert
  
      const where = `line='${lineValue}' AND section='${sectionValue}' AND shift='${shift}'`;
      console.log("Where clause:", where); // Log where clause
      // Define the SELECT query
      const selectQuery = `SELECT * FROM supervisor_assign WHERE ${where}`;
      console.log("selectQuery:", selectQuery); // Log where clause

    // Execute the SELECT query
    db.query(selectQuery, (error, results) => {
        if (error) {
          console.error('Error querying database: ' + error.stack);
          res.status(500).json({ success: false, message: 'Internal server error' });
          return;
        }
        if (results.length > 0) {
          prodindex++;
        } else {
          db.query('INSERT INTO supervisor_assign SET ?', data, (err, result) => {
            if (err) {
              console.error('Error inserting into database: ' + err.stack);
              res.status(500).json({ success: false, message: 'Internal server error' });
              return;
            }
            console.log("Inserted data:", data); // Log inserted data
            productlist.push(data); // Push inserted data to productlist
            prodindex++;
            if (prodindex === totalIterations) {
              // All iterations completed, send response
              sendResponse();
            }
          });
        }
      });
    });
  });

  // Function to send response
  function sendResponse() {
    if (prodindex > 0) {
      const successMessage = `${prodindex} Number Of Data Successfully Inserted And ${prodindex} Already assigned to same or other operator.`;
      console.log("Success message:", successMessage); // Log success message
      res.status(200).json({ success: true, message: successMessage, productlist: productlist });
    } else {
      console.log("No data inserted."); // Log no data inserted
      res.status(500).json({ success: false, message: 'ERROR' });
    }
  }
});

// Delete supervisor route
app.delete('/ota/delete_supervisor/:id', (req, res) => {
  const id = req.params.id;
  console.log("id:", id); // Log where clause
  if (id) {
    // Delete supervisor from database
    db.query('DELETE FROM supervisor_assign WHERE id = ?', [id], (err, result) => {
      if (err) {
        console.error(err);
        res.status(500).json({ status: 'Error', message: 'Internal Server Error' });
      } else {
        res.json({ status: 'Success', message: 'Delete Successfully' });
      }
    });
  } else {
    res.status(400).json({ status: 'Error', message: 'Invalid Request' });
  }
});

// API endpoint to delete items by IDs
app.delete('/ota/delete_multiple_supervisor', (req, res) => {
  const { ids } = req.body;
  console.log("ids:", ids); // Log where clause
  // Validate request body
  if (!ids || !Array.isArray(ids)) {
    return res.status(400).json({ message: 'Invalid request body. Expected an array of IDs.' });
  }

  // Delete supervisors from the database for each ID
  ids.forEach(id => {
    // Delete supervisor from database
    db.query('DELETE FROM supervisor_assign WHERE id = ?', [id], (err, result) => {
      if (err) {
        console.error(err);
        res.status(500).json({ status: 'Error', message: 'Internal Server Error' });
      } else {
        console.log(`Supervisor with ID ${id} deleted successfully.`);
      }
    });
  });

  // Send response after all deletions are completed
  res.status(200).json({ message: 'Supervisors deleted successfully.' });
});




//Operator Data
/**
 * @swagger
 * /ota/operator_data_view:
 *   get:
 *     summary: Get OTA (Over-The-Air) operator data view
 *     description: Retrieve OTA operator data view filtered by role ID, production type, and ban status.
 *     tags:
 *       - OTA Operator Management
 *     security:
 *       - BearerAuth: []
 *     responses:
 *       200:
 *         description: OTA operator data view retrieved successfully.
 *         content:
 *           application/json:
 *             schema:
 *               type: array
 *               items:
 *                 $ref: '#/components/schemas/OTAOperatorDataView'
 *       500:
 *         description: Internal server error.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 message:
 *                   type: string
 *                   example: Internal Server Error
 *                 error:
 *                   type: string
 *                   example: Error message describing the encountered error.
 * @function
 * @name getOtaOperatorDataView
 * @memberof module:Routes/OTAOperatorManagement
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with fetching OTA operator data view.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */

app.get('/ota/operator_data_view', authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    const query = `
      SELECT employees_ota.*, geopos_users.banned, geopos_users.roleid, geopos_users.email, geopos_users.loc, geopos_emptype.name as empname
      FROM employees_ota
      LEFT JOIN geopos_users ON employees_ota.entryid = geopos_users.entryid
      LEFT JOIN geopos_emptype ON employees_ota.roleid = geopos_emptype.id
      WHERE geopos_users.roleid = ?
      AND employees_ota.roleid = ?
      AND geopos_users.production_type = ?
      AND geopos_users.banned = ?
      ORDER BY geopos_users.name ASC`;
    
    const roleId = '3';
    const productionType = 'ota';
    const banned = '0';

    const result = await executeQuery(connection,query, [roleId, roleId, productionType, banned]);
    res.send(result);
  } catch (error) {
    console.error('Error fetching OTA operator data:', error);
    res.status(500).send('Internal Server Error');
  } finally {
    if (connection) {
      connection.release();
      //console.log("Connection released");
    }
  }
});


/**
 * @swagger
 * /ota/add_operator:
 *   post:
 *     summary: Add OTA (Over-The-Air) operator
 *     description: Add a new OTA operator with the provided details.
 *     tags:
 *       - OTA Operator Management
 *     security:
 *       - BearerAuth: []
 *     requestBody:
 *       description: OTA operator details to be added
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             $ref: '#/components/schemas/OTAOperator'
 *     responses:
 *       200:
 *         description: Record inserted successfully.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 message:
 *                   type: string
 *                   example: Record inserted successfully
 *       409:
 *         description: Entry Id already exists.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 status:
 *                   type: number
 *                   example: 409
 *                 message:
 *                   type: string
 *                   example: Entry Id already Exists
 *       500:
 *         description: Internal server error.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 status:
 *                   type: number
 *                   example: 500
 *                 message:
 *                   type: string
 *                   example: Internal server error
 * @function
 * @name addOtaOperator
 * @memberof module:Routes/OTAOperatorManagement
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with adding the OTA operator.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
//add operator data submit
app.post('/ota/add_operator', authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    const name = req.body.name;
    const username = req.body.username;
    const email = req.body.email;
    const entryid = req.body.entryid;
    const pass = req.body.password !== "" ? req.body.password : '123456';
    const worktyp = req.body.workertype;
    const shift = req.body.shift;
    const site = req.body.site;
    const zone = req.body.zone;
    const machine = req.body.machiness;
    const type = req.body.type;
    const roleid = '3';
  
    const currentDate = new Date();
    const formattedDate = formatDate(currentDate);
  
    const options = { timeZone: 'Africa/Lagos', day: 'numeric', month: 'numeric', year: 'numeric' };
    const currentTime = new Date().toLocaleString('en-US', options);
    const [date, month, year] = currentTime.split('/');
    const tdate = `${date.padStart(2, '0')}-${month.padStart(2, '0')}-${year}`;
  
    const tags = machine.split(',');
    const numTags = tags.length - 1;
    const empCount = (1 / numTags).toFixed(4);
  
    const rowcheck = `SELECT * FROM geopos_users WHERE entryid="${entryid}"`;
    const rowcheck1 = `SELECT * FROM employees_ota WHERE entryid="${entryid}"`;
    const rowcheck2 = `SELECT * FROM geopos_users WHERE email="${email}" OR username="${username}" OR name="${name}"`;
  
    const result = await executeQuery(connection,rowcheck);
    if (result.length > 0) {
      return res.status(200).json({ status: 409, message: 'Entry Id already Exists' });
    }
  
    const resultt = await executeQuery(connection,rowcheck2);
    if (resultt.length > 0) {
      // Handle if email, username, or name already exists
    }
  
    const insertResult = await executeQuery(connection,
      'INSERT INTO geopos_users (email, username, name, entryid, date_created) VALUES (?, ?, ?, ?, ?)',
      [email, username, name, entryid, formattedDate]
    );
    const userId = insertResult.insertId;
  
    const resultt1 = await executeQuery(connection,rowcheck1);
    if (resultt1.length > 0) {
      if(type === 'BRAID'){
        await executeQuery(connection,
          'UPDATE employees_ota SET roleid=?, workertype=?, shift=?, staff=?, zone=?, machine=?, emp_count=?, section_id=? , category_type=? WHERE entryid=?',
          [roleid, worktyp, shift,site, zone, machine, empCount,'0',type, entryid]
        );
        const userIdAsString = userId.toString();
        const hashedPassword = hashPassword(pass, userIdAsString);
        await executeQuery(connection,
          'UPDATE geopos_users SET roleid=?, name=?, category_type=?,pass=? WHERE entryid=?',
          [roleid, name, 'ikeja', hashedPassword, entryid]
        );
      } else {
        await executeQuery(connection,
          'UPDATE employees_ota SET roleid=?, workertype=?, shift=?, staff=?, category_type=? WHERE entryid=?',
          [roleid, worktyp, shift,site,type, entryid]
        );
        const userIdAsString = userId.toString();
        const hashedPassword = hashPassword(pass, userIdAsString);
        await executeQuery(connection,
          'UPDATE geopos_users SET roleid=?, name=?, production_type=?, category_type=?,pass=? WHERE entryid=?',
          [roleid,name,'ota',type, hashedPassword, entryid]
        );
      }
    } else {
      if(type === 'BRAID'){
        await executeQuery(connection,
          'INSERT INTO employees_ota (username,entryid,email,name,roleid,workertype,shift,staff,zone,machine,emp_count,passive_type,date,category_type) VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?)',
          [username, entryid, email, name, roleid, worktyp,shift,site,zone, machine, empCount,'ACT',tdate,type]
        );
        const userIdAsString = userId.toString();
        const hashedPassword = hashPassword(pass, userIdAsString);
        await executeQuery(connection,
          'UPDATE geopos_users SET roleid=?, name=?, production_type=?, category_type=?, pass=? WHERE entryid=?',
          [roleid, name, 'ota', type, hashedPassword, entryid]
        );
      } else {
        await executeQuery(connection,
          'INSERT INTO employees_ota (username,entryid,email,name,roleid,workertype,shift,date,category_type,staff) VALUES (?,?,?,?,?,?,?,?,?,?)',
          [username, entryid, email, name, roleid, worktyp,shift,tdate,type,site]
        );
        const userIdAsString = userId.toString();
        const hashedPassword = hashPassword(pass, userIdAsString);
        await executeQuery(connection,
          'UPDATE geopos_users SET roleid=?, name=?, production_type=?, category_type=?, pass=? WHERE entryid=?',
          [roleid, name, 'ota', type, hashedPassword, entryid]
        );
      }
    }
    res.status(200).json({ message: 'Record inserted successfully' });
  } catch (error) {
    console.error("Error occurred:", error);
    res.status(500).json({ status: 500, message : 'Internal server error'});
  } finally {
    if (connection) {
      connection.release();
      //console.log("Connection released");
    }
  }
});
 
/**
 * @swagger
 * /ota/getConvertdata/{id}:
 *   get:
 *     summary: Get OTA operator data by ID
 *     description: Retrieve OTA operator data by ID.
 *     tags:
 *       - OTA Operator Management
 *     security:
 *       - BearerAuth: []
 *     parameters:
 *       - in: path
 *         name: id
 *         description: ID of the OTA operator to retrieve
 *         required: true
 *         schema:
 *           type: integer
 *           minimum: 1
 *     responses:
 *       200:
 *         description: OTA operator data retrieved successfully.
 *         content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/OTAOperator'
 *       404:
 *         description: OTA operator not found.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: Item not found
 *       500:
 *         description: Failed to fetch OTA operator data.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: Failed to fetch item data
 * @function
 * @name getOtaOperatorById
 * @memberof module:Routes/OTAOperatorManagement
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with fetching OTA operator data.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */

//getconvert data of category
app.get('/ota/getConvertdata/:id', authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    const id = req.params.id;
    const query = 'SELECT * FROM employees_ota WHERE id = ?';
    const results = await executeQuery(connection,query, [id]);
    if (results.length === 0) {
      res.status(404).json({ error: 'Item not found' });
    } else {
      res.json(results[0]);
    }
  } catch (error) {
    console.error('Error fetching shift data:', error);
    res.status(500).json({ error: 'Failed to fetch item data' });
  } finally {
    if (connection) {
      connection.release();
      //console.log("Connection released");
    }
  }
});


/**
 * @swagger
 * /ota/getMachines/{id}:
 *   get:
 *     summary: Get machines by zone ID
 *     description: Retrieve machines by zone ID.
 *     tags:
 *       - OTA Machine Management
 *     security:
 *       - BearerAuth: []
 *     parameters:
 *       - in: path
 *         name: id
 *         description: ID of the zone to retrieve machines for
 *         required: true
 *         schema:
 *           type: integer
 *           minimum: 1
 *     responses:
 *       200:
 *         description: Machines retrieved successfully.
 *         content:
 *           application/json:
 *             schema:
 *               type: string
 *               example: Machine1, Machine2
 *       404:
 *         description: No machines found for the given zone ID.
 *         content:
 *           application/json:
 *             schema:
 *               type: string
 *               example: ''
 *       500:
 *         description: Failed to fetch machine data.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: Failed to fetch machine data
 * @function
 * @name getMachinesByZoneId
 * @memberof module:Routes/OTAMachineManagement
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with fetching machine data.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */

//get machines data
app.get('/ota/getMachines/:id', authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    const id = req.params.id;
    const query = 'SELECT * FROM geopos_machine WHERE zone = ?';
    const result = await executeQuery(connection,query, [id]);

    if (result.length > 0) {
      res.send(result[0].machine);
    } else {
      res.send('');
    }
  } catch (error) {
    console.error('Error fetching machines:', error);
    res.status(500).json({ error: 'Failed to fetch machine data' });
  } finally {
    if (connection) {
      connection.release();
      //console.log("Connection released");
    }
  }
});

/**
 * @swagger
 * /ota/category_convert_op:
 *   post:
 *     summary: Convert employee category
 *     description: Convert employee category based on provided parameters.
 *     tags:
 *       - OTA Employee Management
 *     security:
 *       - BearerAuth: []
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             properties:
 *               id:
 *                 type: integer
 *                 description: The ID of the employee.
 *               entryid:
 *                 type: integer
 *                 description: The entry ID of the employee.
 *               workertype:
 *                 type: string
 *                 description: The workertype of the employee.
 *               shift:
 *                 type: string
 *                 description: The shift of the employee.
 *               staff:
 *                 type: string
 *                 description: The staff details of the employee.
 *               zone:
 *                 type: string
 *                 description: The zone of the employee.
 *               machiness:
 *                 type: string
 *                 description: The machines assigned to the employee.
 *               typ:
 *                 type: string
 *                 description: The category type to convert to.
 *     responses:
 *       200:
 *         description: Employee category converted successfully.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 message:
 *                   type: string
 *                   example: Record updated successfully
 *       404:
 *         description: Employee record not found.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 message:
 *                   type: string
 *                   example: Employee record not found
 *       500:
 *         description: Internal Server Error.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 message:
 *                   type: string
 *                   example: Internal Server Error
 * @function
 * @name convertEmployeeCategory
 * @memberof module:Routes/OTAEmployeeManagement
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with updating employee category.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */

//add operator category convert data submit
app.post('/ota/category_convert_op', authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    const {
      id,
      entryid,
      workertype,
      shift,
      staff,
      zone,
      machiness,
      typ
    } = req.body;

    const tags = machiness.split(',');
    const numTags = tags.length - 1;
    const empCount = (1 / numTags).toFixed(4);

    const rowcheckQuery = 'SELECT * FROM employees_ota WHERE id = ?';
    const rowcheckResult = await executeQuery(connection,rowcheckQuery, [id]);

    if (rowcheckResult.length > 0) {
      if (typ === 'NBRAID') {
        const userIdQuery = 'SELECT * FROM geopos_users WHERE entryid = ?';
        const userIdResult = await executeQuery(connection,userIdQuery, [entryid]);
        const eid = userIdResult.length > 0 ? userIdResult[0].id : null;

        const updateEmployeeQuery = `
          UPDATE employees_ota 
          SET workertype=?, shift=?, staff=?, zone=?, machine=?, emp_count=?, section_id=?, category_type=?
          WHERE entryid=?
        `;
        await executeQuery(connection,updateEmployeeQuery, [workertype, shift, staff, '', '', '', '0', typ, entryid]);

        const updateUserQuery = 'UPDATE geopos_users SET category_type=? WHERE id=?';
        const updateUserResult = await executeQuery(connection,updateUserQuery, [typ, eid]);

        if (updateUserResult.affectedRows === 0) {
          res.status(404).json({ message: 'Record not updated' });
        } else {
          res.status(200).json({ message: 'Record updated successfully' });
        }
      } else {
        const userIdQuery = 'SELECT * FROM geopos_users WHERE entryid = ?';
        const userIdResult = await executeQuery(connection,userIdQuery, [entryid]);
        const eid = userIdResult.length > 0 ? userIdResult[0].id : null;

        const updateEmployeeQuery = `
          UPDATE employees_ota 
          SET workertype=?, shift=?, staff=?, zone=?, machine=?, emp_count=?, section_id=?, category_type=?, product=?, line=?
          WHERE entryid=?
        `;
        await executeQuery(connection,updateEmployeeQuery, [workertype, shift, staff, zone, machiness, empCount, '0', typ, '', '', entryid]);

        const updateUserQuery = 'UPDATE geopos_users SET category_type=? WHERE id=?';
        const updateUserResult = await executeQuery(connection,updateUserQuery, [typ, eid]);

        if (updateUserResult.affectedRows === 0) {
          res.status(404).json({ message: 'Record not updated' });
        } else {
          res.status(200).json({ message: 'Record updated successfully' });
        }
      }
    } else {
      res.status(404).json({ message: 'Employee record not found' });
    }
  } catch (error) {
    console.error('Error updating employee category:', error);
    res.status(500).json({ message: 'Internal Server Error' });
  } finally {
    if (connection) {
      connection.release();
      //console.log("Connection released");
    }
  }
});



//Get operator data single 
app.get('/ota/operator_data_single/:id', authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    const id = req.params.id;
    const query = 'SELECT * FROM employees_ota WHERE id=?';
    const result = await executeQuery(connection,query, [id]);

    if (result.length > 0) {
      res.json(result[0]);
    } else {
      res.status(404).json({ message: 'Operator not found' });
    }
  } catch (error) {
    console.error('Error fetching operator data:', error);
    res.status(500).json({ error: 'Failed to fetch operator data' });
  } finally {
    if (connection) {
      connection.release();
      //console.log("Connection released");
    }
  }
});

/**
 * @swagger
 * /ota/getzone:
 *   get:
 *     summary: Get zones
 *     description: Retrieve zones from the database.
 *     tags:
 *       - OTA Employee Management
 *     security:
 *       - BearerAuth: []
 *     responses:
 *       200:
 *         description: Zones retrieved successfully.
 *         content:
 *           application/json:
 *             schema:
 *               type: array
 *               items:
 *                 type: object
 *                 properties:
 *                   id:
 *                     type: integer
 *                     description: The ID of the zone.
 *                   zone:
 *                     type: string
 *                     description: The name of the zone.
 *                   machine:
 *                     type: string
 *                     description: The machine associated with the zone.
 *       500:
 *         description: Internal Server Error.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: Failed to fetch zone data
 * @function
 * @name getZones
 * @memberof module:Routes/OTAEmployeeManagement
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with fetching zone data.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */

//get zone
app.get('/ota/getzone', authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    const query = 'SELECT * FROM geopos_machine';
    const result = await executeQuery(connection,query);
    res.json(result);
  } catch (error) {
    console.error('Error fetching zone data:', error);
    res.status(500).json({ error: 'Failed to fetch zone data' });
  } finally {
    if (connection) {
      connection.release();
      //console.log("Connection released");
    }
  }
});

/**
 * @swagger
 * /ota/getuserid/{id}:
 *   get:
 *     summary: Get user by entry ID
 *     description: Retrieve user information by entry ID from the database.
 *     tags:
 *       - OTA Employee Management
 *     security:
 *       - BearerAuth: []
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         description: Entry ID of the user.
 *         schema:
 *           type: integer
 *     responses:
 *       200:
 *         description: User information retrieved successfully.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 id:
 *                   type: integer
 *                   description: The ID of the user.
 *                 email:
 *                   type: string
 *                   description: The email of the user.
 *                 username:
 *                   type: string
 *                   description: The username of the user.
 *                 name:
 *                   type: string
 *                   description: The name of the user.
 *                 entryid:
 *                   type: integer
 *                   description: The entry ID of the user.
 *       404:
 *         description: User not found.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 message:
 *                   type: string
 *                   example: User not found
 *       500:
 *         description: Internal Server Error.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: Failed to fetch user data
 * @function
 * @name getUserByID
 * @memberof module:Routes/OTAEmployeeManagement
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {NotFoundError} Will throw an error if the user with the specified ID is not found.
 * @throws {InternalServerError} Will throw an error if there's an issue with fetching user data.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */

//get user id
app.get('/ota/getuserid/:id', authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    const id = req.params.id;
    const query = 'SELECT * FROM geopos_users WHERE entryid=?';
    const result = await executeQuery(connection,query, [id]);
    if (result.length > 0) {
      res.json(result[0]);
    } else {
      res.status(404).send("User not found");
    }
  } catch (error) {
    console.error('Error fetching user data:', error);
    res.status(500).json({ error: 'Failed to fetch user data' });
  } finally {
    if (connection) {
      connection.release();
      //console.log("Connection released");
    }
  }
});

/**
 * @swagger
 * /ota/getItems/{id}:
 *   get:
 *     summary: Get items by user ID
 *     description: Retrieve items assigned to a user by user ID from the database.
 *     tags:
 *       - OTA Employee Management
 *     security:
 *       - BearerAuth: []
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         description: ID of the user.
 *         schema:
 *           type: integer
 *     responses:
 *       200:
 *         description: Items retrieved successfully.
 *         content:
 *           application/json:
 *             schema:
 *               type: array
 *               items:
 *                 type: object
 *                 properties:
 *                   id:
 *                     type: integer
 *                     description: The ID of the item.
 *                   name_id:
 *                     type: integer
 *                     description: The ID of the user.
 *                   item_id:
 *                     type: integer
 *                     description: The ID of the item.
 *                   category_type:
 *                     type: string
 *                     description: The category type of the item.
 *       500:
 *         description: Internal Server Error.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: Failed to fetch items
 * @function
 * @name getItemsByUserID
 * @memberof module:Routes/OTAEmployeeManagement
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with fetching items.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
//get ota items
app.get('/ota/getItems/:id', authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();    
    const id = req.params.id;
    const query = 'SELECT * FROM operator_assign WHERE name_id=? AND category_type=?';
    const result = await executeQuery(connection,query, [id, 'BRAID']);
    res.json(result);
  } catch (error) {
    console.error('Error fetching items:', error);
    res.status(500).json({ error: 'Failed to fetch items' });
  } finally {
    if (connection) {
      connection.release();
      //console.log("Connection released");
    }
  }
});

/**
 * @swagger
 * /ota/add_zone:
 *   post:
 *     summary: Add or update zone for a user
 *     description: Add or update zone and machines for a user in the database.
 *     tags:
 *       - OTA Employee Management
 *     security:
 *       - BearerAuth: []
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             properties:
 *               id:
 *                 type: integer
 *                 description: The ID of the user.
 *               zone:
 *                 type: string
 *                 description: The zone to add or update.
 *               machiness:
 *                 type: string
 *                 description: The machines to add or update.
 *             required:
 *               - id
 *               - zone
 *               - machiness
 *     responses:
 *       200:
 *         description: Record inserted or updated successfully.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 message:
 *                   type: string
 *                   example: Record inserted successfully
 *       500:
 *         description: Internal Server Error.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: Internal Server Error
 * @function
 * @name addOrUpdateZoneForUser
 * @memberof module:Routes/OTAEmployeeManagement
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with adding or updating zone.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
//submit zone data
app.post("/ota/add_zone", authenticateJWT, async (req, res) => {   
  let connection;
  try {
    connection = await getPoolConnection(); 
    const id = req.body.id;
    const zone = req.body.zone;
    const machiness = req.body.machiness;

    const options = { timeZone: 'Africa/Lagos', day: 'numeric', month: 'numeric', year: 'numeric' };
    const currentTime = new Date().toLocaleString('en-US', options);
    const [date, month, year] = currentTime.split('/');
    const formattedDate = `${date.padStart(2, '0')}-${month.padStart(2, '0')}-${year}`;

    const rowcheck = `SELECT * FROM operator_assign WHERE zone=? AND name_id=? AND category_type='BRAID'`;
    const [rows] = await executeQuery(connection,rowcheck, [zone, id]);

    if (rows.length > 0) {
      await executeQuery(connection,
        'UPDATE operator_assign SET machine=? WHERE name_id=? AND zone=?',
        [machiness, id, zone]
      );
      res.status(200).json({ message: 'Record updated successfully' });
    } else {
      await executeQuery(connection,
        'INSERT INTO operator_assign (name_id, zone, machine, date, category_type) VALUES (?, ?, ?, ?, ?)',
        [id, zone, machiness, formattedDate, 'BRAID']
      );
      res.status(200).json({ message: 'Record inserted successfully' });
    }
  } catch (error) {
    console.error('Error adding zone:', error);
    res.status(500).json({ error: 'Internal Server Error' });
  } finally {
    if (connection) {
      connection.release();
      //console.log("Connection released");
    }
  }
});


/**
 * @swagger
 * /ota/item_zone_delete/{id}:
 *   delete:
 *     summary: Delete zone item by ID
 *     description: Delete zone item from the database by its ID.
 *     tags:
 *       - OTA Employee Management
 *     security:
 *       - BearerAuth: []
 *     parameters:
 *       - in: path
 *         name: id
 *         schema:
 *           type: integer
 *         required: true
 *         description: Numeric ID of the zone item to delete.
 *     responses:
 *       200:
 *         description: Data deleted successfully.
 *         content:
 *           text/plain:
 *             schema:
 *               type: string
 *               example: Data deleted successfully
 *       404:
 *         description: Record not found.
 *         content:
 *           text/plain:
 *             schema:
 *               type: string
 *               example: Record not found
 *       500:
 *         description: Internal Server Error.
 *         content:
 *           text/plain:
 *             schema:
 *               type: string
 *               example: Internal Server Error
 * @function
 * @name deleteZoneItemById
 * @memberof module:Routes/OTAEmployeeManagement
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {NotFoundError} Will throw an error if the record to delete is not found.
 * @throws {InternalServerError} Will throw an error if there's an issue with deleting the record.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
//ota operator item  Delete 
app.delete('/ota/item_zone_delete/:id', authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    const id = req.params.id;
    const result = await executeQuery(connection,'DELETE FROM operator_assign WHERE id = ?', id);
    if (result.affectedRows > 0) {
      res.status(200).send('Data deleted successfully');
    } else {
      res.status(404).send('Record not found');
    }
  } catch (error) {
    console.error('Error deleting record:', error);
    res.status(500).send('Internal Server Error');
  } finally {
    if (connection) {
      connection.release();
      //console.log("Connection released");
    }
  }
});

/**
 * @swagger
 * /ota/getSectionitem/{id}:
 *   get:
 *     summary: Get section item details for an operator
 *     description: Retrieve section item details assigned to an operator.
 *     tags:
 *       - OTA Employee Management
 *     security:
 *       - BearerAuth: []
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         description: The ID of the operator.
 *         schema:
 *           type: integer
 *     responses:
 *       200:
 *         description: Section item details retrieved successfully.
 *         content:
 *           application/json:
 *             schema:
 *               type: array
 *               items:
 *                 type: object
 *                 properties:
 *                   id:
 *                     type: integer
 *                     description: The ID of the section item.
 *                   section_name:
 *                     type: string
 *                     description: The name of the section.
 *                   other_property:
 *                     type: string
 *                     description: Other properties of the section item.
 *                   
 *       404:
 *         description: Operator not found or no section item details available.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 message:
 *                   type: string
 *                   example: Operator not found or no section item details available
 *       500:
 *         description: Internal Server Error.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 message:
 *                   type: string
 *                   example: Internal Server Error
 * @function
 * @name getSectionItemDetails
 * @memberof module:Routes/OTAEmployeeManagement
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with fetching section item details.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */

//get operator section data
app.get('/ota/getSectionitem/:id', authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    const operatorId = req.params.id;
    const query = `
      SELECT operator_assign.*, section.section_name
      FROM operator_assign
      LEFT JOIN section ON operator_assign.section = section.id
      WHERE operator_assign.name_id = ?
    `;
    const result = await executeQuery(connection,query, [operatorId]);
    res.json(result);
  } catch (error) {
    console.error('Error fetching data from MySQL:', error);
    res.status(500).json({ message: 'Internal Server Error' });
  } finally {
    if (connection) {
      connection.release();
      //console.log("Connection released");
    }
  }
});

/**
 * @swagger
 * /ota/getlinemaster:
 *   get:
 *     summary: Get line master data
 *     description: Retrieve line master data filtered by status.
 *     tags:
 *       - OTA Employee Management
 *     security:
 *       - BearerAuth: []
 *     responses:
 *       200:
 *         description: Line master data retrieved successfully.
 *         content:
 *           application/json:
 *             schema:
 *               type: array
 *               items:
 *                 type: object
 *                 properties:
 *                   id:
 *                     type: integer
 *                     description: The ID of the line.
 *                   name:
 *                     type: string
 *                     description: The name of the line.
 *                   status:
 *                     type: integer
 *                     description: The status of the line.
 *                   other_property:
 *                     type: string
 *                     description: Other properties of the line master data.
 *                   
 *       500:
 *         description: Internal Server Error.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 message:
 *                   type: string
 *                   example: Internal Server Error
 * @function
 * @name getLineMasterData
 * @memberof module:Routes/OTAEmployeeManagement
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with fetching line master data.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */

//get Line master
app.get('/ota/getlinemaster', authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    const result = await executeQuery(connection,'SELECT * FROM line_master WHERE status=?', ['1']);
    res.json(result);
  } catch (error) {
    console.error('Error fetching data from MySQL:', error);
    res.status(500).json({ message: 'Internal Server Error' });
  } finally {
    if (connection) {
      connection.release();
      //console.log("Connection released");
    }
  }
});

/**
 * @swagger
 * /ota/getSection:
 *   get:
 *     summary: Get section data
 *     description: Retrieve section data filtered by status.
 *     tags:
 *       - OTA Employee Management
 *     security:
 *       - BearerAuth: []
 *     responses:
 *       200:
 *         description: Section data retrieved successfully.
 *         content:
 *           application/json:
 *             schema:
 *               type: array
 *               items:
 *                 type: object
 *                 properties:
 *                   id:
 *                     type: integer
 *                     description: The ID of the section.
 *                   name:
 *                     type: string
 *                     description: The name of the section.
 *                   status:
 *                     type: integer
 *                     description: The status of the section.
 *                   other_property:
 *                     type: string
 *                     description: Other properties of the section data.
 *                   
 *       500:
 *         description: Internal Server Error.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 message:
 *                   type: string
 *                   example: Internal Server Error
 * @function
 * @name getSectionData
 * @memberof module:Routes/OTAEmployeeManagement
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with fetching section data.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */

//get Line master
app.get('/ota/getSection', authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    const result = await executeQuery(connection,'SELECT * FROM section WHERE status=?', ['1']);
    res.json(result);
  } catch (error) {
    console.error('Error fetching data from MySQL:', error);
    res.status(500).json({ message: 'Internal Server Error' });
  } finally {
    if (connection) {
      connection.release();
      //console.log("Connection released");
    }
  }
});


//submit section op  data
/**
 * @swagger
 * /ota/addSectionOp:
 *   post:
 *     summary: Add section operator assignment
 *     description: Add an operator assignment to a section with the specified shift and line.
 *     tags:
 *       - OTA Employee Management
 *     security:
 *       - BearerAuth: []
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             properties:
 *               id:
 *                 type: integer
 *                 description: The ID of the operator.
 *               shift:
 *                 type: string
 *                 description: The shift of the operator.
 *               line:
 *                 type: string
 *                 description: The line of the operator.
 *               section:
 *                 type: integer
 *                 description: The ID of the section to assign the operator to.
 *             required:
 *               - id
 *               - shift
 *               - line
 *               - section
 *     responses:
 *       200:
 *         description: Record inserted successfully or already assigned to the same operator or other.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 message:
 *                   type: string
 *                   example: Record inserted successfully
 *       404:
 *         description: Record not inserted.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 message:
 *                   type: string
 *                   example: Record not inserted
 *       500:
 *         description: Internal Server Error.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 message:
 *                   type: string
 *                   example: Internal Server Error
 * @function
 * @name addSectionOperatorAssignment
 * @memberof module:Routes/OTAEmployeeManagement
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with inserting the record.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */

app.post("/ota/addSectionOp", authenticateJWT, async (req, res) => {   
  let connection;
  try {
    connection = await getPoolConnection();
    const { id, shift, line, section } = req.body;

    const options = { timeZone: 'Africa/Lagos', day: 'numeric', month: 'numeric', year: 'numeric' };
    const currentTime = new Date().toLocaleString('en-US', options);
    const [date, month, year] = currentTime.split('/');
    const formattedDate = `${date.padStart(2, '0')}-${month.padStart(2, '0')}-${year}`;

    const rowcheck = `SELECT * FROM operator_assign WHERE section=? AND line=? AND shift=?`;
    const result = await executeQuery(connection,rowcheck, [section, line, shift]);

    if (result.length > 0) {
      res.status(200).json({ message: 'Already assigned to the same operator or other' });
    } else {
      const insertQuery = 'INSERT INTO operator_assign (name_id, section, line, shift, date, category_type) VALUES (?, ?, ?, ?, ?, ?)';
      const insertResult = await executeQuery(connection,insertQuery, [id, section, line, shift, formattedDate, 'NBRAID']);
      
      if (insertResult.affectedRows === 0) {
        res.status(404).json({ message: 'Record not inserted' });
      } else {
        res.status(200).json({ message: 'Record inserted successfully' });
      }
    }
  } catch (error) {
    console.error('Error inserting record:', error);
    res.status(500).json({ message: 'Internal Server Error' });
  } finally {
    if (connection) {
      connection.release();
      //console.log("Connection released");
    }
  }
});

/**
 * @swagger
 * /ota/delete_section_assign/{id}:
 *   delete:
 *     summary: Delete section assignment
 *     description: Delete an operator assignment from a section.
 *     tags:
 *       - OTA Employee Management
 *     security:
 *       - BearerAuth: []
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         description: ID of the operator assignment to delete.
 *         schema:
 *           type: integer
 *     responses:
 *       200:
 *         description: Data deleted successfully.
 *         content:
 *           text/plain:
 *             schema:
 *               type: string
 *               example: Data deleted successfully
 *       404:
 *         description: Record not found.
 *         content:
 *           text/plain:
 *             schema:
 *               type: string
 *               example: Record not found
 *       500:
 *         description: Internal Server Error.
 *         content:
 *           text/plain:
 *             schema:
 *               type: string
 *               example: Internal Server Error
 * @function
 * @name deleteSectionAssignment
 * @memberof module:Routes/OTAEmployeeManagement
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with deleting the record.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */

//assign section Delete 
app.delete('/ota/delete_section_assign/:id', authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    const id = req.params.id;
    const deleteQuery = 'DELETE FROM operator_assign WHERE id = ?';
    const result = await executeQuery(connection,deleteQuery, [id]);

    if (result.affectedRows === 0) {
      res.status(404).send('Record not found');
    } else {
      res.status(200).send('Data deleted successfully');
    }
  } catch (error) {
    console.error('Error deleting record:', error);
    res.status(500).send('Internal Server Error');
  } finally {
    if (connection) {
      connection.release();
      //console.log("Connection released");
    }
  }
});

/**
 * @swagger
 * /ota/get_users:
 *   get:
 *     summary: Get OTA users
 *     description: Retrieve OTA users with specific criteria.
 *     tags:
 *       - OTA Employee Management
 *     security:
 *       - BearerAuth: []
 *     responses:
 *       200:
 *         description: Successful operation.
 *         content:
 *           application/json:
 *             schema:
 *               type: array
 *               items:
 *                 $ref: '#/components/schemas/User'
 *       500:
 *         description: Internal Server Error.
 *         content:
 *           text/plain:
 *             schema:
 *               type: string
 *               example: Internal Server Error
 * @function
 * @name getOTAUsers
 * @memberof module:Routes/OTAEmployeeManagement
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with executing the MySQL query.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */

//Get all users
app.get('/ota/get_users', authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    const query = `
      SELECT * 
      FROM geopos_users 
      WHERE roleid = ? AND production_type = ? AND banned = ? AND category_type = ?
    `;
    const params = ['3', 'ota', '0', 'NBRAID'];
    const result = await executeQuery(connection,query, params);
    res.send(result);
  } catch (error) {
    console.error('Error executing MySQL query:', error);
    res.status(500).send('Internal Server Error');
  } finally {
    if (connection) {
      connection.release();
      //console.log("Connection released");
    }
  }
});

/**
 * @swagger
 * /ota/assign_check:
 *   get:
 *     summary: Check assignment status
 *     description: Retrieve assignment status based on provided criteria.
 *     tags:
 *       - OTA Employee Management
 *     security:
 *       - BearerAuth: []
 *     parameters:
 *       - in: query
 *         name: where
 *         schema:
 *           type: string
 *         description: The conditions to filter the assignment data.
 *     responses:
 *       200:
 *         description: Successful operation.
 *         content:
 *           application/json:
 *             schema:
 *               type: array
 *               items:
 *                 $ref: '#/components/schemas/OperatorAssignment'
 *       500:
 *         description: Internal Server Error.
 *         content:
 *           text/plain:
 *             schema:
 *               type: string
 *               example: Internal Server Error
 * @function
 * @name checkAssignmentStatus
 * @memberof module:Routes/OTAEmployeeManagement
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with executing the MySQL query.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */

 //Operator section exit check
 app.get('/ota/assign_check', authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    const { where } = req.query;
    const result = await executeQuery(connection,`SELECT * FROM operator_assign WHERE ${where}`);
    res.send(result);
  } catch (error) {
    console.error(error);
    res.status(500).send('Internal Server Error');
  } finally {
    if (connection) {
      connection.release();
      //console.log("Connection released");
    }
  }
});

/**
 * @swagger
 * /ota/update_assign_operator/{id}:
 *   get:
 *     summary: Update assigned operator
 *     description: Update the assigned operator based on provided criteria.
 *     tags:
 *       - OTA Employee Management
 *     security:
 *       - BearerAuth: []
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: integer
 *         description: The ID of the operator to be updated.
 *       - in: query
 *         name: where
 *         schema:
 *           type: string
 *         description: The conditions to filter the assignment data.
 *     responses:
 *       200:
 *         description: Successful operation.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 message:
 *                   type: string
 *                   description: A message indicating the success of the operation.
 *                   example: Record Updated successfully
 *       404:
 *         description: Record not found.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 message:
 *                   type: string
 *                   description: A message indicating that the record was not updated.
 *                   example: Record not Updated
 *       500:
 *         description: Internal Server Error.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 message:
 *                   type: string
 *                   description: A message indicating an internal server error.
 *                   example: Error update record
 * @function
 * @name updateAssignedOperator
 * @memberof module:Routes/OTAEmployeeManagement
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with executing the MySQL query.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */

//update assign operator
app.get('/ota/update_assign_operator/:id', authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    const { where } = req.query;
    const userid = req.params.id;
    const result = await executeQuery(connection,`UPDATE operator_assign SET name_id = ${userid} WHERE ${where}`);
    if (result.affectedRows === 0) {
      res.status(404).json({ message: 'Record not Updated' });
    } else {
      res.status(200).json({ message: 'Record Updated successfully' });
    }
  } catch (error) {
    console.error(error);
    res.status(500).json({ message: 'Error update record' });
  } finally {
    if (connection) {
      connection.release();
      //console.log("Connection released");
    }
  }
});

/**
 * @swagger
 * /ota/get_role/{id}:
 *   get:
 *     summary: Get role by ID
 *     description: Retrieve role information by its ID.
 *     tags:
 *       - OTA Employee Management
 *     security:
 *       - BearerAuth: []
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: integer
 *         description: The ID of the role to retrieve.
 *     responses:
 *       200:
 *         description: Successful operation.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 id:
 *                   type: integer
 *                   description: The ID of the role.
 *                   example: 1
 *                 name:
 *                   type: string
 *                   description: The name of the role.
 *                   example: Operator
 *       500:
 *         description: Internal Server Error.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 message:
 *                   type: string
 *                   description: A message indicating an internal server error.
 *                   example: Internal Server Error
 * @function
 * @name getRoleByID
 * @memberof module:Routes/OTAEmployeeManagement
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with executing the MySQL query.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */

//get role id
app.get('/ota/get_role/:id', authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    const id = req.params.id;
    const result = await executeQuery(connection,'SELECT * FROM geopos_emptype WHERE id = ?', id);
    res.send(result);
  } catch (error) {
    console.error(error);
    res.status(500).send('Internal Server Error');
  } finally {
    if (connection) {
      connection.release();
      //console.log("Connection released");
    }
  }
});

/**
 * @swagger
 * /ota/update_operator:
 *   post:
 *     summary: Update operator details
 *     description: Update details of an OTA operator including name, work type, and shift.
 *     tags:
 *       - OTA Employee Management
 *     security:
 *       - BearerAuth: []
 *     requestBody:
 *       description: Object containing operator details to be updated
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             properties:
 *               id:
 *                 type: integer
 *                 description: The ID of the operator.
 *                 example: 1
 *               entryid:
 *                 type: string
 *                 description: The entry ID of the operator.
 *                 example: ABC123
 *               name:
 *                 type: string
 *                 description: The name of the operator.
 *                 example: John Doe
 *               worktyp:
 *                 type: string
 *                 description: The work type of the operator.
 *                 example: Type A
 *               shift:
 *                 type: string
 *                 description: The shift of the operator.
 *                 example: Night Shift
 *     responses:
 *       200:
 *         description: Successful operation.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 message:
 *                   type: string
 *                   description: A message indicating the success of the operation.
 *                   example: Record Updated successfully
 *       404:
 *         description: Record not found.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 message:
 *                   type: string
 *                   description: A message indicating that the record was not found.
 *                   example: Record not Updated
 *       500:
 *         description: Internal Server Error.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 message:
 *                   type: string
 *                   description: A message indicating an internal server error.
 *                   example: Internal Server Error
 * @function
 * @name updateOperatorDetails
 * @memberof module:Routes/OTAEmployeeManagement
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with executing the MySQL query.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */

//Update operator
app.post('/ota/update_operator', authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    const { name, worktyp, shift, id, entryid } = req.body;
    // Update employees_ota table
    const updateEmployeeQuery = 'UPDATE employees_ota SET name=?, workertype=?, shift=? WHERE id=?';
    const updateEmployeeResult = await executeQuery(connection,updateEmployeeQuery, [name, worktyp, shift, id]);

    if (updateEmployeeResult.affectedRows === 0) {
      return res.status(404).json({ message: 'Record not Updated' });
    }

    // Update geopos_users table
    const updateGeoposUserQuery = 'UPDATE geopos_users SET name=? WHERE entryid=?';
    const updateGeoposUserResult = await executeQuery(connection,updateGeoposUserQuery, [name, entryid]);

    if (updateGeoposUserResult.affectedRows === 0) {
      return res.status(404).json({ message: 'User record not updated' });
    }

    // Both records updated successfully
    res.status(200).json({ message: 'Record Updated successfully' });

  } catch (error) {
    console.error(error);
    res.status(500).json({ message: 'Internal Server Error' });
  } finally {
    if (connection) {
      connection.release();
      //console.log("Connection released");
    }
  } 
});

/**
 * @swagger
 * /ota/operator_data_username/{id}:
 *   get:
 *     summary: Get operator data by ID
 *     description: Retrieve operator data by their ID, including username.
 *     tags:
 *       - OTA Employee Management
 *     security:
 *       - BearerAuth: []
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         description: The ID of the operator.
 *         schema:
 *           type: integer
 *     responses:
 *       200:
 *         description: Successful operation.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 id:
 *                   type: integer
 *                   description: The ID of the operator.
 *                   example: 1
 *                 username:
 *                   type: string
 *                   description: The username of the operator.
 *                   example: john_doe
 *                 
 *       500:
 *         description: Internal Server Error.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 message:
 *                   type: string
 *                   description: A message indicating an internal server error.
 *                   example: Internal Server Error
 * @function
 * @name getOperatorDataById
 * @memberof module:Routes/OTAEmployeeManagement
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with executing the MySQL query.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */

//Get operator username single
app.get('/ota/operator_data_username/:id', authenticateJWT, async (req, res) => {
  let connection
  try {
    connection = await getPoolConnection();
    const id = req.params.id;
    console.log('id:', id);
    
    const query = `
      SELECT * 
      FROM employees_ota 
      JOIN geopos_users ON employees_ota.entryid = geopos_users.entryid 
      WHERE employees_ota.id = ?
    `;
    const result = await executeQuery(connection,query, [id]);
    
    res.json(result); // Sending the full result as JSON
  } catch (error) {
    console.error(error);
    res.status(500).send("Internal Server Error");
  } finally {
    if (connection) {
      connection.release();
      //console.log("Connection released");
    }
  } 
});

/**
 * @swagger
 * /ota/change_password:
 *   post:
 *     summary: Change user password
 *     description: Change the password of a user.
 *     tags:
 *       - OTA Employee Management
 *     security:
 *       - BearerAuth: []
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             properties:
 *               id:
 *                 type: integer
 *                 description: The ID of the user whose password will be changed.
 *                 example: 1
 *               confirmPassword:
 *                 type: string
 *                 description: The new password for the user.
 *                 example: new_password123
 *     responses:
 *       200:
 *         description: Successful operation.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 message:
 *                   type: string
 *                   description: A message indicating that the password has been changed successfully.
 *                   example: Record updated successfully
 *       404:
 *         description: Record not found.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 message:
 *                   type: string
 *                   description: A message indicating that the record was not found.
 *                   example: Record not found
 *       500:
 *         description: Internal Server Error.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 message:
 *                   type: string
 *                   description: A message indicating an internal server error.
 *                   example: Error hashing password
 * @function
 * @name changePassword
 * @memberof module:Routes/OTAEmployeeManagement
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with executing the MySQL query or hashing the password.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */

//Operator change password
app.post('/ota/change_password', authenticateJWT, async (req, res) => {
  const newpassword = req.body.confirmPassword;
  const uid = req.body.id;
  console.log("uid", uid);
  const userId = `${uid}`; // Converts the integer to a string using template literals
  let connection;
  try {
    connection = await getPoolConnection();
    const hashedPassword = hashPassword(newpassword, userId);
    console.log("userId :", userId);
    console.log("hashedPassword :", hashedPassword);
    //const entryid = req.body.entryid;
    const query = `UPDATE geopos_users SET pass = ? WHERE id = ?`;
    console.log('Update query:', query); // Log the generated SQL query
    const result = await executeQuery(connection,query, [hashedPassword, uid]);
    if (result.affectedRows === 0) {
      res.status(404).json({ message: 'Record not updated' });
    } else {
      res.status(200).json({ message: 'Record updated successfully' });
    }
  } catch (error) {
    console.error('Error:', error);
    res.status(500).json({ message: 'Error hashing password' });
  } finally {
    if (connection) {
      connection.release();
      //console.log("Connection released");
    }
  }
});

/**
 * @swagger
 * /ota/operator_delete/{id}:
 *   delete:
 *     summary: Delete operator and related records
 *     description: Deletes an operator and updates related records such as banning the operator and removing assignments.
 *     tags:
 *       - OTA Employee Management
 *     security:
 *       - BearerAuth: []
 *     parameters:
 *       - in: path
 *         name: id
 *         schema:
 *           type: integer
 *         required: true
 *         description: The ID of the operator to delete.
 *     responses:
 *       200:
 *         description: Successful operation.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 message:
 *                   type: string
 *                   description: A message indicating that the operator was deleted and related records were updated successfully.
 *                   example: Operator deleted and related records updated successfully
 *       404:
 *         description: Operator not found.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   description: A message indicating that the operator was not found.
 *                   example: Operator not found
 *       500:
 *         description: Internal Server Error.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 message:
 *                   type: string
 *                   description: A message indicating an internal server error.
 *                   example: Internal server error
 * @function
 * @name deleteOperator
 * @memberof module:Routes/OTAEmployeeManagement
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with executing the MySQL queries.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */

// Delete operator ota
app.delete('/ota/operator_delete/:id', authenticateJWT, async (req, res) => {
  const id = req.params.id; // ID will be a string here
  const selectQuery = `
    SELECT geopos_users.id AS userId
    FROM geopos_users
    LEFT JOIN employees_ota ON geopos_users.entryid = employees_ota.entryid
    WHERE employees_ota.id = ?
  `;
  let connection;
  try {
    connection = await getPoolConnection();   
    // Get the user ID associated with the operator from the geopos_users table
    const result1 = await executeQuery(connection,selectQuery, [id]);

    if (result1.length === 0) {
      return res.status(404).json({ error: 'Operator not found' });
    }

    const userId = result1[0].userId;

    // Update the 'banned' column in employees_ota table
    const updateOtaQuery = 'UPDATE employees_ota SET banned = ? WHERE id = ?';
    await executeQuery(connection,updateOtaQuery, [1, id]);

    // Update the 'banned' column in geopos_users table
    const updateGeoposQuery = 'UPDATE geopos_users SET banned = ? WHERE id = ?';
    await executeQuery(connection,updateGeoposQuery, [1, userId]);

    // Delete related records from operator_assign table
    const deleteAssignQuery = 'DELETE FROM operator_assign WHERE name_id = ?';
    await executeQuery(connection,deleteAssignQuery, [userId]);

    // All operations completed successfully
    res.status(200).json({ message: 'Operator deleted and related records updated successfully' });

  } catch (error) {
    console.error("Error deleting operator:", error);
    res.status(500).send('Internal server error');
  } finally {
    if (connection) {
      connection.release();
      //console.log("Connection released");
    }
  }
});

/**
 * @swagger
 * /ota/convert/{id}:
 *   delete:
 *     summary: Convert operator to worker
 *     description: Converts an operator to a worker by updating role IDs and banning the operator.
 *     tags:
 *       - OTA Employee Management
 *     security:
 *       - BearerAuth: []
 *     parameters:
 *       - in: path
 *         name: id
 *         schema:
 *           type: integer
 *         required: true
 *         description: The ID of the operator to convert.
 *     responses:
 *       200:
 *         description: Successful operation.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 message:
 *                   type: string
 *                   description: A message indicating that the operator was successfully converted to a worker.
 *                   example: Operator successfully converted to Worker
 *       404:
 *         description: Operator not found.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   description: A message indicating that the operator was not found.
 *                   example: Operator not found
 *       500:
 *         description: Internal Server Error.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   description: A message indicating an internal server error.
 *                   example: Internal server error
 * @function
 * @name convertOperatorToWorker
 * @memberof module:Routes/OTAEmployeeManagement
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with executing the MySQL queries.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */

// Convert operator to worker
app.delete('/ota/convert/:id', authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    const id = req.params.id; // ID will be a string here
    const selectQuery = `
      SELECT geopos_users.*, employees_ota.id as idd
      FROM geopos_users
      LEFT JOIN employees_ota ON geopos_users.entryid = employees_ota.entryid
      WHERE employees_ota.id = ?
    `;

    // Get the user ID associated with the operator from the geopos_users table
    const result1 = await dbQexecuteQueryuery(selectQuery, id);

    if (result1.length === 0) {
      return res.status(404).json({ error: 'Operator not found' });
    }

    const userId = result1[0].id;

    // Update the 'banned' column in employees_ota table
    const updateOtaQuery = 'UPDATE employees_ota SET roleid = ? WHERE id = ?';
    await executeQuery(connection,updateOtaQuery, [1, id]);

    // Update the 'banned' column in geopos_users table
    const updateGeoposQuery = 'UPDATE geopos_users SET banned = ?, roleid = ? WHERE id = ?';
    await executeQuery(connection,updateGeoposQuery, [1, 1, userId]);

    // Delete related records from operator_assign table
    const deleteAssignQuery = 'DELETE FROM operator_assign WHERE name_id = ?';
    await executeQuery(connection,deleteAssignQuery, userId);

    // All operations completed successfully
    res.status(200).json({ message: 'Operator successfully converted to Worker' });
  } catch (error) {
    console.error(error);
    res.status(500).json({ error: 'Internal server error' });
  } finally {
    if (connection) {
      connection.release();
      //console.log("Connection released");
    }
  }
});


/**
 * @swagger
 * /ota/get_operator_assign_list:
 *   get:
 *     summary: Get operator assignment list
 *     description: Retrieves a list of operator assignments along with relevant details.
 *     tags:
 *       - OTA Employee Management
 *     security:
 *       - BearerAuth: []
 *     responses:
 *       200:
 *         description: Successful operation.
 *         content:
 *           application/json:
 *             schema:
 *               type: array
 *               items:
 *                 type: object
 *                 properties:
 *                   id:
 *                     type: integer
 *                     description: The ID of the operator assignment.
 *                   name_id:
 *                     type: integer
 *                     description: The ID of the operator.
 *                   section:
 *                     type: integer
 *                     description: The ID of the section where the operator is assigned.
 *                   line:
 *                     type: integer
 *                     description: The ID of the line where the operator is assigned.
 *                   shift:
 *                     type: string
 *                     description: The shift assigned to the operator.
 *                   date:
 *                     type: string
 *                     format: date
 *                     description: The date of the assignment.
 *                   category_type:
 *                     type: string
 *                     description: The category type of the assignment.
 *                   entryid:
 *                     type: integer
 *                     description: The entry ID of the operator.
 *                   roleid:
 *                     type: integer
 *                     description: The role ID of the operator.
 *                   name:
 *                     type: string
 *                     description: The name of the operator.
 *                   section_name:
 *                     type: string
 *                     description: The name of the section where the operator is assigned.
 *       500:
 *         description: Internal Server Error.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   description: A message indicating an internal server error.
 *                   example: Error fetching operator assignments
 * @function
 * @name getOperatorAssignList
 * @memberof module:Routes/OTAEmployeeManagement
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with executing the MySQL query.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */

//get all assign worker list
app.get('/ota/get_operator_assign_list', authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    const query = `SELECT operator_assign.*, geopos_users.entryid, geopos_users.roleid, geopos_users.name, section.section_name
                   FROM operator_assign
                   LEFT JOIN geopos_users ON operator_assign.name_id = geopos_users.id
                   LEFT JOIN section ON operator_assign.section = section.id
                   WHERE operator_assign.category_type = ?`;

    const result = await executeQuery(connection,query, ['BRAID']);
    res.send(result);
  } catch (error) {
    console.error(error);
    res.status(500).send('Error fetching operator assignments');
  } finally {
    if (connection) {
      connection.release();
      //console.log("Connection released");
    }
  }
});

/**
 * @swagger
 * /ota/delete_assign_list/{id}:
 *   delete:
 *     summary: Delete operator assignment
 *     description: Deletes an operator assignment by ID.
 *     tags:
 *       - OTA Employee Management
 *     security:
 *       - BearerAuth: []
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         description: ID of the operator assignment to delete.
 *         schema:
 *           type: integer
 *     responses:
 *       200:
 *         description: Successful deletion.
 *         content:
 *           text/plain:
 *             schema:
 *               type: string
 *               example: Delete successfully
 *       404:
 *         description: Operator assignment not found.
 *         content:
 *           text/plain:
 *             schema:
 *               type: string
 *               example: Not Deleted
 *       500:
 *         description: Internal Server Error.
 *         content:
 *           text/plain:
 *             schema:
 *               type: string
 *               example: Error deleting record
 * @function
 * @name deleteOperatorAssignList
 * @memberof module:Routes/OTAEmployeeManagement
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with executing the MySQL query.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */

//Delete assign braid and nonbraid list
app.delete('/ota/delete_assign_list/:id', authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    const id = req.params.id;
    const result = await executeQuery(connection,'DELETE FROM operator_assign WHERE id = ?', [id]);
    
    if (result.affectedRows === 0) {
      res.status(404).send('Not Deleted');
    } else {
      res.status(200).send('Delete successfully');
    }
  } catch (error) {
    console.error(error);
    res.status(500).send('Error deleting record');
  } finally {
    if (connection) {
      connection.release();
      //console.log("Connection released");
    }
  }
});
/**
 * @swagger
 * /ota/get_operator_nbraid_assign_list:
 *   get:
 *     summary: Get operator assignments for NBRAID
 *     description: Retrieves operator assignments for NBRAID category type.
 *     tags:
 *       - OTA Employee Management
 *     security:
 *       - BearerAuth: []
 *     responses:
 *       200:
 *         description: Successfully retrieved operator assignments.
 *         content:
 *           application/json:
 *             schema:
 *               type: array
 *               items:
 *                 $ref: '#/components/schemas/OperatorAssign'
 *       500:
 *         description: Internal Server Error.
 *         content:
 *           text/plain:
 *             schema:
 *               type: string
 *               example: Error fetching operator assignments
 * components:
 *   schemas:
 *     OperatorAssign:
 *       type: object
 *       properties:
 *         id:
 *           type: integer
 *           description: The ID of the operator assignment.
 *         entryid:
 *           type: string
 *           description: The entry ID of the associated user.
 *         roleid:
 *           type: integer
 *           description: The role ID of the associated user.
 *         name:
 *           type: string
 *           description: The name of the associated user.
 *         section_name:
 *           type: string
 *           description: The name of the section assigned.
 *       required:
 *         - id
 *         - entryid
 *         - roleid
 *         - name
 *         - section_name
 * @function
 * @name getOperatorNBRAIDAssignList
 * @memberof module:Routes/OTAEmployeeManagement
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with executing the MySQL query.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
//get all assign worker list nonbraid
app.get('/ota/get_operator_nbraid_assign_list', authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    const query = `
      SELECT operator_assign.*, geopos_users.entryid, geopos_users.roleid, geopos_users.name, section.section_name
      FROM operator_assign
      LEFT JOIN geopos_users ON operator_assign.name_id = geopos_users.id
      LEFT JOIN section ON operator_assign.section = section.id
      WHERE operator_assign.category_type = ?`;

    const result = await executeQuery(connection,query, ['NBRAID']);
    res.send(result);
  } catch (error) {
    console.error(error);
    res.status(500).send('Error fetching operator assignments');
  } finally {
    if (connection) {
      connection.release();
      //console.log("Connection released");
    }
  }
});

/**
 * @swagger
 * /ota/delete_assign_list/{id}:
 *   delete:
 *     summary: Delete an operator assignment
 *     description: Deletes an operator assignment by its ID.
 *     tags:
 *       - OTA Employee Management
 *     security:
 *       - BearerAuth: []
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: integer
 *         description: The ID of the operator assignment to delete.
 *     responses:
 *       200:
 *         description: Successfully deleted the operator assignment.
 *         content:
 *           text/plain:
 *             schema:
 *               type: string
 *               example: Delete successfully
 *       404:
 *         description: Operator assignment not found.
 *         content:
 *           text/plain:
 *             schema:
 *               type: string
 *               example: Not Deleted
 *       500:
 *         description: Internal Server Error.
 *         content:
 *           text/plain:
 *             schema:
 *               type: string
 *               example: Error deleting record
 * @function
 * @name deleteAssignList
 * @memberof module:Routes/OTAEmployeeManagement
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with executing the MySQL query.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
//Delete assign braid and nonbraid list
app.delete('/ota/delete_assign_list/:id', authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    const id = req.params.id;
    const result = await executeQuery(connection,'DELETE FROM operator_assign WHERE id = ?', [id]);

    if (result.affectedRows === 0) {
      res.status(404).send('Not Deleted');
    } else {
      res.status(200).send('Delete successfully');
    }
  } catch (error) {
    console.error(error);
    res.status(500).send('Error deleting record');
  } finally {
    if (connection) {
      connection.release();
      //console.log("Connection released");
    }
  }
});

/**
 * @swagger
 * /ota/getEmployees:
 *   get:
 *     summary: Retrieve list of employees
 *     description: Retrieves a list of employees with the role ID of 3 and not banned.
 *     tags:
 *       - OTA Employee Management
 *     security:
 *       - BearerAuth: []
 *     responses:
 *       200:
 *         description: Successfully retrieved list of employees.
 *         content:
 *           application/json:
 *             schema:
 *               type: array
 *               items:
 *                 type: object
 *                 properties:
 *                   id:
 *                     type: integer
 *                     example: 1
 *                   name:
 *                     type: string
 *                     example: John Doe
 *                   roleid:
 *                     type: integer
 *                     example: 3
 *                   role:
 *                     type: string
 *                     example: Operator
 *                   banned:
 *                     type: integer
 *                     example: 0
 *       500:
 *         description: Internal Server Error.
 *         content:
 *           text/plain:
 *             schema:
 *               type: string
 *               example: Internal Server Error
 * @function
 * @name getEmployees
 * @memberof module:Routes/OTAEmployeeManagement
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with executing the MySQL query.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
// Get change shift operator data
app.get('/ota/getEmployees', authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    const query = `
      SELECT employees_ota.*, geopos_emptype.name as role
      FROM employees_ota
      LEFT JOIN geopos_emptype ON employees_ota.roleid = geopos_emptype.id
      WHERE employees_ota.roleid = ? AND employees_ota.banned = ?`;
    
    const result = await executeQuery(connection,query, ['3', '0']);
    res.send(result);
  } catch (error) {
    console.error(error);
    res.status(500).send('Internal Server Error');
  }  finally {
    if (connection) {
      connection.release();
      //console.log("Connection released");
    }
  }
});

/**
 * @swagger
 * /ota/changeshift_entryid:
 *   post:
 *     summary: Retrieve entry IDs for specified employee IDs
 *     description: Retrieves the entry IDs from the employees_ota table for the given employee IDs.
 *     tags:
 *       - OTA Shift Management
 *     security:
 *       - BearerAuth: []
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             properties:
 *               entryIds:
 *                 type: array
 *                 items:
 *                   type: integer
 *                 example: [1, 2, 3]
 *     responses:
 *       200:
 *         description: Successfully retrieved entry IDs.
 *         content:
 *           application/json:
 *             schema:
 *               type: array
 *               items:
 *                 type: object
 *                 properties:
 *                   entryid:
 *                     type: integer
 *                     example: 123
 *       500:
 *         description: Internal Server Error.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: Internal Server Error
 * @function
 * @name changeshift_entryid
 * @memberof module:Routes/OTAShiftManagement
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with executing the MySQL query.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
//get changez shift employee entryid
app.post('/ota/changeshift_entryid', authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    const { entryIds } = req.body;
    const entryIdsArray = Array.isArray(entryIds) ? entryIds : [entryIds];
    
    // Use the IN operator in the SQL query to check for multiple entryid values
    const query = 'SELECT entryid FROM employees_ota WHERE id IN (?)';
    
    const results = await executeQuery(connection,query, [entryIdsArray]);
    res.json(results);
  } catch (error) {
    console.error(error);
    res.status(500).json({ error: 'Internal Server Error' });
  } finally {
    if (connection) {
      connection.release();
      //console.log("Connection released");
    }
  }
});

/**
 * @swagger
 * /ota/update_shift:
 *   post:
 *     summary: Update shift for multiple employees
 *     description: Updates the shift for multiple employees based on provided entry IDs.
 *     tags:
 *       - OTA Shift Management
 *     security:
 *       - BearerAuth: []
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             properties:
 *               shift:
 *                 type: string
 *                 example: "morning"
 *               entryIds:
 *                 type: string
 *                 example: "1,2,3"
 *     responses:
 *       200:
 *         description: Details updated successfully.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 status:
 *                   type: string
 *                   example: Success
 *                 message:
 *                   type: string
 *                   example: Details updated successfully.
 *       400:
 *         description: Shift and entryIds are required.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 status:
 *                   type: string
 *                   example: Error
 *                 message:
 *                   type: string
 *                   example: Shift and entryIds are required.
 *       500:
 *         description: Internal Server Error.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 status:
 *                   type: string
 *                   example: Error
 *                 message:
 *                   type: string
 *                   example: Internal Server Error
 * @function
 * @name update_shift
 * @memberof module:Routes/OTAShiftManagement
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with executing the MySQL query.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */

// update shift operator
app.post('/ota/update_shift', authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    const { shift, entryIds } = req.body;
    
    if (!shift || !entryIds) {
      return res.status(400).json({ status: 'Error', message: 'Shift and entryIds are required.' });
    }

    const entryIdsArray = entryIds.split(',');

    // Query to check if the employee with the given entryId exists
    const checkQuery = 'SELECT id FROM employees_ota WHERE id = ? ';

    // Query to update data for each entryId
    const updateQuery = 'UPDATE employees_ota SET shift = ? WHERE id = ?';

    // Counter to keep track of processed entries
    let processedCount = 0;

    for (const entryId of entryIdsArray) {
      const [checkResult] = await executeQuery(connection,checkQuery, [entryId]);

      if (checkResult) {
        // Employee exists, update the data
        await executeQuery(connection,updateQuery, [shift, entryId]);
        processedCount++;
        console.log(`Data updated for entryId: ${entryId}`);
      } else {
        // Employee does not exist, skip the update for this entryId
        processedCount++;
        console.log(`Employee not found for entryId: ${entryId}`);
      }
    }

    res.json({ status: 'Success', message: 'Details updated successfully.' });
  } catch (error) {
    console.error('Error updating data:', error);
    res.status(500).json({ status: 'Error', message: 'Internal Server Error' });
  } finally {
    if (connection) {
      connection.release();
      //console.log("Connection released");
    }
  }
});

/**
 * @swagger
 * /ota/get_employeess:
 *   get:
 *     summary: Get active Braid employees excluding specific roles
 *     description: Retrieves a list of active Braid employees from the database excluding those with role IDs 3 and 5.
 *     tags:
 *       - OTA Employee Management
 *     security:
 *       - BearerAuth: []
 *     responses:
 *       200:
 *         description: Successfully retrieved the list of employees.
 *         content:
 *           application/json:
 *             schema:
 *               type: array
 *               items:
 *                 type: object
 *                 properties:
 *                   id:
 *                     type: integer
 *                     example: 1
 *                   name:
 *                     type: string
 *                     example: John Doe
 *                   section_id:
 *                     type: integer
 *                     example: 1
 *                   roleid:
 *                     type: integer
 *                     example: 4
 *                   passive_type:
 *                     type: string
 *                     example: ACT
 *                   category_type:
 *                     type: string
 *                     example: BRAID
 *                   section_name:
 *                     type: string
 *                     example: Section A
 *                   role:
 *                     type: string
 *                     example: Operator
 *       500:
 *         description: Error retrieving records.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 message:
 *                   type: string
 *                   example: Error retrieving records
 * @function
 * @name get_employeess
 * @memberof module:Routes/OTAEmployeeManagement
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with executing the MySQL query.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */

//BRAID Employee Defulte data search
app.get('/ota/get_employeess', authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection(); 
    const query = `
      SELECT employees_ota.*, section.section_name, geopos_emptype.name as role
      FROM employees_ota
      LEFT JOIN geopos_emptype ON employees_ota.roleid = geopos_emptype.id
      LEFT JOIN section ON employees_ota.section_id = section.id
      WHERE (employees_ota.roleid != '3' AND employees_ota.roleid != '5')
        AND employees_ota.passive_type = 'ACT'
        AND employees_ota.category_type = 'BRAID';
    `;

    const result = await executeQuery(connection,query);
    res.json(result);
  } catch (error) {
    console.error(error);
    res.status(500).json({ message: 'Error retrieving records' });
  } finally {
    if (connection) {
      connection.release();
      //console.log("Connection released");
    }
  }
});

/**
 * @swagger
 * /ota/get_employees:
 *   get:
 *     summary: Get employees based on a dynamic WHERE clause
 *     description: Retrieves a list of employees from the database based on a dynamically provided WHERE clause.
 *     tags:
 *       - OTA Employee Management
 *     security:
 *       - BearerAuth: []
 *     parameters:
 *       - in: query
 *         name: where
 *         schema:
 *           type: string
 *         required: true
 *         description: The dynamic WHERE clause to filter the employees.
 *         example: roleid != '3' AND roleid != '5' AND passive_type = 'ACT' AND category_type = 'BRAID'
 *     responses:
 *       200:
 *         description: Successfully retrieved the list of employees.
 *         content:
 *           application/json:
 *             schema:
 *               type: array
 *               items:
 *                 type: object
 *                 properties:
 *                   id:
 *                     type: integer
 *                     example: 1
 *                   name:
 *                     type: string
 *                     example: John Doe
 *                   section_id:
 *                     type: integer
 *                     example: 1
 *                   roleid:
 *                     type: integer
 *                     example: 4
 *                   passive_type:
 *                     type: string
 *                     example: ACT
 *                   category_type:
 *                     type: string
 *                     example: BRAID
 *                   section_name:
 *                     type: string
 *                     example: Section A
 *                   role:
 *                     type: string
 *                     example: Operator
 *       500:
 *         description: Error retrieving records.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 message:
 *                   type: string
 *                   example: Error retrieving records
 * @function
 * @name get_employees
 * @memberof module:Routes/OTAEmployeeManagement
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with executing the MySQL query.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */

//BRAID Employee filter data search
app.get('/ota/get_employees', authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    const { where } = req.query;

    let query = `
      SELECT employees_ota.*, section.section_name,geopos_emptype.name as role
      FROM employees_ota
      LEFT JOIN geopos_emptype ON employees_ota.roleid = geopos_emptype.id
      LEFT JOIN section ON employees_ota.section_id = section.id
      WHERE ${where}
    `;

    const result = await executeQuery(connection,query);
    res.json(result);
  } catch (error) {
    console.error(error);
    res.status(500).json({ message: 'Error retrieving records' });
  } finally {
    if (connection) {
      connection.release();
      //console.log("Connection released");
    }
  }
});

/**
 * @swagger
 * /ota/changeEmpToOp:
 *   post:
 *     summary: Update employee to operator.
 *     description: Update employee details to operator details in the database.
 *     tags:
 *       - OTA
 *     security:
 *       - BearerAuth: []
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             properties:
 *               entryid:
 *                 type: string
 *                 description: The ID of the employee entry.
 *               unm:
 *                 type: string
 *                 description: The username of the employee.
 *               password:
 *                 type: string
 *                 description: The password of the employee.
 *               rlid:
 *                 type: string
 *                 description: The role ID of the employee.
 *               name:
 *                 type: string
 *                 description: The name of the employee.
 *               workertype:
 *                 type: string
 *                 description: The type of worker.
 *               shift:
 *                 type: string
 *                 description: The shift of the employee.
 *               zone:
 *                 type: string
 *                 description: The zone of the employee.
 *               machine:
 *                 type: string
 *                 description: The machine details.
 *               category_type:
 *                 type: string
 *                 description: The category type of the employee.
 *               staff:
 *                 type: string
 *                 description: The staff details.
 *     responses:
 *       200:
 *         description: Record updated successfully.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 message:
 *                   type: string
 *                   example: Record updated successfully.
 *       404:
 *         description: Record not updated.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 message:
 *                   type: string
 *                   example: Record not updated.
 *       500:
 *         description: Internal server error.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 message:
 *                   type: string
 *                   example: Internal Server Error
 * @function
 * @name changeEmpToOp
 * @memberof module:Routes/OTA
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {NotFoundError} Will throw a not found error if the record is not inserted.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */

//employee to operator change
app.post('/ota/changeEmpToOp', authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    const {
      entryid,
      unm: username,
      password: pass,
      rlid: roleid,
      name,
      workertype: worktyp,
      shift,
      zone,
      machine,
      category_type: type,
      staff
    } = req.body;

    const tags = machine.split(',');
    const numTags = tags.length - 1;
    const empCount = (1 / numTags).toFixed(4);

    // Insert user into geopos_users table
    const insertUserQuery = 'INSERT INTO geopos_users (username, entryid, email, name, roleid) VALUES (?, ?, ?, ?, ?)';
    const insertUserResult = await executeQuery(connection,insertUserQuery, [username, entryid, username, name, roleid]);

    if (insertUserResult.affectedRows === 0) {
      return res.status(404).json({ message: 'Record not Inserted' });
    }

    const userId = insertUserResult.insertId;

    // Check if employee exists in employees_ota table
    const rowcheck = 'SELECT * FROM employees_ota WHERE entryid = ?';
    const rowCheckResult = await executeQuery(rowcheck, [entryid]);

    if (rowCheckResult.length > 0) {
      // Update employee details in employees_ota table
      const updateEmpQuery = `
        UPDATE employees_ota 
        SET username = ?, roleid = ?, workertype = ?, shift = ?, zone = ?, machine = ?, emp_count = ?, section_id = ?, category_type = ?, staff = ? 
        WHERE entryid = ?`;
      await executeQuery(connection,updateEmpQuery, [username, roleid, worktyp, shift, zone, machine, empCount, '0', type, staff, entryid]);

      // Update user details in geopos_users table
      const hashedPassword = hashPassword(pass, userId.toString());
      const updateUserQuery = `
        UPDATE geopos_users 
        SET entryid = ?, name = ?, roleid = ?, production_type = ?, category_type = ?, pass = ? 
        WHERE entryid = ?`;
      const updateUserResult = await executeQuery(connection,updateUserQuery, [entryid, name, roleid, 'ota', type, hashedPassword, entryid]);

      if (updateUserResult.affectedRows === 0) {
        return res.status(404).json({ message: 'Record not Updated' });
      }
    }

    res.status(200).json({ message: 'Record Updated successfully' });
  } catch (error) {
    console.error(error);
    res.status(500).json({ message: 'Internal Server Error' });
  } finally {
    if (connection) {
      connection.release();
      //console.log("Connection released");
    }
  }
});

/**
 * @swagger
 * /ota/update_employee:
 *   post:
 *     summary: Update employee details.
 *     description: Update employee details in the database.
 *     tags:
 *       - OTA
 *     security:
 *       - BearerAuth: []
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             properties:
 *               name:
 *                 type: string
 *                 description: The name of the employee.
 *               entryid:
 *                 type: string
 *                 description: The ID of the employee entry.
 *               workertype:
 *                 type: string
 *                 description: The type of worker.
 *               shift:
 *                 type: string
 *                 description: The shift of the employee.
 *               section_id:
 *                 type: string
 *                 description: The ID of the section.
 *               roleid:
 *                 type: string
 *                 description: The role ID of the employee.
 *               uzone:
 *                 type: string
 *                 description: The zone of the employee.
 *               id:
 *                 type: string
 *                 description: The ID of the employee.
 *               machiness:
 *                 type: string
 *                 description: The machine details.
 *     responses:
 *       200:
 *         description: Record updated successfully.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 message:
 *                   type: string
 *                   example: Record updated successfully.
 *       404:
 *         description: Record not updated.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 message:
 *                   type: string
 *                   example: Record not updated.
 *       500:
 *         description: Internal server error.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 message:
 *                   type: string
 *                   example: Internal Server Error
 * @function
 * @name update_employee
 * @memberof module:Routes/OTA
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {NotFoundError} Will throw a not found error if the record is not updated.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */

//Update employee 
app.post('/ota/update_employee', authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    const { name, entryid, workertype, shift, section_id, roleid, uzone: zone, id, machiness: machine } = req.body;

    const tags = machine.split(',');
    const numTags = tags.length - 1;
    const empCount = (1 / numTags).toFixed(4);

    const query = `
      UPDATE employees_ota 
      SET entryid = ?, name = ?, workertype = ?, shift = ?, section_id = ?, roleid = ?, zone = ?, machine = ?, emp_count = ? 
      WHERE id = ?`;

    const result = await executeQuery(connection,query, [entryid, name, workertype, shift, section_id, roleid, zone, machine, empCount, id]);

    if (result.affectedRows === 0) {
      res.status(404).json({ message: 'Record not Updated' });
    } else {
      res.status(200).json({ message: 'Record Updated successfully' });
    }
  } catch (error) {
    console.error(error);
    res.status(500).json({ message: 'Internal Server Error' });
  } finally {
    if (connection) {
      connection.release();
      //console.log("Connection released");
    }
  }
});

/**
 * @swagger
 * /ota/get_employeess_date:
 *   get:
 *     summary: Get employee details by date.
 *     description: Retrieve employee details from the database based on date.
 *     tags:
 *       - OTA
 *     security:
 *       - BearerAuth: []
 *     responses:
 *       200:
 *         description: Successfully retrieved employee details.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 id:
 *                   type: integer
 *                   description: The ID of the employee.
 *                 name:
 *                   type: string
 *                   description: The name of the employee.
 *                 entryid:
 *                   type: string
 *                   description: The entry ID of the employee.
 *                 workertype:
 *                   type: string
 *                   description: The type of worker.
 *                 shift:
 *                   type: string
 *                   description: The shift of the employee.
 *                 section_id:
 *                   type: string
 *                   description: The ID of the section.
 *                 roleid:
 *                   type: string
 *                   description: The role ID of the employee.
 *                 uzone:
 *                   type: string
 *                   description: The zone of the employee.
 *                 machiness:
 *                   type: string
 *                   description: The machine details.
 *                 emp_count:
 *                   type: number
 *                   description: The count of employees.
 *       404:
 *         description: No records found.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 message:
 *                   type: string
 *                   example: No records found.
 *       500:
 *         description: Internal server error.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 message:
 *                   type: string
 *                   example: Internal Server Error
 * @function
 * @name get_employeess_date
 * @memberof module:Routes/OTA
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {NotFoundError} Will throw a not found error if no records are found.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */

//Employee Default date
app.get('/ota/get_employeess_date', authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    const query = `SELECT * FROM employees_ota ORDER BY id ASC LIMIT 1`;
    const result = await executeQuery(connection,query);

    if (result.length === 0) {
      return res.status(404).json({ message: 'No records found' });
    }

    res.json(result[0]);
  } catch (error) {
    console.error(error);
    res.status(500).json({ message: 'Internal Server Error' });
  } finally {
    if (connection) {
      connection.release();
      //console.log("Connection released");
    }
  }
});


//Delete employee 
app.delete('/ota/delete_user/:id', authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    const id = req.params.id;
    const deleteQuery = 'DELETE FROM employees_ota WHERE id = ?';
    const result = await executeQuery(connection,deleteQuery, [id]);

    if (result.affectedRows === 0) {
      res.status(404).send('Record not found');
    } else {
      res.status(200).send('Data deleted successfully');
    }
  } catch (error) {
    console.error(error);
    res.status(500).send('Error deleting record');
  } finally {
    if (connection) {
      connection.release();
      //console.log("Connection released");
    }
  }
});

/**
 * @swagger
 * /ota/delete_user/{id}:
 *   delete:
 *     summary: Delete user by ID.
 *     description: Delete a user from the database by ID.
 *     tags:
 *       - OTA
 *     security:
 *       - BearerAuth: []
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         description: ID of the user to delete.
 *         schema:
 *           type: integer
 *     responses:
 *       200:
 *         description: Data deleted successfully.
 *         content:
 *           text/plain:
 *             schema:
 *               type: string
 *               example: Data deleted successfully
 *       404:
 *         description: Record not found.
 *         content:
 *           text/plain:
 *             schema:
 *               type: string
 *               example: Record not found
 *       500:
 *         description: Error deleting record.
 *         content:
 *           text/plain:
 *             schema:
 *               type: string
 *               example: Error deleting record
 * @function
 * @name delete_user
 * @memberof module:Routes/OTA
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {NotFoundError} Will throw a not found error if the record to delete is not found.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */

//Employee Default date
app.get('/ota/get_employeess_nbraid_date', authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    const query = `SELECT * FROM employees_ota ORDER BY id ASC LIMIT 1`;
    const result = await executeQuery(connection,query);

    if (result.length === 0) {
      return res.status(404).json({ message: 'No records found' });
    }
    res.json(result[0]);
  } catch (error) {
    console.error(error);
    res.status(500).json({ message: 'Internal Server Error' });
  } finally {
    if (connection) {
      connection.release();
      //console.log("Connection released");
    }
  }
});

/**
 * @swagger
 * /ota/get_employeess_nbraid:
 *   get:
 *     summary: Get employees for NBRAID category.
 *     description: Retrieve employees for the NBRAID category from the database.
 *     tags:
 *       - OTA
 *     security:
 *       - BearerAuth: []
 *     responses:
 *       200:
 *         description: Successfully retrieved employee details.
 *         content:
 *           application/json:
 *             schema:
 *               type: array
 *               items:
 *                 type: object
 *                 properties:
 *                   id:
 *                     type: integer
 *                     description: The ID of the employee.
 *                   name:
 *                     type: string
 *                     description: The name of the employee.
 *                   entryid:
 *                     type: string
 *                     description: The entry ID of the employee.
 *                   workertype:
 *                     type: string
 *                     description: The type of worker.
 *                   shift:
 *                     type: string
 *                     description: The shift of the employee.
 *                   section_id:
 *                     type: string
 *                     description: The ID of the section.
 *                   roleid:
 *                     type: string
 *                     description: The role ID of the employee.
 *                   zone:
 *                     type: string
 *                     description: The zone of the employee.
 *                   machine:
 *                     type: string
 *                     description: The machine details.
 *                   emp_count:
 *                     type: number
 *                     description: The count of employees.
 *                   section_name:
 *                     type: string
 *                     description: The name of the section.
 *                   item_description:
 *                     type: string
 *                     description: The description of the item.
 *                   role:
 *                     type: string
 *                     description: The role of the employee.
 *       500:
 *         description: Error retrieving records.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 message:
 *                   type: string
 *                   example: Error retrieving records
 * @function
 * @name get_employeess_nbraid
 * @memberof module:Routes/OTA
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue retrieving records.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */

//Nonbraid Employee Defulte data search
app.get('/ota/get_employeess_nbraid', authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    const query = `
      SELECT employees_ota.*, section.section_name, item_masterr.item_description, geopos_emptype.name as role
      FROM employees_ota
      LEFT JOIN geopos_emptype ON employees_ota.roleid = geopos_emptype.id
      LEFT JOIN section ON employees_ota.section_id = section.id
      LEFT JOIN item_masterr ON employees_ota.product = item_masterr.id
      WHERE employees_ota.roleid != '3'
        AND employees_ota.passive_type = 'ACT'
        AND employees_ota.category_type = 'NBRAID';
    `;
    
    const result = await executeQuery(connection,query);

    res.json(result);
  } catch (error) {
    console.error(error);
    res.status(500).json({ message: 'Error retrieving records' });
  } finally {
    if (connection) {
      connection.release();
      //console.log("Connection released");
    }
  }
});

/**
 * @swagger
 * /ota/get_employees_nbraid:
 *   get:
 *     summary: Get employees for NBRAID category with filtering.
 *     description: Retrieve employees for the NBRAID category from the database with optional filtering.
 *     tags:
 *       - OTA
 *     security:
 *       - BearerAuth: []
 *     parameters:
 *       - in: query
 *         name: where
 *         schema:
 *           type: string
 *         description: SQL WHERE clause to filter employees. For example, "roleid = 1".
 *     responses:
 *       200:
 *         description: Successfully retrieved employee details.
 *         content:
 *           application/json:
 *             schema:
 *               type: array
 *               items:
 *                 type: object
 *                 properties:
 *                   id:
 *                     type: integer
 *                     description: The ID of the employee.
 *                   name:
 *                     type: string
 *                     description: The name of the employee.
 *                   entryid:
 *                     type: string
 *                     description: The entry ID of the employee.
 *                   workertype:
 *                     type: string
 *                     description: The type of worker.
 *                   shift:
 *                     type: string
 *                     description: The shift of the employee.
 *                   section_id:
 *                     type: string
 *                     description: The ID of the section.
 *                   roleid:
 *                     type: string
 *                     description: The role ID of the employee.
 *                   zone:
 *                     type: string
 *                     description: The zone of the employee.
 *                   machine:
 *                     type: string
 *                     description: The machine details.
 *                   emp_count:
 *                     type: number
 *                     description: The count of employees.
 *                   section_name:
 *                     type: string
 *                     description: The name of the section.
 *                   role:
 *                     type: string
 *                     description: The role of the employee.
 *       500:
 *         description: Error retrieving records.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 message:
 *                   type: string
 *                   example: Error retrieving records
 * @function
 * @name get_employees_nbraid
 * @memberof module:Routes/OTA
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue retrieving records.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */

//Nonbraid Employee filter data search
app.get('/ota/get_employees_nbraid', authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    const { where } = req.query;
    const query = `
      SELECT employees_ota.*, section.section_name, geopos_emptype.name as role
      FROM employees_ota
      LEFT JOIN geopos_emptype ON employees_ota.roleid = geopos_emptype.id
      LEFT JOIN section ON employees_ota.section_id = section.id
      WHERE ${where}
    `;

    const result = await executeQuery(connection,query);
    res.json(result);
  } catch (error) {
    console.error(error);
    res.status(500).json({ message: 'Error retrieving records' });
  } finally {
    if (connection) {
      connection.release();
      //console.log("Connection released");
    }
  }
});

/**
 * @swagger
 * /ota/getSectionName/{id}:
 *   get:
 *     summary: Get section name by ID.
 *     description: Retrieve the name of a section from the database by its ID.
 *     tags:
 *       - OTA
 *     security:
 *       - BearerAuth: []
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         description: ID of the section to retrieve the name for.
 *         schema:
 *           type: integer
 *     responses:
 *       200:
 *         description: Successfully retrieved section name.
 *         content:
 *           text/plain:
 *             schema:
 *               type: string
 *               example: Section Name
 *       404:
 *         description: Section not found.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 message:
 *                   type: string
 *                   example: Section not found
 *       500:
 *         description: Internal server error.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 message:
 *                   type: string
 *                   example: Internal Server Error
 * @function
 * @name getSectionName
 * @memberof module:Routes/OTA
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {NotFoundError} Will throw a not found error if the section is not found.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */

//get section Name from id
app.get('/ota/getSectionName/:id', authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    const id = req.params.id;
    const query = 'SELECT section_name FROM section WHERE id = ?';
    const result = await executeQuery(connection,query, [id]);

    if (result.length === 0) {
      return res.status(404).json({ message: 'Section not found' });
    }

    res.send(result[0].section_name);
  } catch (error) {
    console.error(error);
    res.status(500).json({ message: 'Internal Server Error' });
  } finally {
    if (connection) {
      connection.release();
      //console.log("Connection released");
    }
  }
});

/**
 * @swagger
 * /ikeja/getSectionName/{id}:
 *   get:
 *     summary: Get section name by ID for Ikeja.
 *     description: Retrieve the name of a section from the database by its ID for Ikeja.
 *     tags:
 *       - Ikeja
 *     security:
 *       - BearerAuth: []
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         description: ID of the section to retrieve the name for.
 *         schema:
 *           type: integer
 *     responses:
 *       200:
 *         description: Successfully retrieved section name.
 *         content:
 *           text/plain:
 *             schema:
 *               type: string
 *               example: Section Name
 *       404:
 *         description: Section not found.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: Section not found
 *       500:
 *         description: Internal server error.
 *         content:
 *           text/plain:
 *             schema:
 *               type: string
 *               example: Internal Server Error
 * @function
 * @name getSectionName
 * @memberof module:Routes/Ikeja
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {NotFoundError} Will throw a not found error if the section is not found.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */

//get section Name from id
app.get('/ikeja/getSectionName/:id', authenticateJWT, async (req, res) => {
  const id = req.params.id;
  let connection;
  try {
    connection = await getPoolConnection();
    const result = await executeQuery(connection,'SELECT * FROM section WHERE id = ?', [id]);
    if (result.length === 0) {
      return res.status(404).json({ error: 'Section not found' });
    }

    res.send(result[0].section_name); // Send only the name value from the result
  } catch (error) {
    console.error(error);
    res.status(500).send('Internal Server Error');
  } finally {
    if (connection) {
      connection.release();
      //console.log("Connection released");
    }
  }
});


/**
 * @swagger
 * /ota/updateemployee:
 *   post:
 *     summary: Update employee details.
 *     description: Update employee details in the database.
 *     tags:
 *       - OTA
 *     security:
 *       - BearerAuth: []
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             properties:
 *               id:
 *                 type: integer
 *                 description: The ID of the employee to update.
 *               name:
 *                 type: string
 *                 description: The updated name of the employee.
 *               entryid:
 *                 type: string
 *                 description: The entry ID of the employee.
 *               workertype:
 *                 type: string
 *                 description: The updated type of worker.
 *               shift:
 *                 type: string
 *                 description: The updated shift of the employee.
 *               roleid:
 *                 type: integer
 *                 description: The updated role ID of the employee.
 *               line:
 *                 type: string
 *                 description: The original line of the employee.
 *               section_id:
 *                 type: integer
 *                 description: The original section ID of the employee.
 *               usection_id:
 *                 type: integer
 *                 description: The updated section ID of the employee.
 *               uline:
 *                 type: string
 *                 description: The updated line of the employee.
 *     responses:
 *       200:
 *         description: Record updated successfully.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 message:
 *                   type: string
 *                   example: Record Updated successfully
 *       404:
 *         description: Record not updated.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 message:
 *                   type: string
 *                   example: Record not Updated
 *       500:
 *         description: Internal server error.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 message:
 *                   type: string
 *                   example: Internal Server Error
 * @function
 * @name updateemployee
 * @memberof module:Routes/OTA
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {NotFoundError} Will throw a not found error if the record to update is not found.
 * @throws {InternalServerError} Will throw an error if there's an issue updating the employee details.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */

//employee to opeartor change
app.post('/ota/updateemployee', authenticateJWT, async (req, res) => {
  const {
    id,
    name,
    entryid,
    workertype,
    shift,
    roleid,
    line,
    section_id,
    usection_id,
    uline
  } = req.body;
  let connection;
  try {
    connection = await getPoolConnection();
    // Update employees_ota table
    const updateEmployeeResult = await executeQuery(connection,
      'UPDATE employees_ota SET name=?, workertype=?, shift=?, section_id=?, line=?, roleid=? WHERE id=?',
      [name, workertype, shift, usection_id, uline, roleid, id]
    );

    if (updateEmployeeResult.affectedRows === 0) {
      return res.status(404).json({ message: 'Record not Updated' });
    }

    // Insert into change_product table
    const insertChangeProductResult = await executeQuery(connection,
      'INSERT INTO change_product (entryid, emp_id, line_old, line_new, section_old, section_new) VALUES (?,?,?,?,?,?)',
      [entryid, id, line, uline, section_id, usection_id]
    );

    if (insertChangeProductResult.affectedRows === 0) {
      return res.status(404).json({ message: 'Record not Updated' });
    }

    // Both operations completed successfully
    res.status(200).json({ message: 'Record Updated successfully' });

  } catch (error) {
    console.error('Error updating employee:', error);
    res.status(500).json({ message: 'Internal Server Error' });
  } finally {
    if (connection) {
      connection.release();
      //console.log("Connection released");
    }
  }
});


//Change zone OTA
/**
 * @swagger
 * /ota/getZonedata:
 *   get:
 *     summary: Get zone data for BRAID category.
 *     description: Retrieve employees' zone data for the BRAID category from the database.
 *     tags:
 *       - OTA
 *     security:
 *       - BearerAuth: []
 *     responses:
 *       200:
 *         description: Successfully retrieved zone data.
 *         content:
 *           application/json:
 *             schema:
 *               type: array
 *               items:
 *                 type: object
 *                 properties:
 *                   id:
 *                     type: integer
 *                     description: The ID of the employee.
 *                   name:
 *                     type: string
 *                     description: The name of the employee.
 *                   entryid:
 *                     type: string
 *                     description: The entry ID of the employee.
 *                   workertype:
 *                     type: string
 *                     description: The type of worker.
 *                   shift:
 *                     type: string
 *                     description: The shift of the employee.
 *                   section_id:
 *                     type: integer
 *                     description: The ID of the section.
 *                   line:
 *                     type: string
 *                     description: The line of the employee.
 *                   roleid:
 *                     type: integer
 *                     description: The role ID of the employee.
 *                   zone:
 *                     type: string
 *                     description: The zone of the employee.
 *                   machine:
 *                     type: string
 *                     description: The machine details.
 *                   emp_count:
 *                     type: number
 *                     description: The count of employees.
 *                   section_name:
 *                     type: string
 *                     description: The name of the section.
 *                   role:
 *                     type: string
 *                     description: The role of the employee.
 *       500:
 *         description: Internal Server Error.
 *         content:
 *           text/plain:
 *             schema:
 *               type: string
 *               example: Internal Server Error
 * @function
 * @name getZonedata
 * @memberof module:Routes/OTA
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue retrieving the zone data.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */

// Get zone data default view
app.get('/ota/getZonedata', authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    let query = `
      SELECT employees_ota.*, section.section_name, geopos_emptype.name AS role
      FROM employees_ota
      LEFT JOIN geopos_emptype ON employees_ota.roleid = geopos_emptype.id
      LEFT JOIN section ON employees_ota.section_id = section.id
      WHERE (employees_ota.roleid != '3' AND employees_ota.roleid != '5') 
      AND employees_ota.passive_type = 'ACT' 
      AND employees_ota.category_type = 'BRAID'
    `;
    
    const result = await executeQuery(connection,query);

    res.send(result);
  } catch (error) {
    console.error(error);
    res.status(500).send('Internal Server Error');
  } finally {
    if (connection) {
      connection.release();
      //console.log("Connection released");
    }
  }
});

/**
 * @swagger
 * /ota/get_zonedata_search:
 *   get:
 *     summary: Get zone data with search criteria.
 *     description: Retrieve employees' zone data based on search criteria from the database.
 *     tags:
 *       - OTA
 *     security:
 *       - BearerAuth: []
 *     parameters:
 *       - in: query
 *         name: where
 *         required: true
 *         description: The WHERE clause to filter the search results.
 *         schema:
 *           type: string
 *           example: "roleid != '3' AND roleid != '5' AND passive_type = 'ACT' AND category_type = 'BRAID'"
 *     responses:
 *       200:
 *         description: Successfully retrieved zone data.
 *         content:
 *           application/json:
 *             schema:
 *               type: array
 *               items:
 *                 type: object
 *                 properties:
 *                   id:
 *                     type: integer
 *                     description: The ID of the employee.
 *                   name:
 *                     type: string
 *                     description: The name of the employee.
 *                   entryid:
 *                     type: string
 *                     description: The entry ID of the employee.
 *                   workertype:
 *                     type: string
 *                     description: The type of worker.
 *                   shift:
 *                     type: string
 *                     description: The shift of the employee.
 *                   section_id:
 *                     type: integer
 *                     description: The ID of the section.
 *                   line:
 *                     type: string
 *                     description: The line of the employee.
 *                   roleid:
 *                     type: integer
 *                     description: The role ID of the employee.
 *                   zone:
 *                     type: string
 *                     description: The zone of the employee.
 *                   machine:
 *                     type: string
 *                     description: The machine details.
 *                   emp_count:
 *                     type: number
 *                     description: The count of employees.
 *                   section_name:
 *                     type: string
 *                     description: The name of the section.
 *                   role:
 *                     type: string
 *                     description: The role of the employee.
 *       500:
 *         description: Internal Server Error.
 *         content:
 *           text/plain:
 *             schema:
 *               type: string
 *               example: Internal Server Error
 * @function
 * @name get_zonedata_search
 * @memberof module:Routes/OTA
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue retrieving the zone data.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */

// Get zone data search  view
app.get('/ota/get_zonedata_search', authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    const { where } = req.query;
    let query =
      `SELECT employees_ota.*, section.section_name, geopos_emptype.name AS role
      FROM employees_ota
      LEFT JOIN geopos_emptype ON employees_ota.roleid = geopos_emptype.id
      LEFT JOIN section ON employees_ota.section_id = section.id
      WHERE ${where}`;
    
    const result = await executeQuery(connection,query);

    res.send(result);
  } catch (error) {
    console.error(error);
    res.status(500).send('Internal Server Error');
  } finally {
    if (connection) {
      connection.release();
      //console.log("Connection released");
    }
  }
});

/**
 * @swagger
 * /ota/update_multiple_zone:
 *   post:
 *     summary: Update multiple zones for employees.
 *     description: Update zone and machine details for multiple employees based on their entry IDs.
 *     tags:
 *       - OTA
 *     security:
 *       - BearerAuth: []
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             properties:
 *               shift:
 *                 type: string
 *                 description: The new shift for the employees.
 *               entryIds:
 *                 type: string
 *                 description: Comma-separated entry IDs of the employees.
 *               section_id:
 *                 type: integer
 *                 description: The new section ID for the employees.
 *               zone:
 *                 type: string
 *                 description: The new zone for the employees.
 *               machines:
 *                 type: string
 *                 description: The new machine details.
 *             required:
 *               - shift
 *               - entryIds
 *               - section_id
 *               - zone
 *               - machines
 *     responses:
 *       200:
 *         description: Details updated successfully.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 status:
 *                   type: string
 *                   example: Success
 *                 message:
 *                   type: string
 *                   example: Details updated successfully.
 *       500:
 *         description: Internal Server Error.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 status:
 *                   type: string
 *                   example: Error
 *                 message:
 *                   type: string
 *                   example: Internal Server Error
 * @function
 * @name update_multiple_zone
 * @memberof module:Routes/OTA
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue updating the zone data.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */

// Change zone braid multiple entry id wise zone update
app.post('/ota/update_multiple_zone', authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    const { shift, entryIds, section_id, zone, machines } = req.body;
    const category_type = 'BRAID';
    const production_type = 'OTA';
    
    const options = {
      timeZone: 'Africa/Lagos',
      day: '2-digit',
      month: '2-digit',
      year: 'numeric',
      hour: '2-digit',
      minute: '2-digit',
      second: '2-digit'
    };
    const currentTime = new Date().toLocaleString('en-US', options);

    const [datePart, timePart] = currentTime.split(', ');
    const [month, date, year] = datePart.split('/');
    const [time, amPm] = timePart.split(' ');
    const [hours, minutes, seconds] = time.split(':');
    const tdate = `${date.padStart(2, '0')}-${month.padStart(2, '0')}-${year} ${hours}:${minutes}:${seconds}`;

    const tags = machines.split(',');
    const numTags = tags.length - 1;
    const empCount = (1 / numTags).toFixed(4);

    const entryIdsArray = entryIds.split(',');

    const checkQuery = 'SELECT * FROM employees_ota WHERE id = ? ';
    const insertQuery =
      'INSERT INTO geopos_changezonemachine (zone_old, machine_old, zone_new, machine_new, shift_old, section_old, shift_new, section_new, emp_id, entry_id, date_time, category_type, production_type) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)';
    const updateQuery =
      'UPDATE employees_ota SET zone=?, machine=?, emp_count=?, shift=?, section_id=? WHERE id = ?';

    let processedCount = 0;

    for (const entryId of entryIdsArray) {
      const [checkResult] = await executeQuery(connection, checkQuery, [entryId]);
      
      if (checkResult) {
        const {
          entryid,
          zone: zone_old,
          machine: machine_old,
          shift: shift_old,
          section_id: section_old,
          id
        } = checkResult;

        const insertValues = [
          zone_old,
          machine_old,
          zone,
          machines,
          shift_old,
          section_old,
          shift,
          section_id,
          id,
          entryid,
          tdate,
          category_type,
          production_type
        ];

        await executeQuery(connection,insertQuery, insertValues);

        const updateValues = [zone, machines, empCount, shift, section_id, id];
        await executeQuery(connection,updateQuery, updateValues);

        processedCount++;
        console.log(`Data updated for entryId: ${entryId}`);

        if (processedCount === entryIdsArray.length) {
          return res.json({ status: 'Success', message: 'Details updated successfully.' });
        }
      } else {
        processedCount++;
        console.log(`Employee not found for entryId: ${entryId}`);

        if (processedCount === entryIdsArray.length) {
          return res.json({ status: 'Success', message: 'Details updated successfully.' });
        }
      }
    }
  } catch (error) {
    console.error(error);
    res.status(500).json({ status: 'Error', message: 'Internal Server Error' });
  } finally {
    if (connection) {
      connection.release();
      //console.log("Connection released");
    }
  }
});

/**
 * @swagger
 * /ota/update_multiple_zone_to_nbraid:
 *   post:
 *     summary: Update multiple employees to NBRAID category.
 *     description: Update the zone, machine, emp_count, line, section_id, and category_type fields for multiple employees to NBRAID.
 *     tags:
 *       - OTA
 *     security:
 *       - BearerAuth: []
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             properties:
 *               entryIds:
 *                 type: string
 *                 description: Comma-separated entry IDs of the employees to be updated.
 *                 example: "1,2,3"
 *               line:
 *                 type: string
 *                 description: The new line for the employees.
 *               section_id:
 *                 type: integer
 *                 description: The new section ID for the employees.
 *             required:
 *               - entryIds
 *               - line
 *               - section_id
 *     responses:
 *       200:
 *         description: Details updated successfully.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 status:
 *                   type: string
 *                   example: Success
 *                 message:
 *                   type: string
 *                   example: Details updated successfully.
 *       500:
 *         description: Internal Server Error.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 status:
 *                   type: string
 *                   example: Error
 *                 message:
 *                   type: string
 *                   example: Internal Server Error
 * @function
 * @name update_multiple_zone_to_nbraid
 * @memberof module:Routes/OTA
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue updating the zone data.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */

// change zone braid to nbraid assign 
app.post('/ota/update_multiple_zone_to_nbraid', authenticateJWT, async (req, res) => {
  let connection
  try {
    connection = await getPoolConnection();
    const { entryIds, line, section_id } = req.body;
    const entryIdsArray = entryIds.split(',');
    const checkQuery = 'SELECT * FROM employees_ota WHERE id = ? ';
    const updateQuery =
      'UPDATE employees_ota SET zone=?, machine=?, emp_count=?, line=?, section_id=?, category_type=? WHERE id = ?';
    let processedCount = 0;

    for (const entryId of entryIdsArray) {
      const [checkResult] = await executeQuery(connection,checkQuery, [entryId]);
      
      if (checkResult) {
        const { id } = checkResult;
        const updateValue = ['', '', '', line, section_id, 'NBRAID', id];
        await executeQuery(connection,updateQuery, updateValue);

        processedCount++;
        console.log(`Data updated for entryId: ${entryId}`);

        if (processedCount === entryIdsArray.length) {
          return res.json({ status: 'Success', message: 'Details updated successfully.' });
        }
      } else {
        processedCount++;
        console.log(`Employee not found for entryId: ${entryId}`);

        if (processedCount === entryIdsArray.length) {
          return res.json({ status: 'Success', message: 'Details updated successfully.' });
        }
      }
    }
  } catch (error) {
    console.error(error);
    res.status(500).json({ status: 'Error', message: 'Internal Server Error' });
  }  finally {
    if (connection) {
      connection.release();
      //console.log("Connection released");
    }
  }
});

/**
 * @swagger
 * /ota/getZonedataNbraid:
 *   get:
 *     summary: Retrieve data for employees in the NBRAID category.
 *     description: Get detailed information about employees who are active, not in roleid 3, and belong to the NBRAID category.
 *     tags:
 *       - OTA
 *     security:
 *       - BearerAuth: []
 *     responses:
 *       200:
 *         description: Successfully retrieved employee data.
 *         content:
 *           application/json:
 *             schema:
 *               type: array
 *               items:
 *                 type: object
 *                 properties:
 *                   id:
 *                     type: integer
 *                     example: 1
 *                   entryid:
 *                     type: string
 *                     example: EMP12345
 *                   name:
 *                     type: string
 *                     example: John Doe
 *                   roleid:
 *                     type: integer
 *                     example: 2
 *                   role:
 *                     type: string
 *                     example: Supervisor
 *                   section_id:
 *                     type: integer
 *                     example: 5
 *                   section_name:
 *                     type: string
 *                     example: Section A
 *                   product:
 *                     type: integer
 *                     example: 10
 *                   item_description:
 *                     type: string
 *                     example: Product XYZ
 *                   zone:
 *                     type: string
 *                     example: Zone 1
 *                   machine:
 *                     type: string
 *                     example: Machine 3
 *                   emp_count:
 *                     type: number
 *                     format: float
 *                     example: 0.5000
 *                   shift:
 *                     type: string
 *                     example: Shift A
 *                   passive_type:
 *                     type: string
 *                     example: ACT
 *                   category_type:
 *                     type: string
 *                     example: NBRAID
 *       500:
 *         description: Internal Server Error.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 message:
 *                   type: string
 *                   example: Internal Server Error
 * @function
 * @name getZonedataNbraid
 * @memberof module:Routes/OTA
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
// Get zone nbraid data default view
app.get('/ota/getZonedataNbraid', authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    const query =
      `SELECT employees_ota.*, section.section_name, item_masterr.item_description, geopos_emptype.name AS role
      FROM employees_ota
      LEFT JOIN geopos_emptype ON employees_ota.roleid = geopos_emptype.id
      LEFT JOIN section ON employees_ota.section_id = section.id
      LEFT JOIN item_masterr ON employees_ota.product = item_masterr.id
      WHERE employees_ota.roleid != '3' AND employees_ota.passive_type = 'ACT' AND employees_ota.category_type = 'NBRAID'`;

    const result = await executeQuery(connection,query);

    res.send(result);
  } catch (error) {
    console.error(error);
    res.status(500).send('Internal Server Error');
  } finally {
    if (connection) {
      connection.release();
      //console.log("Connection released");
    }
  }
});

/**
 * @swagger
 * /ota/get_zoneNbraid_search:
 *   get:
 *     summary: Search for NBRAID zone data based on specific criteria.
 *     description: Retrieve detailed information about employees who match the specified search criteria in the NBRAID category.
 *     tags:
 *       - OTA
 *     security:
 *       - BearerAuth: []
 *     parameters:
 *       - in: query
 *         name: where
 *         schema:
 *           type: string
 *         description: SQL WHERE clause to filter the search results.
 *         required: true
 *     responses:
 *       200:
 *         description: Successfully retrieved search results.
 *         content:
 *           application/json:
 *             schema:
 *               type: array
 *               items:
 *                 type: object
 *                 properties:
 *                   id:
 *                     type: integer
 *                     example: 1
 *                   entryid:
 *                     type: string
 *                     example: EMP12345
 *                   name:
 *                     type: string
 *                     example: John Doe
 *                   roleid:
 *                     type: integer
 *                     example: 2
 *                   role:
 *                     type: string
 *                     example: Supervisor
 *                   section_id:
 *                     type: integer
 *                     example: 5
 *                   section_name:
 *                     type: string
 *                     example: Section A
 *                   zone:
 *                     type: string
 *                     example: Zone 1
 *                   machine:
 *                     type: string
 *                     example: Machine 3
 *                   emp_count:
 *                     type: number
 *                     format: float
 *                     example: 0.5000
 *                   shift:
 *                     type: string
 *                     example: Shift A
 *                   passive_type:
 *                     type: string
 *                     example: ACT
 *                   category_type:
 *                     type: string
 *                     example: NBRAID
 *       500:
 *         description: Internal Server Error.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 message:
 *                   type: string
 *                   example: Internal Server Error
 * @function
 * @name get_zoneNbraid_search
 * @memberof module:Routes/OTA
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */

// Get zone nbraid data search view OTA
app.get('/ota/get_zoneNbraid_search', authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    const { where } = req.query;
    const query =
      `SELECT employees_ota.*, section.section_name, geopos_emptype.name AS role
      FROM employees_ota
      LEFT JOIN geopos_emptype ON employees_ota.roleid = geopos_emptype.id
      LEFT JOIN section ON employees_ota.section_id = section.id
      WHERE ${where}`;

    const result = await executeQuery(connection,query);

    res.send(result);
  } catch (error) {
    console.error(error);
    res.status(500).send('Internal Server Error');
  } finally {
    if (connection) {
      connection.release();
      //console.log("Connection released");
    }
  }
});

/**
 * @swagger
 * /ota/update_multiple_zone_nbraid:
 *   post:
 *     summary: Update multiple employees' zone to NBRAID.
 *     description: Update the line and section for multiple employees identified by their IDs, and log the changes in the change_product table.
 *     tags:
 *       - OTA
 *     security:
 *       - BearerAuth: []
 *     requestBody:
 *       description: The entry IDs, line, and section ID to update.
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             properties:
 *               entryIds:
 *                 type: string
 *                 description: Comma-separated list of employee IDs to update.
 *                 example: "1,2,3"
 *               line:
 *                 type: string
 *                 description: The new line for the employees.
 *                 example: "Line 1"
 *               section_id:
 *                 type: integer
 *                 description: The new section ID for the employees.
 *                 example: 5
 *     responses:
 *       200:
 *         description: Details updated successfully.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 status:
 *                   type: string
 *                   example: Success
 *                 message:
 *                   type: string
 *                   example: Details updated successfully.
 *       500:
 *         description: Internal Server Error.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 status:
 *                   type: string
 *                   example: Error
 *                 message:
 *                   type: string
 *                   example: Internal Server Error
 * @function
 * @name update_multiple_zone_nbraid
 * @memberof module:Routes/OTA
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
// Entryids wise section/line data update Nbraid OTA
app.post('/ota/update_multiple_zone_nbraid', authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    const { entryIds, line, section_id } = req.body;
    const entryIdsArray = entryIds.split(',');

    const checkQuery = 'SELECT * FROM employees_ota WHERE id = ? ';
    const InsertQuery = 'INSERT INTO change_product (emp_id, entryid, line_old, line_new, section_old, section_new) VALUES (?, ?, ?, ?, ?, ?)';
    const updateQuery = 'UPDATE employees_ota SET line=?, section_id=? WHERE id = ?';

    let processedCount = 0;

    for (const entryId of entryIdsArray) {
      const [checkResult] = await executeQuery(connection,checkQuery, [entryId]);

      if (checkResult) {
        const { id, entryid, line: line_old, section_id: section_old } = checkResult;
        const insertValues = [id, entryid, line_old, line, section_old, section_id];

        await executeQuery(connection,InsertQuery, insertValues);
        await executeQuery(connection,updateQuery, [line, section_id, id]);

        processedCount++;
        console.log(`Data updated for entryId: ${entryId}`);
      } else {
        processedCount++;
        console.log(`Employee not found for entryId: ${entryId}`);
      }
    }

    res.json({ status: 'Success', message: 'Details updated successfully.' });
  } catch (error) {
    console.error('Error:', error);
    res.status(500).json({ status: 'Error', message: 'Internal Server Error' });
  } finally {
    if (connection) {
      connection.release();
      //console.log("Connection released");
    }
  }
});

/**
 * @swagger
 * /ota/update_multiple_zone_braid:
 *   post:
 *     summary: Update multiple employees' zone to BRAID.
 *     description: Update the zone, machines, employee count, shift, and section for multiple employees identified by their IDs.
 *     tags:
 *       - OTA
 *     security:
 *       - BearerAuth: []
 *     requestBody:
 *       description: The entry IDs, shift, section ID, zone, and machines to update.
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             properties:
 *               shift:
 *                 type: string
 *                 description: The new shift for the employees.
 *                 example: "Morning"
 *               entryIds:
 *                 type: string
 *                 description: Comma-separated list of employee IDs to update.
 *                 example: "1,2,3"
 *               section_id:
 *                 type: integer
 *                 description: The new section ID for the employees.
 *                 example: 5
 *               zone:
 *                 type: string
 *                 description: The new zone for the employees.
 *                 example: "Zone A"
 *               machines:
 *                 type: string
 *                 description: Comma-separated list of machines assigned to the employees.
 *                 example: "Machine1,Machine2,Machine3"
 *     responses:
 *       200:
 *         description: Details updated successfully.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 status:
 *                   type: string
 *                   example: Success
 *                 message:
 *                   type: string
 *                   example: Details updated successfully.
 *       500:
 *         description: Internal Server Error.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 status:
 *                   type: string
 *                   example: Error
 *                 message:
 *                   type: string
 *                   example: Internal Server Error
 * @function
 * @name update_multiple_zone_braid
 * @memberof module:Routes/OTA
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */

// Entryids wise zone braid update
app.post('/ota/update_multiple_zone_braid', authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    const { shift, entryIds, section_id, zone, machines } = req.body;
    const tags = machines.split(',');
    const numTags = tags.length - 1;
    const empCount = (1 / numTags).toFixed(4);
    const entryIdsArray = entryIds.split(',');
    const checkQuery = 'SELECT * FROM employees_ota WHERE id = ? ';
    const updateQuery = 'UPDATE employees_ota SET zone=?, machine=?, emp_count=?, line=?, shift=?, section_id=?, category_type=? WHERE id = ?';

    let processedCount = 0;

    for (const entryId of entryIdsArray) {
      const [checkResult] = await executeQuery(connection,checkQuery, [entryId]);
      
      if (checkResult) {
        const { id } = checkResult;
        const updateValue = [zone, machines, empCount, '', shift, section_id, 'BRAID', id];
        await executeQuery(connection,updateQuery, updateValue);
        processedCount++;
        console.log(`Data updated for entryId: ${entryId}`);

        if (processedCount === entryIdsArray.length) {
          res.json({ status: 'Success', message: 'Details updated successfully.' });
        }
      } else {
        processedCount++;
        console.log(`Employee not found for entryId: ${entryId}`);

        if (processedCount === entryIdsArray.length) {
          res.json({ status: 'Success', message: 'Details updated successfully.' });
        }
      }
    }
  } catch (error) {
    console.error('Error updating data:', error);
    res.status(500).json({ status: 'Error', message: 'Internal Server Error' });
  } finally {
    if (connection) {
      connection.release();
      //console.log("Connection released");
    }
  }
});


//Change Shift Ota//
/**
 * @swagger
 * /ota/getShiftdata:
 *   get:
 *     summary: Get shift data for employees.
 *     description: Retrieve detailed shift data for employees, including section name, item description, and role, filtered by specific criteria.
 *     tags:
 *       - OTA
 *     security:
 *       - BearerAuth: []
 *     responses:
 *       200:
 *         description: Shift data retrieved successfully.
 *         content:
 *           application/json:
 *             schema:
 *               type: array
 *               items:
 *                 type: object
 *                 properties:
 *                   id:
 *                     type: integer
 *                     example: 1
 *                   name:
 *                     type: string
 *                     example: John Doe
 *                   entryid:
 *                     type: string
 *                     example: E12345
 *                   workertype:
 *                     type: string
 *                     example: Full-Time
 *                   shift:
 *                     type: string
 *                     example: Morning
 *                   section_id:
 *                     type: integer
 *                     example: 5
 *                   section_name:
 *                     type: string
 *                     example: Manufacturing
 *                   product:
 *                     type: integer
 *                     example: 3
 *                   item_description:
 *                     type: string
 *                     example: Widget A
 *                   roleid:
 *                     type: integer
 *                     example: 2
 *                   role:
 *                     type: string
 *                     example: Supervisor
 *                   passive_type:
 *                     type: string
 *                     example: ACT
 *                   category_type:
 *                     type: string
 *                     example: NBRAID
 *       500:
 *         description: Internal Server Error.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 status:
 *                   type: string
 *                   example: Error
 *                 message:
 *                   type: string
 *                   example: Internal Server Error
 * @function
 * @name getShiftdata
 * @memberof module:Routes/OTA
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */

// Get shift data default view
app.get('/ota/getShiftdata', authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    const query = `SELECT employees_ota.*, section.section_name, item_masterr.item_description, geopos_emptype.name as role
      FROM employees_ota
      LEFT JOIN geopos_emptype ON employees_ota.roleid = geopos_emptype.id
      LEFT JOIN section ON employees_ota.section_id = section.id
      LEFT JOIN item_masterr ON employees_ota.product = item_masterr.id
      WHERE (employees_ota.roleid !='3' AND employees_ota.roleid !='5') AND employees_ota.passive_type='ACT' AND employees_ota.category_type='NBRAID'`;

    const result = await executeQuery(connection,query);
    res.send(result);
  } catch (error) {
    console.error(error);
    res.status(500).send('Internal Server Error');
  } finally {
    if (connection) {
      connection.release();
      //console.log("Connection released");
    }
  }
});
          
/**
 * @swagger
 * /ota/get_shiftdata_search:
 *   get:
 *     summary: Search shift data for employees.
 *     description: Retrieve detailed shift data for employees based on a specified search condition, including section name and role, ordered by employee name.
 *     tags:
 *       - OTA
 *     security:
 *       - BearerAuth: []
 *     parameters:
 *       - in: query
 *         name: where
 *         required: true
 *         schema:
 *           type: string
 *         description: The condition for filtering employees' shift data.
 *         example: employees_ota.roleid != '3' AND employees_ota.passive_type = 'ACT'
 *     responses:
 *       200:
 *         description: Shift data retrieved successfully.
 *         content:
 *           application/json:
 *             schema:
 *               type: array
 *               items:
 *                 type: object
 *                 properties:
 *                   id:
 *                     type: integer
 *                     example: 1
 *                   name:
 *                     type: string
 *                     example: John Doe
 *                   entryid:
 *                     type: string
 *                     example: E12345
 *                   workertype:
 *                     type: string
 *                     example: Full-Time
 *                   shift:
 *                     type: string
 *                     example: Morning
 *                   section_id:
 *                     type: integer
 *                     example: 5
 *                   section_name:
 *                     type: string
 *                     example: Manufacturing
 *                   product:
 *                     type: integer
 *                     example: 3
 *                   roleid:
 *                     type: integer
 *                     example: 2
 *                   role:
 *                     type: string
 *                     example: Supervisor
 *                   passive_type:
 *                     type: string
 *                     example: ACT
 *                   category_type:
 *                     type: string
 *                     example: BRAID
 *       500:
 *         description: Internal Server Error.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 status:
 *                   type: string
 *                   example: Error
 *                 message:
 *                   type: string
 *                   example: Internal Server Error
 * @function
 * @name getShiftdataSearch
 * @memberof module:Routes/OTA
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */

// Get shift data search  view
app.get('/ota/get_shiftdata_search', authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    const { where } = req.query;
    const query = `
      SELECT employees_ota.*, section.section_name, geopos_emptype.name as role
      FROM employees_ota
      LEFT JOIN geopos_emptype ON employees_ota.roleid = geopos_emptype.id
      LEFT JOIN section ON employees_ota.section_id = section.id
      WHERE ${where}
      ORDER BY employees_ota.name ASC
    `;
    
    const result = await executeQuery(connection,query);
    res.send(result);
  } catch (error) {
    console.error(error);
    res.status(500).send('Internal Server Error');
  } finally {
    if (connection) {
      connection.release();
      //console.log("Connection released");
    }
  }
});
  
/**
 * @swagger
 * /ota/update_multiple_shift:
 *   post:
 *     summary: Update shift for multiple employees.
 *     description: Update the shift for multiple employees based on their entry IDs.
 *     tags:
 *       - OTA
 *     security:
 *       - BearerAuth: []
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             properties:
 *               shift:
 *                 type: string
 *                 description: The new shift to be assigned to the employees.
 *               entryIds:
 *                 type: string
 *                 description: Comma-separated list of entry IDs of the employees to be updated.
 *                 example: "123,456,789"
 *     responses:
 *       200:
 *         description: Shift updated successfully for all specified employees.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 status:
 *                   type: string
 *                   example: Success
 *                 message:
 *                   type: string
 *                   example: Details updated successfully.
 *       500:
 *         description: Internal Server Error.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 status:
 *                   type: string
 *                   example: Error
 *                 message:
 *                   type: string
 *                   example: Internal Server Error
 * @function
 * @name updateMultipleShift
 * @memberof module:Routes/OTA
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */

// Multiple shift data update
app.post('/ota/update_multiple_shift', authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    const { shift, entryIds } = req.body;
    const entryIdsArray = entryIds.split(',');
    const checkQuery = 'SELECT * FROM employees_ota WHERE id = ? ';
    const updateQuery = 'UPDATE employees_ota SET shift=? WHERE id = ?';

    let processedCount = 0;

    for (const entryId of entryIdsArray) {
      const checkValues = [entryId];
      const [checkResult] = await executeQuery(connection,checkQuery, checkValues);

      if (checkResult) {
        const updateValues = [shift, entryId];
        await executeQuery(connection,updateQuery, updateValues);
        processedCount++;
        console.log(`Data updated for entryId: ${entryId}`);
      } else {
        console.log(`Employee not found for entryId: ${entryId}`);
      }
    }

    if (processedCount === entryIdsArray.length) {
      res.json({ status: 'Success', message: 'Details updated successfully.' });
    }
  } catch (error) {
    console.error('Error updating shift:', error);
    res.status(500).json({ status: 'Error', message: 'Internal Server Error' });
  } finally {
    if (connection) {
      connection.release();
      //console.log("Connection released");
    }
  }
});


//Change worker type
/**
 * @swagger
 * /ota/getWorkerTypeDefaultData:
 *   get:
 *     summary: Get default data for worker types.
 *     description: Retrieve default data for worker types with category type NBRAID.
 *     tags:
 *       - OTA
 *     security:
 *       - BearerAuth: []
 *     responses:
 *       200:
 *         description: Default data for worker types retrieved successfully.
 *         content:
 *           application/json:
 *             schema:
 *               type: array
 *               items:
 *                 type: object
 *                 properties:
 *                   // Define properties based on the response data structure
 *       500:
 *         description: Internal Server Error.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 message:
 *                   type: string
 *                   example: Internal Server Error
 * @function
 * @name getWorkerTypeDefaultData
 * @memberof module:Routes/OTA
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */

// Get worker type  default view
app.get('/ota/getWorkerTypeDefaultData', authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    const query =
      `SELECT employees_ota.*, section.section_name, item_masterr.item_description, geopos_emptype.name AS role
      FROM employees_ota
      LEFT JOIN geopos_emptype ON employees_ota.roleid = geopos_emptype.id
      LEFT JOIN section ON employees_ota.section_id = section.id
      LEFT JOIN item_masterr ON employees_ota.product = item_masterr.id
      WHERE employees_ota.roleid != '3' AND employees_ota.passive_type = 'ACT' AND employees_ota.category_type = 'NBRAID'`;

    const result = await executeQuery(connection,query);

    res.send(result);
  } catch (error) {
    console.error('Error fetching default worker type data:', error);
    res.status(500).send('Internal Server Error');
  } finally {
    if (connection) {
      connection.release();
      //console.log("Connection released");
    }
  }
});
  
/**
 * @swagger
 * /ota/get_workerdata_search:
 *   get:
 *     summary: Get worker data based on search criteria.
 *     description: Retrieve worker data based on the specified search criteria.
 *     tags:
 *       - OTA
 *     security:
 *       - BearerAuth: []
 *     parameters:
 *       - in: query
 *         name: where
 *         description: The search criteria.
 *         required: true
 *         schema:
 *           type: string
 *     responses:
 *       200:
 *         description: Worker data retrieved successfully.
 *         content:
 *           application/json:
 *             schema:
 *               type: array
 *               items:
 *                 type: object
 *                 properties:
 *                   // Define properties based on the response data structure
 *       500:
 *         description: Internal Server Error.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 message:
 *                   type: string
 *                   example: Internal Server Error
 * @function
 * @name get_workerdata_search
 * @memberof module:Routes/OTA
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */

//Get worker type search data
app.get('/ota/get_workerdata_search', authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    const { where } = req.query;
    const query =
      `SELECT employees_ota.*, section.section_name, geopos_emptype.name AS role
      FROM employees_ota
      LEFT JOIN geopos_emptype ON employees_ota.roleid = geopos_emptype.id
      LEFT JOIN section ON employees_ota.section_id = section.id
      WHERE ${where} ORDER BY employees_ota.name ASC`;

    const result = await executeQuery(connection,query);

    res.send(result);
  } catch (error) {
    console.error('Error fetching worker data:', error);
    res.status(500).send('Internal Server Error');
  } finally {
    if (connection) {
      connection.release();
      //console.log("Connection released");
    }
  }
});
  
/**
 * @swagger
 * /ota/update_multiple_workertype:
 *   post:
 *     summary: Update multiple worker types.
 *     description: Update the worker type for multiple employees identified by their IDs.
 *     tags:
 *       - OTA
 *     security:
 *       - BearerAuth: []
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             properties:
 *               wtype:
 *                 type: string
 *                 description: The new worker type to be assigned to the employees.
 *               entryIds:
 *                 type: string
 *                 description: Comma-separated list of entry IDs of the employees to be updated.
 *     responses:
 *       200:
 *         description: Details updated successfully.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 status:
 *                   type: string
 *                   example: Success
 *                 message:
 *                   type: string
 *                   example: Details updated successfully.
 *       500:
 *         description: Internal Server Error.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 status:
 *                   type: string
 *                   example: Error
 *                 message:
 *                   type: string
 *                   example: Internal Server Error
 * @function
 * @name update_multiple_workertype
 * @memberof module:Routes/OTA
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */

//Multiple update worker type data    
app.post('/ota/update_multiple_workertype', authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    const { wtype, entryIds } = req.body;
    const entryIdsArray = entryIds.split(',');

    const checkQuery = 'SELECT * FROM employees_ota WHERE id = ?';
    const updateQuery = 'UPDATE employees_ota SET workertype = ? WHERE id = ?';

    let processedCount = 0;

    for (const entryId of entryIdsArray) {
      const [checkResult] = await executeQuery(connection,checkQuery, [entryId]);

      if (checkResult) {
        const id = checkResult.id;
        await executeQuery(connection,updateQuery, [wtype, id]);
        processedCount++;
        console.log(`Data updated for entryId: ${entryId}`);
      } else {
        processedCount++;
        console.log(`Employee not found for entryId: ${entryId}`);
      }
    }

    if (processedCount === entryIdsArray.length) {
      res.json({ status: 'Success', message: 'Details updated successfully.' });
    }
  } catch (error) {
    console.error('Error updating workertype:', error);
    res.status(500).json({ status: 'Error', message: 'Internal Server Error' });
  }  finally {
    if (connection) {
      connection.release();
      //console.log("Connection released");
    }
  }
});


//Employee FDA
/**
 * @swagger
 * /ota/getEmployeeFdaData:
 *   get:
 *     summary: Get FDA (First Date of Absence) data for employees within the last 3 months.
 *     description: Retrieve FDA data for employees who exited within the last 3 months.
 *     tags:
 *       - OTA
 *     security:
 *       - BearerAuth: []
 *     responses:
 *       200:
 *         description: FDA data retrieved successfully.
 *         content:
 *           application/json:
 *             schema:
 *               type: array
 *               items:
 *                 type: object
 *                 properties:
 *                   // Define properties based on the structure of the returned data
 *       500:
 *         description: Internal Server Error.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 status:
 *                   type: string
 *                   example: Error
 *                 message:
 *                   type: string
 *                   example: Internal Server Error
 * @function
 * @name getEmployeeFdaData
 * @memberof module:Routes/OTA
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */

// Get employee fda data default view
app.get('/ota/getEmployeeFdaData', authenticateJWT, async (req, res) => {
  let connection
  try {
    connection = await getPoolConnection();
    const today = new Date();
    const dateThreeMonthsAgo = new Date(today);
    dateThreeMonthsAgo.setMonth(today.getMonth() - 3);
    const firstDayOfCurrentMonth = new Date(today.getFullYear(), today.getMonth(), 1);

    const query =
      `SELECT employees_ota_attrition.*
      FROM employees_ota_attrition
      WHERE STR_TO_DATE(exitdate, "%d-%m-%Y") >= ? 
        AND STR_TO_DATE(exitdate, "%d-%m-%Y") < ?;`;

    const values = [dateThreeMonthsAgo, firstDayOfCurrentMonth];
    const result = await executeQuery(connection,query, values);

    res.send(result);
    console.log(result, '---------------');
  } catch (error) {
    console.error('Error fetching FDA data:', error);
    res.status(500).send('Internal Server Error');
  }  finally {
    if (connection) {
      connection.release();
      //console.log("Connection released");
    }
  }
});
       
//------------------OTA END----------------------//

//----------------------------HRM--------------------------------//

//getshift
app.get('/getShiftOptions', authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    const query = 'SELECT * FROM geopos_shift';
    const results = await executeQuery(connection,query);
    res.json(results);
  } catch (error) {
    console.error('Error fetching shift data:', error);
    res.status(500).json({ error: 'Failed to fetch shift data' });
  } finally {
    if (connection) {
      connection.release();
      //console.log("Connection released");
    }
  }
});


//getsection
app.get('/getSectionOptions', authenticateJWT, async (req, res) => {
  const query = `SELECT * FROM section WHERE status='1'`;
 let connection;
  try {
    connection = await getPoolConnection();
    const results = await executeQuery(connection,query);
    res.json(results);
  } catch (error) {
    console.error('Error fetching section data:', error);
    res.status(500).json({ error: 'Failed to fetch section data' });
  } finally {
    if (connection) {
      connection.release();
      //console.log("Connection released");
    }
  }
});


//getsection for operator login
app.get('/getSectionOptionsOpLogin/:userid', authenticateJWT, async (req, res) => {
  const { userid } = req.params;
 let connection;
  try {
    connection = await getPoolConnection();
    // Fetch user data
    const userResults = await executeQuery(connection,'SELECT * FROM geopos_users WHERE id = ?', [userid]);

    if (userResults.length === 0) {
      res.status(404).json({ error: 'User not found' });
      return;
    }

    const user = userResults[0];
    const eid = user.entryid;
    const site = user.production_type;
    const ctype = user.category_type;

    let shiftResults;

    // Fetch shift data based on site and category type
    if (site === 'ota' && ctype === 'NBRAID') {
      shiftResults = await executeQuery(connection,'SELECT * FROM employees_ota WHERE entryid = ?', [eid]);
    } else {
      shiftResults = await executeQuery(connection,'SELECT * FROM geopos_employees WHERE entryid = ?', [eid]);
    }

    if (shiftResults.length === 0) {
      res.status(404).json({ error: 'Shift data not found' });
      return;
    }

    const shift = shiftResults[0].shift;

    // Fetch sections based on user, shift, and category type
    let sectionsResults;

    if (site === 'ota' && ctype === 'NBRAID') {
      sectionsResults = await executeQuery(connection,`
        SELECT operator_assign.*, section.*
        FROM operator_assign
        LEFT JOIN section ON operator_assign.section = section.id
        WHERE operator_assign.name_id = ? AND operator_assign.shift = ? AND operator_assign.category_type = 'NBRAID'
        GROUP BY operator_assign.section
      `, [userid, shift]);
    } else {
      sectionsResults = await executeQuery(connection,`
        SELECT operator_assign_ikeja.*, section.*
        FROM operator_assign_ikeja
        LEFT JOIN section ON operator_assign_ikeja.section = section.id
        WHERE operator_assign_ikeja.operator_id = ? AND operator_assign_ikeja.shift = ? AND operator_assign_ikeja.category_type = 'NBRAID'
        GROUP BY operator_assign_ikeja.section
      `, [userid, shift]);
    }

    res.json(sectionsResults);
  } catch (error) {
    console.error('Error fetching data:', error);
    res.status(500).json({ error: 'Failed to fetch data' });
  } finally {
    if (connection) {
      connection.release();
      //console.log("Connection released");
    }
  }
});


//get product name braid
app.get('/getProductOptions', authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    const query = 'SELECT * FROM item_masterr WHERE category_id IN (?, ?)';
    const results = await executeQuery(connection, query, [1, 3]);
    res.json(results);
  } catch (error) {
    console.error('Error fetching product data:', error);
    res.status(500).json({ error: 'Failed to fetch product data' });
  } finally {
    if (connection) {
      connection.release();
      //console.log("Connection released");
    }
  }
});



//get product name nbraid
app.get('/getProductOptionsnbraid', authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    const query = 'SELECT * FROM item_masterr WHERE category_id IN (?, ?)';
    const results = await executeQuery(connection,query, [2, 3]);
    res.json(results);
  } catch (error) {
    console.error('Error fetching product data:', error);
    res.status(500).json({ error: 'Failed to fetch product data' });
  } finally {
    if (connection) {
      connection.release();
      //console.log("Connection released");
    }
  }
});

//get product name braid
app.get('/getProductOptionsnbraidotalist', authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    const query = `SELECT item_masterr.*, item_category.category_name
    FROM item_masterr
    LEFT JOIN item_category ON item_masterr.category_id = item_category.id`;

    const results = await executeQuery(connection,query);
    res.json(results);
  } catch (error) {
    console.error('Error fetching product data:', error);
    res.status(500).json({ error: 'Failed to fetch product data' });
  } finally {
    if (connection) {
      connection.release();
     
    }
  }
});




// Define a route for fetching line options
app.get('/getLineOptions/:line', authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    const line = req.params.line;
    const query = 'SELECT * FROM line_master WHERE id = ? AND status = 1';
    const results = await executeQuery(connection,query, [line]);

    res.json(results);
  } catch (error) {
    console.error('Error fetching line:', error);
    res.status(500).json({ error: 'Failed to fetch line' });
  } finally {
    if (connection) {
      connection.release();
      //console.log("Connection released");
    }
  }
});

//getline without product 
app.get('/getindividualLineOptions/:roleid/:userid', authenticateJWT, async (req, res) => {
  const { roleid, userid } = req.params;
  console.log('roleid:', roleid);
  console.log('userid:', userid);
  let connection;
  try {
    connection = await getPoolConnection();
    if (roleid === '3') {
      // Implement logic for roleid 3
      const id = userid;
      console.log('id:', id);
      const userData = await executeQuery(connection,'SELECT * FROM geopos_users WHERE id = ?', [id]);
      
      if (userData.length === 0) {
        res.status(404).json({ error: 'User not found' });
        return;
      }

      const site = userData[0].production_type;
      const ctype = userData[0].category_type;

      let strQuery, params;

      if (site === 'ota' && ctype === 'NBRAID') {
        strQuery = `SELECT * FROM operator_assign WHERE name_id = ? GROUP BY line`;
        params = [id];
      } else if (site === 'ikeja' && ctype === 'NBRAID') {
        strQuery = `SELECT * FROM operator_assign_ikeja WHERE operator_id = ? GROUP BY line`;
        params = [id];
      } else {
        res.status(400).json({ error: 'Invalid site or category type' });
        return;
      }

      const results = await executeQuery(connection,strQuery, params);
      res.json(results);
    } else if (roleid === '5') {
      // Implement logic for roleid 5
      const results = await executeQuery(connection,'SELECT * FROM line_master WHERE status = 1');
      res.json(results);
    } else {
      res.status(400).json({ error: 'Invalid roleid' });
    }
  } catch (error) {
    console.error('Error:', error);
    res.status(500).json({ error: 'Internal Server Error' });
  } finally {
    if (connection) {
      connection.release();
      //console.log("Connection released");
    }
  }  
});





//getline without product 
app.get('/getindividualLineOptionss', authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    const query = 'SELECT * FROM line_master WHERE status = 1';
    const results = await executeQuery(connection,query);
    res.json(results);
  } catch (error) {
    console.error('Error fetching line:', error);
    res.status(500).json({ error: 'Failed to fetch line' });
  } finally {
    if (connection) {
      connection.release();
      //console.log("Connection released");
    }
  }
});


//get worker name 
app.get('/getWorkerOptions', authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    const where = "roleid != '3'";
    const query = `
      SELECT *
      FROM employees_moz
      WHERE ${where}
      GROUP BY name
    `;
    
    const results = await executeQuery(connection,query);
    res.json(results);
  } catch (error) {
    console.error('Error fetching worker data:', error);
    res.status(500).json({ error: 'Failed to fetch worker data' });
  } finally {
    if (connection) {
      connection.release();
      //console.log("Connection released");
    }
  }
});

//get category name options
app.get('/getCategoryOptions', authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    const query = `
      SELECT *
      FROM item_category
    `;

    const results = await executeQuery(connection,query);
    res.json(results);
  } catch (error) {
    console.error('Error fetching category data:', error);
    res.status(500).json({ error: 'Failed to fetch category data' });
  } finally {
    if (connection) {
      connection.release();
      //console.log("Connection released");
    }
  }
});

/**
 * @swagger
 * /getIkejaOperatorOptions:
 *   get:
 *     summary: Retrieve Ikeja operator options.
 *     description: Fetches a list of users with a role ID of 3, production type 'ikeja', and who are not banned.
 *     tags:
 *       - Operators
 *     security:
 *       - BearerAuth: []
 *     responses:
 *       200:
 *         description: Successful response with a list of Ikeja operator options.
 *         content:
 *           application/json:
 *             schema:
 *               type: array
 *               items:
 *                 type: object
 *                 properties:
 *                   id:
 *                     type: integer
 *                     description: The ID of the operator.
 *                     example: 101
 *                   username:
 *                     type: string
 *                     description: The username of the operator.
 *                     example: "john_doe"
 *                   production_type:
 *                     type: string
 *                     description: The production type of the operator.
 *                     example: "ikeja"
 *                   banned:
 *                     type: boolean
 *                     description: Whether the operator is banned or not.
 *                     example: false
 *       500:
 *         description: An error occurred while fetching operator options.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: "Failed to fetch operator"
 *
 * @function
 * @name getIkejaOperatorOptions
 * @memberof module:Routes/Operators
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with executing the MySQL query.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
//get operators for ikeja
app.get('/getIkejaOperatorOptions', authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    const query = `SELECT * FROM geopos_users WHERE roleid = 3 AND production_type = 'ikeja' AND banned = 0;`;

    // Execute the query
    const results = await executeQuery(connection, query);

    res.status(200).json(results);
  } catch (error) {
    console.error('Error fetching operator:', error);
    res.status(500).json({ error: 'Failed to fetch operator' });
  } finally {
    // Release the connection back to the pool in case of success or error
    if (connection) {
      connection.release();
    }
  }
});

/**
 * @swagger
 * /getOtaOperatorOptions:
 *   get:
 *     summary: Retrieve OTA operator options.
 *     description: Fetches a list of users with a role ID of 3, production type 'ota', and who are not banned.
 *     tags:
 *       - Operators
 *     security:
 *       - BearerAuth: []
 *     responses:
 *       200:
 *         description: Successful response with a list of OTA operator options.
 *         content:
 *           application/json:
 *             schema:
 *               type: array
 *               items:
 *                 type: object
 *                 properties:
 *                   id:
 *                     type: integer
 *                     description: The ID of the operator.
 *                     example: 101
 *                   username:
 *                     type: string
 *                     description: The username of the operator.
 *                     example: "john_doe"
 *                   production_type:
 *                     type: string
 *                     description: The production type of the operator.
 *                     example: "ota"
 *                   banned:
 *                     type: boolean
 *                     description: Whether the operator is banned or not.
 *                     example: false
 *       500:
 *         description: An error occurred while fetching operator options.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: "Failed to fetch operator"
 *
 * @function
 * @name getOtaOperatorOptions
 * @memberof module:Routes/Operators
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with executing the MySQL query.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
//get operators for ota
app.get('/getOtaOperatorOptions', authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    const query = `SELECT * FROM geopos_users WHERE roleid = 3 AND production_type = 'ota' AND banned = 0;`;

    // Execute the query
    const results = await executeQuery(connection, query);

    res.status(200).json(results);
  } catch (error) {
    console.error('Error fetching operator:', error);
    res.status(500).json({ error: 'Failed to fetch operator' });
  } finally {
    // Release the connection back to the pool in case of success or error
    if (connection) {
      connection.release();
    }
  }
});

/**
 * @swagger
 * /ikeja/search_operator_assignlist:
 *   post:
 *     summary: Search operator assignment list for Ikeja.
 *     description: Retrieves a list of operator assignments based on search criteria like operator name, shift, line number, and section.
 *     tags:
 *       - Operators
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             properties:
 *               operator_name:
 *                 type: string
 *                 description: Name or ID of the operator.
 *                 example: "JohnDoe"
 *               name:
 *                 type: string
 *                 description: Full name of the operator.
 *                 example: "John Doe"
 *               shift:
 *                 type: string
 *                 description: Shift of the operator.
 *                 example: "DAY"
 *               line_no:
 *                 type: string
 *                 description: Line number assigned to the operator.
 *                 example: "Line1"
 *               section:
 *                 type: string
 *                 description: Section assigned to the operator.
 *                 example: "SectionA"
 *               section_name:
 *                 type: string
 *                 description: Name of the section.
 *                 example: "Assembly"
 *     responses:
 *       200:
 *         description: Successful response with a list of operator assignments.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 timesheet:
 *                   type: array
 *                   items:
 *                     type: object
 *                 name:
 *                   type: string
 *                   example: "John Doe"
 *                 shift:
 *                   type: string
 *                   example: "DAY"
 *                 line:
 *                   type: string
 *                   example: "Line1"
 *                 section_name:
 *                   type: string
 *                   example: "Assembly"
 *       500:
 *         description: Internal server error.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: "Internal server error"
 *
 * @function
 * @name searchOperatorAssignList
 * @memberof module:Routes/Operators
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with executing the MySQL query.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
app.post('/ikeja/search_operator_assignlist', authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    
    // Extract data from request body
    const { operator_name: name, name: fullname, shift, line: line_no, section, section_name } = req.body;

    // Log the received data
    console.log('Received data:');
    console.log('Operator:', name);
    console.log('Operator Full name:', fullname);
    console.log('Shift:', shift);
    console.log('Line:', line_no);
    console.log('Section:', section);
    console.log('Section Name:', section_name);

    let whereClause = "(operator_assign_ikeja.category_type ='NBRAID')";

    if (shift) {
      whereClause += ` AND operator_assign_ikeja.shift='${shift}'`;
    }
    if (section) {
      whereClause += ` AND operator_assign_ikeja.section='${section}'`;
    }
    if (line_no) {
      whereClause += ` AND operator_assign_ikeja.line='${line_no}'`;
    }
    if (name) {
      whereClause += ` AND operator_assign_ikeja.operator_id='${name}'`;
    }

    const sql = `
      SELECT operator_assign_ikeja.*, geopos_users.entryid, geopos_users.roleid,
             geopos_users.name, section.section_name
      FROM operator_assign_ikeja
      LEFT JOIN geopos_users ON operator_assign_ikeja.operator_id = geopos_users.id
      LEFT JOIN section ON operator_assign_ikeja.section = section.id
      WHERE ${whereClause};
    `;

    const results = await executeQuery(connection, sql);

    res.json({ timesheet: results, name: fullname, shift, line: line_no, section_name });
  } catch (error) {
    console.error('Error executing MySQL query: ' + error);
    res.status(500).json({ error: 'Internal server error' });
  } finally {
    if (connection) {
      connection.release();
    }
  }
});



/**
 * @swagger
 * /ota/search_operator_assignlist_ota:
 *   post:
 *     summary: Search operator assignment list for OTA.
 *     description: Retrieves a list of operator assignments based on search criteria like operator name, shift, line number, and section.
 *     tags:
 *       - Operators
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             properties:
 *               operator_name:
 *                 type: string
 *                 description: Name or ID of the operator.
 *                 example: "JaneDoe"
 *               name:
 *                 type: string
 *                 description: Full name of the operator.
 *                 example: "Jane Doe"
 *               shift:
 *                 type: string
 *                 description: Shift of the operator.
 *                 example: "NIGHT"
 *               line_no:
 *                 type: string
 *                 description: Line number assigned to the operator.
 *                 example: "Line2"
 *               section:
 *                 type: string
 *                 description: Section assigned to the operator.
 *                 example: "SectionB"
 *               section_name:
 *                 type: string
 *                 description: Name of the section.
 *                 example: "Packing"
 *     responses:
 *       200:
 *         description: Successful response with a list of operator assignments.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 timesheet:
 *                   type: array
 *                   items:
 *                     type: object
 *                 name:
 *                   type: string
 *                   example: "Jane Doe"
 *                 shift:
 *                   type: string
 *                   example: "NIGHT"
 *                 line:
 *                   type: string
 *                   example: "Line2"
 *                 section_name:
 *                   type: string
 *                   example: "Packing"
 *       500:
 *         description: Internal server error.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: "Internal server error"
 *
 * @function
 * @name searchOperatorAssignListOta
 * @memberof module:Routes/Operators
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with executing the MySQL query.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
app.post('/ota/search_operator_assignlist_ota', authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    
    // Extract data from request body
    const { operator_name: name, name: fullname, shift, line: line_no, section, section_name } = req.body;

    // Log the received data
    console.log('Received data:');
    console.log('Operator:', name);
    console.log('Operator Full name:', fullname);
    console.log('Shift:', shift);
    console.log('Line:', line_no);
    console.log('Section:', section);
    console.log('Section Name:', section_name);

    let whereClause = "(operator_assign.category_type ='NBRAID')";

    if (shift) {
      whereClause += ` AND operator_assign.shift='${shift}'`;
    }
    if (section) {
      whereClause += ` AND operator_assign.section='${section}'`;
    }
    if (line_no) {
      whereClause += ` AND operator_assign.line='${line_no}'`;
    }
    if (name) {
      whereClause += ` AND operator_assign.name_id='${name}'`;
    }

    const sql = `
      SELECT operator_assign.*, geopos_users.entryid, geopos_users.roleid,
             geopos_users.name, section.section_name
      FROM operator_assign
      LEFT JOIN geopos_users ON operator_assign.name_id = geopos_users.id
      LEFT JOIN section ON operator_assign.section = section.id
      WHERE ${whereClause};
    `;

    const results = await executeQuery(connection, sql);

    res.json({ timesheet: results, name: fullname, shift, line: line_no, section_name });
  } catch (error) {
    console.error('Error executing MySQL query: ' + error);
    res.status(500).json({ error: 'Internal server error' });
  } finally {
    if (connection) {
      connection.release();
    }
  }
});




//-----------------------------------------------------------REPORTS ----------------------------------------------------------------//

//BRAID REPORTS

//Performance Eff individual Report

//Performance eff individual braid
/**
 * @swagger
 * /report/getEmployeesikeja:
 *   get:
 *     summary: Fetches a list of employees from the operator_section table.
 *     description: Retrieves a list of employees from the operator_section table, grouped by empid and ordered by emp in ascending order.
 *     tags:
 *       - Employee Reports
 *     security:
 *       - BearerAuth: []
 *     responses:
 *       200:
 *         description: A list of employees retrieved successfully.
 *         content:
 *           application/json:
 *             schema:
 *               type: array
 *               items:
 *                 type: object
 *       500:
 *         description: Error occurred while fetching the list of employees.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: Internal Server Error
 * @function
 * @name getEmployeesIkeja
 * @memberof module:Routes/EmployeeReports
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with executing the MySQL query.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
app.get('/report/getEmployeesikeja', authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    const query = 'SELECT * FROM operator_section GROUP BY empid ORDER BY emp ASC';
    const result = await executeQuery(connection,query);

    res.send(result);
  } catch (error) {
    console.error('Error executing MySQL query:', error);
    res.status(500).send('Internal Server Error');
  } finally {
    if (connection) {
      connection.end();
    }
  }
});


//Get Filter Search  Performance Eff individual data 
/**
 * @swagger
 * /braid/get_performance_eff_individual:
 *   post:
 *     summary: Get performance efficiency of individual employees
 *     tags:
 *       - Performance
 *     security:
 *       - bearerAuth: []
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             properties:
 *               employees:
 *                 type: string
 *                 example: "12345"
 *               fromdate:
 *                 type: string
 *                 format: date
 *                 example: "01-01-2023"
 *               todate:
 *                 type: string
 *                 format: date
 *                 example: "31-01-2023"
 *     responses:
 *       200:
 *         description: Successful response
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 fd:
 *                   type: string
 *                   example: "01-01-2023"
 *                 ld:
 *                   type: string
 *                   example: "31-01-2023"
 *                 items:
 *                   type: array
 *                   items:
 *                     type: object
 *                     properties:
 *                       emp:
 *                         type: string
 *                         example: "John Doe"
 *                       empid:
 *                         type: string
 *                         example: "12345"
 *                       doj:
 *                         type: string
 *                         example: "01-01-2020"
 *                       total_days:
 *                         type: string
 *                         example: "30 Days"
 *                       shift:
 *                         type: string
 *                         example: "Morning"
 *                       section:
 *                         type: string
 *                         example: "Section A"
 *                       item_name:
 *                         type: string
 *                         example: "Item 1"
 *                       zone:
 *                         type: string
 *                         example: "Zone A"
 *                       machine:
 *                         type: string
 *                         example: "Machine 1"
 *                       tar1:
 *                         type: number
 *                         example: 100
 *                       total:
 *                         type: number
 *                         example: 95
 *                       eff:
 *                         type: string
 *                         example: "95.00"
 *                       dt:
 *                         type: string
 *                         example: "01-01-2023"
 *                       site:
 *                         type: string
 *                         example: "OTA"
 *                       fd:
 *                         type: string
 *                         example: "01-01-2023"
 *                       ld:
 *                         type: string
 *                         example: "31-01-2023"
 *                       daycount:
 *                         type: number
 *                         example: 30
 *                       avgeff:
 *                         type: string
 *                         example: "95.00"
 *       500:
 *         description: Internal Server Error
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: Internal Server Error
 */
app.post('/braid/get_performance_eff_individual', authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    const employee = req.body.employees;
    const fromdate = req.body.fromdate;
    const fdParts = fromdate.split('-');
    const fd = `${fdParts[2]}-${fdParts[1]}-${fdParts[0]}`;

    const todate = req.body.todate;
    const tdParts = todate.split('-');
    const td = `${tdParts[2]}-${tdParts[1]}-${tdParts[0]}`;

    const dateObj = new Date(fromdate);
    const day = dateObj.getDate().toString().padStart(2, '0');
    const month = (dateObj.getMonth() + 1).toString().padStart(2, '0');
    const year = dateObj.getFullYear();

    const convertedDate = `${day}-${month}-${year}`;

    const dateObj1 = new Date(todate);
    const day1 = dateObj1.getDate().toString().padStart(2, '0');
    const month1 = (dateObj1.getMonth() + 1).toString().padStart(2, '0');
    const year1 = dateObj1.getFullYear();

    const convertedDate1 = `${day1}-${month1}-${year1}`;

    let whereConditions = [];
    whereConditions.push(`date BETWEEN '${convertedDate}' AND '${convertedDate1}'`);

    if (employee !== '') {
      whereConditions.push(`AND empid = '${employee}'`);
    }

    const whereClause = whereConditions.join(' ');

    const query = `SELECT * FROM operator_section WHERE ${whereClause}`;

    const results = await executeQuery(connection, query);

    const operatorSections = {
      fd: convertedDate,
      ld: convertedDate1,
      items: []
    };

    let dateArr = [];
    let dayCount = 0;

    // Use Promise.all for parallel processing of multiple async operations
    await Promise.all(results.map(async (item) => {
      const ids = item.opmanual_id.split(',');

      const operatorData = await executeQuery(connection, 'SELECT geopos_operator.*, COUNT(*) as individual_complete FROM geopos_operator WHERE id IN (?) GROUP BY item, zone, machine', [ids]);

      const mj = [];
      operatorData.forEach((res1) => {
        const str = `${item.empid}-${res1.item}-${res1.zone}-${res1.machine}-${item.date}`;
        if (!mj.includes(str)) {
          mj.push(str);
        }
      });

      let tar1 = '';
      let total = 0;
      let numb = 0;
      let eff = '';
      let total_eff_count = 0;
      let total_eff = 0;

      // Use Promise.all for parallel processing of multiple async operations
      await Promise.all(operatorData.map(async (res) => {
        const target = item.target;
        const str1 = `${item.empid}-${res.item}-${res.zone}-${res.machine}-${item.date}`;

        if (mj.includes(str1)) {
          const entryidoResult = await executeQuery(connection, 'SELECT * FROM employees_ota WHERE entryid=?', [item.empid]);
          const entryido = entryidoResult.length > 0 ? entryidoResult[0].entryid : null;

          const entryidiResult = await executeQuery(connection, 'SELECT * FROM geopos_employees WHERE entryid=?', [item.empid]);
          const entryidi = entryidiResult.length > 0 ? entryidiResult[0].entryid : null;

          const sectionNameResult = await executeQuery(connection, 'SELECT section_name FROM section WHERE id=?', [item.section_id]);
          const sectionName = sectionNameResult[0].section_name;

          const itemNameResult = await executeQuery(connection, 'SELECT item_description FROM item_masterr WHERE id=?', [res.item]);
          const itemDescription = itemNameResult[0].item_description;

          const querysResult = await executeQuery(connection, 'SELECT * FROM employees_ota WHERE entryid=?', [item.empid]);
          const num = querysResult.length;
          let site;
          let diff;
          let regg;

          if (num > 0) {
            const entryidoResult = await executeQuery(connection, 'SELECT * FROM employees_ota WHERE entryid=?', [item.empid]);
            const entryido = entryidoResult.length > 0 ? entryidoResult[0].entryid : null;

            regg = new Date(entryidoResult[0].joindate || null);
            const day = regg.getDate().toString().padStart(2, '0');
            const month = (regg.getMonth() + 1).toString().padStart(2, '0');
            const year = regg.getFullYear();

            regg = `${day}-${month}-${year}`;

            const datek1 = item.date;

            const reggParts = regg.split('-').map(Number);
            const datek1Parts = datek1.split('-').map(Number);

            const earlier = new Date(reggParts[2], reggParts[1] - 1, reggParts[0]);
            const later = new Date(datek1Parts[2], datek1Parts[1] - 1, datek1Parts[0]);

            if (!isNaN(earlier) && !isNaN(later)) {
              const timeDiff = Math.abs(later - earlier);
              diff = Math.ceil(timeDiff / (1000 * 60 * 60 * 24));
            } else {
              console.log('Date parsing failed for regg or datek1');
            }
            site = 'OTA';
          } else {
            const entryidiResult = await executeQuery(connection, 'SELECT * FROM geopos_employees WHERE entryid=?', [item.empid]);
            const entryidi = entryidiResult.length > 0 ? entryidiResult[0].entryid : null;

            regg = new Date(entryidiResult[0].joindate);
            const day = regg.getDate().toString().padStart(2, '0');
            const month = (regg.getMonth() + 1).toString().padStart(2, '0');
            const year = regg.getFullYear();

            regg = `${day}-${month}-${year}`;

            const datek1 = item.date;

            const reggParts = regg.split('-').map(Number);
            const datek1Parts = datek1.split('-').map(Number);

            const earlier = new Date(reggParts[2], reggParts[1] - 1, reggParts[0]);
            const later = new Date(datek1Parts[2], datek1Parts[1] - 1, datek1Parts[0]);

            if (!isNaN(earlier) && !isNaN(later)) {
              const timeDiff = Math.abs(later - earlier);
              diff = Math.ceil(timeDiff / (1000 * 60 * 60 * 24));
            } else {
              console.log('Date parsing failed for regg or datek1');
            }
            site = 'IKEJA';

            if (convertedDate !== '' && convertedDate1 !== '') {
              const rows = await executeQuery(connection, 'SELECT * FROM operator_section WHERE date = ? AND empid = ?', [item.date, item.empid]);

              if (Array.isArray(rows) && rows.length > 0) {
                for (const rs of rows) {
                  const ra = rs.opmanual_id.split(',');
                  const comp1 = rs.complete.split(',');

                  const results = await executeQuery(connection, 'SELECT geopos_operator.*, COUNT(*) AS datewise_individual_complete FROM geopos_operator WHERE id IN (?) AND item = ? AND zone = ? AND machine = ?', [ra, res.item, res.zone, res.machine]);

                  if (Array.isArray(results) && results.length > 0) {
                    numb = results[0].datewise_individual_complete;

                    const results2 = await executeQuery(connection, 'SELECT geopos_operator.* FROM geopos_operator WHERE id IN (?) AND item = ? AND zone = ? AND machine = ?', [ra, res.item, res.zone, res.machine]);

                    for (const rs2 of results2) {
                      const numericValue = parseFloat(rs2.id.toString().replace(/\s/g, ''));

                      if (!isNaN(numericValue)) {
                        const index = ra.findIndex(id => id === numericValue.toString());

                        if (index !== -1) {
                          total += +comp1[index];
                        }
                      }
                    }

                    tar1 = target * numb;
                    const eff1 = (total / tar1) * 100;
                    eff = eff1.toFixed(2);
                    total_eff += eff;
                    total_eff_count++;

                    const datee = item.date;

                    if (!dateArr.includes(datee)) {
                      dateArr.push(datee);
                      dayCount++;
                    }

                    let tteff = total_eff / total_eff_count;
                    let ttefff = tteff.toFixed(2);

                    const data = {
                      emp: item.emp,
                      empid: item.empid,
                      doj: regg,
                      total_days: `${diff} Days`,
                      shift: res.shift,
                      section: sectionName,
                      item_name: itemDescription,
                      zone: res.zone,
                      machine: res.machine,
                      tar1: tar1,
                      total: total,
                      eff: eff,
                      dt: item.date,
                      site: site,
                      fd: convertedDate,
                      ld: convertedDate1,
                      daycount: dayCount,
                      avgeff: ttefff,
                    };

                    operatorSections.items.push(data);
                    console.log(operatorSections);
                  }
                }
              }
            }
          }
        }
      }));
    }));

    res.json(operatorSections);
  } catch (error) {
    console.error('Error executing database query:', error);
    res.status(500).json({ error: 'Internal Server Error' });
  } finally {
    if (connection) {
      connection.end();
    }
  }
});



//PLAN  VS ACTUAL Report

//Plan Vs Actual Report default search
/**
 * @swagger
 * /braid/getPlanVsactualReportDefault:
 *   get:
 *     summary: Get Plan vs Actual Report Default
 *     tags:
 *       - Reports
 *     security:
 *       - bearerAuth: []
 *     responses:
 *       200:
 *         description: Successful response
 *         content:
 *           application/json:
 *             schema:
 *               type: array
 *               items:
 *                 type: object
 *                 properties:
 *                   product:
 *                     type: string
 *                     example: "Product A"
 *                   total:
 *                     type: number
 *                     example: 100
 *                   sump:
 *                     type: number
 *                     example: 90
 *       500:
 *         description: Internal Server Error
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: Internal Server Error
 */
app.get('/braid/getPlanVsactualReportDefault', authenticateJWT, async (req, res) => {
  let connection;
  const timeZone = 'Africa/Lagos';
  const options = {
    day: '2-digit',
    month: '2-digit',
    year: 'numeric',
  };
  const date = new Date().toLocaleDateString('en-NG', options).replace(/\//g, '-');
  const targetPlan = 0;
  const category = 1;
  const itemCodeId = 0;
  const query = `
    SELECT *, target_plan as tot
    FROM target_plan_ota
    WHERE date = ? AND target_plan > ? AND category = ? AND item_code_id != ?
  `;

  try {
    connection = await getPoolConnection();
    const results = await executeQuery(connection,query, [date, targetPlan, category, itemCodeId]);

    const data = [];

    for (const item of results) {
      const prdd = item.item_code_id;
      const itemCodeQuery = `SELECT * FROM item_code WHERE id = ?`;
      const rows = await executeQuery(connection,itemCodeQuery, [prdd]);

      if (rows.length > 0) {
        const pro = rows[0].product_des;
        const col = rows[0].color_id;
        const prdid = rows[0].product_id;

        const where2 = `date='${date}' and color_id='${col}'`;
        const geoposOperatorQuery = `
          SELECT SUM(fg_output) as tar
          FROM geopos_operator
          WHERE ${where2}
          GROUP BY item, date
        `;

        const rows = await executeQuery(connection,geoposOperatorQuery);

        if (rows.length > 0) {
          const sump = rows[0].tar;
          data.push({
            product: pro,
            total: item.tot,
            sump: sump,
          });
        }
      }
    }

    if (data.length === 0) {
      res.json({});
    } else {
      res.json(data);
    }
  } catch (error) {
    console.error('Error executing database query:', error);
    res.status(500).json({ error: 'Internal Server Error' });
  } finally {
    if (connection) {
      connection.end();
    }
  }
});


//Plan Vs Actual Report date wise search 
/**
 * @swagger
 * /braid/getPlanVsactualReportSearch:
 *   post:
 *     summary: Get Plan vs Actual Report for a specified date range
 *     tags:
 *       - Reports
 *     security:
 *       - bearerAuth: []
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             properties:
 *               fromdate:
 *                 type: string
 *                 format: date
 *                 example: "2023-01-01"
 *               todate:
 *                 type: string
 *                 format: date
 *                 example: "2023-01-31"
 *     responses:
 *       200:
 *         description: Successful response
 *         content:
 *           application/json:
 *             schema:
 *               type: array
 *               items:
 *                 type: object
 *                 properties:
 *                   product:
 *                     type: string
 *                     example: "Product A"
 *                   total:
 *                     type: number
 *                     example: 100
 *                   sump:
 *                     type: number
 *                     example: 90
 *                   fdate:
 *                     type: string
 *                     example: "01-01-2023"
 *                   tdate:
 *                     type: string
 *                     example: "31-01-2023"
 *       500:
 *         description: Internal Server Error
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: Internal Server Error
 */
app.post('/braid/getPlanVsactualReportSearch', authenticateJWT, async (req, res) => {
  const timeZone = 'Africa/Lagos';
  const options = {
    day: '2-digit',
    month: '2-digit',
    year: 'numeric',
  };
  const date = new Date().toLocaleDateString('en-NG', options).replace(/\//g, '-');
  const fromdate = req.body.fromdate;
  const fdParts = fromdate.split('-');
  const fd = `${fdParts[2]}-${fdParts[1]}-${fdParts[0]}`;
  const todate = req.body.todate;
  const tdParts = todate.split('-');
  const td = `${tdParts[2]}-${tdParts[1]}-${tdParts[0]}`;
  const dateObj = new Date(fromdate);
  const day = dateObj.getDate().toString().padStart(2, '0');
  const month = (dateObj.getMonth() + 1).toString().padStart(2, '0');
  const year = dateObj.getFullYear();
  const convertedDate = `${day}-${month}-${year}`;
  const dateObj1 = new Date(todate);
  const day1 = dateObj1.getDate().toString().padStart(2, '0');
  const month1 = (dateObj1.getMonth() + 1).toString().padStart(2, '0');
  const year1 = dateObj1.getFullYear();
  const convertedDate1 = `${day1}-${month1}-${year1}`;
  const fd2 = Math.floor(new Date(fromdate).getTime() / 1000);
  const td1 = Math.floor(new Date(todate).getTime() / 1000);
  const fd1 = Math.floor(new Date(fd2 * 1000).setDate(new Date(fd2 * 1000).getDate() - 1) / 1000);
  var newfd = fd2;
  var newtd = td1;
  let connection;
  try {
    connection = await getPoolConnection();
    const where = `(timestamp BETWEEN ${newfd} AND ${newtd} AND target_plan > 0 AND category = '1' AND item_code_id != '0')`;
    const query = `
      SELECT *, SUM(target_plan) as tot
      FROM target_plan_ota
      WHERE ${where}
      GROUP BY item_code_id
    `;

    const results = await executeQuery(connection, query);

    const data = [];

    for (const item of results) {
      const prdd = item.item_code_id;
      const itemCodeQuery = `SELECT * FROM item_code WHERE id = ?`;
      const rowsItem = await executeQuery(connection, itemCodeQuery, [prdd]);

      if (rowsItem.length > 0) {
        const pro = rowsItem[0].product_des;
        const col = rowsItem[0].color_id;
        const prdid = rowsItem[0].product_id;

        const geoposOperatorQuery = `
          SELECT SUM(a.tar) as res
          FROM (SELECT SUM(fg_output) as tar
                FROM geopos_operator
                WHERE timestamp BETWEEN ? AND ?
                AND item = ?
                AND color_id = ?
                GROUP BY item, timestamp) a
        `;

        const rowsGeoPos = await executeQuery(connection, geoposOperatorQuery, [newfd, newtd, prdid, col]);

        if (rowsGeoPos.length > 0) {
          const sump = rowsGeoPos[0].res;
          data.push({
            product: pro,
            total: item.tot,
            sump: sump,
            fdate: convertedDate,
            tdate: convertedDate1,
          });
        }
      }
    }

    if (data.length === 0) {
      res.json({});
    } else {
      res.json(data);
    }
  } catch (error) {
    console.error('Error executing database query:', error);
    res.status(500).json({ error: 'Internal Server Error' });
  } finally {
    if (connection) {
      connection.end();
    }
  }
});




//MTD AVG PPP REPORT

//get Mtd ppp average category options
/**
 * @swagger
 * /braid/getCategoryOptions:
 *   get:
 *     summary: Get category options.
 *     description: Retrieves all active category options from the item_category table.
 *     tags:
 *       - Braid
 *     security:
 *       - BearerAuth: []
 *     responses:
 *       200:
 *         description: Successful response with category options.
 *         content:
 *           application/json:
 *             schema:
 *               type: array
 *               items:
 *                 type: object
 *                 properties:
 *                   id:
 *                     type: integer
 *                     description: The ID of the category option.
 *                   name:
 *                     type: string
 *                     description: The name of the category option.
 *                   description:
 *                     type: string
 *                     description: The description of the category option.
 *                   status:
 *                     type: string
 *                     description: The status of the category option.
 *       500:
 *         description: Internal server error.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: "Failed to fetch category options"
 *
 * @function
 * @name getCategoryOptions
 * @memberof module:Routes/Braid
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with the database query.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
app.get('/braid/getCategoryOptions', authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    const query = `
      SELECT *
      FROM item_category WHERE status='1'
    `;

    const results = await executeQuery(connection,query);

    res.json(results);
  } catch (error) {
    console.error('Error fetching category options:', error);
    res.status(500).json({ error: 'Failed to fetch item data' });
  } finally {
    if (connection) {
      connection.end();
    }
  }
});


//get Mtd ppp average default data
/**
 * @swagger
 * /braid/getMtdPppAverageDefaultData:
 *   get:
 *     summary: Get MTD PPP average default data.
 *     description: Retrieves MTD PPP (Month-to-Date Production Per Person) average default data from the geopos_operator table.
 *     tags:
 *       - Braid
 *     security:
 *       - BearerAuth: []
 *     responses:
 *       200:
 *         description: Successful response with MTD PPP average default data.
 *         content:
 *           application/json:
 *             schema:
 *               type: array
 *               items:
 *                 type: object
 *                 properties:
 *                   category:
 *                     type: string
 *                     description: The category of the item.
 *                   item:
 *                     type: string
 *                     description: The description of the item.
 *                   avg:
 *                     type: number
 *                     description: The average MTD PPP value rounded to 2 decimal places.
 *       500:
 *         description: Internal server error.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: "Internal Server Error"
 *
 * @function
 * @name getMtdPppAverageDefaultData
 * @memberof module:Routes/Braid
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with the database query.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
app.get('/braid/getMtdPppAverageDefaultData', authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    const datem = new Date().toLocaleDateString('en-US', { month: 'numeric', year: 'numeric' }).replace(/\//g, '-');
    const date = new Date().toLocaleDateString('en-GB', { timeZone: 'Africa/Lagos' });
    const parts = date.split('/');
    const day = parts[0].padStart(2, '0');
    const month = parts[1].padStart(2, '0');
    const year = parts[2];
    const currentMonth = `${month}-${year}`;
    const currentDate = `${day}-${month}-${year}`;
    console.log('currentMonth:',currentMonth);
    const array = [`geopos_operator.month = '${currentMonth}'`, "geopos_operator.item IS NOT NULL"];

    const query = `
      SELECT
        geopos_operator.*,
        item_masterr.item_description,
        item_category.category_name,
        COUNT(geopos_operator.id) AS tot
      FROM
        geopos_operator
      LEFT JOIN
        item_masterr ON item_masterr.id = geopos_operator.item
      LEFT JOIN
        item_category ON item_masterr.category_id = item_category.id
      WHERE
        ${array.join(' AND ')}
      GROUP BY
        geopos_operator.item, geopos_operator.month
    `;

    const results = await executeQuery(connection,query);

    const data = []; // Initialize an array to store the result objects
    // Loop through the results and calculate averages for each result
    if(results.length > 0 ){
      for (const result of results) {
        const kk = result.item;
        const where = `item='${kk}' AND month='${currentMonth}'`;

        const query2 = `SELECT max(iemp_count) AS it, max(demp_count) AS at 
                 FROM geopos_operator 
                 WHERE ${where} 
                 GROUP BY zone, machine, item, date`;

        console.log('query2:',query2);

        const results2 = await executeQuery(connection,query2);

        let workerk = 0;
        for (const row of results2) {
          workerk += +row.at + +row.it;
        }

        const query3 = `SELECT * FROM geopos_operator 
        WHERE ${where} 
        GROUP BY item, date, zone, machine, hr_start`;

        console.log('query3:',query3);

        const results3 = await executeQuery(connection,query3);

        let sum = 0;
        for (const ws of results3) {
          sum += +ws.fg_output;
        }

        const rew = workerk > 0 ? sum / workerk : 0;
        console.log(rew.toFixed(2)); // Output the result rounded to 2 decimal places

        // Create an object for each result set and push it to the data array
        data.push({
          category: result.category_name,
          item: result.item_description,
          avg: rew.toFixed(2),
        });
      }

      res.json(data); // Send the data array as a JSON response
    } else {
      res.json(''); 
    }
  } catch (error) {
    console.error('Error fetching MTD PPP average default data:', error);
    res.status(500).json({ error: 'Internal Server Error' });
  } finally {
    if (connection) {
      connection.end();
    }
  }
});


//get Mtd ppp average search data
/**
 * @swagger
 * /braid/getMtdPppAverageSearch:
 *   post:
 *     summary: Get MTD PPP average search data.
 *     description: Retrieves MTD PPP (Month-to-Date Production Per Person) average search data from the geopos_operator table based on the specified date range and category.
 *     tags:
 *       - Braid
 *     security:
 *       - BearerAuth: []
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             properties:
 *               start_year:
 *                 type: integer
 *                 description: The starting year of the date range.
 *               end_year:
 *                 type: integer
 *                 description: The ending year of the date range.
 *               start_month:
 *                 type: integer
 *                 description: The starting month of the date range.
 *               end_month:
 *                 type: integer
 *                 description: The ending month of the date range.
 *               category:
 *                 type: string
 *                 description: The category of items to filter the search.
 *     responses:
 *       200:
 *         description: Successful response with MTD PPP average search data.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 data:
 *                   type: object
 *                   properties:
 *                     fdt:
 *                       type: string
 *                       description: The formatted start date of the search.
 *                     edt:
 *                       type: string
 *                       description: The formatted end date of the search.
 *                     fdtt:
 *                       type: string
 *                       description: The formatted start date of the search (MM-YYYY).
 *                     edtt:
 *                       type: string
 *                       description: The formatted end date of the search (MM-YYYY).
 *                     items:
 *                       type: array
 *                       items:
 *                         type: object
 *                         properties:
 *                           category:
 *                             type: string
 *                             description: The category of the item.
 *                           item:
 *                             type: string
 *                             description: The description of the item.
 *                           monthlyAverages:
 *                             type: array
 *                             items:
 *                               type: string
 *                               description: The MTD PPP average for each month in the specified date range.
 *                           months:
 *                             type: array
 *                             items:
 *                               type: string
 *                               description: The months in the specified date range.
 *       500:
 *         description: Internal server error.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: "An error occurred"
 *
 * @function
 * @name getMtdPppAverageSearch
 * @memberof module:Routes/Braid
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with the database query.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
app.post('/braid/getMtdPppAverageSearch',authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    const start_year = req.body.start_year;
    const end_year = req.body.end_year;
    const start_month = req.body.start_month;
    const end_month = req.body.end_month;

    const s_year = start_month + '-' + start_year;
    const e_year = end_month + '-' + end_year;
    const cat = req.body.category;
    console.log(s_year + '' + e_year);

    const year_s = `${start_year}-${start_month}`;
    const year_e = `${end_year}-${end_month}`;

    const year_ss = `${start_month}-${start_year}`;
    const year_ee = `${end_month}-${end_year}`;

    const startDate = new Date(year_s);
    const endDate = new Date(year_e);
    const monthsArray = [];
    const monthsArray1 = [];
    const timeZone = 'Africa/Lagos';

    const formattedStartDate = startDate.toLocaleDateString('en-US', { year: 'numeric', month: 'long' });
    const formattedEndDate = endDate.toLocaleDateString('en-US', { year: 'numeric', month: 'long' });

    console.log('Start Date:', formattedStartDate);
    console.log('End Date:', formattedEndDate);

    const monthDifference = (endDate.getFullYear() - startDate.getFullYear()) * 12 + (endDate.getMonth() - startDate.getMonth()) + 1;

    for (let i = 0; i < monthDifference; i++) {
      const currentMonth = new Date(startDate.getFullYear(), startDate.getMonth() + i, 1);
      const monthName = currentMonth.toLocaleDateString('en-US', { month: 'long' });
      const mths = currentMonth.toLocaleDateString('en-US', { month: '2-digit', year: 'numeric' }).replace(/\//g, '-');

      monthsArray.push(mths);
      monthsArray1.push(monthName);
    }

    let where = `(geopos_operator.month between '${s_year}' and '${e_year}' and geopos_operator.item !='')`;

    if (cat !== '') {
      where += ` AND item_masterr.category_id='${cat}'`;
    }

    const query = `
      SELECT geopos_operator.*, item_masterr.item_description, item_category.category_name,
             COUNT(geopos_operator.id) as tot
      FROM geopos_operator
      LEFT JOIN item_masterr ON item_masterr.id = geopos_operator.item
      LEFT JOIN item_category ON item_masterr.category_id = item_category.id
      WHERE ${where}
      GROUP BY geopos_operator.item
    `;

    const results = await executeQuery(connection,query);

    const data = { 
      fdt: year_s,
      edt: year_e,
      fdtt: year_ss,
      edtt: year_ee,
      items: [], 
    };

    for (const result of results) {
      const monthlyAverages = [];

      const promises = monthsArray.map(async (dt1) => {
        const mths = dt1;
        console.log(mths);
        const p1 = await executeQuery(connection,"SELECT SUM(fg_output) as tar from geopos_operator WHERE month=? and item=? group by item", [mths, result.item]);
        const query3 = await executeQuery(connection,"SELECT count(*) as tot from geopos_operator  WHERE month=? and item=? group by item", [mths, result.item]);
        
        const sum1 = p1.length > 0 ? p1[0].tar : 0;
        const worker = query3.length > 0 ? query3[0].tot : 0;
        console.log('Sum:', sum1);
        console.log('Worker:', worker);

        let rew;
        if (worker > 0) {
          rew = sum1 / worker;
          if (isNaN(rew) || !isFinite(rew)) {
            rew = '-';
          } else {
            rew = rew.toFixed(2);
          }
        } else {
          rew = '-';
        }
        console.log('Average:', rew);
        monthlyAverages.push(rew);
      });

      await Promise.all(promises);

      data.items.push({
        category: result.category_name,
        item: result.item_description,
        monthlyAverages: monthlyAverages,
        months: monthsArray1,
      });
    }

    res.json({ data });
  } catch (error) {
    console.error("Error:", error);
    res.status(500).json({ error: "An error occurred" });
  } finally {
    if (connection) {
      connection.end();
    }
  }
});

//EmployeeTimesheet Report 

//Employee Timesheet Reports Default data
/**
 * @swagger
 * /braid/getEmployeeTimesheetDefaultData:
 *   get:
 *     summary: Get default employee timesheet data.
 *     description: Retrieves default employee timesheet data from the database for the current date.
 *     tags:
 *       - Braid
 *     security:
 *       - BearerAuth: []
 *     responses:
 *       200:
 *         description: Successful response with employee timesheet data for the current date.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 message:
 *                   type: string
 *                   description: A message indicating the success of the operation.
 *                 resultData:
 *                   type: array
 *                   items:
 *                     type: object
 *                     properties:
 *                       emp:
 *                         type: string
 *                         description: The employee name.
 *                       empid:
 *                         type: string
 *                         description: The employee ID.
 *                       site:
 *                         type: string
 *                         description: The employee's site.
 *                       regg:
 *                         type: string
 *                         description: The registration date of the employee.
 *                       diff:
 *                         type: integer
 *                         description: The number of days between the registration date and the current date.
 *                       item_description:
 *                         type: string
 *                         description: The description of the item.
 *                       section_name:
 *                         type: string
 *                         description: The name of the section.
 *                       zone:
 *                         type: string
 *                         description: The zone.
 *                       machine:
 *                         type: string
 *                         description: The machine.
 *                       shift:
 *                         type: string
 *                         description: The shift.
 *                       complete:
 *                         type: string
 *                         description: The completion status.
 *                       tar1:
 *                         type: number
 *                         description: The target value.
 *                       total:
 *                         type: number
 *                         description: The total value.
 *                       eff:
 *                         type: number
 *                         description: The efficiency value.
 *                       tDate:
 *                         type: string
 *                         description: The current date.
 *       500:
 *         description: Internal server error.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: "Database error"
 *
 * @function
 * @name getEmployeeTimesheetDefaultData
 * @memberof module:Routes/Braid
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with the database query.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
app.get('/braid/getEmployeeTimesheetDefaultData',authenticateJWT , async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    const tDate = new Date().toLocaleDateString('en-US', {
      day: '2-digit',
      month: '2-digit',
      year: 'numeric',
    }).replace(/\//g, '-');

    const results1 = await executeQuery(connection, 'SELECT * FROM operator_section WHERE date = ?', [tDate]);
    const resultData = [];

    for (const item of results1) {
      const ids = item.opmanual_id.split(',');

      const results2 = await executeQuery(connection, `
        SELECT geopos_operator.*, COUNT(id) AS individual_complete, GROUP_CONCAT(id) AS idk
        FROM geopos_operator
        WHERE id IN (?)
        GROUP BY item, zone, machine
      `, [ids]);

      for (const res2 of results2) {
        const target = item.target;
        const comp = item.complete.split(',');
        const idg = res2.idk ? res2.idk.split(',') : [];
        const zone = res2.zone;
        const machine = res2.machine;
        const shift = res2.shift;

        let total = 0;
        let numb = 0;
        let complete = '';

        for (const vall of idg) {
          const index = ids.indexOf(vall);
          total += parseInt(comp[index]);
          complete += comp[index] + ',';
          numb = res2.individual_complete;
        }

        const tar1 = target * numb;
        const eff1 = (total / tar1) * 100;
        const eff = eff1.toFixed(2);

        const entry = item.empid;

        const entryidoResult = await executeQuery(connection, "SELECT entryid FROM employees_ota WHERE entryid = ?", [item.empid]);
        const entryido = entryidoResult[0]?.entryid;

        const entryidiResult = await executeQuery(connection, "SELECT entryid FROM geopos_employees WHERE entryid = ?", [item.empid]);
        const entryidi = entryidiResult[0]?.entryid;

        const rows = await promisifyQuery7(db, 'SELECT * FROM employees_ota WHERE entryid = ?', [item.empid]);
        const num = rows.length;

        let regg, site, diff;

        if (num > 0) {
          const query1 = await executeQuery(connection, 'SELECT * FROM employees_ota WHERE entryid = ?', [entryido]);
          regg = query1 ? new Date(query1[0].joindate).toLocaleDateString('en-US', { day: '2-digit', month: '2-digit', year: 'numeric' }).replace(/\//g, '-') : null;
          site = query1 ? query1[0].new_staff : null;
          const datek1 = new Date().toLocaleDateString('en-US', { day: '2-digit', month: '2-digit', year: 'numeric' }).replace(/\//g, '-');
          const earlier = new Date(query1[0].joindate);
          const later = new Date(datek1);
          diff = Math.floor((later - earlier) / (1000 * 60 * 60 * 24));
        } else {
          const rows5 = await executeQuery(connection, 'SELECT * FROM geopos_employees WHERE entryid = ?', [entryidi]);

          if (rows5.length > 0) {
            const query2 = await executeQuery(connection, 'SELECT * FROM geopos_employees WHERE entryid = ?', [entryidi]);
            regg = query2 ? new Date(query2[0].joindate).toLocaleDateString('en-US', { day: '2-digit', month: '2-digit', year: 'numeric' }).replace(/\//g, '-') : null;
            site = 'IKEJA';
            const datek1 = new Date().toLocaleDateString('en-US', { day: '2-digit', month: '2-digit', year: 'numeric' }).replace(/\//g, '-');
            const earlier = new Date(query2[0].joindate);
            const later = new Date(datek1);
            diff = Math.floor((later - earlier) / (1000 * 60 * 60 * 24));
          }
        }

        const [sectionResult] = await executeQuery(connection, "SELECT section_name FROM section WHERE id = ?", [item.section_id]);
        const section_name = sectionResult?.section_name;

        const [itemResult] = await executeQuery(connection, "SELECT item_description FROM item_masterr WHERE id = ?", [res2.item]);
        const item_description = itemResult?.item_description;

        const dataObject = {
          emp: item.emp,
          empid: item.empid,
          site,
          regg,
          diff,
          item_description,
          section_name,
          zone,
          machine,
          shift,
          complete,
          tar1,
          total,
          eff,
          tDate,
        };

        resultData.push(dataObject);

        console.log('Result:', dataObject);
      }
    }

    console.log('Result Data:', resultData);
    res.json({ message: 'Successfully processed data', resultData });
  } catch (error) {
    console.error('Error executing SQL queries:', error);
    res.status(500).json({ error: 'Database error' });
  } finally {
    if (connection) {
      connection.end();
    }
  }
});

/**
 * @swagger
 * /braid/getEmployeeTimesheetDataNew:
 *   post:
 *     summary: Get employee timesheet data with custom date.
 *     description: Retrieves employee timesheet data from the database for a specified date range.
 *     tags:
 *       - Braid
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             properties:
 *               fromdate:
 *                 type: string
 *                 format: date
 *                 description: The starting date of the date range (DD-MM-YYYY).
 *     responses:
 *       200:
 *         description: Successful response with employee timesheet data for the specified date.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 message:
 *                   type: string
 *                   description: A message indicating the success of the operation.
 *                 resultData:
 *                   type: array
 *                   items:
 *                     type: object
 *                     properties:
 *                       emp:
 *                         type: string
 *                         description: The employee name.
 *                       empid:
 *                         type: string
 *                         description: The employee ID.
 *                       site:
 *                         type: string
 *                         description: The employee's site.
 *                       regg:
 *                         type: string
 *                         description: The registration date of the employee.
 *                       diff:
 *                         type: integer
 *                         description: The number of days between the registration date and the current date.
 *                       item_description:
 *                         type: string
 *                         description: The description of the item.
 *                       section_name:
 *                         type: string
 *                         description: The name of the section.
 *                       zone:
 *                         type: string
 *                         description: The zone.
 *                       machine:
 *                         type: string
 *                         description: The machine.
 *                       shift:
 *                         type: string
 *                         description: The shift.
 *                       complete:
 *                         type: string
 *                         description: The completion status.
 *                       tar1:
 *                         type: number
 *                         description: The target value.
 *                       total:
 *                         type: number
 *                         description: The total value.
 *                       eff:
 *                         type: number
 *                         description: The efficiency value.
 *                       date:
 *                         type: string
 *                         description: The specified date for the timesheet data.
 *       400:
 *         description: Bad request error.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: "Invalid request body"
 *       500:
 *         description: Internal server error.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: "Database error"
 *
 * @function
 * @name getEmployeeTimesheetDataNew
 * @memberof module:Routes/Braid
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with the database query.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
//Employee Timesheet Braid Reports search data
app.post('/braid/getEmployeeTimesheetDataNew', async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    //const fdate = req.body.fromdate;
    const fromdate = req.body.fromdate ? req.body.fromdate.replace(/\//g, '-') : '';
    
let fdate = ''; // Initialize fdate as an empty string

if (fromdate && !isNaN(Date.parse(fromdate))) {
  // If fromdate is defined and can be successfully parsed as a date
  const dateObj = new Date(fromdate);
  const day = dateObj.getDate().toString().padStart(2, '0');
  const month = (dateObj.getMonth() + 1).toString().padStart(2, '0');
  const year = dateObj.getFullYear();
  fdate = `${day}-${month}-${year}`;
}

//console.log(fdate + '--------------');

  // if (fdate !== '') {
  //   // Clear tables
  //   await promisifyQuery6(db, 'TRUNCATE TABLE geopos_operator_timesheet');
  //   await promisifyQuery6(db, 'TRUNCATE TABLE operator_section_timesheet');
  // }


  //   // Copy data from 'operator_section' to 'operator_section_timesheet'
  //   await promisifyQuery6(db, 'INSERT INTO operator_section_timesheet SELECT * FROM operator_section WHERE date = ?', [fdate]);

  //   // Copy data from 'geopos_operator' to 'geopos_operator_timesheet'
  //   await promisifyQuery6(db, 'INSERT INTO geopos_operator_timesheet SELECT * FROM geopos_operator WHERE date = ?', [fdate]);

  //   // Get the last recorded date from 'operator_section_timesheet'
  //   const [dateRow] = await promisifyQuery6(db, 'SELECT MAX(date) as date FROM operator_section_timesheet');
  //   const lastRecordedDate = dateRow.date;

    const results1 = await executeQuery(connection, 'SELECT * FROM operator_section WHERE date = ?', [fdate]);
     const resultData = [];
   
    let date;
    if (typeof fdate !== 'undefined' && fdate !== '') {
      date = fdate;
    }else{
      date = fdate;
    }
    for (const item of results1) {
      const ids = item.opmanual_id.split(',');

      const results2 = await executeQuery(connection, `
        SELECT geopos_operator.*, COUNT(id) AS individual_complete, GROUP_CONCAT(id) AS idk
        FROM geopos_operator
        WHERE id IN (?)
        GROUP BY item, zone, machine
      `, [ids]);

      for (const res2 of results2) {
        const target = item.target;
        const comp = item.complete.split(',');
        const idg = res2.idk ? res2.idk.split(',') : [];
        const zone = res2.zone;
        const machine = res2.machine;
        const shift = res2.shift;
        let total = 0;
        let numb = 0;
        let complete = '';

        for (const vall of idg) {
          const index = ids.indexOf(vall);
          total += parseInt(comp[index]);
          complete += comp[index] + ',';
          numb = res2.individual_complete;
        }

        const tar1 = target * numb;
        const eff1 = (total / tar1) * 100;
        const eff = eff1.toFixed(2);

        const entry = item.empid;

        const entryidoResult = await executeQuery(connection, "SELECT entryid FROM employees_ota WHERE entryid = ?", [item.empid]);
        const entryido = entryidoResult[0]?.entryid;

        const entryidiResult = await executeQuery(connection, "SELECT entryid FROM geopos_employees WHERE entryid = ?", [item.empid]);
        const entryidi = entryidiResult[0]?.entryid;

        const rows = await executeQuery(db, 'SELECT * FROM employees_ota WHERE entryid = ?', [item.empid]);
        const num = rows.length;

        let regg, site, diff;

        if (num > 0) {
          const query1 = await executeQuery(connection, 'SELECT * FROM employees_ota WHERE entryid = ?', [entryido]);
          regg = query1 ? new Date(query1[0].joindate).toLocaleDateString('en-US', { day: '2-digit', month: '2-digit', year: 'numeric' }).replace(/\//g, '-') : null;
          site = query1 ? query1[0].new_staff : null;
          const datek1 = new Date().toLocaleDateString('en-US', { day: '2-digit', month: '2-digit', year: 'numeric' }).replace(/\//g, '-');
          const earlier = new Date(query1[0].joindate);
          const later = new Date(datek1);
          diff = Math.floor((later - earlier) / (1000 * 60 * 60 * 24)) + 1;
        } else {
          const rows5 = await executeQuery(connection, 'SELECT * FROM geopos_employees WHERE entryid = ?', [entryidi]);

          if (rows5.length > 0) {
            const query2 = await promisifyQuery6(connection, 'SELECT * FROM geopos_employees WHERE entryid = ?', [entryidi]);
            regg = query2 ? new Date(query2[0].joindate).toLocaleDateString('en-US', { day: '2-digit', month: '2-digit', year: 'numeric' }).replace(/\//g, '-') : null;
            site = 'IKEJA';
            const datek1 = new Date().toLocaleDateString('en-US', { day: '2-digit', month: '2-digit', year: 'numeric' }).replace(/\//g, '-');
            const earlier = new Date(query2[0].joindate);
            const later = new Date(datek1);
            diff = Math.floor((later - earlier) / (1000 * 60 * 60 * 24)) + 1;
          }
        }

        const [sectionResult] = await executeQuery(connection, "SELECT section_name FROM section WHERE id = ?", [item.section_id]);
        const section_name = sectionResult?.section_name;

        const [itemResult] = await executeQuery(connection, "SELECT item_description FROM item_masterr WHERE id = ?", [res2.item]);
        const item_description = itemResult?.item_description;

        const dataObject = {
          emp: item.emp,
          empid: item.empid,
          site,
          regg,
          diff,
          item_description,
          section_name,
          zone,
          machine,
          shift,
          complete,
          tar1,
          total,
          eff,
          date,
        };

        resultData.push(dataObject);

        console.log('Result:', dataObject);
      }
    }

    console.log('Result Data:', resultData);
    res.json({ message: 'Successfully processed data', resultData });
  } catch (error) {
    console.error('Error executing SQL queries:', error);
    res.status(500).json({ error: 'Database error' });
  } finally {
    if (connection) {
      connection.end();
    }
  }
});


//Performance Efficiency Report

//Get performance eff data default wise
/**
 * @swagger
 * /braid/get_performance_Eff_report_braid_default:
 *   get:
 *     summary: Get default performance efficiency report for Braid.
 *     description: Retrieves default performance efficiency report data for Braid from the database.
 *     tags:
 *       - Braid
 *     responses:
 *       200:
 *         description: Successful response with default performance efficiency report data.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 message:
 *                   type: string
 *                   description: A message indicating the success of the operation.
 *                 resultData:
 *                   type: array
 *                   items:
 *                     type: object
 *                     properties:
 *                       emp:
 *                         type: string
 *                         description: The employee name.
 *                       empid:
 *                         type: string
 *                         description: The employee ID.
 *                       site:
 *                         type: string
 *                         description: The employee's site.
 *                       regg:
 *                         type: string
 *                         description: The registration date of the employee.
 *                       diff:
 *                         type: integer
 *                         description: The number of days between the registration date and the current date.
 *                       section_name:
 *                         type: string
 *                         description: The name of the section.
 *                       item_description:
 *                         type: string
 *                         description: The description of the item.
 *                       zone:
 *                         type: string
 *                         description: The zone.
 *                       machine:
 *                         type: string
 *                         description: The machine.
 *                       eff:
 *                         type: number
 *                         description: The efficiency value.
 *                       shift:
 *                         type: string
 *                         description: The shift.
 *       500:
 *         description: Internal server error.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: "Database error"
 *
 * @function
 * @name get_performance_Eff_report_braid_default
 * @memberof module:Routes/Braid
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with the database query.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
app.get('/braid/get_performance_Eff_report_braid_default',authenticateJWT , async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    const date = new Date().toLocaleDateString('en-GB', { timeZone: 'Africa/Lagos' });
    const parts = date.split('/');
    const formattedDay = parts[0].padStart(2, '0');
    const formattedMonth = parts[1].padStart(2, '0');
    const year = parts[2];
    const date1 = `${formattedDay}-${formattedMonth}-${year}`;
    const tDate = new Date().toLocaleDateString('en-US', {
      day: '2-digit',
      month: '2-digit',
      year: 'numeric',
    }).replace(/\//g, '-');

    const results1 = await executeQuery(db, 'SELECT * FROM operator_section WHERE date = ?', [date1]);
    const resultData = [];
    const tpr = []; 
    for (const item of results1) {
      const ids = item.opmanual_id.split(',');

      const results2 = await executeQuery(db, `
        SELECT geopos_operator.*, COUNT(id) AS individual_complete, GROUP_CONCAT(id) AS idk
        FROM geopos_operator
        WHERE id IN (?)
        GROUP BY item, zone, machine
      `, [ids]);
      const mj = [];

      results2.forEach((res2) => {
        const str = `${item.empid}-${res2.item}-${res2.zone}-${res2.machine}`;
        if (!tpr.includes(str)) {
          tpr.push(str);
          mj.push(str);
        }
      });
      for (const res2 of results2) {
        const target = item.target;
        const zone = res2.zone;
        const machine = res2.machine;
        const shift = res2.shift;
        const str1 = `${item.empid}-${res2.item}-${res2.zone}-${res2.machine}`;
        if (mj.includes(str1)) {
     

        const entryidoResult = await executeQuery(db, "SELECT entryid FROM employees_ota WHERE entryid = ?", [item.empid]);
        const entryido = entryidoResult[0]?.entryid;

        const entryidiResult = await executeQuery(db, "SELECT entryid FROM geopos_employees WHERE entryid = ?", [item.empid]);
        const entryidi = entryidiResult[0]?.entryid;

        const rows = await executeQuery(db, 'SELECT * FROM employees_ota WHERE entryid = ?', [item.empid]);
        const num = rows.length;

        let regg, site, diff;

        if (num > 0) {
          const query1 = await executeQuery(db, 'SELECT * FROM employees_ota WHERE entryid = ?', [entryido]);
          regg = query1 ? new Date(query1[0].joindate).toLocaleDateString('en-US', { day: '2-digit', month: '2-digit', year: 'numeric' }).replace(/\//g, '-') : null;
          site = query1 ? query1[0].new_staff : null;
          const datek1 = new Date().toLocaleDateString('en-US', { day: '2-digit', month: '2-digit', year: 'numeric' }).replace(/\//g, '-');
          const earlier = new Date(query1[0].joindate);
          const later = new Date(datek1);
          diff = Math.floor((later - earlier) / (1000 * 60 * 60 * 24))+1;
        } else {
          const rows5 = await executeQuery(db, 'SELECT * FROM geopos_employees WHERE entryid = ?', [entryidi]);

          if (rows5.length > 0) {
            const query2 = await executeQuery(db, 'SELECT * FROM geopos_employees WHERE entryid = ?', [entryidi]);
            regg = query2 ? new Date(query2[0].joindate).toLocaleDateString('en-US', { day: '2-digit', month: '2-digit', year: 'numeric' }).replace(/\//g, '-') : null;
            site = 'IKEJA';
            const datek1 = new Date().toLocaleDateString('en-US', { day: '2-digit', month: '2-digit', year: 'numeric' }).replace(/\//g, '-');
            const earlier = new Date(query2[0].joindate);
            const later = new Date(datek1);
            diff = Math.floor((later - earlier) / (1000 * 60 * 60 * 24))+1;
          }
        }

        const [sectionResult] = await executeQuery(db, "SELECT section_name FROM section WHERE id = ?", [item.section_id]);
        const section_name = sectionResult?.section_name;

        const [itemResult] = await executeQuery(db, "SELECT item_description FROM item_masterr WHERE id = ?", [res2.item]);
        const item_description = itemResult?.item_description;
       //

        const comp = item.complete.split(",");
        let total = 0;
        let numb = 0;
        let flag = 0;

        for (let j = 0; j < res2.individual_complete; j++) {
          total += parseInt(comp[flag]);
          numb = res2.individual_complete;
          flag++;
        }

        const tar1 = target * numb;
        const eff1 = (total / tar1) * 100;
        const eff = parseFloat(eff1.toFixed(2));
       

        const dataObject = {
          emp: item.emp,
          empid: item.empid,
          site,
          regg,
          diff,
          section_name,
          item_description,
          zone,
          machine,
          eff,
          shift,
        };

        resultData.push(dataObject);

        console.log('Result:', dataObject);
       }
      }
    }

    console.log('Result Data:', resultData);
    res.json({ message: 'Successfully processed data', resultData });
  } catch (error) {
    console.error('Error executing SQL queries:', error);
    res.status(500).json({ error: 'Database error' });
  } finally {
    if (connection) {
      connection.end();
    }
  }
});


 
//Get performance eff data search wise
/**
 * @swagger
 * /braid/get_performance_eff_braid_searchh:
 *   post:
 *     summary: Get performance efficiency report for Braid with search parameters.
 *     description: Retrieves performance efficiency report data for Braid from the database with search parameters.
 *     tags:
 *       - Braid
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             properties:
 *               fromdate:
 *                 type: string
 *                 format: date
 *                 description: The start date for the report.
 *               todate:
 *                 type: string
 *                 format: date
 *                 description: The end date for the report.
 *     responses:
 *       200:
 *         description: Successful response with performance efficiency report data.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 message:
 *                   type: string
 *                   description: A message indicating the success of the operation.
 *                 resultData:
 *                   type: object
 *                   properties:
 *                     fdate:
 *                       type: string
 *                       description: The start date used for the report.
 *                     tdate:
 *                       type: string
 *                       description: The end date used for the report.
 *                     dates:
 *                       type: array
 *                       description: An array of dates included in the report period.
 *                       items:
 *                         type: string
 *                         format: date
 *                       example: ["01-05-2024", "02-05-2024", "03-05-2024"]
 *                     items:
 *                       type: array
 *                       description: An array of performance efficiency report data for each employee.
 *                       items:
 *                         type: object
 *                         properties:
 *                           emp:
 *                             type: string
 *                             description: The employee name.
 *                           empid:
 *                             type: string
 *                             description: The employee ID.
 *                           site:
 *                             type: string
 *                             description: The employee's site.
 *                           regg:
 *                             type: string
 *                             description: The registration date of the employee.
 *                           diff:
 *                             type: integer
 *                             description: The number of days between the registration date and the current date.
 *                           section_name:
 *                             type: string
 *                             description: The name of the section.
 *                           item_description:
 *                             type: string
 *                             description: The description of the item.
 *                           zone:
 *                             type: string
 *                             description: The zone.
 *                           machine:
 *                             type: string
 *                             description: The machine.
 *                           shift:
 *                             type: string
 *                             description: The shift.
 *                           eff:
 *                             type: array
 *                             description: An array of performance efficiencies for each date in the report period.
 *                             items:
 *                               type: string
 *                               description: The performance efficiency value for a specific date.
 *       500:
 *         description: Internal server error.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: "Database error"
 *
 * @function
 * @name get_performance_eff_braid_searchh
 * @memberof module:Routes/Braid
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with the database query.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
app.post('/braid/get_performance_eff_braid_searchh',  authenticateJWT , async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    const fromdate = req.body.fromdate;
    const todate = req.body.todate;

    const dateObj = new Date(fromdate);
    const day = dateObj.getDate().toString().padStart(2, '0');
    const month = (dateObj.getMonth() + 1).toString().padStart(2, '0');
    const year = dateObj.getFullYear();

    const convertedDate = `${day}-${month}-${year}`;

    const dateObj1 = new Date(todate);
    const day1 = dateObj1.getDate().toString().padStart(2, '0');
    const month1 = (dateObj1.getMonth() + 1).toString().padStart(2, '0');
    const year1 = dateObj1.getFullYear();
   
    const convertedDate1 = `${day1}-${month1}-${year1}`;
    
    console.log('Converted Date:', convertedDate);
    console.log('Converted Date1:', convertedDate1);
    
    const whereConditions = [
      `date >= ?`,
      `date <= ?`
    ];
    
    const whereClause = whereConditions.join(' AND ');
    
    const sqlQuery = `
      SELECT *
      FROM operator_section
      WHERE STR_TO_DATE(date, '%d-%m-%Y') >= STR_TO_DATE(?, '%d-%m-%Y')
      AND STR_TO_DATE(date, '%d-%m-%Y') <= STR_TO_DATE(?, '%d-%m-%Y');
    `;
    
    const results1 = await executeQuery(connection, sqlQuery, [convertedDate, convertedDate1]);

    /////
    const fdate = convertedDate;
    const tdate = convertedDate1;

    const startDateParts = fdate.split('-').map(Number);
    const endDateParts = tdate.split('-').map(Number);

    const startDate = new Date(startDateParts[2], startDateParts[1] - 1, startDateParts[0]);
    const endDate = new Date(endDateParts[2], endDateParts[1] - 1, endDateParts[0]);

    const dateIncrement = 24 * 60 * 60 * 1000; // 1 day in milliseconds
    const dates = [];
   for (let currentDate = new Date(startDate); currentDate <= endDate; currentDate.setTime(currentDate.getTime() + dateIncrement)) {
      const day = currentDate.getDate().toString().padStart(2, '0');
      const month = (currentDate.getMonth() + 1).toString().padStart(2, '0');
      const year = currentDate.getFullYear();
      const datt = `${day}-${month}-${year}`;
      dates.push(datt);
    }
    ////
    const resultData = {
      fdate: convertedDate,
      tdate: convertedDate1,
      dates:dates,
      items:[],
    }
    
    for (const item of results1) {
      console.log(sqlQuery);
      const ids = item.opmanual_id.split(',');

      const results2 = await executeQuery(connection, `
        SELECT geopos_operator.*, COUNT(id) AS individual_complete, GROUP_CONCAT(id) AS idk
        FROM geopos_operator
        WHERE id IN (?)
        GROUP BY item, zone, machine
      `, [ids]);

      const tpr = [];
      const mj = [];

      results2.forEach((res2) => {
        const str = `${item.empid}-${res2.item}-${res2.zone}-${res2.machine}`;
        if (!tpr.includes(str)) {
          tpr.push(str);
          mj.push(str);
        }
      });

      for (const res2 of results2) {
        const target = item.target;
        const zone = res2.zone;
        const machine = res2.machine;
        const shift = res2.shift;
        const str1 = `${item.empid}-${res2.item}-${res2.zone}-${res2.machine}`;
        
        if (mj.includes(str1)) {
          const entryidoResult = await executeQuery(connection, 'SELECT entryid FROM employees_ota WHERE entryid = ?', [item.empid]);
          const entryido = entryidoResult[0]?.entryid;

          const entryidiResult = await executeQuery(connection, 'SELECT entryid FROM geopos_employees WHERE entryid = ?', [item.empid]);
          const entryidi = entryidiResult[0]?.entryid;

          const rows = await executeQuery(connection, 'SELECT * FROM employees_ota WHERE entryid = ?', [item.empid]);
          const num = rows.length;

          let regg, site, diff;

          if (num > 0) {
            const query1 = await executeQuery(connection, 'SELECT * FROM employees_ota WHERE entryid = ?', [entryido]);
            regg = query1 ? new Date(query1[0].joindate).toLocaleDateString('en-US', { day: '2-digit', month: '2-digit', year: 'numeric' }).replace(/\//g, '-') : null;
            site = query1 ? query1[0].new_staff : null;
            const datek1 = new Date().toLocaleDateString('en-US', { day: '2-digit', month: '2-digit', year: 'numeric' }).replace(/\//g, '-');
            const earlier = new Date(query1[0].joindate);
            const later = new Date(datek1);
            diff = Math.floor((later - earlier) / (1000 * 60 * 60 * 24)) + 1;
          } else {
            const rows5 = await executeQuery(connection, 'SELECT * FROM geopos_employees WHERE entryid = ?', [entryidi]);

            if (rows5.length > 0) {
              const query2 = await executeQuery(connection, 'SELECT * FROM geopos_employees WHERE entryid = ?', [entryidi]);
              regg = query2 ? new Date(query2[0].joindate).toLocaleDateString('en-US', { day: '2-digit', month: '2-digit', year: 'numeric' }).replace(/\//g, '-') : null;
              site = 'IKEJA';
              const datek1 = new Date().toLocaleDateString('en-US', { day: '2-digit', month: '2-digit', year: 'numeric' }).replace(/\//g, '-');
              const earlier = new Date(query2[0].joindate);
              const later = new Date(datek1);
              diff = Math.floor((later - earlier) / (1000 * 60 * 60 * 24))+ 1;
            }
          }

          const [sectionResult] = await executeQuery(connection, 'SELECT section_name FROM section WHERE id = ?', [item.section_id]);
          const section_name = sectionResult?.section_name;

          const [itemResult] = await executeQuery(connection, 'SELECT item_description FROM item_masterr WHERE id = ?', [res2.item]);
          const item_description = itemResult?.item_description;

          const fdate = convertedDate;
          const tdate = convertedDate1;

          const startDateParts = fdate.split('-').map(Number);
          const endDateParts = tdate.split('-').map(Number);

          const startDate = new Date(startDateParts[2], startDateParts[1] - 1, startDateParts[0]);
          const endDate = new Date(endDateParts[2], endDateParts[1] - 1, endDateParts[0]);

          const dateIncrement = 24 * 60 * 60 * 1000; // 1 day in milliseconds
          const eff_data = [];
          const dates = [];
          
          for (let currentDate = new Date(startDate); currentDate <= endDate; currentDate.setTime(currentDate.getTime() + dateIncrement)) {
            const day = currentDate.getDate().toString().padStart(2, '0');
            const month = (currentDate.getMonth() + 1).toString().padStart(2, '0');
            const year = currentDate.getFullYear();
            const datt = `${day}-${month}-${year}`;
            dates.push(datt);
            //console.log(datt + '---------------');
            let total = 0;
            let numb = 0;
         
            const resu = await executeQuery(connection, 'SELECT * FROM operator_section WHERE date = ? AND empid = ?', [datt, item.empid]);
         
            if (resu.length === 0) {
              // No data available for this date, push a placeholder to eff_data
              eff_data.push('-'); // You can use another placeholder if needed
              continue; // Skip the rest of the loop for this date
            }

            for (const rs of resu) {
              const ra = rs.opmanual_id.split(',');
              const comp1 = rs.complete.split(',');
         
              const results = await executeQuery(connection, `
                SELECT geopos_operator.*, COUNT(id) AS datewise_individual_complete
                FROM geopos_operator
                WHERE id IN (?)
                AND item = ?
                AND zone = ?
                AND machine = ?
              `, [ra, res2.item, res2.zone, res2.machine]);
            
              if (results.length > 0) {
                numb = results[0].datewise_individual_complete;
              }
             //console.log(numb+'--------------Numb')
              const results2 = await executeQuery(connection, `
                SELECT geopos_operator.*
                FROM geopos_operator
                WHERE id IN (?)
                AND item = ?
                AND zone = ?
                AND machine = ?
              `, [ra, res2.item, res2.zone, res2.machine]);
             //onsole.log(JSON.stringify(results2, null, 2), 'arrayyyyyyyyyyyyyyyyyyy');

            // Initialize total to 0
            

            for (const rs2 of results2) {
              const idToSearch = String(rs2.id); // Convert to string to ensure matching
            
              const index = ra.indexOf(idToSearch);
              console.log('index:', index);
              if (index !== -1) {
                // Use reduce to sum the values in comp1
                total += parseFloat(comp1[index]);
              }
            }

           // console.log('Total:', total);

              const tar1 = target * numb;
              const eff1 = (total / tar1) * 100;
              const eff = isNaN(eff1) ? '-' : eff1.toFixed(2);
              eff_data.push(eff);
            }
          }

          const dataObject = {
            emp: item.emp,
            empid: item.empid,
            site,
            regg,
            diff,
            section_name,
            item_description,
            zone,
            machine,
            shift,
            eff: eff_data,
          };

          resultData.items.push(dataObject);
          console.log('Result:', dataObject);
        }
      }
    }

    //console.log('Result Data:', resultData);
    res.json({ message: 'Successfully processed data', resultData });
  } catch (error) {
    console.error('Error executing SQL queries:', error);
    res.status(500).json({ error: 'Database error' });
  } finally {
    if (connection) {
      connection.end();
    }
  }
});



// Production Breakdown

//default data fetch
/**
 * @swagger
 * /getdefaultproductionbreakdown:
 *   get:
 *     summary: Get default production breakdown data.
 *     description: Retrieves default production breakdown data for the current date or a specific employee.
 *     tags:
 *       - Production
 *     security:
 *       - bearerAuth: []
 *     parameters:
 *       - in: query
 *         name: id1
 *         schema:
 *           type: integer
 *         description: The ID of the employee (optional). If not provided, default value is 9.
 *     responses:
 *       200:
 *         description: Successful response with default production breakdown data.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 items:
 *                   type: array
 *                   description: An array of production breakdown data.
 *                   items:
 *                     type: object
 *                     properties:
 *                       item:
 *                         type: string
 *                         description: The item.
 *                       date:
 *                         type: string
 *                         description: The date.
 *                       tdate:
 *                         type: integer
 *                         description: The total date.
 *                       wh:
 *                         type: string
 *                         description: The where condition.
 *                       zone:
 *                         type: string
 *                         description: The zone.
 *                       machine:
 *                         type: string
 *                         description: The machine.
 *                       shift:
 *                         type: string
 *                         description: The shift.
 *       404:
 *         description: Employee not found.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: "Employee not found"
 *       500:
 *         description: Internal server error.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: "Internal Server Error"
 *
 * @function
 * @name getdefaultproductionbreakdown
 * @memberof module:Routes/Production
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with the database query.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
app.get('/getdefaultproductionbreakdown',  authenticateJWT , async (req, res) => {
  try {
    
    const date = new Date().toLocaleDateString('en-GB', { timeZone: 'Africa/Lagos' });
    const [formattedDay, formattedMonth, year] = date.split('/').map(part => part.padStart(2, '0'));
    const date1 = `${formattedDay}-${formattedMonth}-${year}`;

    let where = `date = '${date1}'`;

   // console.log('Step 7: itemsResponse:', itemsResponse);

   
    const roleid = 5;

    if (roleid === 5) {
      
      const operatorResults = await getOperatorResults(where);
      const itemsResponse = {
        items: operatorResults.map((result) => ({
          item: result.item,
          date: result.date, // Replace 'date' with the actual name of the date field in your database
          tdate: 1,
          wh: where,
          zone:result.zone,
          machine:result.machine,
          shift:result.shift,
        })),
      };
      res.json(itemsResponse);
    } else {
      
      const id1 = req.query.id1 || 9; // Get 'id1' from the query parameter or set a default value
      const employee = await getEmployeeById(id1);
      console.log(id1,'-------')
      if (!employee) {
       // console.log('Step 4: No employee found.');
        return res.status(404).json({ error: 'Employee not found' });
      }

      const empId = employee.id;
     // console.log('Step 4: Employee found. Employee ID:', empId);
      where += ` AND emp_id = '${empId}'`;
      const operatorResults = await getOperatorResults(where);

      //console.log('Step 6: geopos_operator results:', operatorResults);

      const itemsResponse = {
        items: operatorResults.map((result) => ({
          item: result.item,
          date: result.date, // Replace 'date' with the actual name of the date field in your database
          tdate: 1,
          wh: where,
          zone:result.zone,
          machine:result.machine,
          shift:result.shift,
        })),
      };

     // console.log('Step 7: itemsResponse:', itemsResponse);

      res.json(itemsResponse);
      
    }

    ////
    
   

  } catch (error) {
    console.error('Error:', error);
    res.status(500).json({ error: 'Internal Server Error' });
  }
});

// Function to get employee by ID
function getEmployeeById(id) {
  const sql = `
    SELECT geopos_employees.*
    FROM geopos_employees
    LEFT JOIN geopos_users ON geopos_employees.entryid = geopos_users.entryid
    WHERE geopos_users.id = ?
  `;

  return new Promise((resolve, reject) => {
    db.query(sql, [id], (err, results) => {
      if (err) {
        reject(err);
      } else {
        resolve(results.length > 0 ? results[0] : null);
      }
    });
  });
}

// Function to get operator results
function getOperatorResults(where) {
  const operatorSql = `
    SELECT *
    FROM geopos_operator
    WHERE ${where}
    GROUP BY item
  `;

  return new Promise((resolve, reject) => {
    db.query(operatorSql, (err, results) => {
      if (err) {
        reject(err);
      } else {
        resolve(results);
      }
    });
  });
}

// filter data fetch
/**
 * @swagger
 * /getsearchproductionbreakdown:
 *   post:
 *     summary: Get search production breakdown data.
 *     description: Retrieves production breakdown data based on search criteria such as zone, machine, shift, and date range.
 *     tags:
 *       - Production
 *     security:
 *       - bearerAuth: []
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             properties:
 *               zone:
 *                 type: string
 *                 description: The zone.
 *               machine1:
 *                 type: string
 *                 description: The machine.
 *               shift:
 *                 type: string
 *                 description: The shift.
 *               fromdate:
 *                 type: string
 *                 format: date
 *                 description: The start date (YYYY-MM-DD).
 *               todate:
 *                 type: string
 *                 format: date
 *                 description: The end date (YYYY-MM-DD).
 *     responses:
 *       200:
 *         description: Successful response with search production breakdown data.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 items:
 *                   type: array
 *                   description: An array of production breakdown data.
 *                   items:
 *                     type: object
 *                     properties:
 *                       item:
 *                         type: string
 *                         description: The item.
 *                       date:
 *                         type: string
 *                         description: The date.
 *                       tdate:
 *                         type: integer
 *                         description: The total date.
 *                       wh:
 *                         type: string
 *                         description: The where condition.
 *                       fromdate:
 *                         type: string
 *                         format: date
 *                         description: The start date (YYYY-MM-DD).
 *                       todate:
 *                         type: string
 *                         format: date
 *                         description: The end date (YYYY-MM-DD).
 *                       zone:
 *                         type: string
 *                         description: The zone.
 *                       machine:
 *                         type: string
 *                         description: The machine.
 *                       shift:
 *                         type: string
 *                         description: The shift.
 *       500:
 *         description: Internal server error.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: "Internal server error"
 *
 * @function
 * @name getsearchproductionbreakdown
 * @memberof module:Routes/Production
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with the database query.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
app.post('/getsearchproductionbreakdown', authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    // Destructure request body
    const { zone, machine1: machine, shift, fromdate, todate } = req.body;

    // Format dates
    const formattedDate = formatDate(fromdate);
    const formattedDate1 = formatDate(todate, true);

    // Build WHERE clause
    let where = `datetime between '${formattedDate}' and '${formattedDate1}'`;
    if (zone) where += ` AND zone='${zone}'`;
    if (machine) where += ` AND machine='${machine}'`;
    if (shift) where += ` AND shift='${shift}'`;

    // Execute SQL query
    const operatorResults = await executeQuery(connection,`SELECT * FROM geopos_operator WHERE ${where} GROUP BY item`);

    // Prepare response
    const itemsResponse = {
      items: operatorResults.map((result) => ({
        item: result.item,
        date: result.date,
        tdate: 0,
        wh: where,
        fromdate,
        todate,
        zone,
        machine,
        shift,
      }))
    };

    // Send response
    res.json(itemsResponse);
  } catch (error) {
    console.error('Error in getsearchproductionbreakdown:', error);
    res.status(500).json({ error: 'Internal server error' });
  } finally {
    if (connection) {
      connection.end();
    }
  }
});

// Function to format date string
function formatDate(dateString, nextDay = false) {
  const dateObj = new Date(dateString);
  dateObj.setDate(dateObj.getDate() + (nextDay ? 1 : 0)); // Add one day if needed
  const padZero = (num) => num.toString().padStart(2, '0');
  return `${dateObj.getFullYear()}-${padZero(dateObj.getMonth() + 1)}-${padZero(dateObj.getDate())} ${padZero(dateObj.getHours())}:${padZero(dateObj.getMinutes())}:${padZero(dateObj.getSeconds())}`;
}





//get item description
/**
 * @swagger
 * /get-item-description:
 *   get:
 *     summary: Get item description by item ID.
 *     description: Retrieves the description of an item based on its ID.
 *     tags:
 *       - Items
 *     security:
 *       - bearerAuth: []
 *     parameters:
 *       - in: query
 *         name: item
 *         schema:
 *           type: integer
 *         required: true
 *         description: The ID of the item to retrieve description for.
 *     responses:
 *       200:
 *         description: Successful response with item description.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 item_description:
 *                   type: string
 *                   description: The description of the item.
 *       404:
 *         description: Item not found.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: "Item not found"
 *       500:
 *         description: Internal server error.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: "Internal server error"
 *
 * @function
 * @name getItemDescription
 * @memberof module:Routes/Items
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {NotFoundError} Will throw an error if the item with the specified ID is not found.
 * @throws {InternalServerError} Will throw an error if there's an issue with the database query.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
app.get('/get-item-description', authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    const itemId = req.query.item;
    
    // Query the database to get the item description
    const result = await executeQuery(connection,'SELECT item_description FROM item_masterr WHERE id = ?', [itemId]);

    if (result.length === 0) {
      console.error('Item not found:', itemId);
      return res.status(404).json({ error: 'Item not found' });
    }

    const itemDescription = result[0].item_description; // Access the item_description property from the first object

    // Respond with the item description
    res.json({ item_description: itemDescription });
  } catch (error) {
    console.error('Error fetching item description:', error);
    res.status(500).json({ error: 'Internal server error' });
  } finally {
    if (connection) {
      connection.end();
    }
  }
});


// API endpoint to calculate SUM(fg_output) for a specific item
/**
 * @swagger
 * /get-fg-output:
 *   get:
 *     summary: Get total FG output for a specific item.
 *     description: Retrieves the total finished goods (FG) output for a specific item based on its ID and additional conditions.
 *     tags:
 *       - Production
 *     security:
 *       - bearerAuth: []
 *     parameters:
 *       - in: query
 *         name: id
 *         schema:
 *           type: integer
 *         required: true
 *         description: The ID of the item to retrieve total FG output for.
 *       - in: query
 *         name: wh
 *         schema:
 *           type: string
 *         required: true
 *         description: The WHERE condition to filter the query (e.g., 'zone=1 AND machine=2').
 *     responses:
 *       200:
 *         description: Successful response with total FG output.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 fg_output:
 *                   type: number
 *                   description: The total finished goods output for the specified item and conditions.
 *       404:
 *         description: Item not found.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: "Item not found"
 *       500:
 *         description: Internal server error.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: "Internal server error"
 *
 * @function
 * @name getFgOutput
 * @memberof module:Routes/Production
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {NotFoundError} Will throw an error if the item with the specified ID is not found.
 * @throws {InternalServerError} Will throw an error if there's an issue with the database query.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
app.get('/get-fg-output', authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    const itemId = req.query.id; // Get the 'item' value from the 'id' query parameter
    const wh = req.query.wh; // Get the 'wh' value from the 'wh' query parameter
    
    // Execute the query asynchronously
    const rows = await executeQuery(connection,'SELECT SUM(fg_output) AS fg_output FROM geopos_operator WHERE item = ? AND ' + wh, [itemId]);

    if (rows.length > 0) {
      res.json({ fg_output: rows[0].fg_output });
    } else {
      res.status(404).json({ error: 'Item not found' });
    }
  } catch (error) {
    console.error('Error executing the query:', error);
    res.status(500).json({ error: 'Internal server error' });
  } finally {
    if (connection) {
      connection.end();
    }
  }
});


// get direct worker
/**
 * @swagger
 * /get-direct-worker:
 *   get:
 *     summary: Get the total number of direct workers for a specific item.
 *     description: Retrieves the total number of direct workers for a specific item based on various parameters such as item ID, zone, machine, shift, and date.
 *     tags:
 *       - Production
 *     security:
 *       - bearerAuth: []
 *     parameters:
 *       - in: query
 *         name: id
 *         schema:
 *           type: integer
 *         required: true
 *         description: The ID of the item to retrieve the total number of direct workers for.
 *       - in: query
 *         name: wh
 *         schema:
 *           type: string
 *         required: true
 *         description: The WHERE condition to filter the query (e.g., 'zone=1 AND machine=2').
 *       - in: query
 *         name: zone
 *         schema:
 *           type: string
 *         description: The zone to filter the query.
 *       - in: query
 *         name: machine
 *         schema:
 *           type: string
 *         description: The machine to filter the query.
 *       - in: query
 *         name: shift
 *         schema:
 *           type: string
 *         description: The shift to filter the query.
 *       - in: query
 *         name: date
 *         schema:
 *           type: string
 *           format: date
 *        
 *     responses:
 *       200:
 *         description: Successful response with the total number of direct workers.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 fg_output:
 *                   type: number
 *                   description: The total number of direct workers for the specified item and conditions.
 *       404:
 *         description: Item not found.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: "Item not found"
 *       500:
 *         description: Internal server error.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: "Internal server error"
 *
 * @function
 * @name getDirectWorker
 * @memberof module:Routes/Production
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {NotFoundError} Will throw an error if the item with the specified ID is not found.
 * @throws {InternalServerError} Will throw an error if there's an issue with the database query.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
app.get('/get-direct-worker', authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    const item = req.query.id;         // Get the 'item' value from the 'id' query parameter
    const wh = req.query.wh;        // Get the 'wh' value from the 'wh' query parameter
    const zone = req.query.zone;    // Get the 'zone' value from the 'zone' query parameter
    const machine = req.query.machine;  // Get the 'machine' value from the 'machine' query parameter
    const shift = req.query.shift;  // Get the 'shift' value from the 'shift' query parameter
    const date = req.query.date;    // Get the 'date' value from the 'date' query parameter

    const workerSql = `
      SELECT *, MAX(demp_count) AS at
      FROM geopos_operator
      WHERE ${wh} AND item = ?
      GROUP BY zone, machine, item, date, shift
    `;

    // Execute the query asynchronously
    const results = await executeQuery(connection, workerSql, [item]);

    if (results.length > 0) {
      // Calculate the sum of 'at' values
      const sumOfAt = results.reduce((accumulator, row) => accumulator + parseFloat(row.at), 0);

      // Return the sum as part of the response
      res.json({ fg_output: sumOfAt });
    } else {
      res.status(404).json({ error: 'Item not found' });
    }
  } catch (error) {
    console.error('Error executing the query:', error);
    res.status(500).json({ error: 'Internal server error' });
  } finally {
    if (connection) {
      connection.end();
    }       
  }
});


//Daywise Production Summary Report

//Daywise production data default
/**
 * @swagger
 * /braid/get_daywise_production_default:
 *   get:
 *     summary: Get day-wise production data with default parameters.
 *     description: Retrieves day-wise production data with default parameters such as total FG, total active workers, and daily PPP for the current date.
 *     tags:
 *       - Production
 *     security:
 *       - bearerAuth: []
 *     responses:
 *       200:
 *         description: Successful response with day-wise production data.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 resultData:
 *                   type: array
 *                   items:
 *                     type: object
 *                     properties:
 *                       date:
 *                         type: string
 *                         format: date
 *                         description: The date of production data.
 *                       totalFG:
 *                         type: number
 *                         description: The total finished goods output for the specified date.
 *                       totalActiveWorker:
 *                         type: number
 *                         description: The total number of active workers for the specified date.
 *                       dailyPPP:
 *                         type: number
 *                         description: The daily Production Per Person (PPP) for the specified date.
 *                 tfgData:
 *                   type: array
 *                   items:
 *                     type: object
 *                     properties:
 *                       item:
 *                         type: string
 *                         description: The description of the item.
 *                       color:
 *                         type: string
 *                         description: The color name of the item.
 *                       tfg:
 *                         type: number
 *                         description: The total finished goods output for the specified item and color on the current date.
 *       500:
 *         description: Internal server error.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: "An error occurred"
 *
 * @function
 * @name getDaywiseProductionDefault
 * @memberof module:Routes/Production
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with the database query.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
app.get('/braid/get_daywise_production_default',authenticateJWT , async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    const now = new Date();
    const day = String(now.getDate()).padStart(2, '0');
    const month = String(now.getMonth() + 1).padStart(2, '0'); // January is 0!
    const year = now.getFullYear();
    const date = `${day}-${month}-${year}`;
    const period = [date];
    const where = `geopos_operator.date=${date}`; // Specify the table alias for "date"



    const promises = period.map(async (d1) => {
      const where = `geopos_operator.date='${d1}'`;

      // Calculate Total FG
      const fgQuery = `SELECT SUM(fg_output) AS fg_output FROM geopos_operator WHERE ${where}`;
      const fgResults = await executeQuery(connection,fgQuery);
      const tfg = fgResults[0].fg_output;

      // Calculate Total Active Worker
      const workerQuery = `SELECT *, max(demp_count) as at FROM geopos_operator WHERE ${where} GROUP BY zone, machine, item, date, shift`;
      const workerResults = await executeQuery(connection,workerQuery);
      let tw = 0;
      for (const wr of workerResults) {
        tw += wr.at;
      }

      // Calculate Daily PPP
      let ppp = 'X';
      if (tfg !== null) {
        ppp = tfg / tw;
        ppp = isNaN(ppp) ? 'X' : ppp.toFixed(4);
      }

      // Store the results in an object
      const result = {
        date: d1, // You may want to store the date as well
        totalFG: tfg,
        totalActiveWorker: tw,
        dailyPPP: ppp,
      };
      return result;
    });

    // Execute all the promises for 'resultData'
    const resultData = await Promise.all(promises);
   
    const results1 = await executeQuery(connection,`
    SELECT geopos_operator.*, color_master.color_name, item_masterr.item_description
    FROM geopos_operator
    LEFT JOIN color_master ON geopos_operator.color_id = color_master.id
    LEFT JOIN item_masterr ON geopos_operator.item = item_masterr.id
    WHERE geopos_operator.date='${date}'
    GROUP BY geopos_operator.item, geopos_operator.color_id`);
    console.log(results1,'========')
    const tfgPromises = results1.map(async (item) => {
      const subWhere = `geopos_operator.item='${item.item}' AND geopos_operator.date='${date}' AND geopos_operator.color_id='${item.color_id}'`;
    
      // Execute the query to get the tfg
      const results2 = await executeQuery(connection,`
        SELECT SUM(fg_output) AS fg_output
        FROM geopos_operator
        WHERE ${subWhere}`);
    
      console.log(results2); // Check the results in the console
    
      // Get the totalFG value from the results or set a default value
      const totalFG = results2.length > 0 ? results2[0].fg_output || '-' : '-';
    
      // Return the tfgData object
      return {
        item: item.item_description,
        color: item.color_name,
        tfg: totalFG,
      };
    });
    
    // Wait for all tfg promises to resolve
    const tfgData = await Promise.all(tfgPromises);
    
    // Combine the data from both sets of queries
    const responseData = {
      resultData: resultData,
      tfgData: tfgData,
    };
    
    // Send the final response
    res.json(responseData);
    

    console.log(responseData);
  } catch (error) {
    console.error(error);
    res.status(500).json({ error: 'An error occurred' });
  } finally {
    if (connection) {
      connection.end();
    }
  }
});



//Daywise production data date wise search
/**
 * @swagger
 * /braid/get_daywise_production_search:
 *   post:
 *     summary: Get day-wise production data with search parameters.
 *     description: Retrieves day-wise production data based on search parameters such as date range, shift, and site.
 *     tags:
 *       - Production
 *     security:
 *       - bearerAuth: []
 *     requestBody:
 *       description: JSON object containing search parameters
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             properties:
 *               fromdate:
 *                 type: string
 *                 format: date
 *                 description: The start date for the search period.
 *               todate:
 *                 type: string
 *                 format: date
 *                 description: The end date for the search period.
 *               shift:
 *                 type: string
 *                 description: The shift for which production data is to be retrieved.
 *               site:
 *                 type: string
 *                 description: The site for which production data is to be retrieved.
 *             required:
 *               - fromdate
 *               - todate
 *     responses:
 *       200:
 *         description: Successful response with day-wise production data based on search parameters.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 resultData:
 *                   type: array
 *                   items:
 *                     type: object
 *                     properties:
 *                       date:
 *                         type: string
 *                         format: date
 *                         description: The date of production data.
 *                       totalFG:
 *                         type: number
 *                         description: The total finished goods output for the specified date.
 *                       totalActiveWorker:
 *                         type: number
 *                         description: The total number of active workers for the specified date.
 *                       dailyPPP:
 *                         type: number
 *                         description: The daily Production Per Person (PPP) for the specified date.
 *                       dates:
 *                         type: array
 *                         description: Array of dates within the search period.
 *                         items:
 *                           type: string
 *                           format: date
 *                           description: Date within the search period.
 *                       fdate:
 *                         type: string
 *                         format: date
 *                         description: The start date for the search period.
 *                       tdate:
 *                         type: string
 *                         format: date
 *                         description: The end date for the search period.
 *                 tfgData:
 *                   type: array
 *                   items:
 *                     type: object
 *                     properties:
 *                       item:
 *                         type: string
 *                         description: The description of the item.
 *                       color:
 *                         type: string
 *                         description: The color name of the item.
 *                       tfg:
 *                         type: array
 *                         description: Array of total finished goods output for each date within the search period.
 *                         items:
 *                           type: number
 *                           description: Total finished goods output for a specific date.
 *       500:
 *         description: Internal server error.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: "An error occurred"
 *
 * @function
 * @name getDaywiseProductionSearch
 * @memberof module:Routes/Production
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with the database query.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
app.post("/braid/get_daywise_production_search",  authenticateJWT , async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    const hr_start = req.body.fromdate;
    const hr_end = req.body.todate;
    const shift = req.body.shift;
    const site = req.body.site;

    // Set the timezone (if needed, you can change "Africa/Lagos" to your desired timezone)
    const timezone = "Africa/Lagos";
    const from = new Date(hr_start);
    const to = new Date(hr_end);

    // Set the timezone for the "from" and "to" dates
    from.toLocaleString("en-US", { timeZone: timezone });
    to.toLocaleString("en-US", { timeZone: timezone });

    // Calculate the start and end dates
    const st = from.toISOString().slice(0, 10);
    const ed = new Date(to.getTime() + 24 * 60 * 60 * 1000)
      .toISOString()
      .slice(0, 10);

    // Create the date range condition
    let where = `datetime BETWEEN '${st}' AND '${ed}'`;
    if (shift !== "") {
      where += ` AND shift='${shift}'`;
    }

    // Initialize an array to store the date range
    const period = [];
    const date = new Date(st); // Initialize the date variable

    // Loop through the date range from start to end date
    while (date <= to) {
      period.push(new Date(date));
      date.setDate(date.getDate() + 1); // Increment the date by one day
    }

    const dates = period.map((d1) => {
      const day = d1.getDate().toString().padStart(2, "0");
      const month = (d1.getMonth() + 1).toString().padStart(2, "0");
      const year = d1.getFullYear();
      return `${day}-${month}-${year}`;
    });

  
    // Promises for Total FG, Total Active Worker, and Daily PPP calculations
    const totalFGPromises = dates.map(async (formattedDate) => {
      let dateCondition = `geopos_operator.date='${formattedDate}'`;

      if (shift !== "") {
        dateCondition += ` AND shift='${shift}'`;
      }

      // Calculate Total FG for the specific date
      const fgQuery = `SELECT SUM(fg_output) AS fg_output FROM geopos_operator WHERE ${dateCondition}`;
      const fgResults = await executeQuery(connection,fgQuery);
      const tfg = fgResults[0].fg_output;

      return tfg;
    });

    const totalActiveWorkerPromises = dates.map(async (formattedDate) => {
      let dateCondition = `geopos_operator.date='${formattedDate}'`;

      if (shift !== "") {
        dateCondition += ` AND shift='${shift}'`;
      }
      
      if (site !== "") {
        dateCondition += ` AND site='${site}'`;
      }

      // Calculate Total Active Worker for the specific date
      const workerQuery = `SELECT *, MAX(demp_count) AS at FROM geopos_operator WHERE ${dateCondition} GROUP BY zone, machine, item, date, shift,site`;
      const workerResults = await executeQuery(connection,workerQuery);
      
      let tw = 0;
      for (const wr of workerResults) {
        // Convert the 'at' value to a number using the unary plus operator
        tw += +wr.at;
      }
      
      // Convert the result to a string with dynamic precision
      tw = tw.toString(); // Convert to string
      tw = parseFloat(tw).toString();
      return tw;
     
    });

    const dailyPPPPromises = dates.map(async (formattedDate) => {
      let dateCondition = `date='${formattedDate}'`;

      if (shift !== "") {
        dateCondition += ` AND shift='${shift}'`;
      }

      // Calculate Total FG for the specific date
      const fgQuery = `SELECT SUM(fg_output) AS fg_output FROM geopos_operator WHERE ${dateCondition}`;
      const fgResults = await executeQuery(connection,fgQuery);
      const tfg = fgResults[0].fg_output;

      // Calculate Total Active Worker for the specific date
      const workerQuery = `SELECT *, MAX(demp_count) AS at FROM geopos_operator WHERE ${dateCondition} GROUP BY zone, machine, item, date, shift`;
      const workerResults = await executeQuery(connection,workerQuery);
      let tw = 0;
      for (const wr of workerResults) {
        tw += + wr.at;
      }
      
      // Calculate Daily PPP for the specific date
      let ppp = "X";
      if (tfg !== null) {
        ppp = tfg / tw;
        ppp = isNaN(ppp) ? "X" : ppp.toFixed(4);
      }

      return ppp;
    });

    // Wait for all promises to resolve
    const totalFGs = await Promise.all(totalFGPromises);
    const totalActiveWorkers = await Promise.all(totalActiveWorkerPromises);
    const dailyPPPs = await Promise.all(dailyPPPPromises);

    // Create an array to store the final result data
    const resultData = dates.map((d1, index) => {
      const tfg = totalFGs[index];
      const tw = totalActiveWorkers[index];
      const ppp = dailyPPPs[index];
      //console.log(tw+']]]]]]]]]]]]]]]]]]]]]]]]')
      // Store the results in an object for each date
      return {
        date: d1,
        totalFG: tfg,
        totalActiveWorker: tw,
        dailyPPP: ppp,
        dates:dates,
        fdate:hr_start,
        tdate:hr_end,
      };
    });

    // Execute the first query using the connection pool
    const results1 = await executeQuery(connection,`
      SELECT geopos_operator.*, color_master.color_name, item_masterr.item_description
      FROM geopos_operator
      LEFT JOIN color_master ON geopos_operator.color_id = color_master.id
      LEFT JOIN item_masterr ON geopos_operator.item = item_masterr.id
      WHERE ${where}
      GROUP BY geopos_operator.item, geopos_operator.color_id`);
    //console.log(dates + "==============");

    // Create an array of promises for the second queries
    const tfgPromises = results1.map(async (item) => {
      const totalFG = [];
      for (const formattedDate of dates) {
        const subWhere = `geopos_operator.item='${item.item}' AND geopos_operator.date='${formattedDate}' AND geopos_operator.color_id='${item.color_id}'`;

        const results2 = await executeQuery(connection,`
          SELECT SUM(fg_output) AS fg_output
          FROM geopos_operator
          WHERE ${subWhere}`);

        const tfg = results2[0].fg_output;
        const totalFGs = tfg !== null && tfg !== "" ? tfg : "-";
        totalFG.push(totalFGs);
      }
      return {
        item: item.item_description,
        color: item.color_name,
        tfg: totalFG,
      };
    });

    // Wait for all tfg promises to resolve
    const tfgData = await Promise.all(tfgPromises);

    // Send the final response
    const responseData = {
      resultData: resultData,
      tfgData: tfgData,
    };

    res.json(responseData);
    console.log(responseData);
  } catch (error) {
    console.error(error);
    res.status(500).json({ error: "An error occurred" });
  } finally {
    connection.end();
    //console.log("Connection released");
  }
});



//Wastage Report

//default data fetch
/**
 * @swagger
 * /get-direct-worker:
 *   get:
 *     summary: Retrieve information about direct workers.
 *     description: Retrieves information about direct workers based on provided query parameters such as item, warehouse, zone, machine, shift, and date.
 *     tags:
 *       - Direct Worker
 *     security:
 *       - bearerAuth: []
 *     parameters:
 *       - in: query
 *         name: id
 *         schema:
 *           type: integer
 *         description: The ID of the item.
 *       - in: query
 *         name: wh
 *         schema:
 *           type: string
 *         description: The warehouse value.
 *       - in: query
 *         name: zone
 *         schema:
 *           type: string
 *         description: The zone value.
 *       - in: query
 *         name: machine
 *         schema:
 *           type: string
 *         description: The machine value.
 *       - in: query
 *         name: shift
 *         schema:
 *           type: string
 *         description: The shift value.
 *       - in: query
 *         name: date
 *         schema:
 *           type: string
 *           format: date
 *         description: The date value.
 *     responses:
 *       200:
 *         description: Successful response with information about direct workers.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 fg_output:
 *                   type: number
 *                   description: The sum of direct workers' counts for the specified parameters.
 *       404:
 *         description: Item not found.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: "Item not found"
 *       500:
 *         description: Internal server error.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: "Internal server error"
 *
 * @function
 * @name getDirectWorker
 * @memberof module:Routes/DirectWorker
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with the database query.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
app.get('/get-direct-worker', authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    const item = req.query.id;         // Get the 'item' value from the 'id' query parameter
    const wh = req.query.wh;        // Get the 'wh' value from the 'wh' query parameter
    const zone = req.query.zone;    // Get the 'zone' value from the 'zone' query parameter
    const machine = req.query.machine;  // Get the 'machine' value from the 'machine' query parameter
    const shift = req.query.shift;  // Get the 'shift' value from the 'shift' query parameter
    const date = req.query.date;    // Get the 'date' value from the 'date' query parameter

    const workerSql = `
      SELECT *, MAX(demp_count) AS at
      FROM geopos_operator
      WHERE ${wh} AND item = ?
      GROUP BY zone, machine, item, date, shift
    `;

    // Execute the query asynchronously
    const results = await executeQuery(connection,workerSql, [item]);

    if (results.length > 0) {
      // Calculate the sum of 'at' values
      const sumOfAt = results.reduce((accumulator, row) => accumulator + parseFloat(row.at), 0);

      // Return the sum as part of the response
      res.json({ fg_output: sumOfAt });
    } else {
      res.status(404).json({ error: 'Item not found' });
    }
  } catch (error) {
    console.error('Error executing the query:', error);
    res.status(500).json({ error: 'Internal server error' });
  } finally {
    if (connection) {
      connection.end();
    }
  }
});


//filter data search
/**
 * @swagger
 * /wastage-daterangeview:
 *   post:
 *     summary: Fetch data within a specified date range for viewing wastage.
 *     description: Fetches data within a specified date range for viewing wastage based on the provided 'fromdate' and 'todate' parameters.
 *     tags:
 *       - Wastage
 *     security:
 *       - bearerAuth: []
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             properties:
 *               fromdate:
 *                 type: string
 *                 format: date
 *                 description: The start date of the date range.
 *               todate:
 *                 type: string
 *                 format: date
 *                 description: The end date of the date range.
 *     responses:
 *       200:
 *         description: Successful response with wastage data within the specified date range.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 data:
 *                   type: object
 *                   properties:
 *                     items:
 *                       type: array
 *                       items:
 *                         type: object
 *                         properties:
 *                           id:
 *                             type: integer
 *                             description: The ID of the item.
 *                           item_description:
 *                             type: string
 *                             description: The description of the item.
 *                        
 *                     from:
 *                       type: string
 *                       format: date
 *                       description: The start date of the date range.
 *                     to:
 *                       type: string
 *                       format: date
 *                       description: The end date of the date range.
 *                     tdate:
 *                       type: integer
 *                       description: A flag indicating the type of date (0 for specific date, 1 for date range).
 *       500:
 *         description: Internal server error.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: "Internal Server Error"
 *
 * @function
 * @name getWastageDateRangeView
 * @memberof module:Routes/Wastage
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with the database query.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
app.post('/wastage-daterangeview', authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    const fromdate = req.body.fromdate;
    const fdParts = fromdate.split('-');
    const fd = `${fdParts[2]}-${fdParts[1]}-${fdParts[0]}`;

    const todate = req.body.todate;
    const tdParts = todate.split('-');
    const td = `${tdParts[2]}-${tdParts[1]}-${tdParts[0]}`;

    const dateObj = new Date(fromdate);
    const day = dateObj.getDate().toString().padStart(2, '0');
    const month = (dateObj.getMonth() + 1).toString().padStart(2, '0');
    const year = dateObj.getFullYear();

    const convertedDate = `${day}-${month}-${year}`;

    const dateObj1 = new Date(todate);
    const day1 = dateObj1.getDate().toString().padStart(2, '0');
    const month1 = (dateObj1.getMonth() + 1).toString().padStart(2, '0');
    const year1 = dateObj1.getFullYear();

    const convertedDate1 = `${day1}-${month1}-${year1}`;
    console.log('Converted:', convertedDate);
    console.log('Converted2:', convertedDate1);

    const fd2 = Math.floor(new Date(fromdate).getTime() / 1000);
    const td1 = Math.floor(new Date(todate).getTime() / 1000);
    const fd1 = Math.floor(new Date(fd2 * 1000).setDate(new Date(fd2 * 1000).getDate() - 1) / 1000);

    var newfd = fd2;
    var newtd = td1;

    // Parse the ISO 8601 date string
    const parsedDate = new Date(fromdate);
    const parsedDate1 = new Date(todate);

    // Add one day to the parsed dates
    parsedDate1.setDate(parsedDate1.getDate() + 1);

    // Format the date in a more human-readable format (e.g., "YYYY-MM-DD HH:MM:SS")
    const formattedDate = `${parsedDate.getFullYear()}-${(parsedDate.getMonth() + 1).toString().padStart(2, '0')}-${parsedDate.getDate().toString().padStart(2, '0')} ${parsedDate.getHours().toString().padStart(2, '0')}:${parsedDate.getMinutes().toString().padStart(2, '0')}:${parsedDate.getSeconds().toString().padStart(2, '0')}`;
    const formattedDate1 = `${parsedDate1.getFullYear()}-${(parsedDate1.getMonth() + 1).toString().padStart(2, '0')}-${parsedDate1.getDate().toString().padStart(2, '0')} ${parsedDate1.getHours().toString().padStart(2, '0')}:${parsedDate1.getMinutes().toString().padStart(2, '0')}:${parsedDate1.getSeconds().toString().padStart(2, '0')}`;

    // Log the received data
    const where = `geopos_operator.datetime BETWEEN '${formattedDate}' AND '${formattedDate1}'`;

    const sql = `
      SELECT item_masterr.*, geopos_operator.item
      FROM item_masterr
      LEFT JOIN geopos_operator ON item_masterr.id = geopos_operator.item
      WHERE ${where}
      GROUP BY geopos_operator.item
    `;

    // Execute the query asynchronously
    const results = await executeQuery(connection,sql);

    const data = {
      items: results,
      from: convertedDate,
      to: convertedDate1,
      tdate: 0,
    };

    res.status(200).json({ data });
  } catch (error) {
    console.error('Error executing SQL query:', error);
    res.status(500).json({ error: 'Internal Server Error' });
  } finally {
    if (connection) {
      connection.end();
    }
  }
});


// get target expected and waste weight
/**
 * @swagger
 * /wastage-target-expected-wasteweight:
 *   post:
 *     summary: Calculate target and expected waste weight for items within a date range.
 *     description: |
 *       Calculates the target and expected waste weight for items within a date range based on the provided data.
 *       The request body should contain an array of date columns and response data containing items with their properties.
 *     tags:
 *       - Wastage
 *     security:
 *       - bearerAuth: []
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             properties:
 *               dateColumns:
 *                 type: array
 *                 items:
 *                   type: object
 *                   properties:
 *                     data:
 *                       type: string
 *                       format: date
 *                       description: The date for the calculation.
 *               responseData:
 *                 type: object
 *                 properties:
 *                   items:
 *                     type: array
 *                     items:
 *                       type: object
 *                       properties:
 *                         id:
 *                           type: integer
 *                           description: The ID of the item.
 *                         item_description:
 *                           type: string
 *                           description: The description of the item.
 *                         net_weight:
 *                           type: number
 *                           description: The net weight of the item.
 *                         targeted_waste:
 *                           type: number
 *                           description: The targeted waste of the item.
 *     responses:
 *       200:
 *         description: Successful response with calculated target and expected waste weight.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 data:
 *                   type: array
 *                   items:
 *                     type: object
 *                     properties:
 *                       item_description:
 *                         type: string
 *                         description: The description of the item.
 *                       item_data:
 *                         type: array
 *                         items:
 *                           type: object
 *                           properties:
 *                             item_id:
 *                               type: integer
 *                               description: The ID of the item.
 *                             item_description:
 *                               type: string
 *                               description: The description of the item.
 *                             tww:
 *                               type: string
 *                               description: The calculated target waste weight.
 *                             eww:
 *                               type: string
 *                               description: The calculated expected waste weight.
 *                             wst:
 *                               type: string
 *                               description: The total waste weight.
 *       500:
 *         description: Internal server error.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: "Server error"
 *
 * @function
 * @name calculateWastageTargetExpectedWeight
 * @memberof module:Routes/Wastage
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with the database query or calculation.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
app.post('/wastage-target-expected-wasteweight', authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    const receivedData = req.body;
    const { dateColumns, responseData } = receivedData;
    const roleid = 5;

    const resultArray = [];

    for (const item of responseData.items) {
      const id = item.id;
      const itemDescription = item.item_description;

      // Assuming each item has a 'net_weight' and 'targeted_waste' property
      const netWeight = item.net_weight;
      const targetedWaste = item.targeted_waste;

      const itemData = [];

      for (const dateColumn of dateColumns) {
        let where;

        if (roleid === 5) {
          where = `item='${item.id}' AND date='${dateColumn.data}'`;
        } else {
          const id1 = 9;
          const query = `
            SELECT geopos_employees.*
            FROM geopos_employees
            LEFT JOIN geopos_users ON geopos_employees.entryid = geopos_users.entryid
            WHERE geopos_users.id = ${id1}
          `;

          const results = await executeQuery(connection,query);

          if (results.length === 0) {
            return res.status(404).json({ error: 'Employee not found' });
          }

          const empid = results[0].id;
          where = `item='${item.id}' AND date='${dateColumn}' AND emp_id='${empid}'`;
        }

        const query = `
          SELECT *
          FROM geopos_operator
          WHERE ${where}
          GROUP BY item,date,zone,machine,hr_start
        `;

        const operatorResults = await executeQuery(connection,query);

        let re = 0;
        let t = 0;
        let wst = 0;

        for (const ws of operatorResults) {
          const tf = parseFloat(ws.fiber);
          re += parseFloat(ws.fg_output);
          t += tf; // Accumulate tf into t
          wst += parseFloat(ws.waste_weight);
        }

        const tg = t * 1000;
        const twww = (parseInt(t) * 1000) - (parseInt(item.net_weight) * (parseInt(t) * 1000) / (parseInt(item.net_weight) + parseInt(item.targeted_waste)));
        const tww = twww.toFixed(3) + ' gm';
        const eww = (tg - item.net_weight * re).toFixed(0) + ' gm';

        itemData.push({
          item_id: id,
          item_description: itemDescription,
          tww,
          eww,
          wst: wst.toFixed(0) + ' gm',
        });
      }

      resultArray.push({
        item_description: itemDescription,
        item_data: itemData,
      });
    }

    const responseDataObject = {
      data: resultArray,
    };

    res.json(responseDataObject);
  } catch (err) {
    console.error('Error:', err);
    res.status(500).json({ error: 'Server error' });
  } finally {
    if (connection) {
      connection.end();
    }
  }
});



//Wastage Per Item Report

//Wastage percentage per item search data
/**
 * @swagger
 * /braid/get_wastage_item_search_data:
 *   post:
 *     summary: Get wastage item search data within a date range.
 *     description: |
 *       Retrieves wastage data for items within a specified date range.
 *       The request body should contain `fromdate` and `todate` in `dd-mm-yyyy` format.
 *     tags:
 *       - Wastage
 *     security:
 *       - bearerAuth: []
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             properties:
 *               fromdate:
 *                 type: string
 *                 format: date
 *                 description: The start date in `dd-mm-yyyy` format.
 *                 example: "01-01-2023"
 *               todate:
 *                 type: string
 *                 format: date
 *                 description: The end date in `dd-mm-yyyy` format.
 *                 example: "31-01-2023"
 *     responses:
 *       200:
 *         description: Successful response with wastage item data.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 dates:
 *                   type: array
 *                   items:
 *                     type: string
 *                     format: date
 *                     description: Dates in the specified range.
 *                 fdate:
 *                   type: string
 *                   format: date
 *                   description: The formatted start date in `yyyy-mm-dd` format.
 *                 tdate:
 *                   type: string
 *                   format: date
 *                   description: The formatted end date in `yyyy-mm-dd` format.
 *                 datas:
 *                   type: array
 *                   items:
 *                     type: object
 *                     properties:
 *                       items:
 *                         type: string
 *                         description: The item description.
 *                       values:
 *                         type: object
 *                         additionalProperties:
 *                           type: array
 *                           items:
 *                             type: string
 *                             description: Waste percentage value for the item on the given date.
 *       500:
 *         description: Internal server error.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: "An error occurred"
 *
 * @function
 * @name getWastageItemSearchData
 * @memberof module:Routes/Wastage
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with the database query or calculation.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
app.post('/braid/get_wastage_item_search_data',  authenticateJWT , async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    const timezone = 'Africa/Lagos';
    const fromdate = req.body.fromdate;
    const fdParts = fromdate.split('-');
    const fd = `${fdParts[2]}-${fdParts[1]}-${fdParts[0]}`;

    const todate = req.body.todate;
    const tdParts = todate.split('-');
    const td = `${tdParts[2]}-${tdParts[1]}-${tdParts[0]}`;

    const dateObj = new Date(fromdate);
    const day = dateObj.getDate().toString().padStart(2, '0');
    const month = (dateObj.getMonth() + 1).toString().padStart(2, '0');
    const year = dateObj.getFullYear();
    const convertedDate = `${year}-${month}-${day}`;

    const dateObj1 = new Date(todate);
    const day1 = dateObj1.getDate().toString().padStart(2, '0');
    const month1 = (dateObj1.getMonth() + 1).toString().padStart(2, '0');
    const year1 = dateObj1.getFullYear();
    const convertedDate1 = `${year1}-${month1}-${day1}`;

    if (fromdate && todate) {
      from = new Date(fromdate);
      to = new Date(todate);
    }

    from.toLocaleString('en-US', { timeZone: timezone });
    to.toLocaleString('en-US', { timeZone: timezone });

    const period = [];
    const date = new Date(from);

    while (date <= to) {
      period.push(new Date(date));
      date.setDate(date.getDate() + 1);
    }

    // Function to format a date as "d-m-Y"
    
    const formatDate = (date) => {
      const day = String(date.getDate()).padStart(2, '0');
      const month = String(date.getMonth() + 1).padStart(2, '0');
      const year = date.getFullYear();
      return `${day}-${month}-${year}`;
    };
    
  
    const formattedDates = period.map((date) => formatDate(date));
    // Fetch data for geopos_machine
    const sql=`
    SELECT item_masterr.*, geopos_operator.item
    FROM item_masterr
    LEFT JOIN geopos_operator ON item_masterr.id = geopos_operator.item
    WHERE geopos_operator.datetime between '${convertedDate}' and '${convertedDate1}'
    GROUP BY geopos_operator.item`;
    console.log(sql);
    const zoneRows = await executeQuery(connection,sql);
  

   
      const responseData ={
        dates: formattedDates,
        fdate:convertedDate,
        tdate:convertedDate1,
        datas:[],
      }; // Collect response data here
           
      for (const zoneItem of zoneRows) {
        const items = zoneItem.item_description;
        const id = zoneItem.id;
        const valuesByDate = {}; // Store values by date
          for (const dt of period) {
            const d1 = formatDate(dt); // Format as "d-m-Y"
            
            const where = `item='${id}' AND date='${d1}' `;

            try {
              // Fetch data for geopos_operator
              const operatorRows = await executeQuery(connection,`
              SELECT * FROM geopos_operator WHERE ${where}
              `);
              
              const values = [];

              if (operatorRows.length > 0) {
                let rs = 0;
                let re = 0;
                let j = 1;
                let t = 0;
                let wst = 0;
                let pw = 0; // Initialize pw
                
                for (const ws of operatorRows) {
                  const tf = parseInt(ws.fiber, 10);
                  const fgOutput = parseInt(ws.fg_output, 10);
                  const wasteWeight = parseFloat(ws.waste_weight);
                 
                  re +=fgOutput;
                  t +=tf;
                  wst +=wasteWeight;
                  j++;
                }
                
                if (t !== 0) {
                 
                  pw = (wst / (t * 1000)) * 100;
                  // Convert pw to an integer using parseInt
                  pw = parseInt(Math.round(pw * 100), 10) / 100;
                  values.push(pw.toFixed(2) + ' %');
                } else {
                  values.push(pw + ' %');
                }

              }else {
                // Handle case when operatorRows is empty
                values.push('-');
              }

              // Store values for this date
              valuesByDate[d1] = values;
              console.log(`Values for date ${d1}:`, valuesByDate[d1]);
            } catch (dbError) {
              console.error('Database Error:', dbError);
              // Initialize values for this date as an array containing an error message
              valuesByDate[d1] = ['Error fetching data'];
            } finally {
              // Close the database connection
              connection.end();
            }
          }

          // Push the data for this machine to responseData
          responseData.datas.push({
            items: items,
            values: valuesByDate,
          });

      }

      // Send the response data
      res.json(responseData);
   
  } catch (error) {
    console.error(error);
    res.status(500).json({ error: 'An error occurred' });
  } finally {
    if(connection){
      connection.end();
    }
    
  }
});


// function wastagePerQuery1(query, values) {
//   return new Promise((resolve, reject) => {
//     db.query(query, values, (err, results) => {
//       if (err) {
//         reject(err);
//       } else {
//         resolve(results);
//       }
//     });
//   });
// }

//get default data
/**
 * @swagger
 * /get_wastage_item_data:
 *   get:
 *     summary: Get wastage item data for the current date.
 *     description: |
 *       Retrieves wastage data for items on the current date.
 *     tags:
 *       - Wastage
 *     security:
 *       - bearerAuth: []
 *     responses:
 *       200:
 *         description: Successful response with wastage item data.
 *         content:
 *           application/json:
 *             schema:
 *               type: array
 *               items:
 *                 type: object
 *                 properties:
 *                   items:
 *                     type: string
 *                     description: The item description.
 *                   values:
 *                     type: object
 *                     additionalProperties:
 *                       type: array
 *                       items:
 *                         type: string
 *                         description: Waste percentage value for the item on the given date.
 *                   dates:
 *                     type: array
 *                     items:
 *                       type: string
 *                       format: date
 *                       description: Dates in the specified range.
 *       404:
 *         description: No data found.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: "No data found"
 *       500:
 *         description: Internal server error.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: "An error occurred"
 *
 * @function
 * @name getWastageItemData
 * @memberof module:Routes/Wastage
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with the database query or calculation.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
app.get('/get_wastage_item_data',authenticateJWT , async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection()
    const now = new Date();
    const day = String(now.getDate()).padStart(2, '0');
    const month = String(now.getMonth() + 1).padStart(2, '0'); // January is 0!
    const year = now.getFullYear();
    const date = `${day}-${month}-${year}`;
    const period = [date];
  
    const formattedDates = period.map((date) => date);
    // Fetch data for geopos_machine
    const ItemsRows = await executeQuery(connection,'SELECT * FROM item_masterr');

    if (ItemsRows.length > 0) {
      const responseData = []; // Collect response data here

      for (const zoneItem of ItemsRows) {
        const items = zoneItem.item_description;

        const valuesByDate = {}; // Store values by date
          for (const dt of period) {
            const d1 = dt; // Format as "d-m-Y"
          
            const where = `item='${zoneItem.id}' AND date='${d1}' `;

            try {
              // Fetch data for geopos_operator
              const operatorRows = await executeQuery(connection,`
              SELECT * FROM geopos_operator WHERE ${where}
              `);
              
              const values = [];

              if (operatorRows.length > 0) {
                let rs = 0;
                let re = 0;
                let j = 1;
                let t = 0;
                let wst = 0;

                for (const ws of operatorRows) {
                  const tf = ws.fiber;
                  re = re + ws.fg_output;
                  t = t + tf;
                  wst = wst + ws.waste_weight;
                  j++;
                }

                if (t !== 0) {
                  const pw = (wst / (t * 1000)) * 100;
                  values.push(pw.toFixed(2) + ' %');
                } else {
                  values.push('-');
                }
              }else {
                // Handle case when operatorRows is empty
                values.push('-');
              }

              // Store values for this date
              valuesByDate[d1] = values;
              //console.log(`Values for date ${d1}:`, valuesByDate[d1]);
            } catch (dbError) {
              console.error('Database Error:', dbError);
              // Initialize values for this date as an array containing an error message
              valuesByDate[d1] = ['Error fetching data'];
            }
          }

          // Push the data for this machine to responseData
          responseData.push({
            items: items,
            values: valuesByDate,
            dates: formattedDates,
          });
      }

      // Send the response data
      res.json(responseData);
      console.log(responseData);
    } else {
      // Handle case when zoneRows is empty
      res.status(404).json({ error: 'No data found' });
    }
  } catch (error) {
    console.error(error);
    res.status(500).json({ error: 'An error occurred' });
  } finally {
    if(connection){
      connection.end();
    }
    
  }
});


// function wastagePerQuery(query, values) {
//   return new Promise((resolve, reject) => {
//     db.query(query, values, (err, results) => {
//       if (err) {
//         reject(err);
//       } else {
//         resolve(results);
//       }
//     });
//   });
// }


//Production Dashboard Report

//Braid Report performance dashboard
/**
 * @swagger
 * /braid/get_dashboard_default_data:
 *   get:
 *     summary: Get default dashboard data for the current date.
 *     description: |
 *       Retrieves default data for the dashboard for the current date in the 'Africa/Lagos' timezone.
 *     tags:
 *       - Dashboard
 *     security:
 *       - bearerAuth: []
 *     responses:
 *       200:
 *         description: Successful response with default dashboard data.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 Dates:
 *                   type: array
 *                   items:
 *                     type: string
 *                     format: date
 *                     description: Current date in "dd-MM-yyyy" format.
 *                 results:
 *                   type: array
 *                   items:
 *                     type: object
 *                     properties:
 *                       id:
 *                         type: integer
 *                         description: Item ID.
 *                       item_description:
 *                         type: string
 *                         description: Item description.
 *                       other_properties:
 *                         type: object
 *                         description: Other properties from the item_masterr and geopos_operator tables.
 *       500:
 *         description: Internal server error.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: "Internal Server Error"
 *
 * @function
 * @name getDashboardDefaultData
 * @memberof module:Routes/Dashboard
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with the database query or calculation.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
app.get('/braid/get_dashboard_default_data', authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    const date = new Date().toLocaleDateString('en-GB', { timeZone: 'Africa/Lagos' });
    const parts = date.split('/');
    const day = parts[0].padStart(2, '0');
    const month = parts[1].padStart(2, '0');
    const year = parts[2];
    const currentDate = `${day}-${month}-${year}`;

    const sql = `
      SELECT item_masterr.*, geopos_operator.item
      FROM item_masterr
      LEFT JOIN geopos_operator ON item_masterr.id = geopos_operator.item
      WHERE geopos_operator.date = ?
      GROUP BY geopos_operator.item
    `;

    const results = await executeQuery(connection, sql, [currentDate]);

    const response = {
      Dates: [currentDate],
      results: results,
    };

    res.json(response);
    console.log(response);
  } catch (error) {
    console.error('Error executing SQL query:', error);
    res.status(500).json({ error: 'Internal Server Error' });
  } finally {
    if(connection){
      connection.end();
    }
  }
});


//Braid Report Performance dashboard search report
/**
 * @swagger
 * /braid/get_dashboard_search_data:
 *   post:
 *     summary: Get dashboard data for a specific date range.
 *     description: |
 *       Retrieves dashboard data for the specified date range in the 'Africa/Lagos' timezone.
 *     tags:
 *       - Dashboard
 *     security:
 *       - bearerAuth: []
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             properties:
 *               fromdate:
 *                 type: string
 *                 format: date
 *                 description: Start date of the range in "dd-MM-yyyy" format.
 *                 example: "01-01-2024"
 *               todate:
 *                 type: string
 *                 format: date
 *                 description: End date of the range in "dd-MM-yyyy" format.
 *                 example: "31-01-2024"
 *     responses:
 *       200:
 *         description: Successful response with dashboard data for the specified date range.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 Dates:
 *                   type: array
 *                   items:
 *                     type: string
 *                     format: date
 *                     description: Dates in the specified range.
 *                 results:
 *                   type: array
 *                   items:
 *                     type: object
 *                     properties:
 *                       id:
 *                         type: integer
 *                         description: Item ID.
 *                       item_description:
 *                         type: string
 *                         description: Item description.
 *                       other_properties:
 *                         type: object
 *                         description: Other properties from the item_masterr and geopos_operator tables.
 *       500:
 *         description: Internal server error.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: "Internal Server Error"
 *
 * @function
 * @name getDashboardSearchData
 * @memberof module:Routes/Dashboard
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with the database query or calculation.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
app.post('/braid/get_dashboard_search_data', authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    const timezone = 'Africa/Lagos';
    const fromdate = req.body.fromdate;
    const fdParts = fromdate.split('-');
    const fd = `${fdParts[2]}-${fdParts[1]}-${fdParts[0]}`;

    const todate = req.body.todate;
    const tdParts = todate.split('-');
    const td = `${tdParts[2]}-${tdParts[1]}-${tdParts[0]}`;

    const dateObj = new Date(fromdate);
    const day = dateObj.getDate().toString().padStart(2, '0');
    const month = (dateObj.getMonth() + 1).toString().padStart(2, '0');
    const year = dateObj.getFullYear();
    const convertedDate = `${year}-${month}-${day}`;

    const dateObj1 = new Date(todate);
    const day1 = dateObj1.getDate().toString().padStart(2, '0');
    const month1 = (dateObj1.getMonth() + 1).toString().padStart(2, '0');
    const year1 = dateObj1.getFullYear();
    const convertedDate1 = `${year1}-${month1}-${day1}`;

    const period = [];
    const date = new Date(dateObj);

    while (date <= dateObj1) {
      period.push(new Date(date));
      date.setDate(date.getDate() + 1);
    }

    // Function to format a date as "d-m-Y"
    const formatDate = (date) => {
      const day = String(date.getDate()).padStart(2, '0');
      const month = String(date.getMonth() + 1).padStart(2, '0');
      const year = date.getFullYear();
      return `${day}-${month}-${year}`;
    };

    const formattedDates = period.map((date) => formatDate(date));
    const where = `geopos_operator.datetime BETWEEN '${convertedDate}' AND '${convertedDate1}'`;

    const sql = `
      SELECT item_masterr.*, geopos_operator.item
      FROM item_masterr
      LEFT JOIN geopos_operator ON item_masterr.id = geopos_operator.item
      WHERE ${where}
      GROUP BY geopos_operator.item
    `;

    const results = await executeQuery(connection, sql);
    const response = {
      Dates: formattedDates,
      results: results,
    };

    res.json(response);
    console.log(formattedDates);
  } catch (error) {
    console.error('Error executing SQL query:', error);
    res.status(500).json({ error: 'Internal Server Error' });
  } finally {
    if(connection){
      connection.end();
    }
  } 
});



//Braid Report performance dashboard fg output data
/**
 * @swagger
 * /braid/get_fg_output_data:
 *   get:
 *     summary: Retrieve finished goods output data for a specific item and date.
 *     description: Fetches data from the geopos_operator table for a specific item and date, grouped by item, date, zone, machine, and hr_start.
 *     tags:
 *       - Dashboard
 *     security:
 *       - bearerAuth: []
 *     parameters:
 *       - in: query
 *         name: item
 *         schema:
 *           type: integer
 *         required: true
 *         description: ID of the item to fetch data for.
 *         example: 1
 *       - in: query
 *         name: date
 *         schema:
 *           type: string
 *           format: date
 *         required: true
 *         description: Date to fetch data for in "Y-m-d" format.
 *         example: "2024-05-29"
 *     responses:
 *       200:
 *         description: Successfully retrieved finished goods output data.
 *         content:
 *           application/json:
 *             schema:
 *               type: array
 *               items:
 *                 type: object
 *                 properties:
 *                   item:
 *                     type: integer
 *                     description: Item ID.
 *                   date:
 *                     type: string
 *                     format: date
 *                     description: Date of the data.
 *                   zone:
 *                     type: string
 *                     description: Zone of operation.
 *                   machine:
 *                     type: string
 *                     description: Machine used.
 *                   hr_start:
 *                     type: string
 *                     format: time
 *                     description: Start time of the hour.
 *                   fg_output:
 *                     type: number
 *                     description: Finished goods output.
 *                   fiber:
 *                     type: number
 *                     description: Amount of fiber used.
 *                   waste_weight:
 *                     type: number
 *                     description: Weight of the waste produced.
 *       500:
 *         description: Internal server error.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: "Internal Server Error"
 *
 * @function
 * @name getFgOutputData
 * @memberof module:Routes/Dashboard
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with the database query.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
app.get('/braid/get_fg_output_data', authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    const itemId = req.query.item;
    const dates = req.query.date; // Assuming date is in a valid format, e.g., "Y-m-d"
    const inputDate = new Date(dates); // Replace with your input date
    const options = { year: 'numeric', month: '2-digit', day: '2-digit' };
    const formattedDate = inputDate.toLocaleDateString('en-US', options).replace(/\//g, '-');

    //const empId = req.query.emp_id; // Make sure you have a query parameter for emp_id
    const sql = `
      SELECT *
      FROM geopos_operator
      WHERE item = ? AND date = ?
      GROUP BY item, date, zone, machine, hr_start
    `;

    const results = await executeQuery(connection,sql, [itemId, formattedDate]);

    res.json(results);
  } catch (error) {
    console.error('Error in get_fg_output_data endpoint:', error);
    res.status(500).json({ error: 'Internal Server Error' });
  } finally {
    if(connection){
      connection.end();
    }
  }
});

/**
 * @swagger
 * /braid/get_labour_worker_data:
 *   get:
 *     summary: Retrieve labour worker data for a specific item and date.
 *     description: Fetches data from the geopos_operator table for a specific item and date, grouped by zone, machine, item, and date, and returns the maximum demp_count.
 *     tags:
 *       - Labour
 *     security:
 *       - bearerAuth: []
 *     parameters:
 *       - in: query
 *         name: item
 *         schema:
 *           type: integer
 *         required: true
 *         description: ID of the item to fetch data for.
 *         example: 1
 *       - in: query
 *         name: date
 *         schema:
 *           type: string
 *           format: date
 *         required: true
 *         description: Date to fetch data for in "Y-m-d" format.
 *         example: "2024-05-29"
 *     responses:
 *       200:
 *         description: Successfully retrieved labour worker data.
 *         content:
 *           application/json:
 *             schema:
 *               type: array
 *               items:
 *                 type: object
 *                 properties:
 *                   item:
 *                     type: integer
 *                     description: Item ID.
 *                   date:
 *                     type: string
 *                     format: date
 *                     description: Date of the data.
 *                   zone:
 *                     type: string
 *                     description: Zone of operation.
 *                   machine:
 *                     type: string
 *                     description: Machine used.
 *                   demp_count:
 *                     type: integer
 *                     description: Labour worker count.
 *                   at:
 *                     type: integer
 *                     description: Maximum labour worker count.
 *       500:
 *         description: Internal server error.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: "Internal Server Error"
 *
 * @function
 * @name getLabourWorkerData
 * @memberof module:Routes/Labour
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with the database query.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
//Braid Report performance dashboard labour data
app.get('/braid/get_labour_worker_data', authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    const itemId = req.query.item;
    const dates = req.query.date; // Assuming date is in a valid format, e.g., "Y-m-d"

    const inputDate = new Date(dates); // Replace with your input date
    const options = { year: 'numeric', month: '2-digit', day: '2-digit' };
    const formattedDate = inputDate.toLocaleDateString('en-US', options).replace(/\//g, '-');

    const sql = `
      SELECT *, MAX(demp_count) as at
      FROM geopos_operator
      WHERE item = ? AND date = ?
      GROUP BY zone, machine, item, date
    `;

    const results = await executeQuery(connection,sql, [itemId, formattedDate]);

    res.json(results);
  } catch (error) {
    console.error('Error in get_labour_worker_data endpoint:', error);
    res.status(500).json({ error: 'Internal Server Error' });
  } finally {
    if(connection){
      connection.end();
    }
  }
});


//Braid Report performance dashboard ppp data
/**
 * @swagger
 * /braid/get_ppp_data:
 *   get:
 *     summary: Retrieve PPP data for a specific item and date.
 *     description: Calculates and returns the PPP (finished goods output per worker) for a given item and date.
 *     tags:
 *       - PPP
 *     security:
 *       - bearerAuth: []
 *     parameters:
 *       - in: query
 *         name: item
 *         schema:
 *           type: integer
 *         required: true
 *         description: ID of the item to fetch data for.
 *         example: 1
 *       - in: query
 *         name: date
 *         schema:
 *           type: string
 *           format: date
 *         required: true
 *         description: Date to fetch data for in "Y-m-d" format.
 *         example: "2024-05-29"
 *     responses:
 *       200:
 *         description: Successfully retrieved PPP data.
 *         content:
 *           application/json:
 *             schema:
 *               type: number
 *               example: 10.5
 *       500:
 *         description: Internal server error.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: "Internal Server Error"
 *
 * @function
 * @name getPPPData
 * @memberof module:Routes/PPP
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with the database query.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
app.get('/braid/get_ppp_data',authenticateJWT , async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    const itemId = req.query.item;
    const dates = req.query.date; // Assuming date is in a valid format, e.g., "Y-m-d"

    const inputDate = new Date(dates);
    const options = { year: 'numeric', month: '2-digit', day: '2-digit' };
    const formattedDate = inputDate.toLocaleDateString('en-US', options).replace(/\//g, '-');

    // Execute the first query
    const query1 = `
      SELECT *
      FROM geopos_operator
      WHERE item = '${itemId}' AND date = '${dates}'
      GROUP BY item, date, zone, machine, hr_start
    `;
    const query1Result = await executeQuery(connection,query1);
    //console.log(query1 + '1----------------------')
    let fg = 0;
    for (const ws of query1Result) {
      fg +=+ ws.fg_output;
    }

    // Execute the second query
    const query2 = `
      SELECT *, MAX(demp_count) as at
      FROM geopos_operator
      WHERE item = '${itemId}' AND date = '${dates}'
      GROUP BY zone, machine, item, date
    `;
    const query2Result = await executeQuery(connection,query2);
   // console.log(query2 + '2----------------------');
    let tw = 0;
    for (const wr of query2Result) {
      tw +=+ wr.at;
    }

    const divide = fg / tw;
    res.json(divide);
   // console.log(divide + '----------------------');
  } catch (error) {
    console.error('Error:', error);
    res.status(500).json({ error: 'Internal Server Error' });
  } finally {
    if(connection){
      connection.end();
    }
  }
});

//PPP Overall Report

//default data
/**
 * @swagger
 * /getdefault_ppp_overall:
 *   get:
 *     summary: Retrieve default PPP overall data.
 *     description: Fetches default PPP overall data for the current date, using 'Africa/Lagos' timezone.
 *     tags:
 *       - PPP
 *     security:
 *       - bearerAuth: []
 *     responses:
 *       200:
 *         description: Successfully retrieved default PPP overall data.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 items:
 *                   type: array
 *                   items:
 *                     type: object
 *                     properties:
 *                       id:
 *                         type: integer
 *                         example: 1
 *                       item_description:
 *                         type: string
 *                         example: "Item 1"
 *                       
 *                 from:
 *                   type: string
 *                   example: "29-05-2024"
 *                 to:
 *                   type: string
 *                   example: "29-05-2024"
 *                 tdate:
 *                   type: integer
 *                   example: 0
 *       500:
 *         description: Internal server error.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: "Internal Server Error"
 *
 * @function
 * @name getDefaultPPPOverall
 * @memberof module:Routes/PPP
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with the database query.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
app.get('/getdefault_ppp_overall', authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    const date = new Date().toLocaleDateString('en-GB', { timeZone: 'Africa/Lagos' });
    const parts = date.split('/');
    const day = parts[0].padStart(2, '0');
    const month = parts[1].padStart(2, '0');
    const year = parts[2];
    const newcurrentDate1 = `${day}-${month}-${year}`;
    let pw = (0).toFixed(2);

    // Replace this with your database query logic
    const query = 'SELECT * FROM item_masterr';

    const results = await executeQuery(connection,query);

    // Construct the data object to send to the client
    const data = {
      items: results,
      from: newcurrentDate1,
      to: newcurrentDate1,
      tdate: 0, // You can set this value as needed
    };

    res.json(data);
  } catch (error) {
    console.error('Error in getdefault_ppp_overall endpoint:', error);
    res.status(500).json({ error: 'Internal Server Error' });
  } finally {
    if(connection){
      connection.end();
    }
  }
});


// date filter search
/**
 * @swagger
 * /ppp_overall_daterangeview:
 *   post:
 *     summary: Retrieve PPP overall data for a specified date range.
 *     description: Fetches PPP overall data for the specified date range.
 *     tags:
 *       - PPP
 *     security:
 *       - bearerAuth: []
 *     requestBody:
 *       description: Dates for the data range.
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             properties:
 *               fromdate:
 *                 type: string
 *                 example: "29-05-2024"
 *               todate:
 *                 type: string
 *                 example: "30-05-2024"
 *     responses:
 *       200:
 *         description: Successfully retrieved PPP overall data.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 items:
 *                   type: array
 *                   items:
 *                     type: object
 *                     properties:
 *                       id:
 *                         type: integer
 *                         example: 1
 *                       item_description:
 *                         type: string
 *                         example: "Item 1"
 *                      
 *                 from:
 *                   type: string
 *                   example: "29-05-2024"
 *                 to:
 *                   type: string
 *                   example: "30-05-2024"
 *                 tdate:
 *                   type: integer
 *                   example: 0
 *       500:
 *         description: Internal server error.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: "Internal Server Error"
 *
 * @function
 * @name pppOverallDateRangeView
 * @memberof module:Routes/PPP
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with the database query.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
app.post('/ppp_overall_daterangeview', authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    const fromdate = req.body.fromdate;
    const fdParts = fromdate.split('-');
    const fd = `${fdParts[2]}-${fdParts[1]}-${fdParts[0]}`;

    const todate = req.body.todate;
    const tdParts = todate.split('-');
    const td = `${tdParts[2]}-${tdParts[1]}-${tdParts[0]}`;

    const dateObj = new Date(fromdate);
    const day = dateObj.getDate().toString().padStart(2, '0');
    const month = (dateObj.getMonth() + 1).toString().padStart(2, '0');
    const year = dateObj.getFullYear();

    const convertedDate = `${day}-${month}-${year}`;

    const dateObj1 = new Date(todate);
    const day1 = dateObj1.getDate().toString().padStart(2, '0');
    const month1 = (dateObj1.getMonth() + 1).toString().padStart(2, '0');
    const year1 = dateObj1.getFullYear();

    const convertedDate1 = `${day1}-${month1}-${year1}`;
    console.log('Converted:', convertedDate);
    console.log('Converted2:', convertedDate1);

    // Replace this with your database query logic
    const query = `SELECT * FROM item_masterr`;

    const results = await executeQuery(connection,query);

    // Construct the data object to send to the client
    const data = {
      items: results,
      from: convertedDate,
      to: convertedDate1,
      tdate: 0, // You can set this value as needed
    };

    res.json(data);
  } catch (error) {
    console.error('Error in ppp_overall_daterangeview endpoint:', error);
    res.status(500).json({ error: 'Internal Server Error' });
  } finally {
    if(connection){
      connection.end();
    }
  }
});



//get ppp overall
/**
 * @swagger
 * /getpppvalue:
 *   post:
 *     summary: Get PPP values for specified dates.
 *     description: Retrieves PPP values from the database for the given dates and computes productivity weight (pw).
 *     tags:
 *       - PPP
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             properties:
 *               dateColumns:
 *                 type: array
 *                 items:
 *                   type: object
 *                   properties:
 *                     data:
 *                       type: string
 *                       format: date
 *                       description: The date to retrieve PPP values for (YYYY-MM-DD).
 *     responses:
 *       200:
 *         description: Successful response with PPP values for the specified dates.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 data:
 *                   type: array
 *                   items:
 *                     type: object
 *                     properties:
 *                       item_data:
 *                         type: array
 *                         items:
 *                           type: object
 *                           properties:
 *                             date:
 *                               type: string
 *                               format: date
 *                               description: The date for which the PPP values were retrieved.
 *                             pw:
 *                               type: number
 *                               format: float
 *                               description: The productivity weight value.
 *       404:
 *         description: Employee not found.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: "Employee not found"
 *       500:
 *         description: Server error.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: "Server error"
 *
 * @function
 * @name getPPPValue
 * @memberof module:Routes/PPP
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with the database query.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */ 
app.post('/getpppvalue', authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    const receivedData = req.body;
    const { dateColumns } = receivedData;
    const roleid = 5;
    const resultArray = [];
    const itemData = [];

    for (const dateColumn of dateColumns) {
      console.log('Processing date:', dateColumn.data);

      let where;

      if (roleid === 5) {
        where = `date='${dateColumn.data}'`;
      } else {
        const id1 = 9;
        const empQuery = `
          SELECT emp_id
          FROM geopos_users
          WHERE id = ${id1}
        `;
        const empResult = await executeQuery(connection, empQuery);

        if (empResult.length === 0) {
          return res.status(404).json({ error: 'Employee not found' });
        }

        const empid = empResult[0].id;
        where = `date='${dateColumn}' AND emp_id='${empid}'`;
      }

      const query = `
        SELECT *
        FROM geopos_operator
        WHERE ${where}
      `;

      const operatorResults = await executeQuery(connection, query);

      // Query for sum of iemp_count and demp_count
      const sumQuery = `
        SELECT 
          SUM(iemp_count) AS totalw,
          SUM(demp_count) AS totalwd
        FROM geopos_operator
        WHERE ${where}
      `;

      const sumResult = await executeQuery(connection, sumQuery);

      let tw = 0;
      let twd = 0;

      for (const row of sumResult) {
        tw += parseFloat(row.totalw);
        twd += parseFloat(row.totalwd);
      }

      const total = (tw + twd).toFixed(2);
      const top = operatorResults.reduce((acc, row) => acc + parseFloat(row.fg_output), 0);
      const pw = top !== 0 ? (top / total).toFixed(2) : 0;

      itemData.push({
        date: dateColumn.data,
        pw,
      });
    }

    resultArray.push({
      item_data: itemData,
    });

    const responseDataObject = {
      data: resultArray,
    };

    res.json(responseDataObject);
  } catch (err) {
    console.error('Error:', err);
    res.status(500).json({ error: 'Server error' });
  } finally {
    // Make sure to release the connection in the finally block
    if (connection) {
      connection.release();
    }
  }
});


//Machine DownTime Report

//Machine downtime default data 
/**
 * @swagger
 * /braid/get_machineDowntime_data1:
 *   post:
 *     summary: Get machine downtime data.
 *     description: Fetches machine downtime data for the current date and shift 'DAY' for all machines and zones.
 *     tags:
 *       - Machine Downtime
 *     security:
 *       - bearerAuth: []
 *     responses:
 *       200:
 *         description: Successfully fetched machine downtime data.
 *         content:
 *           application/json:
 *             schema:
 *               type: array
 *               items:
 *                 type: object
 *                 properties:
 *                   zones:
 *                     type: string
 *                     description: Zone and machine identifier.
 *                   values:
 *                     type: object
 *                     additionalProperties:
 *                       type: array
 *                       items:
 *                         type: string
 *                         description: Formatted downtime intervals and totals.
 *                   dates:
 *                     type: array
 *                     items:
 *                       type: string
 *                       format: date
 *                       description: Date for which data is provided.
 *       404:
 *         description: No data found.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: No data found
 *       500:
 *         description: An error occurred.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: An error occurred
 *
 * @function
 * @name getMachineDowntimeData1
 * @memberof module:Routes/MachineDowntime
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with the database query.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
app.post('/braid/get_machineDowntime_data1',  authenticateJWT , async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    const now = new Date();
    const day = String(now.getDate()).padStart(2, '0');
    const month = String(now.getMonth() + 1).padStart(2, '0'); // January is 0!
    const year = now.getFullYear();
    const date = `${day}-${month}-${year}`;
    const period = [date];
  
    const formattedDates = period.map((date) => date);
    // Fetch data for geopos_machine
    const zoneRows = await executeQuery(connection,'SELECT * FROM geopos_machine');

    if (zoneRows.length > 0) {
      const responseData = []; // Collect response data here

      for (const zoneItem of zoneRows) {
        const machineList = zoneItem.machine.split(',');

        for (const mach of machineList) {
          const id = zoneItem.zone;
          const zones = `${zoneItem.zone}->${mach}`;
          const valuesByDate = {}; // Store values by date

          for (const dt of period) {
            const d1 = dt; // Format as "d-m-Y"
          
            const where = `zone='${id}' AND machine='${mach}' AND date='${d1}' AND shift='DAY'`;

            try {
              // Fetch data for geopos_operator
              const operatorRows = await executeQuery(connection,`
                SELECT *
                FROM geopos_operator
                WHERE ${where}
                GROUP BY hr_start
              `);
              
              const values = [];

              if (operatorRows.length > 0) {
                const stime = [];
                const etime = [];
                //console.log('ppppp')
                for (const ws of operatorRows) {
                  stime.push(ws.hr_start);
                  etime.push(ws.hr_end);
                }

                stime.sort((a, b) => a.localeCompare(b));
                etime.sort((a, b) => a.localeCompare(b));

                let totalt = 0;

                for (let k = 0; k < stime.length; k++) {
                  if (k === 0) {
                    trange = '07:30';
                    ed = stime[k];
                  } else {
                    trange = etime[k - 1];
                    ed = stime[k];
                  }

                  const time1 = new Date(`1970-01-01T${trange}:00Z`);
                  const time2 = new Date(`1970-01-01T${ed}:00Z`);
                  const difference = Math.abs((time2 - time1) / 60000);

                  totalt += difference;

                  if (trange !== ed) {
                    //values.push(`${trange}-${ed}`);
                    values.push(`<span style="background-color:#6edde2;line-height: 2;font-size: 11px;">${trange}-${ed}</span>`);
                  }

                  if (k === stime.length - 1) {
                    ed = '18:30';
                    const time11 = new Date(`1970-01-01T${etime[k]}:00Z`);
                    const time21 = new Date(`1970-01-01T${ed}:00Z`);
                    const difference1 = Math.abs((time21 - time11) / 60000);

                    totalt += difference1;

                    if (etime[k] !== ed) {
                      //values.push(`${etime[k]}-${ed}`);
                      values.push(`<span style="background-color:#6edde2;line-height: 2;font-size: 11px;">${etime[k]}-${ed}</span>`);
                    }
                  }
                }

                let color = '#59d474';
                let color1 = 'black';
                let hours = `${Math.floor(totalt / 60)} hrs & ${totalt % 60} mins`;

                if (operatorRows.length === 0) {
                  hours = 'X';
                  color = '#fff';
                  color1 = 'red';
                }

                values.push(`<span style="background-color:${color};line-height: 2;font-size: 14px;padding: 2px 2px 2px 2px;color:${color1};">${hours}</span>`);
              } else {
                // Handle case when operatorRows is empty
                values.push('X');
              }

              // Store values for this date
              valuesByDate[d1] = values;
              //console.log(`Values for date ${d1}:`, valuesByDate[d1]);
            } catch (dbError) {
              console.error('Database Error:', dbError);
              // Initialize values for this date as an array containing an error message
              valuesByDate[d1] = ['Error fetching data'];
            }
          }

          // Push the data for this machine to responseData
          responseData.push({
            zones: zones,
            values: valuesByDate,
            dates: formattedDates,
          });
        }
      }

      // Send the response data
      res.json(responseData);
      console.log(responseData);
    } else {
      // Handle case when zoneRows is empty
      res.status(404).json({ error: 'No data found' });
    }
  } catch (error) {
    console.error(error);
    res.status(500).json({ error: 'An error occurred' });
  } finally {
    if (connection) {
      connection.end();
    }
  }
});



//machine downtime search data
/**
 * @swagger
 * /braid/get_machineDowntime_data2:
 *   post:
 *     summary: Get machine downtime data for a specified date range.
 *     description: Fetches machine downtime data for the specified date range and shift 'DAY' for all machines and zones.
 *     tags:
 *       - Machine Downtime
 *     security:
 *       - bearerAuth: []
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             properties:
 *               fromdate:
 *                 type: string
 *                 format: date
 *                 description: Start date of the range.
 *                 example: '2023-05-01'
 *               todate:
 *                 type: string
 *                 format: date
 *                 description: End date of the range.
 *                 example: '2023-05-31'
 *     responses:
 *       200:
 *         description: Successfully fetched machine downtime data.
 *         content:
 *           application/json:
 *             schema:
 *               type: array
 *               items:
 *                 type: object
 *                 properties:
 *                   zones:
 *                     type: string
 *                     description: Zone and machine identifier.
 *                   values:
 *                     type: object
 *                     additionalProperties:
 *                       type: array
 *                       items:
 *                         type: string
 *                         description: Formatted downtime intervals and totals.
 *                   dates:
 *                     type: array
 *                     items:
 *                       type: string
 *                       format: date
 *                       description: Dates for which data is provided.
 *                   fdate:
 *                     type: string
 *                     format: date
 *                     description: From date of the range.
 *                   tdate:
 *                     type: string
 *                     format: date
 *                     description: To date of the range.
 *       404:
 *         description: No data found.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: No data found
 *       500:
 *         description: An error occurred.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: An error occurred
 *
 * @function
 * @name getMachineDowntimeData2
 * @memberof module:Routes/MachineDowntime
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with the database query.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
app.post('/braid/get_machineDowntime_data2',authenticateJWT , async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    const { fromdate, todate } = req.body;
    const timezone = 'Africa/Lagos';

    let from = '';
    let to = '';

    if (fromdate && todate) {
      from = new Date(fromdate);
      to = new Date(todate);
    } else {
      const now = new Date();
      const day = String(now.getDate()).padStart(2, '0');
      const month = String(now.getMonth() + 1).padStart(2, '0');
      const year = now.getFullYear();
      const date = `${day}-${month}-${year}`;
      from = new Date(date);
      to = new Date(date);
    }
console.log(from,'----');
    from.toLocaleString('en-US', { timeZone: timezone });
    to.toLocaleString('en-US', { timeZone: timezone });

    const period = [];
    const date = new Date(from);

    while (date <= to) {
      period.push(new Date(date));
      date.setDate(date.getDate() + 1);
    }

    // Function to format a date as "d-m-Y"
    
    const formatDate = (date) => {
      const day = String(date.getDate()).padStart(2, '0');
      const month = String(date.getMonth() + 1).padStart(2, '0');
      const year = date.getFullYear();
      return `${day}-${month}-${year}`;
    };
    
  
    const formattedDates = period.map((date) => formatDate(date));
    // Fetch data for geopos_machine
    connection = await getPoolConnection();
    const zoneRows = await executeQuery(connection,'SELECT * FROM geopos_machine');

    if (zoneRows.length > 0) {
      const responseData = []; // Collect response data here

      for (const zoneItem of zoneRows) {
        const machineList = zoneItem.machine.split(',');

        for (const mach of machineList) {
          const id = zoneItem.zone;
          const zones = `${zoneItem.zone}->${mach}`;
          const valuesByDate = {}; // Store values by date

          for (const dt of period) {
            const d1 = formatDate(dt); // Format as "d-m-Y"
          
            const where = `zone='${id}' AND machine='${mach}' AND date='${d1}' AND shift='DAY'`;

            try {
              // Fetch data for geopos_operator
              const operatorRows = await executeQuery(connection,`
                SELECT *
                FROM geopos_operator
                WHERE ${where}
                GROUP BY hr_start
              `);
              
              const values = [];

              if (operatorRows.length > 0) {
                const stime = [];
                const etime = [];
                //console.log('ppppp')
                for (const ws of operatorRows) {
                  stime.push(ws.hr_start);
                  etime.push(ws.hr_end);
                }

                stime.sort((a, b) => a.localeCompare(b));
                etime.sort((a, b) => a.localeCompare(b));

                let totalt = 0;

                for (let k = 0; k < stime.length; k++) {
                  if (k === 0) {
                    trange = '07:30';
                    ed = stime[k];
                  } else {
                    trange = etime[k - 1];
                    ed = stime[k];
                  }

                  const time1 = new Date(`1970-01-01T${trange}:00Z`);
                  const time2 = new Date(`1970-01-01T${ed}:00Z`);
                  const difference = Math.abs((time2 - time1) / 60000);

                  totalt += difference;

                  if (trange !== ed) {
                    //values.push(`${trange}-${ed}`);
                    values.push(`<span style="background-color:#6edde2;line-height: 2;font-size: 11px;">${trange}-${ed}</span>`);
                  }

                  if (k === stime.length - 1) {
                    ed = '18:30';
                    const time11 = new Date(`1970-01-01T${etime[k]}:00Z`);
                    const time21 = new Date(`1970-01-01T${ed}:00Z`);
                    const difference1 = Math.abs((time21 - time11) / 60000);

                    totalt += difference1;

                    if (etime[k] !== ed) {
                      //values.push(`${etime[k]}-${ed}`);
                      values.push(`<span style="background-color:#6edde2;line-height: 2;font-size: 11px;">${etime[k]}-${ed}</span>`);
                    }
                  }
                }

                let color = '#59d474';
                let color1 = 'black';
                let hours = `${Math.floor(totalt / 60)} hrs & ${totalt % 60} mins`;

                if (operatorRows.length === 0) {
                  hours = 'X';
                  color = '#fff';
                  color1 = 'red';
                }

                values.push(`<span style="background-color:${color};line-height: 2;font-size: 14px;padding: 2px 2px 2px 2px;color:${color1};">${hours}</span>`);
              } else {
                // Handle case when operatorRows is empty
                values.push('X');
              }

              // Store values for this date
              valuesByDate[d1] = values;
             // console.log(`Values for date ${d1}:`, valuesByDate[d1]);
            } catch (dbError) {
              console.error('Database Error:', dbError);
              // Initialize values for this date as an array containing an error message
              valuesByDate[d1] = ['Error fetching data'];
            }
          }

          // Push the data for this machine to responseData
          responseData.push({
            zones: zones,
            values: valuesByDate,
            dates: formattedDates,
            fdate: from,
            tdate:to,
          });
        }
      }

      // Send the response data
      res.json(responseData);
     // console.log(responseData);
    } else {
      // Handle case when zoneRows is empty
      res.status(404).json({ error: 'No data found' });
    }
  } catch (error) {
    console.error(error);
    res.status(500).json({ error: 'An error occurred' });
  } finally {
    if (connection) {
      connection.end();
    }
  }
});



//Machine Efficiency FG Output Report

//Machine Eff FgOutput default data
/**
 * @swagger
 * /braid/get_machineEffFgoutput_data:
 *   get:
 *     summary: Get machine efficiency and FG output data.
 *     description: Fetches machine efficiency and finished goods (FG) output data for all machines and zones for the current day.
 *     tags:
 *       - Machine Efficiency
 *     security:
 *       - bearerAuth: []
 *     responses:
 *       200:
 *         description: Successfully fetched machine efficiency and FG output data.
 *         content:
 *           application/json:
 *             schema:
 *               type: array
 *               items:
 *                 type: object
 *                 properties:
 *                   zones:
 *                     type: string
 *                     description: Zone and machine identifier.
 *                   values:
 *                     type: object
 *                     additionalProperties:
 *                       type: array
 *                       items:
 *                         type: string
 *                         description: Calculated efficiency or an error message.
 *                   dates:
 *                     type: array
 *                     items:
 *                       type: string
 *                       format: date
 *                       description: Dates for which data is provided.
 *       404:
 *         description: No data found.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: No data found
 *       500:
 *         description: An error occurred.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: An error occurred
 *
 * @function
 * @name getMachineEffFgoutputData
 * @memberof module:Routes/MachineEfficiency
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with the database query.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
app.get('/braid/get_machineEffFgoutput_data',authenticateJWT , async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    const now = new Date();
    const day = String(now.getDate()).padStart(2, '0');
    const month = String(now.getMonth() + 1).padStart(2, '0'); // January is 0!
    const year = now.getFullYear();
    const date = `${day}-${month}-${year}`;
    const period = [date];
  
    const formattedDates = period.map((date) => date);
    // Fetch data for geopos_machine
    const zoneRows = await executeQuery(connection,'SELECT * FROM geopos_machine');

    if (zoneRows.length > 0) {
      const responseData = []; // Collect response data here

      for (const zoneItem of zoneRows) {
        const machineList = zoneItem.machine.split(',');

        for (const mach of machineList) {
          const id = zoneItem.zone;
          const zones = `${zoneItem.zone}->${mach}`;
          const valuesByDate = {}; // Store values by date

          for (const dt of period) {
            const d1 = dt; // Format as "d-m-Y"
          
            const where = `geopos_operator.zone='${id}' AND geopos_operator.machine='${mach}' AND geopos_operator.date='${d1}' AND geopos_operator.shift='DAY'`;

            try {
              // Fetch data for geopos_operator
              const operatorRows = await executeQuery(connection,`
              SELECT *
              FROM geopos_operator
              LEFT JOIN item_masterr ON item_masterr.id = geopos_operator.item
              WHERE ${where}
              `);
              
              const values = [];

              if (operatorRows.length > 0) {
                let rs = 0; // Initialize as a float
                let re = 0; // Initialize as a float
              
                for (const ws of operatorRows) {
                  const tf = parseFloat(ws.fiber); // Convert to float
                  const netWeight = parseFloat(ws.net_weight);
                  const targetedWaste = parseFloat(ws.targeted_waste);
                  const fgOutput = parseFloat(ws.fg_output);
              
                  // Check if denominator is not zero to avoid division by zero
                  if (netWeight + targetedWaste !== 0) {
                    const tfg = (tf * 1000) / (netWeight + targetedWaste);
                    rs += tfg; // Add to rs without Math.floor
                    re += fgOutput; // Convert to float
                  }
                }
              
                if (rs !== 0.0) { // Check against float value
                  const pw = (re / rs) * 100;
                  values.push(`${pw.toFixed(2)}%`);
                } else {
                  values.push('N/A');
                }
              }else {
                // Handle case when operatorRows is empty
                values.push('N/A');
              }

              // Store values for this date
              valuesByDate[d1] = values;
             // console.log(`Values for date ${d1}:`, valuesByDate[d1]);
            } catch (dbError) {
              console.error('Database Error:', dbError);
              // Initialize values for this date as an array containing an error message
              valuesByDate[d1] = ['Error fetching data'];
            }
          }

          // Push the data for this machine to responseData
          responseData.push({
            zones: zones,
            values: valuesByDate,
            dates: formattedDates,
          });
        }
      }

      // Send the response data
      res.json(responseData);
      console.log(responseData);
    } else {
      // Handle case when zoneRows is empty
      res.status(404).json({ error: 'No data found' });
    }
  } catch (error) {
    console.error(error);
    res.status(500).json({ error: 'An error occurred' });
  } finally {
    if (connection) {
      connection.end();
    }
  }
});


//machine eff fgoutput search wise data
/**
 * @swagger
 * /braid/get_machineEffFgoutput_search_data:
 *   post:
 *     summary: Get machine efficiency and FG output data within a date range.
 *     description: Fetches machine efficiency and finished goods (FG) output data for all machines and zones within the specified date range.
 *     tags:
 *       - Machine Efficiency
 *     security:
 *       - bearerAuth: []
 *     requestBody:
 *       description: Date range for fetching data.
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             properties:
 *               fromdate:
 *                 type: string
 *                 format: date
 *                 description: Start date for the data range.
 *                 example: '2023-05-01'
 *               todate:
 *                 type: string
 *                 format: date
 *                 description: End date for the data range.
 *                 example: '2023-05-31'
 *     responses:
 *       200:
 *         description: Successfully fetched machine efficiency and FG output data.
 *         content:
 *           application/json:
 *             schema:
 *               type: array
 *               items:
 *                 type: object
 *                 properties:
 *                   zones:
 *                     type: string
 *                     description: Zone and machine identifier.
 *                   values:
 *                     type: object
 *                     additionalProperties:
 *                       type: array
 *                       items:
 *                         type: string
 *                         description: Calculated efficiency or an error message.
 *                   dates:
 *                     type: array
 *                     items:
 *                       type: string
 *                       format: date
 *                       description: Dates for which data is provided.
 *                   fdate:
 *                     type: string
 *                     format: date
 *                     description: Start date of the search period.
 *                   tdate:
 *                     type: string
 *                     format: date
 *                     description: End date of the search period.
 *       404:
 *         description: No data found.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: No data found
 *       500:
 *         description: An error occurred.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: An error occurred
 *
 * @function
 * @name getMachineEffFgoutputSearchData
 * @memberof module:Routes/MachineEfficiency
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with the database query.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
app.post('/braid/get_machineEffFgoutput_search_data',authenticateJWT , async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    const { fromdate, todate } = req.body;
    const timezone = 'Africa/Lagos';

    let from = '';
    let to = '';

    if (fromdate && todate) {
      from = new Date(fromdate);
      to = new Date(todate);
    }

    from.toLocaleString('en-US', { timeZone: timezone });
    to.toLocaleString('en-US', { timeZone: timezone });

    const period = [];
    const date = new Date(from);

    while (date <= to) {
      period.push(new Date(date));
      date.setDate(date.getDate() + 1);
    }

    // Function to format a date as "d-m-Y"
    
    const formatDate = (date) => {
      const day = String(date.getDate()).padStart(2, '0');
      const month = String(date.getMonth() + 1).padStart(2, '0');
      const year = date.getFullYear();
      return `${day}-${month}-${year}`;
    };
    
  
    const formattedDates = period.map((date) => formatDate(date));
    // Fetch data for geopos_machine
    const zoneRows = await executeQuery(connection,'SELECT * FROM geopos_machine');

    if (zoneRows.length > 0) {
      const responseData = []; // Collect response data here

      for (const zoneItem of zoneRows) {
        const machineList = zoneItem.machine.split(',');

        for (const mach of machineList) {
          const id = zoneItem.zone;
          const zones = `${zoneItem.zone}->${mach}`;
          const valuesByDate = {}; // Store values by date

          for (const dt of period) {
            const d1 = formatDate(dt); // Format as "d-m-Y"
           console.log
            const where = `geopos_operator.zone='${id}' AND geopos_operator.machine='${mach}' AND geopos_operator.date='${d1}' AND geopos_operator.shift='DAY'`;

            try {
              // Fetch data for geopos_operator
              const operatorRows = await executeQuery(connection,`
              SELECT *
              FROM geopos_operator
              LEFT JOIN item_masterr ON item_masterr.id = geopos_operator.item
              WHERE ${where}
              `);
              
              const values = [];

              if (operatorRows.length > 0) {
                let rs = 0.0; // Initialize as a float
                let re = 0.0; // Initialize as a float
              
                for (const ws of operatorRows) {
                  const tf = parseFloat(ws.fiber); // Convert to float
                  const netWeight = parseFloat(ws.net_weight);
                  const targetedWaste = parseFloat(ws.targeted_waste);
                  const fgOutput = parseFloat(ws.fg_output);
              
                  // Check if denominator is not zero to avoid division by zero
                  if (netWeight + targetedWaste !== 0) {
                    const tfg = (tf * 1000) / (netWeight + targetedWaste);
                    rs += tfg; // Add to rs without Math.floor
                    re += fgOutput; // Convert to float
                  }
                }
              
                if (rs !== 0.0) { // Check against float value
                  const pw = (re / rs) * 100;
                  values.push(`${pw.toFixed(2)}%`);
                } else {
                  values.push('N/A');
                }
              }else {
                // Handle case when operatorRows is empty
                values.push('N/A');
              }

              // Store values for this date
              valuesByDate[d1] = values;
             // console.log(`Values for date ${d1}:`, valuesByDate[d1]);
            } catch (dbError) {
              console.error('Database Error:', dbError);
              // Initialize values for this date as an array containing an error message
              valuesByDate[d1] = ['Error fetching data'];
            }
          }

          // Push the data for this machine to responseData
          responseData.push({
            zones: zones,
            values: valuesByDate,
            dates: formattedDates,
            fdate:from,
            tdate:to,
          });
        }
      }

      // Send the response data
      res.json(responseData);
      console.log(responseData);
    } else {
      // Handle case when zoneRows is empty
      res.status(404).json({ error: 'No data found' });
    }
  } catch (error) {
    console.error(error);
    res.status(500).json({ error: 'An error occurred' });
  } finally {
    // Release the connection back to the pool in case of success or error
    if (connection) {
      connection.end();
      //console.log("Connection released");
    }
  }
});



//Machine Efficiency Waste Report

//Machine Eff waste Report dafault data
/**
 * @swagger
 * /braid/get_machineEffWaste_data:
 *   get:
 *     summary: Get machine efficiency and waste data for the current date.
 *     description: Fetches machine efficiency and waste data for all machines and zones for the current date.
 *     tags:
 *       - Machine Efficiency
 *     security:
 *       - bearerAuth: []
 *     responses:
 *       200:
 *         description: Successfully fetched machine efficiency and waste data.
 *         content:
 *           application/json:
 *             schema:
 *               type: array
 *               items:
 *                 type: object
 *                 properties:
 *                   zones:
 *                     type: string
 *                     description: Zone and machine identifier.
 *                   values:
 *                     type: object
 *                     additionalProperties:
 *                       type: array
 *                       items:
 *                         type: string
 *                         description: Calculated efficiency or an error message.
 *                   dates:
 *                     type: array
 *                     items:
 *                       type: string
 *                       format: date
 *                       description: Dates for which data is provided.
 *       404:
 *         description: No data found.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: No data found
 *       500:
 *         description: An error occurred.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: An error occurred
 *
 * @function
 * @name getMachineEffWasteData
 * @memberof module:Routes/MachineEfficiency
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with the database query.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
app.get('/braid/get_machineEffWaste_data',  authenticateJWT , async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    const now = new Date();
    const day = String(now.getDate()).padStart(2, '0');
    const month = String(now.getMonth() + 1).padStart(2, '0'); // January is 0!
    const year = now.getFullYear();
    const date = `${day}-${month}-${year}`;
    const period = [date];
  
    const formattedDates = period.map((date) => date);
    // Fetch data for geopos_machine
    const zoneRows = await executeQuery(connection,'SELECT * FROM geopos_machine');

    if (zoneRows.length > 0) {
      const responseData = []; // Collect response data here

      for (const zoneItem of zoneRows) {
        const machineList = zoneItem.machine.split(',');

        for (const mach of machineList) {
          const id = zoneItem.zone;
          const zones = `${zoneItem.zone}->${mach}`;
          const valuesByDate = {}; // Store values by date

          for (const dt of period) {
            const d1 = dt; // Format as "d-m-Y"
          
            const where = `geopos_operator.zone='${id}' AND geopos_operator.machine='${mach}' AND geopos_operator.date='${d1}' AND geopos_operator.shift='DAY'`;

            try {
              // Fetch data for geopos_operator
              const operatorRows = await executeQuery(connection,`
              SELECT *
              FROM geopos_operator
              LEFT JOIN item_masterr ON item_masterr.id = geopos_operator.item
              WHERE ${where}
              `);
              
              const values = [];

              if (operatorRows.length > 0) {
                let rs = 0;
                let wst = 0;

                for (const ws of operatorRows) {
                  // Convert string values to integers
                  const tf = parseInt(ws.fiber, 10);
                  const netWeight = parseInt(ws.net_weight, 10);
                  const targetedWaste = parseInt(ws.targeted_waste, 10);
                  const wasteWeight = parseInt(ws.waste_weight, 10);

                  const tfg = (tf * 1000) / (netWeight + targetedWaste);
                  const tww = tf * 1000 - netWeight * tfg;
                  rs += tww;
                  wst += wasteWeight;
                }

                if (wst !== 0) {
                  const pw = (wst / rs) * 100;
                  values.push(pw.toFixed(2) + '%');
                } else {
                  values.push('N/A');
                }


              }else {
                // Handle case when operatorRows is empty
                values.push('N/A');
              }

              // Store values for this date
              valuesByDate[d1] = values;
             // console.log(`Values for date ${d1}:`, valuesByDate[d1]);
            } catch (dbError) {
              console.error('Database Error:', dbError);
              // Initialize values for this date as an array containing an error message
              valuesByDate[d1] = ['Error fetching data'];
            }
          }

          // Push the data for this machine to responseData
          responseData.push({
            zones: zones,
            values: valuesByDate,
            dates: formattedDates,
          });
        }
      }

      // Send the response data
      res.json(responseData);
      console.log(responseData);
    } else {
      // Handle case when zoneRows is empty
      res.status(404).json({ error: 'No data found' });
    }
  } catch (error) {
    console.error(error);
    res.status(500).json({ error: 'An error occurred' });
  } finally {
    // Release the connection back to the pool in case of success or error
    if (connection) {
      connection.end();
      //console.log("Connection released");
    }
  }
});


//Machine eff waste search report
/**
 * @swagger
 * /braid/get_machineEffWaste_search_data:
 *   post:
 *     summary: Get machine efficiency and waste data within a specified date range.
 *     description: Fetches machine efficiency and waste data for all machines and zones within the specified date range.
 *     tags:
 *       - Machine Efficiency
 *     security:
 *       - bearerAuth: []
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             properties:
 *               fromdate:
 *                 type: string
 *                 format: date
 *                 description: Start date of the date range.
 *               todate:
 *                 type: string
 *                 format: date
 *                 description: End date of the date range.
 *             example:
 *               fromdate: "2024-05-01"
 *               todate: "2024-05-31"
 *     responses:
 *       200:
 *         description: Successfully fetched machine efficiency and waste data.
 *         content:
 *           application/json:
 *             schema:
 *               type: array
 *               items:
 *                 type: object
 *                 properties:
 *                   zones:
 *                     type: string
 *                     description: Zone and machine identifier.
 *                   values:
 *                     type: object
 *                     additionalProperties:
 *                       type: array
 *                       items:
 *                         type: string
 *                         description: Calculated efficiency or an error message.
 *                   dates:
 *                     type: array
 *                     items:
 *                       type: string
 *                       format: date
 *                       description: Dates for which data is provided.
 *                   fdate:
 *                     type: string
 *                     format: date
 *                     description: Start date of the date range.
 *                   tdate:
 *                     type: string
 *                     format: date
 *                     description: End date of the date range.
 *       404:
 *         description: No data found.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: No data found
 *       500:
 *         description: An error occurred.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: An error occurred
 *
 * @function
 * @name getMachineEffWasteSearchData
 * @memberof module:Routes/MachineEfficiency
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with the database query.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
app.post('/braid/get_machineEffWaste_search_data',  authenticateJWT , async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    const { fromdate, todate } = req.body;
    const timezone = 'Africa/Lagos';

    let from = '';
    let to = '';

    if (fromdate && todate) {
      from = new Date(fromdate);
      to = new Date(todate);
    }

    from.toLocaleString('en-US', { timeZone: timezone });
    to.toLocaleString('en-US', { timeZone: timezone });

    const period = [];
    const date = new Date(from);

    while (date <= to) {
      period.push(new Date(date));
      date.setDate(date.getDate() + 1);
    }

    // Function to format a date as "d-m-Y"
    
    const formatDate = (date) => {
      const day = String(date.getDate()).padStart(2, '0');
      const month = String(date.getMonth() + 1).padStart(2, '0');
      const year = date.getFullYear();
      return `${day}-${month}-${year}`;
    };
    
  
    const formattedDates = period.map((date) => formatDate(date));
    // Fetch data for geopos_machine
    const zoneRows = await executeQuery(connection,'SELECT * FROM geopos_machine');

    if (zoneRows.length > 0) {
      const responseData = []; // Collect response data here

      for (const zoneItem of zoneRows) {
        const machineList = zoneItem.machine.split(',');

        for (const mach of machineList) {
          const id = zoneItem.zone;
          const zones = `${zoneItem.zone}->${mach}`;
          const valuesByDate = {}; // Store values by date

          for (const dt of period) {
            const d1 = formatDate(dt); // Format as "d-m-Y"
           console.log
            const where = `geopos_operator.zone='${id}' AND geopos_operator.machine='${mach}' AND geopos_operator.date='${d1}' AND geopos_operator.shift='DAY'`;

            try {
              // Fetch data for geopos_operator
              const operatorRows = await executeQuery(connection,`
              SELECT *
              FROM geopos_operator
              LEFT JOIN item_masterr ON item_masterr.id = geopos_operator.item
              WHERE ${where}
              `);
              
              const values = [];

              if (operatorRows.length > 0) {
                let rs = 0;
                let wst = 0;

                for (const ws of operatorRows) {
                  // Convert string values to integers
                  const tf = parseFloat(ws.fiber);
                  const netWeight = parseFloat(ws.net_weight);
                  const targetedWaste = parseFloat(ws.targeted_waste);
                  const wasteWeight = parseFloat(ws.waste_weight);

                  const tfg = (tf * 1000) / (netWeight + targetedWaste);
                  const tww = tf * 1000 - netWeight * tfg;
                  rs += tww;
                  wst += wasteWeight;
                }

                if (wst !== 0) {
                  const pw = (wst / rs) * 100;
                  values.push(pw.toFixed(2) + '%');
                } else {
                  values.push('N/A');
                }
              }else {
                // Handle case when operatorRows is empty
                values.push('N/A');
              }

              // Store values for this date
              valuesByDate[d1] = values;
             // console.log(`Values for date ${d1}:`, valuesByDate[d1]);
            } catch (dbError) {
              console.error('Database Error:', dbError);
              // Initialize values for this date as an array containing an error message
              valuesByDate[d1] = ['Error fetching data'];
            }
          }

          // Push the data for this machine to responseData
          responseData.push({
            zones: zones,
            values: valuesByDate,
            dates: formattedDates,
            fdate:from,
            tdate:to,
          });
        }
      }

      // Send the response data
      res.json(responseData);
      console.log(responseData);
    } else {
      // Handle case when zoneRows is empty
      res.status(404).json({ error: 'No data found' });
    }
  } catch (error) {
    console.error(error);
    res.status(500).json({ error: 'An error occurred' });
  } finally {
    if (connection) {
      connection.end();
    }
  }
});




//Machine Efficiency PPM Report

//Machine Eff PPM Report dafault data
/**
 * @swagger
 * /braid/get_machineEffPpm_data:
 *   get:
 *     summary: Get machine efficiency in PPM (Parts Per Million).
 *     description: Fetches machine efficiency data in PPM (Parts Per Million) for all machines and zones for the current day.
 *     tags:
 *       - Machine Efficiency
 *     security:
 *       - bearerAuth: []
 *     responses:
 *       200:
 *         description: Successfully fetched machine efficiency data.
 *         content:
 *           application/json:
 *             schema:
 *               type: array
 *               items:
 *                 type: object
 *                 properties:
 *                   zones:
 *                     type: string
 *                     description: Zone and machine identifier.
 *                   values:
 *                     type: object
 *                     additionalProperties:
 *                       type: array
 *                       items:
 *                         type: string
 *                         description: Calculated efficiency in PPM (Parts Per Million) or an error message.
 *                   dates:
 *                     type: array
 *                     items:
 *                       type: string
 *                       format: date
 *                       description: Dates for which data is provided.
 *       404:
 *         description: No data found.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: No data found
 *       500:
 *         description: An error occurred.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: An error occurred
 *
 * @function
 * @name getMachineEffPpmData
 * @memberof module:Routes/MachineEfficiency
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with the database query.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
app.get('/braid/get_machineEffPpm_data', authenticateJWT , async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    const now = new Date();
    const day = String(now.getDate()).padStart(2, '0');
    const month = String(now.getMonth() + 1).padStart(2, '0'); // January is 0!
    const year = now.getFullYear();
    const date = `${day}-${month}-${year}`;
    const period = [date];
  
    const formattedDates = period.map((date) => date);
    // Fetch data for geopos_machine
    const zoneRows = await executeQuery(connection,'SELECT * FROM geopos_machine');

    if (zoneRows.length > 0) {
      const responseData = []; // Collect response data here

      for (const zoneItem of zoneRows) {
        const machineList = zoneItem.machine.split(',');

        for (const mach of machineList) {
          const id = zoneItem.zone;
          const zones = `${zoneItem.zone}->${mach}`;
          const valuesByDate = {}; // Store values by date

          for (const dt of period) {
            const d1 = dt; // Format as "d-m-Y"
          
            const where = `geopos_operator.zone='${id}' AND geopos_operator.machine='${mach}' AND geopos_operator.date='${d1}' AND geopos_operator.shift='DAY'`;

            try {
              // Fetch data for geopos_operator
              const operatorRows = await executeQuery(connection,`
              SELECT *
              FROM geopos_operator
              LEFT JOIN item_masterr ON item_masterr.id = geopos_operator.item
              WHERE ${where}
              `);
              
              const values = [];

              if (operatorRows.length > 0) {
                let t = 0;
                let hour = 0;
                
                for (const ws of operatorRows) {
                  const tf =parseFloat(ws.fg_output);
                  t += tf;
                  hour++;
                }

                if (t !== 0) {
                  const pw = (t / hour).toFixed(2);
                  values.push(pw);
                } else {
                  values.push('N/A');
                }

              }else {
                // Handle case when operatorRows is empty
                values.push('N/A');
              }

              // Store values for this date
              valuesByDate[d1] = values;
              //console.log(`Values for date ${d1}:`, valuesByDate[d1]);
            } catch (dbError) {
              console.error('Database Error:', dbError);
              // Initialize values for this date as an array containing an error message
              valuesByDate[d1] = ['Error fetching data'];
            }
          }

          // Push the data for this machine to responseData
          responseData.push({
            zones: zones,
            values: valuesByDate,
            dates: formattedDates,
          });
        }
      }

      // Send the response data
      res.json(responseData);
      //console.log(responseData);
    } else {
      // Handle case when zoneRows is empty
      res.status(404).json({ error: 'No data found' });
    }
  } catch (error) {
    console.error(error);
    res.status(500).json({ error: 'An error occurred' });
  } finally {
    if (connection) {
      connection.end();
    }
  }
});


//Machine eff waste search report
/**
 * @swagger
 * /braid/get_machineEffppm_search_data:
 *   post:
 *     summary: Get machine efficiency in PPM (Parts Per Million) with search parameters.
 *     description: Fetches machine efficiency data in PPM (Parts Per Million) for all machines and zones within the specified date range.
 *     tags:
 *       - Machine Efficiency
 *     security:
 *       - bearerAuth: []
 *     requestBody:
 *       description: Object containing the date range for the search.
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             properties:
 *               fromdate:
 *                 type: string
 *                 format: date
 *                 description: The start date for the search (YYYY-MM-DD).
 *               todate:
 *                 type: string
 *                 format: date
 *                 description: The end date for the search (YYYY-MM-DD).
 *             example:
 *               fromdate: "2024-01-01"
 *               todate: "2024-01-31"
 *     responses:
 *       200:
 *         description: Successfully fetched machine efficiency data.
 *         content:
 *           application/json:
 *             schema:
 *               type: array
 *               items:
 *                 type: object
 *                 properties:
 *                   zones:
 *                     type: string
 *                     description: Zone and machine identifier.
 *                   values:
 *                     type: object
 *                     additionalProperties:
 *                       type: array
 *                       items:
 *                         type: string
 *                         description: Calculated efficiency in PPM (Parts Per Million) or an error message.
 *                   dates:
 *                     type: array
 *                     items:
 *                       type: string
 *                       format: date
 *                       description: Dates for which data is provided.
 *                   fdate:
 *                     type: string
 *                     format: date
 *                     description: Start date of the search range.
 *                   tdate:
 *                     type: string
 *                     format: date
 *                     description: End date of the search range.
 *       404:
 *         description: No data found.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: No data found
 *       500:
 *         description: An error occurred.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: An error occurred
 *
 * @function
 * @name getMachineEffPpmSearchData
 * @memberof module:Routes/MachineEfficiency
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with the database query.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
app.post('/braid/get_machineEffppm_search_data',authenticateJWT , async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    const { fromdate, todate } = req.body;
    const timezone = 'Africa/Lagos';

    let from = '';
    let to = '';

    if (fromdate && todate) {
      from = new Date(fromdate);
      to = new Date(todate);
    }

    from.toLocaleString('en-US', { timeZone: timezone });
    to.toLocaleString('en-US', { timeZone: timezone });

    const period = [];
    const date = new Date(from);

    while (date <= to) {
      period.push(new Date(date));
      date.setDate(date.getDate() + 1);
    }

    // Function to format a date as "d-m-Y"
    
    const formatDate = (date) => {
      const day = String(date.getDate()).padStart(2, '0');
      const month = String(date.getMonth() + 1).padStart(2, '0');
      const year = date.getFullYear();
      return `${day}-${month}-${year}`;
    };
    
  
    const formattedDates = period.map((date) => formatDate(date));
    // Fetch data for geopos_machine
    const zoneRows = await executeQuery(connection,'SELECT * FROM geopos_machine');

    if (zoneRows.length > 0) {
      const responseData = []; // Collect response data here

      for (const zoneItem of zoneRows) {
        const machineList = zoneItem.machine.split(',');

        for (const mach of machineList) {
          const id = zoneItem.zone;
          const zones = `${zoneItem.zone}->${mach}`;
          const valuesByDate = {}; // Store values by date

          for (const dt of period) {
            const d1 = formatDate(dt); // Format as "d-m-Y"
           console.log
            const where = `geopos_operator.zone='${id}' AND geopos_operator.machine='${mach}' AND geopos_operator.date='${d1}' AND geopos_operator.shift='DAY'`;

            try {
              // Fetch data for geopos_operator
              const operatorRows = await executeQuery(connection,`
              SELECT *
              FROM geopos_operator
              LEFT JOIN item_masterr ON item_masterr.id = geopos_operator.item
              WHERE ${where}
              `);
              
              const values = [];

              if (operatorRows.length > 0) {
                let t = 0;
                let hour = 0;
                
                for (const ws of operatorRows) {
                  const tf =parseFloat(ws.fg_output);
                  t += tf;
                  hour++;
                }

                if (t !== 0) {
                  const pw = (t / hour).toFixed(2);
                  values.push(pw);
                } else {
                  values.push('N/A');
                }
              }else {
                // Handle case when operatorRows is empty
                values.push('N/A');
              }

              // Store values for this date
              valuesByDate[d1] = values;
              //console.log(`Values for date ${d1}:`, valuesByDate[d1]);
            } catch (dbError) {
              console.error('Database Error:', dbError);
              // Initialize values for this date as an array containing an error message
              valuesByDate[d1] = ['Error fetching data'];
            }
          }

          // Push the data for this machine to responseData
          responseData.push({
            zones: zones,
            values: valuesByDate,
            dates: formattedDates,
            fdate:from,
            tdate:to,
          });
        }
      }

      // Send the response data
      res.json(responseData);
      console.log(responseData);
    } else {
      // Handle case when zoneRows is empty
      res.status(404).json({ error: 'No data found' });
    }
  } catch (error) {
    console.error(error);
    res.status(500).json({ error: 'An error occurred' });
  } finally {
    if (connection) {
      connection.end();
    }
  }
});


//Machine Hour Report

//Braid Machine hours default data
/**
 * @swagger
 * /braid/get_machineHour_data:
 *   get:
 *     summary: Get machine operating hours data.
 *     description: Fetches machine operating hours data for all machines and zones for the current date.
 *     tags:
 *       - Machine Operating Hours
 *     security:
 *       - bearerAuth: []
 *     responses:
 *       200:
 *         description: Successfully fetched machine operating hours data.
 *         content:
 *           application/json:
 *             schema:
 *               type: array
 *               items:
 *                 type: object
 *                 properties:
 *                   zones:
 *                     type: string
 *                     description: Zone and machine identifier.
 *                   values:
 *                     type: object
 *                     additionalProperties:
 *                       type: array
 *                       items:
 *                         type: integer
 *                         description: Operating hours count for the current date.
 *                   dates:
 *                     type: array
 *                     items:
 *                       type: string
 *                       format: date
 *                       description: Current date.
 *       404:
 *         description: No data found.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: No data found
 *       500:
 *         description: An error occurred.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: An error occurred
 *
 * @function
 * @name getMachineHourData
 * @memberof module:Routes/MachineOperatingHours
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with the database query.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
app.get('/braid/get_machineHour_data',  authenticateJWT , async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    const now = new Date();
    const day = String(now.getDate()).padStart(2, '0');
    const month = String(now.getMonth() + 1).padStart(2, '0'); // January is 0!
    const year = now.getFullYear();
    const date = `${day}-${month}-${year}`;
    const period = [date];
  
    const formattedDates = period.map((date) => date);
    // Fetch data for geopos_machine
    const zoneRows = await executeQuery(connection,'SELECT * FROM geopos_machine');

     // Function to format a date as "d-m-Y"
    
    const formatDate = (date) => {
      const day = String(date.getDate()).padStart(2, '0');
      const month = String(date.getMonth() + 1).padStart(2, '0');
      const year = date.getFullYear();
      return `${day}-${month}-${year}`;
    };

    if (zoneRows.length > 0) {
      const responseData = []; // Collect response data here

      for (const zoneItem of zoneRows) {
        const machineList = zoneItem.machine.split(',');

        for (const mach of machineList) {
          const id = zoneItem.zone;
          const zones = `${zoneItem.zone}->${mach}`;
          const valuesByDate = {}; // Store values by date

          for (const dt of period) {
            const d1 = dt; // Format as "d-m-Y"
           console.log
            const where = `geopos_operator.zone='${id}' AND geopos_operator.machine='${mach}' AND geopos_operator.date='${d1}'`;

            try {
              // Fetch data for geopos_operator
              const operatorRows = await executeQuery(connection,`
              SELECT *
              FROM geopos_operator
              LEFT JOIN item_masterr ON item_masterr.id = geopos_operator.item
              WHERE ${where}
              `);
              
              const values = [];

              if (operatorRows.length > 0) {
                const count = operatorRows.length;
                values.push(count);
              }else {
                // Handle case when operatorRows is empty
                values.push('0');
              }

              // Store values for this date
              valuesByDate[d1] = values;
              //console.log(`Values for date ${d1}:`, valuesByDate[d1]);
            } catch (dbError) {
              console.error('Database Error:', dbError);
              // Initialize values for this date as an array containing an error message
              valuesByDate[d1] = ['Error fetching data'];
            }
          }

          // Push the data for this machine to responseData
          responseData.push({
            zones: zones,
            values: valuesByDate,
            dates: formattedDates,
          });
        }
      }

      // Send the response data
      res.json(responseData);
      //console.log(responseData);
    } else {
      // Handle case when zoneRows is empty
      res.status(404).json({ error: 'No data found' });
    }
  } catch (error) {
    console.error(error);
    res.status(500).json({ error: 'An error occurred' });
  } finally {
    if (connection) {
      connection.end();
    }
  }
});



//Machine hours search report
/**
 * @swagger
 * /braid/get_machineHour_search_data:
 *   post:
 *     summary: Get machine hour search data for a given date range.
 *     description: Retrieves machine hour data for the specified date range and time zone, returning the count of operator entries for each machine.
 *     tags:
 *       - Machine Hour Search
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             properties:
 *               fromdate:
 *                 type: string
 *                 format: date
 *                 description: The start date of the search range (YYYY-MM-DD).
 *                 example: "2023-01-01"
 *               todate:
 *                 type: string
 *                 format: date
 *                 description: The end date of the search range (YYYY-MM-DD).
 *                 example: "2023-01-31"
 *     responses:
 *       200:
 *         description: Successful response with machine hour search data.
 *         content:
 *           application/json:
 *             schema:
 *               type: array
 *               items:
 *                 type: object
 *                 properties:
 *                   zones:
 *                     type: string
 *                     description: The zone and machine information.
 *                     example: "ZoneA->Machine1"
 *                   values:
 *                     type: object
 *                     additionalProperties:
 *                       type: array
 *                       items:
 *                         type: string
 *                       description: The count of operator entries or an error message for each date.
 *                   dates:
 *                     type: array
 *                     items:
 *                       type: string
 *                       format: date
 *                       description: The list of dates in the specified range (d-m-Y).
 *                       example: "01-01-2023"
 *                   fdate:
 *                     type: string
 *                     format: date
 *                     description: The formatted start date.
 *                     example: "01-01-2023"
 *                   tdate:
 *                     type: string
 *                     format: date
 *                     description: The formatted end date.
 *                     example: "31-01-2023"
 *       404:
 *         description: No data found.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: "No data found"
 *       500:
 *         description: An error occurred.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: "An error occurred"
 *
 * @function
 * @name getMachineHourSearchData
 * @memberof module:Routes/MachineHourSearch
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with the database query.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
app.post('/braid/get_machineHour_search_data',authenticateJWT , async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    const { fromdate, todate } = req.body;
    const timezone = 'Africa/Lagos';

    let from = '';
    let to = '';

    if (fromdate && todate) {
      from = new Date(fromdate);
      to = new Date(todate);
    }

    from.toLocaleString('en-US', { timeZone: timezone });
    to.toLocaleString('en-US', { timeZone: timezone });

    const period = [];
    const date = new Date(from);

    while (date <= to) {
      period.push(new Date(date));
      date.setDate(date.getDate() + 1);
    }

    // Function to format a date as "d-m-Y"
    
    const formatDate = (date) => {
      const day = String(date.getDate()).padStart(2, '0');
      const month = String(date.getMonth() + 1).padStart(2, '0');
      const year = date.getFullYear();
      return `${day}-${month}-${year}`;
    };
    
  
    const formattedDates = period.map((date) => formatDate(date));
    // Fetch data for geopos_machine
    const zoneRows = await executeQuery(connection,'SELECT * FROM geopos_machine');

    if (zoneRows.length > 0) {
      const responseData = []; // Collect response data here

      for (const zoneItem of zoneRows) {
        const machineList = zoneItem.machine.split(',');

        for (const mach of machineList) {
          const id = zoneItem.zone;
          const zones = `${zoneItem.zone}->${mach}`;
          const valuesByDate = {}; // Store values by date

          for (const dt of period) {
            const d1 = formatDate(dt); // Format as "d-m-Y"
           console.log
            const where = `geopos_operator.zone='${id}' AND geopos_operator.machine='${mach}' AND geopos_operator.date='${d1}'`;

            try {
              // Fetch data for geopos_operator
              const operatorRows = await executeQuery(connection,`
              SELECT *
              FROM geopos_operator
              LEFT JOIN item_masterr ON item_masterr.id = geopos_operator.item
              WHERE ${where}
              `);
              
              const values = [];

              if (operatorRows.length > 0) {
                const count = operatorRows.length;
                values.push(count);
              }else {
                // Handle case when operatorRows is empty
                values.push('0');
              }

              // Store values for this date
              valuesByDate[d1] = values;
              //console.log(`Values for date ${d1}:`, valuesByDate[d1]);
            } catch (dbError) {
              console.error('Database Error:', dbError);
              // Initialize values for this date as an array containing an error message
              valuesByDate[d1] = ['Error fetching data'];
            }
          }

          // Push the data for this machine to responseData
          responseData.push({
            zones: zones,
            values: valuesByDate,
            dates: formattedDates,
            fdate:from,
            tdate:to,
          });
        }
      }

      // Send the response data
      res.json(responseData);
      //console.log(responseData);
    } else {
      // Handle case when zoneRows is empty
      res.status(404).json({ error: 'No data found' });
    }
  } catch (error) {
    console.error(error);
    res.status(500).json({ error: 'An error occurred' });
  } finally {
    if (connection) {
      connection.end();
    }
  }
});



//Non Braid Report


// Attendance Report

//get default data
/**
 * @swagger
 * /Nbraid/get_attendance_default_data:
 *   get:
 *     summary: Get default attendance data for the current date.
 *     description: Retrieves attendance data for the specified employee statuses on the current date.
 *     tags:
 *       - Attendance
 *     responses:
 *       200:
 *         description: Successful response with attendance data.
 *         content:
 *           application/json:
 *             schema:
 *               type: array
 *               items:
 *                 type: object
 *                 properties:
 *                   estatus:
 *                     type: string
 *                     description: The employee status.
 *                     example: "Contract"
 *                   values:
 *                     type: integer
 *                     description: The count of present employees for the specified status.
 *                     example: 10
 *                   dates:
 *                     type: array
 *                     items:
 *                       type: string
 *                       format: date
 *                       description: The date for the attendance record.
 *                       example: "01-01-2024"
 *       500:
 *         description: An error occurred.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: "An error occurred"
 *
 * @function
 * @name getAttendanceDefaultData
 * @memberof module:Routes/Attendance
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with the database query.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
app.get('/Nbraid/get_attendance_default_data',authenticateJWT , async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    const now = new Date();
    const day = String(now.getDate()).padStart(2, '0');
    const month = String(now.getMonth() + 1).padStart(2, '0'); // January is 0!
    const year = now.getFullYear();
    const date = `${day}-${month}-${year}`;
    const period = [date];
    //console.log(date, '=============');

    // Fetch data for geopos_machine
    const attendance_data = await executeQuery(connection,`SELECT employee_status, SUM(present) as present_count
    FROM ng_attendance
    WHERE employee_status IN ('Contract', 'Outsourcing', 'Casual', 'staff')
    AND date = '${date}'
    GROUP BY employee_status`);

    if (attendance_data.length > 0) {
      const responseData = [];

      for (const row of attendance_data) {
        const status = row.employee_status;
        const presentCount = row.present_count;

        // Create a row object for each status
        responseData.push({
          estatus: status,
          values:presentCount,
          // values: {
          //   [date]: [presentCount], // Set the value for the specific date
          // },
          dates: [date], // An array with a single date
        });
      }

      // Send the response as JSON
      res.json(responseData);
      //console.log(responseData);
    } else {
      // Send an empty array to indicate no data
      res.json('');
    }
  } catch (error) {
    console.error(error);
    res.status(500).json({ error: 'An error occurred' });
  } finally {
    if (connection) {
      connection.end();
    }
  }
});


//Attendance query search data
/**
 * @swagger
 * /Nbraid/get_attendance_search_data:
 *   post:
 *     summary: Get attendance data based on search criteria.
 *     description: Retrieves attendance data for the specified employee statuses within the date range, filtered by category, shift, and site.
 *     tags:
 *       - Attendance
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             properties:
 *               category:
 *                 type: string
 *                 description: The category type of the employees.
 *                 example: "Contract"
 *               shift:
 *                 type: string
 *                 description: The shift of the employees.
 *                 example: "Morning"
 *               site:
 *                 type: string
 *                 description: The site of the employees.
 *                 example: "SiteA"
 *               fromdate:
 *                 type: string
 *                 format: date
 *                 description: The start date for the attendance data range.
 *                 example: "2024-01-01"
 *               todate:
 *                 type: string
 *                 format: date
 *                 description: The end date for the attendance data range.
 *                 example: "2024-01-31"
 *     responses:
 *       200:
 *         description: Successful response with attendance data.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 dates:
 *                   type: array
 *                   items:
 *                     type: string
 *                     format: date
 *                     description: The dates for the attendance records.
 *                     example: "01-01-2024"
 *                 date:
 *                   type: string
 *                   description: The date range for the attendance data.
 *                   example: "01-01-2024 TO 31-01-2024"
 *                 cat:
 *                   type: string
 *                   description: The category type.
 *                   example: "Contract"
 *                 shift:
 *                   type: string
 *                   description: The shift.
 *                   example: "Morning"
 *                 site:
 *                   type: string
 *                   description: The site.
 *                   example: "SiteA"
 *                 data:
 *                   type: array
 *                   items:
 *                     type: object
 *                     properties:
 *                       estatus:
 *                         type: string
 *                         description: The employee status.
 *                         example: "Contract"
 *                       values:
 *                         type: object
 *                         additionalProperties:
 *                           type: array
 *                           items:
 *                             type: integer
 *                             description: The count of present employees for the specified status on that date.
 *                             example: 10
 *       500:
 *         description: An error occurred.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: "An error occurred"
 *
 * @function
 * @name getAttendanceSearchData
 * @memberof module:Routes/Attendance
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with the database query.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
app.post('/Nbraid/get_attendance_search_data',authenticateJWT , async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    const cat = req.body.category;
    const shift = req.body.shift;
    const site = req.body.site;

    const fromdate = req.body.fromdate;
    const todate = req.body.todate;
  
    const dateObj = new Date(fromdate);
    const day = dateObj.getDate().toString().padStart(2, '0');
    const month = (dateObj.getMonth() + 1).toString().padStart(2, '0');
    const year = dateObj.getFullYear();
    const convertedDate = `${day}-${month}-${year}`;

    const dateObj1 = new Date(todate);
    const day1 = dateObj1.getDate().toString().padStart(2, '0');
    const month1 = (dateObj1.getMonth() + 1).toString().padStart(2, '0');
    const year1 = dateObj1.getFullYear();
    const convertedDate1 = `${day1}-${month1}-${year1}`;

    const fd2 = Math.floor(new Date(fromdate).getTime() / 1000);
    const td1 = Math.floor(new Date(todate).getTime() / 1000);
    const fd1 = Math.floor(new Date(fd2 * 1000).setDate(new Date(fd2 * 1000).getDate() - 1) / 1000);

    const period = [];
    const date = new Date(dateObj);

    while (date <= dateObj1) {
      period.push(new Date(date));
      date.setDate(date.getDate() + 1);
    }

    // Function to format a date as "d-m-Y"
    
    const formatDate = (date) => {
      const day = String(date.getDate()).padStart(2, '0');
      const month = String(date.getMonth() + 1).padStart(2, '0');
      const year = date.getFullYear();
      return `${day}-${month}-${year}`;
    };
    
  
    const formattedDates = period.map((date) => formatDate(date));
    // Fetch data for geopos_machine
    let where = `(ng_attendance.time_stamp between '${fd2}' and '${td1}')`;

      if (cat) {
        where += ` AND ng_attendance.category_type='${cat}'`;
      }

      if (shift) {
        where += ` AND ng_attendance.shift='${shift}'`;
      }

      if (site) {
        where += ` AND ng_attendance.site='${site}'`;
      }
    const sql=`SELECT employee_status, SUM(present) as present_count
    FROM ng_attendance
    WHERE employee_status IN ('Contract', 'Outsourcing', 'Casual', 'staff')
    AND ${where}
    GROUP BY employee_status`;
   console.log(sql,'-------------');
    const attendanceSql = await executeQuery(connection,sql);
    const responseData ={
        dates: formattedDates,
        date:convertedDate+' TO '+convertedDate1,
        cat:cat,
        shift:shift,
        site:site,
        data:[],
    } // Collect response data here
    
 
    
      for (const data of attendanceSql) {
        const e_status = data.employee_status;

        const valuesByDate = {}; // Store values by date
          for (const dt of period) {
            const d1 = formatDate(dt); // Format as "d-m-Y"
  
              let where = `(date = '${d1}' and employee_status='${e_status}')`;

              if (cat) {
                where += ` AND category_type='${cat}'`;
              }

              if (shift) {
                where += ` AND shift='${shift}'`;
              }

              if (site) {
                where += ` AND site='${site}'`;
              }

            try {
              // Fetch data for geopos_operator
              const AttendanceRows = await executeQuery(connection,`
              SELECT SUM(present) as present_count FROM ng_attendance WHERE ${where}
              `);
              
              const values = [];

              if (AttendanceRows.length > 0) {
    
                for (const count of AttendanceRows) {
                  values.push(count.present_count);
                }
                
              }else {
                values.push('-');
              }

              // Store values for this date
              valuesByDate[d1] = values;
              //console.log(`Values for date ${d1}:`, valuesByDate[d1]);
            } catch (dbError) {
              console.error('Database Error:', dbError);
              // Initialize values for this date as an array containing an error message
              valuesByDate[d1] = ['Error fetching data'];
            }
          }

          // Push the data for this machine to responseData
          responseData.data.push({
            estatus: e_status,
            values: valuesByDate,
          });

      }

      // Send the response data
      res.json(responseData);
      console.log(responseData,"-----------|++++++++")
  } catch (error) {
    console.error(error);
    res.status(500).json({ error: 'An error occurred' });
  } finally {
    if (connection) {
      connection.end();
    }
  }
});



//Fg Output Monthly Report

//fg monthly report nbraid default
/**
 * @swagger
 * /Nbraid/getFgMonthlyDefaultData:
 *   get:
 *     summary: Get monthly default FG data.
 *     description: Retrieves finished goods (FG) data for the current month, including item description, line, total output, count of entries, and shift details.
 *     tags:
 *       - Finished Goods
 *     responses:
 *       200:
 *         description: Successful response with FG data.
 *         content:
 *           application/json:
 *             schema:
 *               type: array
 *               items:
 *                 type: object
 *                 properties:
 *                   item_description:
 *                     type: string
 *                     description: Description of the item.
 *                     example: "Item A"
 *                   line:
 *                     type: string
 *                     description: The production line.
 *                     example: "Line 1"
 *                   tar:
 *                     type: number
 *                     description: Total output for the product.
 *                     example: 5000
 *                   countResult:
 *                     type: integer
 *                     description: The number of entries in worker timesheet.
 *                     example: 20
 *                   shift:
 *                     type: string
 *                     description: The shift.
 *                     example: "Morning"
 *       500:
 *         description: Internal Server Error.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: "Internal Server Error"
 *
 * @function
 * @name getFgMonthlyDefaultData
 * @memberof module:Routes/FinishedGoods
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with the database query.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
app.get('/Nbraid/getFgMonthlyDefaultData', authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    const date = new Date().toLocaleDateString('en-GB', { timeZone: 'Africa/Lagos' });
    const parts = date.split('/');
    const formattedDay = parts[0].padStart(2, '0');
    const formattedMonth = parts[1].padStart(2, '0');
    const year = parts[2];
    const date1 = `${formattedDay}-${formattedMonth}-${year}`;
    const mon = `${formattedMonth}-${year}`;
    const fgQuery = `
      SELECT fg_details.*, item_masterr.item_description, SUM(fg_output) as tar
      FROM fg_details
      LEFT JOIN item_masterr ON fg_details.product_name = item_masterr.id
      WHERE SUBSTRING(fg_details.date_time, 4) = '${mon}'
      GROUP BY fg_details.product_name, fg_details.line
    `;

    // Execute the query using executeQuery
    const fg = await executeQuery(connection,fgQuery);

    if (fg.length === 0) {
      // No data found for fgQuery
      return res.json([]);
    }

    const responseData = [];

    // Loop through the result rows
    for (const row of fg) {
      // Define the SQL query to count rows in worker_timesheet
      const countQuery = `
        SELECT * FROM worker_timesheet
        WHERE product_name = '${row.product_name}'
        AND line = '${row.line}'
        AND mon = '${mon}'
        AND shift = '${row.shift}'
        GROUP BY entry_id
      `;

      // Execute the count query using executeQuery
      const countResult = await executeQuery(connection,countQuery);

      // Get the number of rows counted
      const count = countResult.length;

      // Prepare the data for JSON response
      const jsonData = {
        item_description: row.item_description,
        line: row.line,
        tar: row.tar,
        countResult: count,
        shift: row.shift,
      };

      // Push the JSON data to the response array
      responseData.push(jsonData);
    }

    // Send the response as JSON
    res.json(responseData);
  } catch (err) {
    console.error('Error:', err);
    res.status(500).json({ error: 'Internal Server Error' });
  } finally {
    if (connection) {
      connection.end();
    }
  }
});


//fg monthly report nbraid search
/**
 * @swagger
 * /Nbraid/getFgMonthlyDataSearch:
 *   post:
 *     summary: Get FG data for a specific month and year.
 *     description: Retrieves finished goods (FG) data for the specified month and year, including item description, line, total output, count of entries, and shift details.
 *     tags:
 *       - Finished Goods
 *     requestBody:
 *       description: The month and year to search FG data.
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             properties:
 *               start_year:
 *                 type: string
 *                 description: The year to search.
 *                 example: "2024"
 *               start_month:
 *                 type: string
 *                 description: The month to search.
 *                 example: "05"
 *     responses:
 *       200:
 *         description: Successful response with FG data.
 *         content:
 *           application/json:
 *             schema:
 *               type: array
 *               items:
 *                 type: object
 *                 properties:
 *                   item_description:
 *                     type: string
 *                     description: Description of the item.
 *                     example: "Item A"
 *                   line:
 *                     type: string
 *                     description: The production line.
 *                     example: "Line 1"
 *                   tar:
 *                     type: number
 *                     description: Total output for the product.
 *                     example: 5000
 *                   countResult:
 *                     type: integer
 *                     description: The number of entries in worker timesheet.
 *                     example: 20
 *                   shift:
 *                     type: string
 *                     description: The shift.
 *                     example: "Morning"
 *       500:
 *         description: Internal Server Error.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: "Internal Server Error"
 *
 * @function
 * @name getFgMonthlyDataSearch
 * @memberof module:Routes/FinishedGoods
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with the database query.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
app.post('/Nbraid/getFgMonthlyDataSearch', authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    const timeZone = 'Africa/Lagos';
    const start_year = req.body.start_year;
    const start_month = req.body.start_month;

    const year_s = `${start_month}-${start_year}`;
    const startDate = new Date(year_s);
    const mon = year_s;

    // Define the SQL query to retrieve data from fg_details and item_masterr tables
    const fgQuery = `
      SELECT fg_details.*, item_masterr.item_description, SUM(fg_output) as tar
      FROM fg_details
      LEFT JOIN item_masterr ON fg_details.product_name = item_masterr.id
      WHERE SUBSTRING(fg_details.date_time, 4) = '${mon}'
      GROUP BY fg_details.product_name, fg_details.line
    `;

    // Execute the first query
    const fg = await executeQuery(connection,fgQuery);

    if (fg.length === 0) {
      // No data found for fgQuery
      return res.json([]);
    }

    const responseData = [];

    // Loop through the result rows
    for (const row of fg) {
      // Define the SQL query to count rows in worker_timesheet
      const countQuery = `
        SELECT * FROM worker_timesheet
        WHERE product_name = '${row.product_name}'
        AND line = '${row.line}'
        AND mon = '${mon}'
        AND shift = '${row.shift}'
        GROUP BY entry_id
      `;

      // Execute the count query
      const countResult = await executeQuery(connection,countQuery);

      // Get the number of rows counted
      const count = countResult.length;

      // Prepare the data for JSON response
      const jsonData = {
        item_description: row.item_description,
        line: row.line,
        tar: row.tar,
        countResult: count,
        shift: row.shift || '',
      };

      // Push the JSON data to the response array
      responseData.push(jsonData);
    }

    // Send the response as JSON
    res.json(responseData);
  } catch (err) {
    console.error('Error:', err);
    res.status(500).json({ error: 'Internal Server Error' });
  } finally {
    if (connection) {
      connection.end();
    }
  }
});





//Performance Eff Individual Report

//Get Performance Eff individual search data report
/**
 * @swagger
 * /nbraid/get_performance_eff_individual:
 *   post:
 *     summary: Get individual performance efficiency data.
 *     description: Retrieves individual performance efficiency data for specified employees within a given date range, including target, sum, efficiency, and other related details.
 *     tags:
 *       - Performance
 *     requestBody:
 *       description: The employees, date range, and other parameters to search for performance data.
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             properties:
 *               employees:
 *                 type: string
 *                 description: The entry ID of the employee at Ikeja site.
 *                 example: "123"
 *               employeesota:
 *                 type: string
 *                 description: The entry ID of the employee at Ota site.
 *                 example: "456"
 *               fromdate:
 *                 type: string
 *                 format: date
 *                 description: The start date for the performance data.
 *                 example: "2024-01-01"
 *               todate:
 *                 type: string
 *                 format: date
 *                 description: The end date for the performance data.
 *                 example: "2024-01-31"
 *     responses:
 *       200:
 *         description: Successful response with performance data.
 *         content:
 *           application/json:
 *             schema:
 *               type: array
 *               items:
 *                 type: object
 *                 properties:
 *                   worker:
 *                     type: string
 *                     description: Worker name or ID.
 *                     example: "John Doe"
 *                   entry_id:
 *                     type: string
 *                     description: Entry ID of the worker.
 *                     example: "123"
 *                   regg:
 *                     type: string
 *                     format: date
 *                     description: Registration date of the worker.
 *                     example: "01-01-2023"
 *                   diff:
 *                     type: integer
 *                     description: Difference in days between current date and registration date.
 *                     example: 30
 *                   shift:
 *                     type: string
 *                     description: The shift of the worker.
 *                     example: "Morning"
 *                   sec:
 *                     type: string
 *                     description: Section name.
 *                     example: "Section A"
 *                   pro:
 *                     type: string
 *                     description: Product description.
 *                     example: "Product A"
 *                   line:
 *                     type: string
 *                     description: Production line.
 *                     example: "Line 1"
 *                   target:
 *                     type: number
 *                     description: Target value.
 *                     example: 500
 *                   sum:
 *                     type: number
 *                     description: Sum of hours.
 *                     example: 480
 *                   efficiency:
 *                     type: string
 *                     description: Efficiency percentage.
 *                     example: "96.00"
 *                   date_time:
 *                     type: string
 *                     format: date-time
 *                     description: Date and time of the entry.
 *                     example: "2024-01-01 08:00:00"
 *                   ss:
 *                     type: string
 *                     description: Site identifier.
 *                     example: "ikeja"
 *                   faef:
 *                     type: string
 *                     description: Final average efficiency.
 *                     example: "95.50"
 *                   day_count:
 *                     type: integer
 *                     description: Number of days counted.
 *                     example: 30
 *       500:
 *         description: Internal Server Error.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: "Internal Server Error"
 *
 * @function
 * @name getPerformanceEffIndividual
 * @memberof module:Routes/Performance
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with the database query.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
app.post('/nbraid/get_performance_eff_individual',authenticateJWT , async (req, res) => {
  const ikeja = req.body.employees;
  const ota = req.body.employeesota;

  const fromdate = req.body.fromdate;
const todate = req.body.todate;

const dateObj = new Date(fromdate);
const day = dateObj.getDate().toString().padStart(2, '0');
const month = (dateObj.getMonth() + 1).toString().padStart(2, '0');
const year = dateObj.getFullYear();

const convertedDate = `${day}-${month}-${year}`;

const dateObj1 = new Date(todate);
const day1 = dateObj1.getDate().toString().padStart(2, '0');
const month1 = (dateObj1.getMonth() + 1).toString().padStart(2, '0');
const year1 = dateObj1.getFullYear();

const convertedDate1 = `${day1}-${month1}-${year1}`;

const fd2 = Math.floor(dateObj.getTime() / 1000);
const td1 = Math.floor(dateObj1.getTime() / 1000);
const fd1 = Math.floor(new Date(fd2 * 1000).setDate(dateObj.getDate() - 1) / 1000);

console.log(convertedDate);
console.log(convertedDate1);
console.log(fd2);
console.log(td1);
console.log(fd1);



  const whereConditions = [];

  // Check if OTA employee is selected and add it to the WHERE conditions array
  if (ota !== '') {
    whereConditions.push(`(entry_id = '${ota}' AND time_stamp BETWEEN ${fd2} AND  ${td1})`);
  }

  // Check if IKEJA employee is selected and add it to the WHERE conditions array
  if (ikeja !== '') {
    whereConditions.push(`(entry_id = '${ikeja}' AND time_stamp BETWEEN ${fd2} AND  ${td1})`);
  }

  // Join the WHERE conditions using OR to get the combined WHERE clause
  const where = whereConditions.join(' OR ');
  const query = `SELECT *, HOUR1, HOUR2, HOUR3, HOUR4, HOUR5, HOUR6, HOUR7, HOUR8, HOUR9, HOUR10, HOUR11, HOUR1+HOUR2+HOUR3+HOUR4+HOUR5+HOUR6+HOUR7+HOUR8+HOUR9+HOUR10+HOUR11 AS value_sum
    FROM worker_timesheet WHERE ${where} GROUP BY shift, entry_id, product_name, line, section, date_time`;
    let connection;
    try {
      connection = await getPoolConnection();
      const timesheet = await executeQuery(connection,query);
  
      const resultPromises = timesheet.map(async (item) => {
        let count = 0;
        for (let i = 1; i <= 11; i++) {
          const str = `HOUR${i}`;
          if (item[str] > 0) {
            count++;
          }
        }
        console.log(item.product_name);
        const proQuery = `SELECT * FROM item_masterr WHERE id='${item.product_name}'`;
        const secQuery = `SELECT * FROM section WHERE id='${item.section}'`;
  
        const [proResult, secResult] = await Promise.all([
          executeQuery(connection,proQuery),
          executeQuery(connection,secQuery),
        ]);
  
        const pro = proResult[0].item_description || '';
        const sec = secResult[0].section_name;
  
        const entry = item.entry_id;
        const site = item.site;
        let query1;
        let ss = '';
  
        if (site === 'both') {
          query1 = `SELECT * FROM employees_ota WHERE entryid='${entry}'`;
  
          const result1 = await executeQuery(connection,query1);
  
          if (!result1 || result1.length === 0) {
            query1 = `SELECT * FROM geopos_employees WHERE entryid='${entry}'`;
            ss = 'ikeja';
          } else {
            ss = 'ota';
          }
        } else if (site === 'ikeja') {
          query1 = `SELECT * FROM geopos_employees WHERE entryid='${entry}'`;
          ss = 'ikeja';
        } else if (site === 'ota') {
          query1 = `SELECT * FROM employees_ota WHERE entryid='${entry}'`;
          ss = 'ota';
        }
        console.log(query1,'My query')
        if (query1) {
          const query1Result = await executeQuery(connection,query1);

           const dateParts = query1Result[0].joindate.split(/[- :]/);
           /* const reggDate = new Date(Date.UTC(dateParts[2], dateParts[1] - 1, dateParts[0], dateParts[3], dateParts[4]));
            const regg = reggDate.toLocaleDateString('en-GB', {
              day: '2-digit',
              month: '2-digit',
              year: 'numeric',
            }).replace(/\//g, '-'); */

             let reggDate;
           if (dateParts.length === 3) {
            // Format: d-m-Y
            reggDate = new Date(Date.UTC(dateParts[2], dateParts[1] - 1, dateParts[0]));
            } else if (dateParts.length === 6) {
                // Format: Y-m-d h:i:s
                reggDate = new Date(Date.UTC(dateParts[0], dateParts[1] - 1, dateParts[2], dateParts[3], dateParts[4], dateParts[5]));
            } else {
                console.error('Unsupported date format');
            }

            const regg = `${reggDate.getUTCDate().toString().padStart(2, '0')}-${(reggDate.getUTCMonth() + 1).toString().padStart(2, '0')}-${reggDate.getUTCFullYear().toString()}`;
        
          const datek1 = item.date_time;
        
          const datek11 = new Date(datek1.split('-').reverse().join('-'));
         const regg1 = new Date(regg.split('-').reverse().join('-'));

         const timeDifference = datek11.getTime() - regg1.getTime();
          const diff = Math.floor(timeDifference / (1000 * 60 * 60 * 24)); // Convert to days
          console.log(datek1,regg)
  
          const response = {
            worker: item.worker,
            entry_id: item.entry_id,
            regg,
            diff,
            shift: item.shift,
            sec,
            pro,
            line: item.line,
          };
      
          if (item.actual_target > 0) {
            response.target = item.actual_target * count;
          } else {
            const targetQuery = `SELECT * FROM item_section_ota WHERE section_id='${item.section}' AND item_id='${item.product_name}'`;
            const targetResult = await executeQuery(connection,targetQuery);
  
            response.target = targetResult[0].target * count;
          }
  
          const sum = item.value_sum;
          response.sum = sum ;
          if (item.actual_target > 0) {
            response.efficiency = ((sum / (item.actual_target * count)) * 100).toFixed(2);
          } else {
            response.efficiency = ((sum / response.target) * 100).toFixed(2);
          }
          response.date_time = item.date_time;
          response.ss = ss;
      
          const entry_id = item.entry_id;
          const product_name = item.product_name;
          const section = item.section;
          const line = item.line;
          const shift = item.shift;
          const whereConditions1 = [];

        // console.log('-------------------------------')
            whereConditions1.push(`(entry_id = '${entry_id}' AND (time_stamp BETWEEN ${fd2} AND ${td1}))`);
            const where1 = whereConditions1.join(' AND ');

            const query3 = `SELECT *, HOUR1, HOUR2, HOUR3, HOUR4, HOUR5, HOUR6, HOUR7, HOUR8, HOUR9, HOUR10, HOUR11, HOUR1+HOUR2+HOUR3+HOUR4+HOUR5+HOUR6+HOUR7+HOUR8+HOUR9+HOUR10+HOUR11 AS value_sum 
              FROM worker_timesheet WHERE ${where1} GROUP BY shift, entry_id, product_name, line, section, date_time`;

              //console.log(query3+'1-------------------------------')
          const res = await executeQuery(connection,query3);
          let eff_sum = 0;
          let eff_count = 0;
          let day_count = 0;
          const date_arr = [];
       
          for (const itt of res) {
           
            let ctt = 0;
            for (let j = 1; j <= 11; j++) {
              const sttrr = `HOUR${j}`;
              if (itt[sttrr] > 0) {
                ctt++;
              }
            }

            if (itt.actual_target > 0) {
              const efff = (itt.value_sum / (itt.actual_target * ctt)) * 100;
              eff_sum += parseFloat(efff.toFixed(2));
            } else {
              const act_tarrr = (await executeQuery(connection,`SELECT target FROM item_section_ota WHERE section_id='${itt.section}' AND item_id='${itt.product_name}'`))[0].target;
              const total_tarr = act_tarrr * ctt;
              const efff = (itt.value_sum / total_tarr) * 100;
              eff_sum += parseFloat(efff.toFixed(2));
            }

            const datee = itt.date_time;
            if (!date_arr.includes(datee)) {
              date_arr.push(datee);
              day_count++;
            }
            eff_count++;
          }

          const faef = (eff_sum / eff_count).toFixed(2);
          console.log(faef);
          response.faef = faef;
          response.day_count = day_count;
          return response;
        }
      });
  
      const results = await Promise.all(resultPromises);
  
      res.send(results);
      console.log(results);
    } catch (error) {
      console.error('Error executing MySQL query:', error);
      res.status(500).send('Internal Server Error');
    } finally {
      // Release the connection back to the pool in case of success or error
      if (connection) {
        connection.release();
        //console.log("Connection released");
      }
    }
});

// function executeQuery(query) {
//   return new Promise((resolve, reject) => {
//     db.query(query, (err, result) => {
//       if (err) {
//         reject(err);
//       } else {
//         resolve(result);
//       }
//     });
//   });
// }

//Plan Vs Actual Report

//Plan Vs Actual Report default search
/**
 * @swagger
 * /Nbraid/getPlanVsactualReportDefault:
 *   get:
 *     summary: Get default Plan vs Actual Report.
 *     description: Retrieves the default Plan vs Actual report for the current date.
 *     tags:
 *       - Reports
 *     responses:
 *       200:
 *         description: Successful response with Plan vs Actual report data.
 *         content:
 *           application/json:
 *             schema:
 *               type: array
 *               items:
 *                 type: object
 *                 properties:
 *                   product:
 *                     type: string
 *                     description: Product description.
 *                     example: "Product A"
 *                   total:
 *                     type: number
 *                     description: Total planned target.
 *                     example: 1000
 *                   sump:
 *                     type: number
 *                     description: Sum of actual output.
 *                     example: 950
 *       500:
 *         description: Internal Server Error.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: "Internal Server Error"
 *
 * @function
 * @name getPlanVsactualReportDefault
 * @memberof module:Routes/Reports
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with the database query.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
app.get('/Nbraid/getPlanVsactualReportDefault', authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    const timeZone = 'Africa/Lagos';
    const options = {
      day: '2-digit',
      month: '2-digit',
      year: 'numeric',
    };

    const date = new Date().toLocaleDateString('en-NG', options).replace(/\//g, '-');
    const targetPlan = 0;
    const category = 2;
    const itemCodeId = 0;
    const query = `
      SELECT *, target_plan as tot
      FROM target_plan_ota
      WHERE date = ? AND target_plan > ? AND category = ? AND item_code_id != ?
    `;

    const results = await executeQuery(connection,query, [date, targetPlan, category, itemCodeId]);

    const data = [];

    for (const item of results) {
      const prdd = item.item_code_id;

      const itemCodeQuery = `
        SELECT * FROM item_code WHERE id = ?
      `;

      const rows = await executeQuery(connection,itemCodeQuery, [prdd]);

      if (rows.length > 0) {
        const pro = rows[0].product_des;

        const where2 = `date_time='${date}' and product_code='${prdd}'`;
        const geoposOperatorQuery = `
          SELECT SUM(fg_output) as tar
          FROM fg_details
          WHERE ${where2}
          GROUP BY product_code, date_time
        `;

        const rowsGeoPos = await executeQuery(connection,geoposOperatorQuery);

        let sump = rowsGeoPos.length > 0 ? rowsGeoPos[0].tar : null;

        data.push({
          product: pro,
          total: item.tot,
          sump: sump,
        });
      }
    }

    res.json(data.length === 0 ? {} : data);
  } catch (error) {
    console.error('Error in the request: ' + error);
    res.status(500).json({ error: 'Internal Server Error' });
  } finally {
    if (connection) {
      connection.release();
    }
  }
});



//Non-Braid Plan Vs Actual Report date wise search 
/**
 * @swagger
 * /Nbraid/getPlanVsactualReportSearch:
 *   post:
 *     summary: Get Plan vs Actual Report based on date range.
 *     description: Retrieves the Plan vs Actual report for a specified date range.
 *     tags:
 *       - Reports
 *     requestBody:
 *       description: The date range for the report.
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             properties:
 *               fromdate:
 *                 type: string
 *                 description: Start date in dd-mm-yyyy format.
 *                 example: "01-05-2023"
 *               todate:
 *                 type: string
 *                 description: End date in dd-mm-yyyy format.
 *                 example: "31-05-2023"
 *     responses:
 *       200:
 *         description: Successful response with Plan vs Actual report data.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 fdate:
 *                   type: string
 *                   description: Formatted start date.
 *                   example: "01-05-2023"
 *                 tdate:
 *                   type: string
 *                   description: Formatted end date.
 *                   example: "31-05-2023"
 *                 items:
 *                   type: array
 *                   items:
 *                     type: object
 *                     properties:
 *                       product:
 *                         type: string
 *                         description: Product description.
 *                         example: "Product A"
 *                       total:
 *                         type: number
 *                         description: Total planned target.
 *                         example: 1000
 *                       sump:
 *                         type: number
 *                         description: Sum of actual output.
 *                         example: 950
 *       500:
 *         description: Internal Server Error.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: "Internal Server Error"
 *
 * @function
 * @name getPlanVsactualReportSearch
 * @memberof module:Routes/Reports
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with the database query.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
app.post('/Nbraid/getPlanVsactualReportSearch', authenticateJWT, async (req, res) => {
  const timeZone = 'Africa/Lagos';

  const options = {
    day: '2-digit',
    month: '2-digit',
    year: 'numeric',
  };

  const date = new Date().toLocaleDateString('en-NG', options).replace(/\//g, '-');

  const fromdate = req.body.fromdate;
  const fdParts = fromdate.split('-');
  const fd = `${fdParts[2]}-${fdParts[1]}-${fdParts[0]}`;

  const todate = req.body.todate;
  const tdParts = todate.split('-');
  const td = `${tdParts[2]}-${tdParts[1]}-${tdParts[0]}`;

  const dateObj = new Date(fromdate);
  const day = dateObj.getDate().toString().padStart(2, '0');
  const month = (dateObj.getMonth() + 1).toString().padStart(2, '0');
  const year = dateObj.getFullYear();
  const convertedDate = `${day}-${month}-${year}`;

  const dateObj1 = new Date(todate);
  const day1 = dateObj1.getDate().toString().padStart(2, '0');
  const month1 = (dateObj1.getMonth() + 1).toString().padStart(2, '0');
  const year1 = dateObj1.getFullYear();
  const convertedDate1 = `${day1}-${month1}-${year1}`;

  const fd2 = Math.floor((new Date(fromdate).getTime() - 2 * 24 * 60 * 60 * 1000) / 1000);
  const td1 = Math.floor(new Date(todate).getTime() / 1000);
  const fd1 = Math.floor(new Date(fd2 * 1000).setDate(new Date(fd2 * 1000).getDate() - 1) / 1000);

  var newfd = fd2;
  var newtd = td1;

  const where = `(timestamp BETWEEN ${newfd} AND ${newtd} AND target_plan > 0 AND category = '2' AND item_code_id != '0')`;

  const query = `
    SELECT *, SUM(target_plan) as tot
    FROM target_plan_ota
    WHERE ${where}
    GROUP BY item_code_id
  `;
let connection;
  try {
    connection = await getPoolConnection();
    const results = await executeQuery(connection,query);
    const data = {
      fdate: convertedDate,
      tdate: convertedDate1,
      items: [],
    };

    for (const item of results) {
      const prdd = item.item_code_id;
      const itemCodeQuery = `SELECT * FROM item_code WHERE id = ?`;

      const rows = await executeQuery(connection,itemCodeQuery, [prdd]);

      if (rows.length > 0) {
        const pro = rows[0].product_des;
        const geoposOperatorQuery = `
          SELECT SUM(a.tar) as res
          FROM (SELECT SUM(fg_output) as tar
                FROM fg_details
                WHERE date_time BETWEEN '${convertedDate}' AND '${convertedDate1}'
                AND product_code = '${prdd}'
                GROUP BY product_code, time_stamp) a
        `;

        const geoposRows = await executeQuery(connection,geoposOperatorQuery);

        if (geoposRows.length > 0) {
          const sump = geoposRows[0].res;
          data.items.push({
            product: pro,
            total: item.tot,
            sump: sump,
          });
        }
      }
    }

    if (data.items.length === 0) {
      res.json({});
    } else {
      res.json(data);
    }
  } catch (error) {
    console.error('Error in the request: ' + error);
    res.status(500).json({ error: 'Internal Server Error' });
  } finally {
    if (connection) {
      connection.release();
    }
  }
});



//MTD AVG PPP Report
/**
 * @swagger
 * /Nbraid/getMtdPppAverageDefaultData:
 *   get:
 *     summary: Get MTD PPP Average Default Data.
 *     description: Retrieves the Month-to-Date (MTD) average data for product production performance.
 *     tags:
 *       - Reports
 *     responses:
 *       200:
 *         description: Successful response with MTD PPP average data.
 *         content:
 *           application/json:
 *             schema:
 *               type: array
 *               items:
 *                 type: object
 *                 properties:
 *                   category:
 *                     type: string
 *                     description: Category name of the item.
 *                     example: "Electronics"
 *                   item:
 *                     type: string
 *                     description: Description of the item.
 *                     example: "Smartphone"
 *                   avg:
 *                     type: string
 *                     description: Average output.
 *                     example: "123.45"
 *       500:
 *         description: Internal Server Error.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: "Internal Server Error"
 *
 * @function
 * @name getMtdPppAverageDefaultData
 * @memberof module:Routes/Reports
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with the database query.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
app.get('/Nbraid/getMtdPppAverageDefaultData', authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    const date = new Date().toLocaleDateString('en-GB', { timeZone: 'Africa/Lagos' });
    const parts = date.split('/');
    const day = parts[0].padStart(2, '0');
    const month = parts[1].padStart(2, '0');
    const year = parts[2];
    const datem = `${month}-${year}`;
    const currentDate = `${day}-${month}-${year}`;

    const array = [`worker_timesheet.mon = '${datem}'`, "worker_timesheet.product_name IS NOT NULL"];

    const query = `
      SELECT
        worker_timesheet.*,
        item_masterr.item_description,
        item_category.category_name,
        COUNT(worker_timesheet.id) AS tot
      FROM
        worker_timesheet
      LEFT JOIN
        item_masterr ON item_masterr.id = worker_timesheet.product_name
      LEFT JOIN
        item_category ON item_masterr.category_id = item_category.id
      WHERE
        ${array.join(' AND ')}
      GROUP BY
        worker_timesheet.product_name, worker_timesheet.mon
    `;

    const results = await executeQuery(connection,query);

    const data = [];

    if (results.length > 0) {
      for (const result of results) {
        const kk = result.product_name;
        const query2 = `SELECT SUM(fg_output) as tar FROM fg_details WHERE SUBSTR(date_time,4) = '${datem}' AND product_name = '${kk}' GROUP BY product_name`;
        const results2 = await executeQuery(connection,query2);

        const sum = results2[0] ? results2[0].tar : 0;
        const rew = sum / result.tot;
        const responseValue = rew === Infinity ? 0 : rew;

        data.push({
          category: result.category_name,
          item: result.item_description,
          avg: responseValue.toFixed(2),
        });
      }
    }

    res.json(data);
  } catch (error) {
    console.error('Error in the request:', error);
    res.status(500).json({ error: 'Internal Server Error' });
  } finally {
    if (connection) {
      connection.release();
    }
  }
});

//Get MTD AVG PPP Report search data
/**
 * @swagger
 * /Nbraid/getMtdPppAverageSearch:
 *   post:
 *     summary: Get MTD PPP Average Search Data.
 *     description: Retrieves the Month-to-Date (MTD) average data for product production performance based on search criteria.
 *     tags:
 *       - Reports
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             properties:
 *               start_year:
 *                 type: string
 *                 description: The start year for the search range.
 *                 example: "2023"
 *               end_year:
 *                 type: string
 *                 description: The end year for the search range.
 *                 example: "2024"
 *               start_month:
 *                 type: string
 *                 description: The start month for the search range.
 *                 example: "01"
 *               end_month:
 *                 type: string
 *                 description: The end month for the search range.
 *                 example: "12"
 *               category:
 *                 type: string
 *                 description: The category ID for filtering the results.
 *                 example: "5"
 *     responses:
 *       200:
 *         description: Successful response with MTD PPP average search data.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 data:
 *                   type: object
 *                   properties:
 *                     months:
 *                       type: array
 *                       items:
 *                         type: string
 *                         description: List of months in the search range.
 *                         example: ["January", "February", "March"]
 *                     items:
 *                       type: array
 *                       items:
 *                         type: object
 *                         properties:
 *                           category:
 *                             type: string
 *                             description: Category name of the item.
 *                             example: "Electronics"
 *                           item:
 *                             type: string
 *                             description: Description of the item.
 *                             example: "Smartphone"
 *                           monthlyAverages:
 *                             type: array
 *                             items:
 *                               type: string
 *                               description: Average output per month.
 *                               example: ["123.45", "-", "67.89"]
 *       500:
 *         description: Internal Server Error.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: "Internal Server Error"
 *
 * @function
 * @name getMtdPppAverageSearch
 * @memberof module:Routes/Reports
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with the database query.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */

app.post('/Nbraid/getMtdPppAverageSearch',  authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    const start_year = req.body.start_year;
    const end_year = req.body.end_year;
    const start_month = req.body.start_month;
    const end_month = req.body.end_month;

    const s_year = start_month + '-' + start_year;
    const e_year = end_month + '-' + end_year;
    const cat = req.body.category;

    const year_s = `${start_year}-${start_month}`;
    const year_e = `${end_year}-${end_month}`;
    const startDate = new Date(year_s);
    const endDate = new Date(year_e);
    const monthsArray = [];
    const monthsArray1 = [];

    const timeZone = 'Africa/Lagos';

    const formattedStartDate = startDate.toLocaleDateString('en-US', { year: 'numeric', month: 'long' });
    const formattedEndDate = endDate.toLocaleDateString('en-US', { year: 'numeric', month: 'long' });

    const monthDifference = (endDate.getFullYear() - startDate.getFullYear()) * 12 + (endDate.getMonth() - startDate.getMonth()) + 1;

    for (let i = 0; i < monthDifference; i++) {
      const currentMonth = new Date(startDate.getFullYear(), startDate.getMonth() + i, 1);
      const monthName = currentMonth.toLocaleDateString('en-US', { month: 'long' });
      const mths = currentMonth.toLocaleDateString('en-US', { month: '2-digit', year: 'numeric' }).replace(/\//g, '-');
      monthsArray.push(mths);
      monthsArray1.push(monthName);
    }

    let where = `(worker_timesheet.mon between '${s_year}' and '${e_year}' and worker_timesheet.product_name !='')`;

    if (cat !== '') {
      where += ` AND item_masterr.category_id='${cat}'`;
    }

    const query = `
      SELECT
        worker_timesheet.*, item_masterr.item_description, item_category.category_name,
        COUNT(worker_timesheet.id) as tot
      FROM
        worker_timesheet
      LEFT JOIN
        item_masterr ON item_masterr.id = worker_timesheet.product_name
      LEFT JOIN
        item_category ON item_masterr.category_id = item_category.id
      WHERE ${where}
      GROUP BY worker_timesheet.product_name
    `;

    const results = await executeQuery(connection,query);

    const data = {
      months: monthsArray1,
      items: [],
    };

    for (const result of results) {
      const monthlyAverages = [];

      const promises = monthsArray.map(async (dt1) => {
        const mths = dt1;

        const p1 = await executeQuery(connection,"SELECT SUM(fg_output) as tar FROM fg_details WHERE SUBSTR(date_time,4) = ? AND product_name = ? GROUP BY product_name", [mths, result.product_name]);
        const query3 = await executeQuery(connection,"SELECT count(*) as tot from worker_timesheet  WHERE mon=? and product_name=? group by product_name", [mths, result.product_name]);

        const sum1 = p1.length > 0 ? p1[0].tar : 0;
        const worker = query3.length > 0 ? query3[0].tot : 0;

        let rew;
        if (worker > 0) {
          rew = sum1 / worker;
          if (isNaN(rew) || !isFinite(rew)) {
            rew = '-';
          } else {
            rew = rew.toFixed(2);
          }
        } else {
          rew = '-';
        }
        monthlyAverages.push(rew);
      });

      await Promise.all(promises);

      data.items.push({
        category: result.category_name,
        item: result.item_description,
        monthlyAverages: monthlyAverages,
      });
    }

    res.json({ data });
  } catch (error) {
    console.error('Error in the request:', error);
    res.status(500).json({ error: 'Internal Server Error' });
  } finally {
    if (connection) {
      connection.release();
    }
  }
});



//Efficiency Overview Report

//NBraid Efficiency overview report search
/**
 * @swagger
 * /Nbraid/get_efficiencyOverview_search_data:
 *   post:
 *     summary: Get Efficiency Overview Search Data.
 *     description: Retrieves efficiency overview search data based on specified date range.
 *     tags:
 *       - Reports
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             properties:
 *               fromdate:
 *                 type: string
 *                
 *                 example: "2024-01-01"
 *               todate:
 *                 type: string
 *                 
 *                 example: "2024-12-31"
 *     responses:
 *       200:
 *         description: Successful response with efficiency overview search data.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 dates:
 *                   type: array
 *                   items:
 *                     type: string
 *                     description: List of dates in the search range.
 *                     example: ["01-01-2024", "01-02-2024", "01-03-2024"]
 *                 effdata:
 *                   type: array
 *                   items:
 *                     type: object
 *                     properties:
 *                       worker:
 *                         type: string
 *                         description: Name of the worker.
 *                         example: "John Doe"
 *                       id:
 *                         type: integer
 *                         description: Worker ID.
 *                         example: 123
 *                       section_name:
 *                         type: string
 *                         description: Name of the section.
 *                         example: "Production"
 *                       sum_ef:
 *                         type: object
 *                         description: Efficiency values by date.
 *                         example: {"01-01-2024": "80%", "01-02-2024": "75%", ...}
 *                       avg:
 *                         type: string
 *                         description: Average efficiency percentage for the worker.
 *                         example: "78%"
 *                       present_days:
 *                         type: integer
 *                         description: Number of days the worker was present.
 *                         example: 20
 *                       date:
 *                         type: array
 *                         description: List of dates in the search range.
 *                         items:
 *                           type: string
 *                           example: ["01-01-2024", "01-02-2024", "01-03-2024"]
 *       500:
 *         description: Internal Server Error.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: "Internal Server Error"
 *
 * @function
 * @name getEfficiencyOverviewSearchData
 * @memberof module:Routes/Reports
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with the database query.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
app.post('/Nbraid/get_efficiencyOverview_search_data',authenticateJWT , async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    const timezone = 'Africa/Lagos';
    const fromdate = req.body.fromdate;
    const fdParts = fromdate.split('-');
    const fd = `${fdParts[2]}-${fdParts[1]}-${fdParts[0]}`;

    const todate = req.body.todate;
    const tdParts = todate.split('-');
    const td = `${tdParts[2]}-${tdParts[1]}-${tdParts[0]}`;

    const dateObj = new Date(fromdate);
    const day = dateObj.getDate().toString().padStart(2, '0');
    const month = (dateObj.getMonth() + 1).toString().padStart(2, '0');
    const year = dateObj.getFullYear();
    const convertedDate = `${day}-${month}-${year}`;

    const dateObj1 = new Date(todate);
    const day1 = dateObj1.getDate().toString().padStart(2, '0');
    const month1 = (dateObj1.getMonth() + 1).toString().padStart(2, '0');
    const year1 = dateObj1.getFullYear();
    const convertedDate1 = `${day1}-${month1}-${year1}`;

    const fd2 = Math.floor((new Date(fromdate).getTime() - 2 * 24 * 60 * 60 * 1000) / 1000);
    const td1 = Math.floor(new Date(todate).getTime() / 1000);
    const fd1 = Math.floor(new Date(fd2 * 1000).setDate(new Date(fd2 * 1000).getDate() - 1) / 1000);

    var newfd = fd2;
    var newtd = td1;

    // Query 1: Get timesheet
    const timesheetQuery = "SELECT * from worker_timesheet WHERE (time_stamp between ? and ?) group by entry_id";
    const timesheet = await executeQuery(connection,timesheetQuery, [newfd, newtd]);

    // Query 2: Get timesheetk
    const timesheetkQuery = "SELECT *, SUM(target) as target_sum, SUM(HOUR1+HOUR2+HOUR3+HOUR4+HOUR5+HOUR6+HOUR7+HOUR8+HOUR9+HOUR10+HOUR11) AS value_sum from worker_timesheet WHERE (time_stamp between ? and ?) group by entry_id, date_time";
    const timesheetk = await executeQuery(connection,timesheetkQuery, [newfd, newtd]);

    dateObj.toLocaleString('en-US', { timeZone: timezone });
    dateObj1.toLocaleString('en-US', { timeZone: timezone });

    const period = [];
    const date = new Date(dateObj);

    while (date <= dateObj1) {
      period.push(new Date(date));
      date.setDate(date.getDate() + 1);
    }

    // Function to format a date as "d-m-Y"
    const formatDate = (date) => {
      const day = String(date.getDate()).padStart(2, '0');
      const month = String(date.getMonth() + 1).padStart(2, '0');
      const year = date.getFullYear();
      return `${day}-${month}-${year}`;
    };

    const formattedDates = period.map((date) => formatDate(date));

    const ard = [];
    const arr_tar = [];
    const arr_ach = [];
    const arr = [];

    // Query 3: Fetch data for ard array
    for (const itemk of timesheetk) {
      
      const dent = `${itemk.date_time}-${itemk.entry_id}`;
      ard.push(dent);

      // Query 4: Fetch data for query_t
      const query_t = "SELECT * FROM worker_timesheet WHERE entry_id=? and date_time=?";
      const queryTResults = await executeQuery(connection,query_t, [itemk.entry_id, itemk.date_time]);

      let totalTarget = 0;
      for (const row_t of queryTResults) {
       
        let count = 0;
        for (let i = 1; i <= 11; i++) {
          const u = `HOUR${i}`;
          if (row_t[u] > 0) {
            count++;
          }
        }

        if (parseInt(row_t.actual_target) > 0) {
          totalTarget += parseInt(row_t.actual_target) * count;
       
        } else {
          // Fetch data for act_target
          const actTargetQuery = "SELECT target FROM item_section_ota WHERE section_id=? and item_id=?";
          const actTargetResult = await executeQuery(connection,actTargetQuery, [row_t.section, row_t.product_name]);
          totalTarget += parseInt(actTargetResult[0].target) * count;
          
        }

        const e = (parseInt(itemk.value_sum) / totalTarget) * 100;

        const eff = parseFloat(e.toFixed(2));

        arr.push(eff);
        arr_tar.push(parseInt(itemk.target_sum));
        arr_ach.push(parseInt(itemk.value_sum));
      }
    }
    
    const responseData = {
      dates: formattedDates,
      effdata:[],
    };
    // Process timesheet2 and other data as needed using Promise.all
    const resultPromises = timesheet.map(async (item) => {
      const worker = item.worker;
      const worker_id = item.entry_id;
      const sec = item.section;
      const section = await executeQuery(connection,"SELECT * FROM section WHERE id = ?", [sec]);
      const section_name = section[0].section_name;

      let sum_ef = 0; // Change from const to let
      let present_days = 0;
      let sumef = 0;
      const valuesByDate = {}; // Store values by date
      const date = [];
      // Assuming you have "period" defined earlier
      for (const dt1 of period) {
        const dd1 = `${formatDate(dt1)}-${item.entry_id}`;
        const e_id = item.entry_id;
        const date23 = formatDate(dt1);
        date.push(date23);

        const values = [];

        if (ard.includes(dd1)) {
          
          present_days++;
          const ky = ard.indexOf(dd1);
         
          const url = `/reports/eff_overview_details?entry_id=${e_id}&date=${date23}`;
          if (ky >= 0 && ky < arr.length && !isNaN(arr[ky])) {
            sum_ef += arr[ky];
            sumef = `${arr[ky]}%`; // Assign value to sumef
            values.push(arr[ky]+'%');
          } else {
            // Handle the case where ky is out of bounds or arr[ky] is non-numeric
            values.push('-');
          }
        } else {
          values.push('-');
        }
        valuesByDate[date23] = values;
      }

      const avg_m = (sum_ef / present_days).toFixed(2);
      const avg = `${avg_m}%`;

      responseData.effdata.push({
        worker: worker,
        id: worker_id,
        section_name: section_name,
        sum_ef: valuesByDate,
        avg: avg,
        present_days: present_days,
        date:date,
      });
    });

    await Promise.all(resultPromises);
    res.send(responseData);
    console.log(responseData)
  } catch (error) {
    console.error('Error executing MySQL query:', error);
    res.status(500).send('Internal Server Error');
  } finally {
    if(connection){
      connection.release();
    }
    
  }
});

//Efficiency overview default data 
/**
 * @swagger
 * /Nbraid/get_efficiencyOverview_deafault_data:
 *   get:
 *     summary: Get Default Efficiency Overview Data.
 *     description: Retrieves default efficiency overview data for the current month.
 *     tags:
 *       - Reports
 *     responses:
 *       200:
 *         description: Successful response with default efficiency overview data.
 *         content:
 *           application/json:
 *             schema:
 *               type: array
 *               items:
 *                 type: object
 *                 properties:
 *                   worker:
 *                     type: string
 *                     description: Name of the worker.
 *                     example: "John Doe"
 *                   id:
 *                     type: integer
 *                     description: Worker ID.
 *                     example: 123
 *                   dates:
 *                     type: string
 *                     description: Date in the format "DD-MM-YYYY".
 *                     example: "01-01-2024"
 *                   eff:
 *                     type: string
 *                     description: Efficiency percentage for the worker.
 *                     example: "75%"
 *       500:
 *         description: Internal Server Error.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: "Internal Server Error"
 *
 * @function
 * @name getDefaultEfficiencyOverviewData
 * @memberof module:Routes/Reports
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with the database query.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
app.get('/Nbraid/get_efficiencyOverview_deafault_data',authenticateJWT , async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    const date = new Date().toLocaleDateString('en-GB', { timeZone: 'Africa/Lagos' });
    const parts = date.split('/');
    const day = parts[0].padStart(2, '0');
    const month = parts[1].padStart(2, '0');
    const year = parts[2];
    const currentMonth = `${month}-${year}`;
    const td = `${day}-${month}-${year}`;

    const workerQuery = `SELECT *, COUNT(*) as cnt, SUM(HOUR1+HOUR2+HOUR3+HOUR4+HOUR5+HOUR6+HOUR7+HOUR8+HOUR9+HOUR10+HOUR11) as value_sum
    FROM worker_timesheet
    WHERE date_time = ?
    GROUP BY entry_id
    HAVING cnt = 1`;
    const workerResults = await executeQuery(connection,workerQuery, [td]);

    const responseData = [];
    
    const resultPromises = workerResults.map(async (workers) => {
        // Define worker, id, section_name, valuesByDate, avg, and present_days here
        const worker = workers.worker;
        const id = workers.entry_id;

                const query_t = "SELECT * FROM worker_timesheet WHERE entry_id=? and date_time=?";
                const queryTResults = await executeQuery(connection,query_t, [workers.entry_id, workers.date_time]);

                let totalTarget = 0;

                for (const row_t of queryTResults) {
                    let count = 0;
                    for (let i = 1; i <= 11; i++) {
                        const u = `HOUR${i}`;
                        if (row_t[u] > 0) {
                            count++;
                        }
                    }

                    if (parseInt(row_t.actual_target) > 0) {
                        totalTarget += parseInt(row_t.actual_target) * count;
                    } else {
                        const actTargetQuery = "SELECT target FROM item_section_ota WHERE section_id=? and item_id=?";
                        const actTargetResult = await executeQuery(connection,actTargetQuery, [row_t.section, row_t.product_name]);
                        totalTarget += parseInt(actTargetResult[0].target) * count;
                    }

                    const e = (parseInt(workers.value_sum) / totalTarget) * 100;
                    const eff = parseFloat(e).toFixed(2) + '%';  

                    // Push data to responseData
                    responseData.push({
                        worker: worker,
                        id: id,
                        dates: td,
                        eff: eff, // Define present_days
                    });
                }
          
    });

    await Promise.all(resultPromises);
    res.send(responseData);
    //console.log(responseData,"-----------------------")
  } catch (error) {
    console.error('Error executing MySQL query:', error);
    res.status(500).send('Internal Server Error');
  } finally {
    if(connection){
      connection.release();
    }
  }
});


//Efficiency overview details wise view
/**
 * @swagger
 * /Nbraid/get_efficiencyOverview_details_data/{id1}/{id2}:
 *   get:
 *     summary: Get Efficiency Overview Details Data.
 *     description: Retrieves efficiency overview details data for a specific worker and date.
 *     tags:
 *       - Reports
 *     parameters:
 *       - in: path
 *         name: id1
 *         required: true
 *         description: Worker ID.
 *         schema:
 *           type: integer
 *       - in: path
 *         name: id2
 *         required: true
 *         description: Date in the format "DD-MM-YYYY".
 *         schema:
 *           type: string
 *           format: date
 *     responses:
 *       200:
 *         description: Successful response with efficiency overview details data.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 tot_tar:
 *                   type: number
 *                   description: Total target.
 *                   example: 100
 *                 tot_sum:
 *                   type: number
 *                   description: Total sum.
 *                   example: 90
 *                 tot_eff:
 *                   type: string
 *                   description: Total efficiency.
 *                   example: "90%"
 *                 date:
 *                   type: string
 *                   description: Date in the format "DD-MM-YYYY".
 *                   example: "01-01-2024"
 *                 items:
 *                   type: array
 *                   items:
 *                     type: object
 *                     properties:
 *                       worker:
 *                         type: string
 *                         description: Name of the worker.
 *                         example: "John Doe"
 *                       eid:
 *                         type: integer
 *                         description: Worker ID.
 *                         example: 123
 *                       prod:
 *                         type: string
 *                         description: Product description.
 *                         example: "Product A"
 *                       line:
 *                         type: string
 *                         description: Line.
 *                         example: "Line 1"
 *                       sec:
 *                         type: string
 *                         description: Section name.
 *                         example: "Section A"
 *                       target:
 *                         type: number
 *                         description: Target.
 *                         example: 10
 *                       h1:
 *                         type: number
 *                         description: Hour 1.
 *                         example: 5
 *                       h2:
 *                         type: number
 *                         description: Hour 2.
 *                         example: 6
 *                       h3:
 *                         type: number
 *                         description: Hour 3.
 *                         example: 7
 *                       h4:
 *                         type: number
 *                         description: Hour 4.
 *                         example: 8
 *                       h5:
 *                         type: number
 *                         description: Hour 5.
 *                         example: 9
 *                       h6:
 *                         type: number
 *                         description: Hour 6.
 *                         example: 10
 *                       h7:
 *                         type: number
 *                         description: Hour 7.
 *                         example: 11
 *                       h8:
 *                         type: number
 *                         description: Hour 8.
 *                         example: 12
 *                       h9:
 *                         type: number
 *                         description: Hour 9.
 *                         example: 13
 *                       h10:
 *                         type: number
 *                         description: Hour 10.
 *                         example: 14
 *                       h11:
 *                         type: number
 *                         description: Hour 11.
 *                         example: 15
 *                       tar:
 *                         type: number
 *                         description: Target for the worker.
 *                         example: 100
 *                       sum:
 *                         type: number
 *                         description: Sum of worker's hours.
 *                         example: 90
 *                       eff:
 *                         type: string
 *                         description: Efficiency percentage for the worker.
 *                         example: "90%"
 *       500:
 *         description: Internal Server Error.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: "Internal Server Error"
 *
 * @function
 * @name getEfficiencyOverviewDetailsData
 * @memberof module:Routes/Reports
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with the database query.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
app.get('/Nbraid/get_efficiencyOverview_details_data/:id1/:id2',authenticateJWT , async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    const eid = req.params.id1;
    const date = req.params.id2;
    console.log(eid,date)
    const workerQuery = `SELECT *, COUNT(*) as cnt, SUM(HOUR1+HOUR2+HOUR3+HOUR4+HOUR5+HOUR6+HOUR7+HOUR8+HOUR9+HOUR10+HOUR11) as value_sum
    FROM worker_timesheet
    WHERE date_time = ? AND entry_id =?
    GROUP BY shift,entry_id,product_name,line,section,date_time`;
    const workerResults = await executeQuery(connection,workerQuery, [date,eid]);

    let total_tar=0;
    let total_sum=0;
    let total_eff=0;
    const responseData = {
      tot_tar: total_tar,
      tot_sum: total_sum,
      tot_eff: total_eff,
      date:date,
      items:[],
    };
    const resultPromises = workerResults.map(async (workers) => {
        // Define worker, id, section_name, valuesByDate, avg, and present_days here
        const worker = workers.worker;
        const id = workers.entry_id;

                  // Query to get item description
                const [productRows] = await executeQuery(connection,`SELECT * FROM item_masterr WHERE id = ?`, [workers.product_name]);
                const productDescription = productRows.item_description;

                // Query to get section name
                const [sectionRows] = await executeQuery(connection,`SELECT * FROM section WHERE id = ?`, [workers.section]);
                const sectionName = sectionRows.section_name;

                // Query to get target
                const [targetdata] = await executeQuery(connection,`SELECT * FROM item_section_ota WHERE section_id = ? AND item_id = ?`, [workers.section,workers.product_name]);
                const targett = targetdata.target;

            
                    let count = 0;
                    for (let i = 1; i <= 11; i++) {
                        const u = `HOUR${i}`;
                        if (workers[u] > 0) {
                            count++;
                        }
                    }
                   //calculatio 
                   const tar = targett * count;
                   total_tar+=tar;

                   const sum = workers.value_sum; 
                   total_sum+=sum;

                   const e = (parseInt(sum) / tar) * 100;
                   const eff = parseFloat(e).toFixed(2) + '%';
                   total_eff+=eff;

                    // Push data to responseData
                    responseData.items.push({
                        worker: worker,
                        eid: id,
                        prod:productDescription,
                        line:workers.line,
                        sec:sectionName,
                        target:targett,
                        h1:workers.HOUR1,
                        h2:workers.HOUR2,
                        h3:workers.HOUR3,
                        h4:workers.HOUR4,
                        h5:workers.HOUR5,
                        h6:workers.HOUR6,
                        h7:workers.HOUR7,
                        h8:workers.HOUR8,
                        h9:workers.HOUR9,
                        h10:workers.HOUR10,
                        h11:workers.HOUR11,
                        tar: tar, // Define present_days
                        sum:sum,
                        eff:eff,
                       
                    });
                
          
    });

    await Promise.all(resultPromises);

    responseData.tot_tar = total_tar;
    responseData.tot_sum = total_sum;
    //responseData.tot_eff = typeof total_eff === 'number' ? total_eff.toFixed(2) + '%' : '0.00%';
    const numericTotalEff = parseFloat(total_eff);
    responseData.tot_eff = !isNaN(numericTotalEff) ? numericTotalEff.toFixed(2) + '%' : '0.00%';

    res.send(responseData);
    console.log(responseData,"-----------------------")
  } catch (error) {
    console.error('Error executing MySQL query:', error);
    res.status(500).send('Internal Server Error');
  } finally {
    if(connection){
      connection.release();
    }
  }
});



//Performance Efficiency Report

//Performance Efficiency default report 
/**
 * @swagger
 * /Nbraid/get_performance_efficiency_data:
 *   get:
 *     summary: Get Performance Efficiency Data
 *     description: Retrieves performance efficiency data for all workers for the current date.
 *     tags:
 *       - Reports
 *     security:
 *       - BearerAuth: []
 *     responses:
 *       200:
 *         description: Successful response with performance efficiency data.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 dates:
 *                   type: array
 *                   items:
 *                     type: string
 *                     description: List of dates in the format "DD-MM-YYYY".
 *                     example: ["01-01-2024", "02-01-2024"]
 *                 items:
 *                   type: array
 *                   items:
 *                     type: object
 *                     properties:
 *                       worker:
 *                         type: string
 *                         description: Name of the worker.
 *                         example: "John Doe"
 *                       entry_id:
 *                         type: integer
 *                         description: Worker ID.
 *                         example: 123
 *                       regg:
 *                         type: string
 *                         description: Registration date of the worker in the format "DD-MM-YYYY".
 *                         example: "01-01-2023"
 *                       diff:
 *                         type: integer
 *                         description: Difference in days between the registration date and the current date.
 *                         example: 365
 *                       section:
 *                         type: string
 *                         description: Name of the section.
 *                         example: "Section A"
 *                       product:
 *                         type: string
 *                         description: Product description.
 *                         example: "Product A"
 *                       line:
 *                         type: string
 *                         description: Line.
 *                         example: "Line 1"
 *                       count:
 *                         type: object
 *                         additionalProperties:
 *                           type: array
 *                           items:
 *                             type: string
 *                             description: Efficiency values by date.
 *                             example: ["90.00", "85.00"]
 *       500:
 *         description: Internal Server Error.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: "Internal Server Error"
 *
 * @function
 * @name getPerformanceEfficiencyData
 * @memberof module:Routes/Reports
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with the database query.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
app.get('/Nbraid/get_performance_efficiency_data',authenticateJWT , async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    const timezone = 'Africa/Lagos';
    
    const currentDate = new Date();
const day = currentDate.getDate().toString().padStart(2, '0');
const month = (currentDate.getMonth() + 1).toString().padStart(2, '0');
const year = currentDate.getFullYear();
const todaydate = `${day}-${month}-${year}`;

const fd2 = Math.floor((currentDate.getTime() - 24 * 60 * 60 * 1000) / 1000);
const td1 = Math.floor(currentDate.getTime() / 1000);

const fd1 = Math.floor(new Date(fd2 * 1000).setDate(currentDate.getDate() - 1) / 1000);

// console.log('Formatted Today Date:', todaydate);
// console.log('Timestamp for Today Date:', fd2);
// console.log('Timestamp for Previous Date:', td1);
const dateObj = new Date(currentDate);
const dateObj1 = new Date(currentDate);

    const newfd = fd2;
    const newtd = td1;
    // Query 1: Get timesheet
    const timesheetQuery = "SELECT *, HOUR1 + HOUR2 + HOUR3 + HOUR4 + HOUR5 + HOUR6 + HOUR7 + HOUR8 + HOUR9 + HOUR10 + HOUR11 AS value_sum FROM worker_timesheet WHERE (date_time BETWEEN ? AND ?) GROUP BY entry_id, product_name, section, line";
    const timesheet = await executeQuery(connection,timesheetQuery, [todaydate, todaydate]);

    // Query 2: Get timesheetk
    const timesheetkQuery = "SELECT *, HOUR1 + HOUR2 + HOUR3 + HOUR4 + HOUR5 + HOUR6 + HOUR7 + HOUR8 + HOUR9 + HOUR10 + HOUR11 AS value_sum FROM worker_timesheet WHERE (date_time BETWEEN ? AND ?) GROUP BY entry_id, product_name, section, line, date_time";
    const timesheetk = await executeQuery(connection,timesheetkQuery, [todaydate, todaydate]);

    dateObj.toLocaleString('en-US', { timeZone: timezone });
    dateObj1.toLocaleString('en-US', { timeZone: timezone });

    const period = [];
    const date = new Date(dateObj);

    while (date <= dateObj1) {
      period.push(new Date(date));
      date.setDate(date.getDate() + 1);
    }

    // Function to format a date as "d-m-Y"
    const formatDate = (date) => {
      const day = String(date.getDate()).padStart(2, '0');
      const month = String(date.getMonth() + 1).padStart(2, '0');
      const year = date.getFullYear();
      return `${day}-${month}-${year}`;
    };

    const formattedDates = period.map((date) => formatDate(date));

    const ard = [];
    const arr = [];
    
    for (const itemk of timesheetk) {
      const dent = `${itemk.date_time}-${itemk.entry_id}-${itemk.product_name}-${itemk.section}-${itemk.line}`;
      ard.push(dent);
      
      const e = (itemk.value_sum / itemk.target) * 100;
      const eff = parseFloat(e.toFixed(2));
      arr.push(eff);
    }

    const responseData = {
      dates: formattedDates,
      items:[],
    }
    // Process timesheet and other data as needed using Promise.all
    const resultPromises = timesheet.map(async (item) => {
      console.log('----');
      const entry = item.entry_id;
      const worker = item.worker;
      const line = item.line;
      const site = item.site;
      let query1;
      let ss = '';

      if (site === 'both') {
        query1 = `SELECT * FROM employees_ota WHERE entryid='${entry}'`;

        try {
          const result1 = await executeQuery(connection,query1);

          if (!result1 || result1.length === 0) {
            query1 = `SELECT * FROM geopos_employees WHERE entryid='${entry}'`;
            ss = 'ikeja';
          } else {
            ss = 'ota';
          }
        } catch (error) {
          // Handle database query error
          console.error('Error querying the database:', error);
        }
      } else if (site === 'ikeja') {
        query1 = `SELECT * FROM geopos_employees WHERE entryid='${entry}'`;
        ss = 'ikeja';
      } else if (site === 'ota') {
        query1 = `SELECT * FROM employees_ota WHERE entryid='${entry}'`;
        ss = 'ota';
      }

      let regg = '';
      let diff = '';

      if (query1) {
        try {
          const query1Result = await executeQuery(connection,query1);
      
          if (query1Result && query1Result[0] && query1Result[0].hasOwnProperty('joindate')) {
             
            const dateParts = query1Result[0].joindate.split(/[- :]/);
            let reggDate;
            if (dateParts.length === 3) {
             // Format: d-m-Y
             reggDate = new Date(Date.UTC(dateParts[2], dateParts[1] - 1, dateParts[0]));
            
             } else if (dateParts.length === 6) {
                 // Format: Y-m-d h:i:s
                 reggDate = new Date(Date.UTC(dateParts[0], dateParts[1] - 1, dateParts[2], dateParts[3], dateParts[4], dateParts[5]));
          
            } else {
                 console.error('Unsupported date format');
            }
          
             regg = reggDate.toLocaleDateString('en-GB', {
                  day: '2-digit',
                  month: '2-digit',
                  year: 'numeric',
                }).replace(/\//g, '-');
        
          const datek1 = item.date_time;
        
          const datek11 = new Date(datek1.split('-').reverse().join('-'));
         const regg1 = new Date(regg.split('-').reverse().join('-'));

          const timeDifference = datek11.getTime() - regg1.getTime();
          diff = Math.floor(timeDifference / (1000 * 60 * 60 * 24)); // Convert to days
           
          } else {
            regg = '';
            diff = '';
          }
        } catch (error) {
          // Handle database query error
          console.error('Error querying the database:', error);
        }
      }
      
      
      


      const productQuery = "SELECT item_description FROM item_masterr WHERE id = ?";
      let productRows;
      let itemDescription; 

      if (item.product_name) {
        [productRows] = await executeQuery(connection,productQuery, [item.product_name]);
        // Use optional chaining and provide a default value (empty string) in case item_description is undefined
        itemDescription = productRows?.item_description ?? ""; 
      } else {
        itemDescription = ''; // Replace '' with "" to maintain consistency in type
      }

     
      
// Now you can use productRows in the rest of your code


      const sectionQuery = "SELECT section_name FROM section WHERE id = ?";
      const [sectionRows] = await executeQuery(connection,sectionQuery, [item.section]);
    

      const valuesByDate = {}; // Store values by date

      for (const dt1 of period) {
        const date23 = formatDate(dt1);
        const dd1 = `${date23}-${item.entry_id}-${item.product_name}-${item.section}-${item.line}`;

        const values = [];

        if (ard.includes(dd1)) {
          const ky = ard.indexOf(dd1);
          //console.log(dt1,'=============')
          if (ky >= 0 && ky < arr.length && !isNaN(arr[ky])) {
            values.push(arr[ky].toFixed(2));
           // console.log(arr[ky]+'----------')
          } else {
            values.push('-');
          }
        } else {
          console.log(date23,dt1,'=======2======')
          values.push('-');
        }

        valuesByDate[date23] = values;
      }
      // const sectionName = sectionRows.length > 0 ? sectionRows.section_name : 'Section Name Not Found';
      // const itemDescription = productRows.length > 0 ? productRows.item_description : 'Item Description Not Found';
     
      responseData.items.push({
        worker: worker,
        entry_id: entry,
        regg: regg,
        diff: diff,
        section: sectionRows.section_name,
        product: itemDescription,
        line: line,
        count: valuesByDate,
        //dates: formattedDates,
      });
    });

    await Promise.all(resultPromises);
    res.send(responseData);
    console.log(responseData)
  } catch (error) {
    console.error('Error executing MySQL query:', error);
    res.status(500).send('Internal Server Error');
  }
});


//Performance efficiency search data
/**
 * @swagger
 * /Nbraid/get_performance_eff_search_data:
 *   post:
 *     summary: Get Performance Efficiency Search Data.
 *     description: Retrieves performance efficiency search data for a specified date range.
 *     tags:
 *       - Reports
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             properties:
 *               fromdate:
 *                 type: string
 *                 format: date
 *                 description: Start date in the format "DD-MM-YYYY".
 *                 example: "01-01-2024"
 *               todate:
 *                 type: string
 *                 format: date
 *                 description: End date in the format "DD-MM-YYYY".
 *                 example: "31-01-2024"
 *     responses:
 *       200:
 *         description: Successful response with performance efficiency search data.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 dates:
 *                   type: array
 *                   items:
 *                     type: string
 *                     example: "01-01-2024"
 *                 items:
 *                   type: array
 *                   items:
 *                     type: object
 *                     properties:
 *                       worker:
 *                         type: string
 *                         description: Name of the worker.
 *                         example: "John Doe"
 *                       entry_id:
 *                         type: integer
 *                         description: Worker ID.
 *                         example: 123
 *                       regg:
 *                         type: string
 *                         description: Registration date in the format "DD-MM-YYYY".
 *                         example: "01-01-2024"
 *                       diff:
 *                         type: integer
 *                         description: Difference in days between registration date and the date of timesheet entry.
 *                         example: 30
 *                       section:
 *                         type: string
 *                         description: Section name.
 *                         example: "Section A"
 *                       product:
 *                         type: string
 *                         description: Product description.
 *                         example: "Product A"
 *                       line:
 *                         type: string
 *                         description: Line.
 *                         example: "Line 1"
 *                       count:
 *                         type: object
 *                         additionalProperties:
 *                           type: array
 *                           items:
 *                             type: string
 *                             description: Efficiency value for each date.
 *                             example: "90.00"
 *       500:
 *         description: Internal Server Error.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: "Internal Server Error"
 *
 * @function
 * @name getPerformanceEfficiencySearchData
 * @memberof module:Routes/Reports
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with the database query.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
app.post('/Nbraid/get_performance_eff_search_data',authenticateJWT , async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    const timezone = 'Africa/Lagos';
    const fromdate = req.body.fromdate;
    const fdParts = fromdate.split('-');
    const fd = `${fdParts[2]}-${fdParts[1]}-${fdParts[0]}`;

    const todate = req.body.todate;
    const tdParts = todate.split('-');
    const td = `${tdParts[2]}-${tdParts[1]}-${tdParts[0]}`;

    const dateObj = new Date(fromdate);
    const day = dateObj.getDate().toString().padStart(2, '0');
    const month = (dateObj.getMonth() + 1).toString().padStart(2, '0');
    const year = dateObj.getFullYear();
    const convertedDate = `${day}-${month}-${year}`;

    const dateObj1 = new Date(todate);
    const day1 = dateObj1.getDate().toString().padStart(2, '0');
    const month1 = (dateObj1.getMonth() + 1).toString().padStart(2, '0');
    const year1 = dateObj1.getFullYear();
    const convertedDate1 = `${day1}-${month1}-${year1}`;

    const fd2 = Math.floor((new Date(fromdate).getTime() -24 * 60 * 60 * 1000) / 1000);
    const td1 = Math.floor(new Date(todate).getTime() / 1000);
    const fd1 = Math.floor(new Date(fd2 * 1000).setDate(new Date(fd2 * 1000).getDate() - 1) / 1000);

    const newfd = fd2;
    const newtd = td1;

    // Query 1: Get timesheet
    const timesheetQuery = "SELECT *, HOUR1 + HOUR2 + HOUR3 + HOUR4 + HOUR5 + HOUR6 + HOUR7 + HOUR8 + HOUR9 + HOUR10 + HOUR11 AS value_sum FROM worker_timesheet WHERE (time_stamp BETWEEN ? AND ?) GROUP BY entry_id, product_name, section, line";
    const timesheet = await executeQuery(connection,timesheetQuery, [newfd, newtd]);

    // Query 2: Get timesheetk
    const timesheetkQuery = "SELECT *, HOUR1 + HOUR2 + HOUR3 + HOUR4 + HOUR5 + HOUR6 + HOUR7 + HOUR8 + HOUR9 + HOUR10 + HOUR11 AS value_sum FROM worker_timesheet WHERE (time_stamp BETWEEN ? AND ?) GROUP BY entry_id, product_name, section, line, date_time";
    const timesheetk = await executeQuery(connection,timesheetkQuery, [newfd, newtd]);

    dateObj.toLocaleString('en-US', { timeZone: timezone });
    dateObj1.toLocaleString('en-US', { timeZone: timezone });

    const period = [];
    const date = new Date(dateObj);

    while (date <= dateObj1) {
      period.push(new Date(date));
      date.setDate(date.getDate() + 1);
    }

    // Function to format a date as "d-m-Y"
    const formatDate = (date) => {
      const day = String(date.getDate()).padStart(2, '0');
      const month = String(date.getMonth() + 1).padStart(2, '0');
      const year = date.getFullYear();
      return `${day}-${month}-${year}`;
    };

    const formattedDates = period.map((date) => formatDate(date));

    const ard = [];
    const arr = [];
    
    for (const itemk of timesheetk) {
      const dent = `${itemk.date_time}-${itemk.entry_id}-${itemk.product_name}-${itemk.section}-${itemk.line}`;
      ard.push(dent);
      
      const e = (itemk.value_sum / itemk.target) * 100;
      const eff = parseFloat(e.toFixed(2));
      arr.push(eff);
    }

    const responseData = {
      dates: formattedDates,
      items:[],
    }
    // Process timesheet and other data as needed using Promise.all
    const resultPromises = timesheet.map(async (item) => {
      const entry = item.entry_id;
      const worker = item.worker;
      const line = item.line;
      const site = item.site;
      let query1;
      let ss = '';

      if (site === 'both') {
        query1 = `SELECT * FROM employees_ota WHERE entryid='${entry}'`;

        try {
          const result1 = await executeQuery(connection,query1);

          if (!result1 || result1.length === 0) {
            query1 = `SELECT * FROM geopos_employees WHERE entryid='${entry}'`;
            ss = 'ikeja';
          } else {
            ss = 'ota';
          }
        } catch (error) {
          // Handle database query error
          console.error('Error querying the database:', error);
        }
      } else if (site === 'ikeja') {
        query1 = `SELECT * FROM geopos_employees WHERE entryid='${entry}'`;
        ss = 'ikeja';
      } else if (site === 'ota') {
        query1 = `SELECT * FROM employees_ota WHERE entryid='${entry}'`;
        ss = 'ota';
      }

      let regg = '';
      let diff = '';

      if (query1) {
        try {
          const query1Result = await executeQuery(connection,query1);
      
          if (query1Result && query1Result[0] && query1Result[0].hasOwnProperty('joindate')) {
       
            const dateParts = query1Result[0].joindate.split(/[- :]/);
            let reggDate;
            if (dateParts.length === 3) {
             // Format: d-m-Y
             reggDate = new Date(Date.UTC(dateParts[2], dateParts[1] - 1, dateParts[0]));
            
             } else if (dateParts.length === 6) {
                 // Format: Y-m-d h:i:s
                 reggDate = new Date(Date.UTC(dateParts[0], dateParts[1] - 1, dateParts[2], dateParts[3], dateParts[4], dateParts[5]));
          
            } else {
                 console.error('Unsupported date format');
            }
          
             regg = reggDate.toLocaleDateString('en-GB', {
                  day: '2-digit',
                  month: '2-digit',
                  year: 'numeric',
                }).replace(/\//g, '-');
        
          const datek1 = item.date_time;
        
          const datek11 = new Date(datek1.split('-').reverse().join('-'));
         const regg1 = new Date(regg.split('-').reverse().join('-'));

          const timeDifference = datek11.getTime() - regg1.getTime();
          diff = Math.floor(timeDifference / (1000 * 60 * 60 * 24)); // Convert to days
           
          } else {
            regg = '';
            diff = '';
          }
        } catch (error) {
          // Handle database query error
          console.error('Error querying the database:', error);
        }
      }
      
      
      


      const productQuery = "SELECT item_description FROM item_masterr WHERE id = ?";
      let productRows;
      let itemDescription; 

      if (item.product_name) {
        [productRows] = await executeQuery(connection,productQuery, [item.product_name]);
        // Use optional chaining and provide a default value (empty string) in case item_description is undefined
        itemDescription = productRows?.item_description ?? ""; 
      } else {
        itemDescription = ''; // Replace '' with "" to maintain consistency in type
      }

     
      
// Now you can use productRows in the rest of your code


      const sectionQuery = "SELECT section_name FROM section WHERE id = ?";
      const [sectionRows] = await executeQuery(connection,sectionQuery, [item.section]);
    

      const valuesByDate = {}; // Store values by date

      for (const dt1 of period) {
        const date23 = formatDate(dt1);
        const dd1 = `${date23}-${item.entry_id}-${item.product_name}-${item.section}-${item.line}`;
      
        const values = [];

        if (ard.includes(dd1)) {
          const ky = ard.indexOf(dd1);

          if (ky >= 0 && ky < arr.length && !isNaN(arr[ky])) {
            values.push(arr[ky].toFixed(2));
           // console.log(arr[ky]+'----------')
          } else {
            values.push('-');
          }
        } else {
          values.push('-');
        }

        valuesByDate[date23] = values;
      }
      // const sectionName = sectionRows.length > 0 ? sectionRows.section_name : 'Section Name Not Found';
      // const itemDescription = productRows.length > 0 ? productRows.item_description : 'Item Description Not Found';
     
      responseData.items.push({
        worker: worker,
        entry_id: entry,
        regg: regg,
        diff: diff,
        section: sectionRows.section_name,
        product: itemDescription,
        line: line,
        count: valuesByDate,
        //dates: formattedDates,
      });
    });

    await Promise.all(resultPromises);
    res.send(responseData);
    //console.log(responseData)
  } catch (error) {
    console.error('Error executing MySQL query:', error);
    res.status(500).send('Internal Server Error');
  } finally {
    if (connection) {
      connection.end();
    }
  }
});



//Performance Overview Report

//Performance Overview Nbraid Report default
/**
 * @swagger
 * /Nbraid/get_performance_overview_data:
 *   get:
 *     summary: Get Performance Overview Data.
 *     description: Retrieves performance overview data for the current date.
 *     tags:
 *       - Performance
 *     responses:
 *       200:
 *         description: Successful response with performance overview data.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 dates:
 *                   type: string
 *                   description: The current date in the format "DD-MM-YYYY".
 *                   example: "01-01-2024"
 *                 items:
 *                   type: array
 *                   items:
 *                     type: object
 *                     properties:
 *                       worker:
 *                         type: string
 *                         description: Name of the worker.
 *                         example: "John Doe"
 *                       entry_id:
 *                         type: integer
 *                         description: Worker ID.
 *                         example: 123
 *                       regg:
 *                         type: string
 *                         description: Registration date in the format "DD-MM-YYYY".
 *                         example: "01-01-2020"
 *                       diff:
 *                         type: integer
 *                         description: Difference in days between the registration date and the current date.
 *                         example: 1460
 *                       totalTarget:
 *                         type: number
 *                         description: Total target.
 *                         example: 100
 *                       tvalue_sum:
 *                         type: number
 *                         description: Total value sum.
 *                         example: 90
 *                       eff:
 *                         type: string
 *                         description: Efficiency percentage.
 *                         example: "90%"
 *       500:
 *         description: Internal Server Error.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: "Internal Server Error"
 *
 * @function
 * @name getPerformanceOverviewData
 * @memberof module:Routes/Performance
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with the database query.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
app.get('/Nbraid/get_performance_overview_data',authenticateJWT , async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    const currentDate = new Date();
    const fd2 = Math.floor((currentDate.getTime() - 24 * 60 * 60 * 1000) / 1000);
    const td1 = Math.floor((currentDate.getTime() + 24 * 60 * 60 * 1000) / 1000);
     
    const dateObj = new Date(currentDate);
    const day = dateObj.getDate().toString().padStart(2, '0');
    const month = (dateObj.getMonth() + 1).toString().padStart(2, '0');
    const year = dateObj.getFullYear();
    const convertedDate = `${day}-${month}-${year}`;

    const newfd = fd2;
    const newtd = td1;
    
    // Query 1: Get timesheet
    const timesheetQuery = "SELECT *, HOUR1 + HOUR2 + HOUR3 + HOUR4 + HOUR5 + HOUR6 + HOUR7 + HOUR8 + HOUR9 + HOUR10 + HOUR11 AS value_sum FROM worker_timesheet WHERE (date_time BETWEEN ? AND ?) GROUP BY entry_id, shift, mon";
    const timesheet = await executeQuery(connection,timesheetQuery, [convertedDate, convertedDate]);

    const responseData ={
      dates: convertedDate,
      items:[],
    }
    // Process timesheet and other data as needed using Promise.all
    const resultPromises = timesheet.map(async (item) => {
      const entry = item.entry_id;
      const worker = item.worker;
      const site = item.site;
      let query1;
      let ss = '';

      if (site === 'both') {
        query1 = `SELECT * FROM employees_ota WHERE entryid='${entry}'`;

        try {
          const result1 = await executeQuery(connection,query1);

          if (!result1 || result1.length === 0) {
            query1 = `SELECT * FROM geopos_employees WHERE entryid='${entry}'`;
            ss = 'ikeja';
          } else {
            ss = 'ota';
          }
        } catch (error) {
          // Handle database query error
          console.error('Error querying the database:', error);
        }
      } else if (site === 'ikeja') {
        query1 = `SELECT * FROM geopos_employees WHERE entryid='${entry}'`;
        ss = 'ikeja';
      } else if (site === 'ota') {
        query1 = `SELECT * FROM employees_ota WHERE entryid='${entry}'`;
        ss = 'ota';
      } else {
        query1 = null;
        ss = '';
      }

      let regg = '';
      let diff = '';

      if (query1) {
        try {
          const query1Result = await executeQuery(connection,query1);
      
          // Add some debug output to see the results of query1Result
          console.log('Query1Result:', query1Result);
      
          if (query1Result && query1Result[0] && query1Result[0].hasOwnProperty('joindate')) {
            const dateParts = query1Result[0].joindate.split(/[- :]/) || '';
            let reggDate;
            if (dateParts.length === 3) {
             // Format: d-m-Y
             reggDate = new Date(Date.UTC(dateParts[2], dateParts[1] - 1, dateParts[0]));
            
             } else if (dateParts.length === 6) {
                 // Format: Y-m-d h:i:s
                 reggDate = new Date(Date.UTC(dateParts[0], dateParts[1] - 1, dateParts[2], dateParts[3], dateParts[4], dateParts[5]));
          
            } else {
                 console.error('Unsupported date format');
            }
          
             regg = reggDate.toLocaleDateString('en-GB', {
                  day: '2-digit',
                  month: '2-digit',
                  year: 'numeric',
                }).replace(/\//g, '-');
        
           const datek1 = item.date_time;
        
          const datek11 = new Date(datek1.split('-').reverse().join('-'));
           const regg1 = new Date(regg.split('-').reverse().join('-'));

          const timeDifference = datek11.getTime() - regg1.getTime();
          diff = Math.floor(timeDifference / (1000 * 60 * 60 * 24)); // Convert to days

          } else {
            regg = '';
            diff = '';
          }
        } catch (error) {
          // Handle database query error
          console.error('Error querying the database:', error);
        }
      }
      

      // Initialize variables
      let targettm = 0;
      let totalTargetm = 0;
      let totalvalue_sum = 0;

      const querytm = `
        SELECT entry_id, time_stamp FROM worker_timesheet
        WHERE entry_id = ? AND (date_time BETWEEN ? AND ?)
        GROUP BY time_stamp
      `;

      const results1 = await executeQuery(connection,querytm, [item.entry_id,convertedDate, convertedDate]);

      // Use Promise.all to ensure all sub-queries are completed
      await Promise.all(
        results1.map(async (itemtm) => {
          const querymn = `
            SELECT *, HOUR1 + HOUR2 + HOUR3 + HOUR4 + HOUR5 + HOUR6 + HOUR7 + HOUR8 + HOUR9 + HOUR10 + HOUR11 AS value_sum
            FROM worker_timesheet
            WHERE entry_id = ? AND time_stamp = ?
          `;

          const results2 = await executeQuery(connection,querymn, [itemtm.entry_id, itemtm.time_stamp]);

          results2.forEach((itemmn) => {
            let count = 0;

            for (let j = 1; j <= 11; j++) {
              const str = 'HOUR' + j;
              if (itemmn[str] > 0) {
                count++;
              }
            }

            // Ensure itemmn.actual_target is defined and a valid number
            if (typeof itemmn.actual_target === 'number') {
              // Calculate targettm for the current item and accumulate it in totalTargetm
              targettm = itemmn.actual_target * count;
              totalTargetm += targettm;

              // Accumulate value_sum in totalvalue_sum
              totalvalue_sum += itemmn.value_sum;
            }
            //console.log('-----------')
          });
        })
      );

      const tvalue_sum = totalvalue_sum;
      const totalTarget = totalTargetm;
      const e = (tvalue_sum / totalTarget) * 100;
      const eff = e.toFixed(2);

      responseData.items.push({
        worker: worker,
        entry_id: entry,
        regg: regg,
        diff: diff,
        totalTarget: totalTarget,
        tvalue_sum: tvalue_sum,
        eff: eff,
        
      });
    });

    await Promise.all(resultPromises);
    res.send(responseData);
    console.log(responseData,'---------------------');
  } catch (error) {
    console.error('Error executing MySQL query:', error);
    res.status(500).send('Internal Server Error');
  } finally {
    if (connection) {
      connection.end();
    }
  }
});



//Performance Overview search data
/**
 * @swagger
 * /Nbraid/get_performance_overview_search_data:
 *   post:
 *     summary: Get Performance Overview Search Data
 *     description: Retrieves performance overview data for a specified date range.
 *     tags:
 *       - Reports
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             properties:
 *               fromdate:
 *                 type: string
 *                 format: date
 *                 description: Start date in the format "DD-MM-YYYY".
 *                 example: "01-01-2024"
 *               todate:
 *                 type: string
 *                 format: date
 *                 description: End date in the format "DD-MM-YYYY".
 *                 example: "31-01-2024"
 *     responses:
 *       200:
 *         description: Successful response with performance overview data.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 dates:
 *                   type: string
 *                   description: Date range.
 *                   example: "01-01-2024 TO 31-01-2024"
 *                 items:
 *                   type: array
 *                   items:
 *                     type: object
 *                     properties:
 *                       worker:
 *                         type: string
 *                         description: Name of the worker.
 *                         example: "John Doe"
 *                       entry_id:
 *                         type: integer
 *                         description: Worker ID.
 *                         example: 123
 *                       regg:
 *                         type: string
 *                         description: Registration date.
 *                         example: "01-01-2024"
 *                       diff:
 *                         type: number
 *                         description: Difference in days between the registration date and the current date.
 *                         example: 10
 *                       totalTarget:
 *                         type: number
 *                         description: Total target for the worker.
 *                         example: 100
 *                       tvalue_sum:
 *                         type: number
 *                         description: Total value sum.
 *                         example: 90
 *                       eff:
 *                         type: string
 *                         description: Efficiency percentage for the worker.
 *                         example: "90%"
 *       500:
 *         description: Internal Server Error.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: "Internal Server Error"
 *
 * @function
 * @name getPerformanceOverviewSearchData
 * @memberof module:Routes/Reports
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with the database query.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
app.post('/Nbraid/get_performance_overview_search_data',authenticateJWT , async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    const timezone = 'Africa/Lagos';
    const fromdate = req.body.fromdate;
    const fdParts = fromdate.split('-');
    const fd = `${fdParts[2]}-${fdParts[1]}-${fdParts[0]}`;

    const todate = req.body.todate;
    const tdParts = todate.split('-');
    const td = `${tdParts[2]}-${tdParts[1]}-${tdParts[0]}`;

    const dateObj = new Date(fromdate);
    const day = dateObj.getDate().toString().padStart(2, '0');
    const month = (dateObj.getMonth() + 1).toString().padStart(2, '0');
    const year = dateObj.getFullYear();
    const convertedDate = `${day}-${month}-${year}`;

    const dateObj1 = new Date(todate);
    const day1 = dateObj1.getDate().toString().padStart(2, '0');
    const month1 = (dateObj1.getMonth() + 1).toString().padStart(2, '0');
    const year1 = dateObj1.getFullYear();
    const convertedDate1 = `${day1}-${month1}-${year1}`;

    const fd2 = Math.floor((new Date(fromdate).getTime() - 2 * 24 * 60 * 60 * 1000) / 1000);
    const td1 = Math.floor(new Date(todate).getTime() / 1000);
    const fd1 = Math.floor(new Date(fd2 * 1000).setDate(new Date(fd2 * 1000).getDate() - 1) / 1000);

    const newfd = fd2;
    const newtd = td1;

    // Query 1: Get timesheet
    const timesheetQuery = "SELECT *, HOUR1 + HOUR2 + HOUR3 + HOUR4 + HOUR5 + HOUR6 + HOUR7 + HOUR8 + HOUR9 + HOUR10 + HOUR11 AS value_sum FROM worker_timesheet WHERE (time_stamp BETWEEN ? AND ?) GROUP BY entry_id, shift, mon";
    const timesheet = await executeQuery(connection,timesheetQuery, [newfd, newtd]);

    const responseData ={
      dates: convertedDate + ' TO ' + convertedDate1,
      items:[],
    }
    // Process timesheet and other data as needed using Promise.all
    const resultPromises = timesheet.map(async (item) => {
      const entry = item.entry_id;
      const worker = item.worker;
      const site = item.site;
      let query1;
      let ss = '';

      if (site === 'both') {
        query1 = `SELECT * FROM employees_ota WHERE entryid='${entry}'`;

        try {
          const result1 = await executeQuery(connection,query1);

          if (!result1 || result1.length === 0) {
            query1 = `SELECT * FROM geopos_employees WHERE entryid='${entry}'`;
            ss = 'ikeja';
          } else {
            ss = 'ota';
          }
        } catch (error) {
          // Handle database query error
          console.error('Error querying the database:', error);
        }
      } else if (site === 'ikeja') {
        query1 = `SELECT * FROM geopos_employees WHERE entryid='${entry}'`;
        ss = 'ikeja';
      } else if (site === 'ota') {
        query1 = `SELECT * FROM employees_ota WHERE entryid='${entry}'`;
        ss = 'ota';
      } else {
        query1 = null;
        ss = '';
      }

      let regg = '';
      let diff = '';

      if (query1) {
        try {
          const query1Result = await executeQuery(connection,query1);
      
          // Add some debug output to see the results of query1Result
          //console.log('Query1Result:', query1Result);
      
          if (query1Result && query1Result[0] && query1Result[0].hasOwnProperty('joindate')) {
            // const joindateStr = query1Result[0].joindate; // Assuming it's a valid date/time string
      
            // const joindate = new Date(joindateStr);
            // // Format joindate as "d-m-Y"
            // const options = { year: 'numeric', month: '2-digit', day: '2-digit' };
            // regg = joindate.toLocaleDateString('en-US', options).replace(/\//g, '-');
            
            // const datek1 = new Date(item.date_time);
            // console.log(datek1,'-',joindate)
            // const timeDifference = datek1 - joindate;
            // diff = Math.floor(timeDifference / (1000 * 60 * 60 * 24));

            ///
            
            const dateParts = query1Result[0].joindate.split(/[- :]/) || '';
            let reggDate;
            if (dateParts.length === 3) {
             // Format: d-m-Y
             reggDate = new Date(Date.UTC(dateParts[2], dateParts[1] - 1, dateParts[0]));
            
             } else if (dateParts.length === 6) {
                 // Format: Y-m-d h:i:s
                 reggDate = new Date(Date.UTC(dateParts[0], dateParts[1] - 1, dateParts[2], dateParts[3], dateParts[4], dateParts[5]));
          
            } else {
                 console.error('Unsupported date format');
            }
          
             regg = reggDate.toLocaleDateString('en-GB', {
                  day: '2-digit',
                  month: '2-digit',
                  year: 'numeric',
                }).replace(/\//g, '-');
        
           const datek1 = item.date_time;
        
          const datek11 = new Date(datek1.split('-').reverse().join('-'));
           const regg1 = new Date(regg.split('-').reverse().join('-'));

          const timeDifference = datek11.getTime() - regg1.getTime();
          diff = Math.floor(timeDifference / (1000 * 60 * 60 * 24)); // Convert to days

          } else {
            regg = '';
            diff = '';
          }
        } catch (error) {
          // Handle database query error
          console.error('Error querying the database:', error);
        }
      }
      

      // Initialize variables
      let targettm = 0;
      let totalTargetm = 0;
      let totalvalue_sum = 0;

      const querytm = `
        SELECT entry_id, time_stamp FROM worker_timesheet
        WHERE entry_id = ? AND (time_stamp BETWEEN ? AND ?)
        GROUP BY time_stamp
      `;

      const results1 = await executeQuery(connection,querytm, [item.entry_id, newfd, newtd]);

      // Use Promise.all to ensure all sub-queries are completed
      await Promise.all(
        results1.map(async (itemtm) => {
          const querymn = `
            SELECT *, HOUR1 + HOUR2 + HOUR3 + HOUR4 + HOUR5 + HOUR6 + HOUR7 + HOUR8 + HOUR9 + HOUR10 + HOUR11 AS value_sum
            FROM worker_timesheet
            WHERE entry_id = ? AND time_stamp = ?
          `;

          const results2 = await executeQuery(connection,querymn, [itemtm.entry_id, itemtm.time_stamp]);

          results2.forEach((itemmn) => {
            let count = 0;

            for (let j = 1; j <= 11; j++) {
              const str = 'HOUR' + j;
              if (itemmn[str] > 0) {
                count++;
              }
            }

            // Ensure itemmn.actual_target is defined and a valid number
            if (typeof itemmn.actual_target === 'number') {
              // Calculate targettm for the current item and accumulate it in totalTargetm
              targettm = itemmn.actual_target * count;
              totalTargetm += targettm;

              // Accumulate value_sum in totalvalue_sum
              totalvalue_sum += itemmn.value_sum;
            }
            //console.log('-----------')
          });
        })
      );

      const tvalue_sum = totalvalue_sum;
      const totalTarget = totalTargetm;
      const e = (tvalue_sum / totalTarget) * 100;
      const eff = e.toFixed(2);

      responseData.items.push({
        worker: worker,
        entry_id: entry,
        regg: regg,
        diff: diff,
        totalTarget: totalTarget,
        tvalue_sum: tvalue_sum,
        eff: eff,
        
      });
    });

    await Promise.all(resultPromises);
    res.send(responseData);
    console.log(responseData);
  } catch (error) {
    console.error('Error executing MySQL query:', error);
    res.status(500).send('Internal Server Error');
  } finally {
    if (connection) {
      connection.end();
    }
  }
});




//Productivity Report

/////////////Productivity Search data//////////////////
/**
 * @swagger
 * /nbraid/getfilteredproductivity:
 *   post:
 *     summary: Get Filtered Productivity Data
 *     description: Retrieves filtered productivity data based on the specified date and line number.
 *     tags:
 *       - Productivity
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             properties:
 *               fromdate:
 *                 type: string
 *                 format: date
 *                 description: Start date in the format "DD-MM-YYYY".
 *                 example: "01-01-2024"
 *               line_no:
 *                 type: string
 *                 description: Line number.
 *                 example: "1"
 *     responses:
 *       200:
 *         description: Successful response with filtered productivity data.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 section:
 *                   type: array
 *                   items:
 *                     type: string
 *                   description: List of sections.
 *                   example: ["Section A", "Section B"]
 *                 items:
 *                   type: array
 *                   items:
 *                     type: object
 *                     properties:
 *                       lines:
 *                         type: string
 *                         description: Line number.
 *                         example: "1"
 *                       section_data:
 *                         type: array
 *                         items:
 *                           type: integer
 *                         description: List of section data values.
 *                         example: [5, 10]
 *                       totals:
 *                         type: array
 *                         items:
 *                           type: object
 *                           properties:
 *                             totalData:
 *                               type: string
 *                               description: Total data description.
 *                               example: "Total ManPower"
 *                       tm:
 *                         type: integer
 *                         description: Total manpower.
 *                         example: 15
 *                       pp:
 *                         type: number
 *                         description: Total production FG output.
 *                         example: 100
 *                       eff:
 *                         type: string
 *                         description: Efficiency percentage.
 *                         example: "6.67"
 *       500:
 *         description: Internal Server Error.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: "Database error"
 *
 * @function
 * @name getFilteredProductivity
 * @memberof module:Routes/Productivity
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with the database query.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
app.post('/nbraid/getfilteredproductivity',authenticateJWT , async (req, res) => {
  const fdate = req.body.fromdate;
  const dateObj = new Date(fdate);
  const day = dateObj.getDate().toString().padStart(2, '0');
  const month = (dateObj.getMonth() + 1).toString().padStart(2, '0');
  const year = dateObj.getFullYear();
  const fd = `${day}-${month}-${year}`;

  //const fd = new Date(fdate).toLocaleDateString('en-US', { day: '2-digit', month: '2-digit', year: 'numeric' }).replace(/\//g, '-');;
  const line = req.body.line_no;

  let query3;
  let query4;

  if (line === '2') {
    query3 = `SELECT line FROM worker_timesheet WHERE line LIKE 'EB%' AND date_time = '${fd}' GROUP BY line`;
    query4 = `SELECT * FROM worker_timesheet WHERE line LIKE 'EB%' AND date_time = '${fd}' GROUP BY section`;
  } else {
    query3 = `SELECT line FROM worker_timesheet WHERE line NOT LIKE 'EB%' AND date_time = '${fd}' GROUP BY line`;
    query4 = `SELECT * FROM worker_timesheet WHERE line NOT LIKE 'EB%' AND date_time = '${fd}' GROUP BY section`;
  }

  let connection;

  try {
    connection = await getPoolConnection();
    const timesheet = await executeQuery(connection,query3);
    const timesheet1 = await executeQuery(connection,query4);

    const sections = [];
    for (const itemk of timesheet1) {
      const sectionNameQuery = `SELECT section_name FROM section WHERE id = ${itemk.section}`;
      const result = await executeQuery(connection,sectionNameQuery);
      if (result.length > 0) {
   
        sections.push(result[0].section_name);
      }
    }

    const totals = [];
    const totalData = ["Total ManPower", "Total Productionb FG OUTPUT", "PPP"];
    for (const data of totalData) {
      totals.push({ totalData: data });
    }

    const responseData = {
      section: sections,
      items:[],
    }


    // Use Promise.all to execute the mapping function in parallel
    await Promise.all(
      timesheet.map(async (item) => {
        let l = 0;
        const section_data =[];
        for (const item1 of timesheet1) {
          const section_name = item.section_name; // Use the correct syntax to access section_name
          //const values = [];
          const date = fd || new Date().toLocaleDateString('en-US', { day: '2-digit', month: '2-digit', year: 'numeric' });
          const queryk = `SELECT id FROM worker_timesheet WHERE date_time = '${date}' AND line = '${item.line}' AND section = '${item1.section}' GROUP BY date_time, line, section, entry_id`;
          const result = await executeQuery(connection,queryk);
          console.log(queryk);

          if (result) {
            const k = result.length;
            console.log(k,'length of k')
            l += k;
            section_data.push(k);
            console.log(k,"--'''''''--");
          }
          //section_data = values;
        }
        console.log(section_data,"section data");
        if (fd) {
          console.log("ffdate",fd);
          const queryfg = `SELECT SUM(fg_output) as tar FROM fg_details WHERE date_time = '${fd}' AND line = '${item.line}' GROUP BY line`;
          const fgResult = await executeQuery(connection,queryfg);
          
            console.log('--++--');
            const fgproduct = fgResult.tar || 0;
            console.log(fgproduct,'Division',l)
            const pp = fgproduct / l;
            const eff = isFinite(pp) ? pp.toFixed(2) : '0';

            responseData.items.push({
              lines: item.line,
              section_data: section_data,
              totals: totals,
              tm: l,
              pp: fgproduct,
              eff: eff,
            });
            console.log(responseData,"response")
          
        }
      })
    );

    res.json(responseData);
    //console.log(responseData,"======______")
  } catch (error) {
    console.error('Error:', error);
    res.status(500).json({ error: 'Database error' });
  } finally {
    if (connection) {
      connection.release();
    }
  }
});


//Get productivity Default data
/**
 * @swagger
 * /Nbraid/getfilteredproductivitydefault:
 *   get:
 *     summary: Get Filtered Default Productivity Data
 *     description: Retrieves filtered default productivity data based on the current date.
 *     tags:
 *       - Productivity
 *     responses:
 *       200:
 *         description: Successful response with filtered default productivity data.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 section:
 *                   type: array
 *                   items:
 *                     type: string
 *                   description: List of sections.
 *                   example: ["Section A", "Section B"]
 *                 items:
 *                   type: array
 *                   items:
 *                     type: object
 *                     properties:
 *                       lines:
 *                         type: string
 *                         description: Line number.
 *                         example: "1"
 *                       section_data:
 *                         type: array
 *                         items:
 *                           type: integer
 *                         description: List of section data values.
 *                         example: [5, 10]
 *                       totals:
 *                         type: array
 *                         items:
 *                           type: object
 *                           properties:
 *                             totalData:
 *                               type: string
 *                               description: Total data description.
 *                               example: "Total ManPower"
 *                       tm:
 *                         type: integer
 *                         description: Total manpower.
 *                         example: 15
 *                       pp:
 *                         type: number
 *                         description: Total production FG output.
 *                         example: 100
 *                       eff:
 *                         type: string
 *                         description: Efficiency percentage.
 *                         example: "6.67"
 *       500:
 *         description: Internal Server Error.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: "Database error"
 *
 * @function
 * @name getFilteredProductivityDefault
 * @memberof module:Routes/Productivity
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with the database query.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
app.get('/Nbraid/getfilteredproductivitydefault',authenticateJWT , async (req, res) => {
  const date = new Date().toLocaleDateString('en-GB', { timeZone: 'Africa/Lagos' });
  const parts = date.split('/');
  const day = parts[0].padStart(2, '0');
  const month = parts[1].padStart(2, '0');
  const year = parts[2];
  const currentMonth = `${month}-${year}`;
  const td = `${day}-${month}-${year}`;

  let query3;
  let query4;

  
    query3 = `SELECT line FROM worker_timesheet WHERE line NOT LIKE 'EB%' AND date_time = '${td}' GROUP BY line`;
    query4 = `SELECT * FROM worker_timesheet WHERE line NOT LIKE 'EB%' AND date_time = '${td}' GROUP BY section`;
  let connection;

  try {
    connection = await getPoolConnection();
    const timesheet = await executeQuery(connection,query3);
    const timesheet1 = await executeQuery(connection,query4);

    const sections = [];
    for (const itemk of timesheet1) {
      const sectionNameQuery = `SELECT section_name FROM section WHERE id = ${itemk.section}`;
      const result = await executeQuery(connection,sectionNameQuery);
      if (result.length > 0) {
   
        sections.push(result[0].section_name);
      }
    }

    const totals = [];
    const totalData = ["Total ManPower", "Total Productionb FG OUTPUT", "PPP"];
    for (const data of totalData) {
      totals.push({ totalData: data });
    }

    const responseData = {
      section: sections,
      items:[],
    }

    // Use Promise.all to execute the mapping function in parallel
    await Promise.all(
      timesheet.map(async (item) => {
        let l = 0;
        const section_data =[];
        for (const item1 of timesheet1) {
          const section_name = item.section_name; // Use the correct syntax to access section_name
          //const values = [];
          const date = td || new Date().toLocaleDateString('en-US', { day: '2-digit', month: '2-digit', year: 'numeric' });
          const queryk = `SELECT id FROM worker_timesheet WHERE date_time = '${date}' AND line = '${item.line}' AND section = '${item1.section}' GROUP BY date_time, line, section, entry_id`;
          const result = await executeQuery(connection,queryk);
          //console.log(queryk);

          if (result) {
            const k = result.length;
            l += k;
            section_data.push(k);
            //console.log(k,"--'''''''--");
          }
          //section_data = values;
        }
        //console.log(section_data,"section data");
        if (td) {
          
          const queryfg = `SELECT SUM(fg_output) as tar FROM fg_details WHERE date_time = '${td}' AND line = '${item.line}' GROUP BY line`;
          const fgResult = await executeQuery(connection,queryfg);
          console.log(item.line,td,'----');
   
            console.log('--++--');
            const fgproduct = fgResult.tar || 0;
            console.log(fgproduct,'Division',l)
            const pp = fgproduct / l;
            const eff = isFinite(pp) ? pp.toFixed(2) : '0';

            responseData.items.push({
              lines: item.line,
              
              section_data: section_data,
              totals: totals,
              tm: l,
              pp: fgproduct,
              eff: eff,
            });
            console.log(responseData,"--------------------")
          
        }
      })
    );

    res.json(responseData);
    console.log(responseData,"======")
  } catch (error) {
    console.error('Error:', error);
    res.status(500).json({ error: 'Database error' });
  } finally {
    if (connection) {
      connection.release();
    }
  }
});


//Employee Timesheet Data

// filter data fetch
/**
 * @swagger
 * /getempreportData:
 *   post:
 *     summary: Get Employee Report Data
 *     description: Retrieves employee report data based on the provided filters.
 *     tags:
 *       - Employee
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             properties:
 *               product_id:
 *                 type: string
 *                 description: Product ID.
 *               line_no:
 *                 type: string
 *                 description: Line number.
 *               section:
 *                 type: string
 *                 description: Section name.
 *               shift:
 *                 type: string
 *                 description: Shift name.
 *               site:
 *                 type: string
 *                 description: Site name.
 *               fromdate:
 *                 type: string
 *                 format: date
 *                 description: Start date (YYYY-MM-DD).
 *               todate:
 *                 type: string
 *                 format: date
 *                 description: End date (YYYY-MM-DD).
 *     responses:
 *       200:
 *         description: Successful response with employee report data.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 timesheet:
 *                   type: array
 *                   items:
 *                     type: object
 *                     properties:
 *                       entry_id:
 *                         type: string
 *                         description: Entry ID.
 *                       operator_name:
 *                         type: string
 *                         description: Operator name.
 *                       item_description:
 *                         type: string
 *                         description: Description of the item.
 *                       line:
 *                         type: string
 *                         description: Line number.
 *                       section_name:
 *                         type: string
 *                         description: Section name.
 *                       regg:
 *                         type: string
 *                         description: Registration date of the operator.
 *                       HOUR1:
 *                         type: number
 *                         description: Work hours for HOUR1.
 *                       value_sum:
 *                         type: number
 *                         description: Sum of work hours for all hours.
 *                   description: Array containing employee report data.
 *                 fdate:
 *                   type: string
 *                   description: Formatted start date (DD-MM-YYYY).
 *                 tdate:
 *                   type: string
 *                   description: Formatted end date (DD-MM-YYYY).
 *                 operatorname:
 *                   type: string
 *                   description: Operator name.
 *                 product:
 *                   type: string
 *                   description: Description of the product.
 *                 line:
 *                   type: string
 *                   description: Line number.
 *                 section:
 *                   type: string
 *                   description: Section name.
 *       500:
 *         description: Internal Server Error.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: "Internal Server Error"
 *
 * @function
 * @name getEmployeeReportData
 * @memberof module:Routes/Employee
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with the database query.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
app.post('/getempreportData',authenticateJWT , async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    var product_name = req.body.product_id;
    var line_no = req.body.line_no;
    var section = req.body.section;
    var shift = req.body.shift;
    var site = req.body.site;
    const fromdate = req.body.fromdate;
    const fdParts = fromdate.split('-');
    const fd = `${fdParts[2]}-${fdParts[1]}-${fdParts[0]}`;
    
    const todate = req.body.todate;
    const tdParts = todate.split('-');
    const td = `${tdParts[2]}-${tdParts[1]}-${tdParts[0]}`;
    
    const dateObj = new Date(fromdate);
    const day = dateObj.getDate().toString().padStart(2, '0');
    const month = (dateObj.getMonth() + 1).toString().padStart(2, '0');
    const year = dateObj.getFullYear();
    
    const convertedDate = `${day}-${month}-${year}`;
    
    const dateObj1 = new Date(todate);
    const day1 = dateObj1.getDate().toString().padStart(2, '0');
    const month1 = (dateObj1.getMonth() + 1).toString().padStart(2, '0');
    const year1 = dateObj1.getFullYear();
    
    const convertedDate1 = `${day1}-${month1}-${year1}`;
    console.log('Converted:', convertedDate);
    console.log('Converted2:', convertedDate1);
    
    const fd2 = Math.floor(new Date(fromdate).getTime() / 1000);
    const td1 = Math.floor(new Date(todate).getTime() / 1000);
    const fd1 = Math.floor(new Date(fd2 * 1000).setDate(new Date(fd2 * 1000).getDate() - 1) / 1000);
    
    var newfd = fd1;
    var newtd = td1;
    
    // Log the received data
    console.log('Received data:');
    console.log('Product Name:', product_name);
    console.log('Line No:', line_no);
    console.log('Section:', section);
    console.log('Shift:', shift);
    console.log('From Date:', fd);
    console.log('To Date:', td);
    console.log('Converted Timestamp:', newfd);
    console.log('Converted Timestamp:', newtd);
      
    let whereConditions = [];

    if (product_name !== '') {
      whereConditions.push(`worker_timesheet.product_name = '${product_name}'`);
    }
    if (line_no !== '') {
      whereConditions.push(`worker_timesheet.line = '${line_no}'`);
    }
    if (section !== '') {
      whereConditions.push(`worker_timesheet.section = '${section}'`);
    }
    if (shift !== '') {
      whereConditions.push(`worker_timesheet.shift = '${shift}'`);
    }
    if (site !== '') {
      whereConditions.push(`worker_timesheet.site = '${site}'`);
    }
    whereConditions.push(`worker_timesheet.time_stamp BETWEEN '${newfd}' AND '${newtd}'`);
  
    const whereClause = whereConditions.join(' AND ');
  
  
    const query = `
      SELECT  worker_timesheet.*,
      item_masterr.item_description,
      section.section_name,
        HOUR1, HOUR2, HOUR3, HOUR4, HOUR5, HOUR6, HOUR7, HOUR8, HOUR9, HOUR10, HOUR11,
        HOUR1 + HOUR2 + HOUR3 + HOUR4 + HOUR5 + HOUR6 + HOUR7 + HOUR8 + HOUR9 + HOUR10 + HOUR11 AS value_sum
      FROM worker_timesheet
      LEFT JOIN item_masterr ON item_masterr.id = worker_timesheet.product_name
      LEFT JOIN section ON section.id = worker_timesheet.section
      WHERE ${whereClause}
      GROUP BY
      worker_timesheet.date_time,
      worker_timesheet.entry_id,
      worker_timesheet.product_name,
      worker_timesheet.section,
      worker_timesheet.shift,
      worker_timesheet.line
    `;

   // console.log('query:', query);
    
    const results = await new Promise((resolve, reject) => {
      db.query(query, async (error, results) => {
        if (error) {
          console.error('Error executing MySQL query: ', error);
          return reject(error);
        }

        const reggMap = {}; // Create a map to associate regg with entry IDs

        for (const row of results) {
          const entryid = row.entry_id;
          const site = row.site;
         

          let query1;
          let ss;
          if (site === 'both') {
            // Check the 'employees_ota' table first
            query1 = await new Promise((resolveQuery1, rejectQuery1) => {
              db.query(`SELECT * FROM employees_ota WHERE entryid='${entryid}'`, (error, results) => {
                if (error) {
                  console.error('MySQL Error:', error);
                  res.status(500).json({ error: 'Internal Server Error' });
                  return rejectQuery1(error);
                }

                if (results.length > 0) {
                  resolveQuery1(results[0]);
                } else {
                  // If no result is found in 'employees_ota', check 'geopos_employees' table
                  db.query(`SELECT * FROM geopos_employees WHERE entryid='${entryid}'`, (error, results2) => {
                    if (error) {
                      console.error('MySQL Error:', error);
                      res.status(500).json({ error: 'Internal Server Error' });
                      return rejectQuery1(error);
                    }

                    if (results2.length > 0) {
                      resolveQuery1(results2[0]);
                    } else {
                      resolveQuery1(null);
                    }
                  });
                }
              });
            });
          } else if (site === 'ikeja') {
            query1 = await new Promise((resolveQuery1, rejectQuery1) => {
              db.query(`SELECT * FROM geopos_employees WHERE entryid='${entryid}'`, (error, results) => {
                if (error) {
                  console.error('MySQL Error:', error);
                  res.status(500).json({ error: 'Internal Server Error' });
                  return rejectQuery1(error);
                }

                if (results.length > 0) {
                  resolveQuery1(results[0]);
                } else {
                  resolveQuery1(null);
                }
              });
            });
          } else if (site === 'ota') {
            query1 = await new Promise((resolveQuery1, rejectQuery1) => {
              db.query(`SELECT * FROM employees_ota WHERE entryid='${entryid}'`, (error, results) => {
                if (error) {
                  console.error('MySQL Error:', error);
                  res.status(500).json({ error: 'Internal Server Error' });
                  return rejectQuery1(error);
                }

                if (results.length > 0) {
                  resolveQuery1(results[0]);
                } else {
                  resolveQuery1(null);
                }
              });
            });
          } else {
            query1 = null;
          }

          if (query1) {
           
            const reg = query1.joindate;
            const regg = typeof reg === 'string' ? reg.split(' ')[0] : null;
            //const regg = reg.split(' ')[0];
            
            //console.log('Received reg:', regg);

            // Store regg in the reggMap with entryid as the key
            reggMap[entryid] = regg;
          } else {
            // Handle the case where no results were found
          }
          
        }

        // Iterate through the timesheet results and add regg to each result object
        for (const row of results) {
          const entryid = row.entry_id;
          row.regg = reggMap[entryid]; // Add regg to the timesheet result object
        }

        resolve(results);
      });
    });

    // Extract entry_ids from the first query results
    const entryIds = results.map((result) => result.entry_id);
    const query2 = `
      SELECT * FROM employees_ota WHERE entryid IN ('${entryIds.join("','")}')
    `;
    
    const results2 = await new Promise((resolve, reject) => {
      db.query(query2, (error2, results2) => {
        if (error2) {
          console.error('Error executing second MySQL query: ', error2);
          return reject(error2);
        }
        resolve(results2);
      });
    });
    
    // Extract product, line, and section from the timesheet results
    const productFromTimesheet = results.length > 0 ? results[0].item_description : null;
    const lineFromTimesheet = results.length > 0 ? results[0].line : null;
    const sectionFromTimesheet = results.length > 0 ? results[0].section_name : null;

    // Modify the data object
    const data = {
      timesheet: results,
      fdate: convertedDate,
      tdate: convertedDate1,
      operatorname: results.length > 0 ? results[0].operator_name : null
    };

    // Conditionally include product, line, and section in the response
    if (product_name) {
      data.product = productFromTimesheet;
    }
    if (line_no) {
      data.line = lineFromTimesheet;
    }
    if (section) {
      data.section = sectionFromTimesheet;
    }

    // Send the modified data object as a response
    res.json(data);
  } catch (error) {
    console.error('Error:', error);
    return res.status(500).json({ error: 'Internal Server Error' });
  }
});
 

//default data fetch
/**
 * @swagger
 * /gettodayempreportData:
 *   get:
 *     summary: Get Today's Employee Report Data
 *     description: Retrieves today's employee report data.
 *     tags:
 *       - Employee
 *     responses:
 *       200:
 *         description: Successful response with today's employee report data.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 timesheet:
 *                   type: array
 *                   items:
 *                     type: object
 *                     properties:
 *                       entry_id:
 *                         type: string
 *                         description: Entry ID.
 *                       operator_name:
 *                         type: string
 *                         description: Operator name.
 *                       item_description:
 *                         type: string
 *                         description: Description of the item.
 *                       line:
 *                         type: string
 *                         description: Line number.
 *                       section_name:
 *                         type: string
 *                         description: Section name.
 *                       regg:
 *                         type: string
 *                         description: Registration date of the operator.
 *                       HOUR1:
 *                         type: number
 *                         description: Work hours for HOUR1.
 *                       value_sum:
 *                         type: number
 *                         description: Sum of work hours for all hours.
 *                   description: Array containing today's employee report data.
 *                 date:
 *                   type: string
 *                   description: Formatted today's date (DD-MM-YYYY).
 *       500:
 *         description: Internal Server Error.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: "Internal Server Error"
 *
 * @function
 * @name getTodayEmployeeReportData
 * @memberof module:Routes/Employee
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with the database query.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
app.get('/gettodayempreportData', authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    const date = new Date().toLocaleDateString('en-GB', { timeZone: 'Africa/Lagos' });
    const parts = date.split('/');
    const formattedDay = parts[0].padStart(2, '0');
    const formattedMonth = parts[1].padStart(2, '0');
    const year = parts[2];
    const date1 = `${formattedDay}-${formattedMonth}-${year}`;

    const query = `
      SELECT  worker_timesheet.*,
      item_masterr.item_description,
      section.section_name,
      HOUR1, HOUR2, HOUR3, HOUR4, HOUR5, HOUR6, HOUR7, HOUR8, HOUR9, HOUR10, HOUR11,
      HOUR1 + HOUR2 + HOUR3 + HOUR4 + HOUR5 + HOUR6 + HOUR7 + HOUR8 + HOUR9 + HOUR10 + HOUR11 AS value_sum
      FROM worker_timesheet
      LEFT JOIN item_masterr ON item_masterr.id = worker_timesheet.product_name
      LEFT JOIN section ON section.id = worker_timesheet.section
      WHERE date_time = ?
      GROUP BY
       worker_timesheet.date_time,
      worker_timesheet.entry_id,
      worker_timesheet.product_name,
      worker_timesheet.section,
      worker_timesheet.shift,
      worker_timesheet.line
    `;

    const results = await executeQuery(connection,query, [date1]);

    const reggMap = {}; // Create a map to associate regg with entry IDs

    for (const row of results) {
      const entryid = row.entry_id;
      const site = row.site;
      const date_time = row.date_time;

      console.log('Entry ID:', entryid);
      console.log('Site:', site);
      console.log('Date Time:', date_time);

      let query1;
      let ss;
      if (site === 'both') {
        // Check the 'employees_ota' table first
        query1 = await executeQuery(connection,`SELECT * FROM employees_ota WHERE entryid='${entryid}'`);

        if (query1.length === 0) {
          // If no result is found in 'employees_ota', check 'geopos_employees' table
          query1 = await executeQuery(connection,`SELECT * FROM geopos_employees WHERE entryid='${entryid}'`);
        }
      } else if (site === 'ikeja') {
        query1 = await executeQuery(connection,`SELECT * FROM geopos_employees WHERE entryid='${entryid}'`);
      } else if (site === 'ota') {
        query1 = await executeQuery(connection,`SELECT * FROM employees_ota WHERE entryid='${entryid}'`);
      }

      if (query1) {
        const reg = query1[0]?.joindate;
        console.log('Received reg:', reg);
        const regg = reg ? reg.split(' ')[0] : 'N/A'; // 'N/A' or any other default value you want to use
        
        // Store regg in the reggMap with entryid as the key
        reggMap[entryid] = regg;
      }
    }

    for (const row of results) {
      const entryid = row.entry_id;
      row.regg = reggMap[entryid]; // Add regg to the timesheet result object
    }

    const data = {
      timesheet: results,
      date: date1,
    };
    
    res.json(data);
  } catch (error) {
    console.error('Error:', error);
    return res.status(500).json({ error: 'Internal Server Error' });
  } finally {
    if (connection) {
      connection.release();      
    }
  }
});




//PPP Report 

//Default data fetch
/**
 * @swagger
 * /gettodaypppreportData:
 *   get:
 *     summary: Get Today's PPP Report Data
 *     description: Retrieves today's PPP (Production, Productivity, and Performance) report data.
 *     tags:
 *       - PPP
 *     responses:
 *       200:
 *         description: Successful response with today's PPP report data.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 timesheet:
 *                   type: array
 *                   items:
 *                     type: object
 *                     properties:
 *                       entry_id:
 *                         type: string
 *                         description: Entry ID.
 *                       operator_name:
 *                         type: string
 *                         description: Operator name.
 *                       item_description:
 *                         type: string
 *                         description: Description of the item.
 *                       line:
 *                         type: string
 *                         description: Line number.
 *                       shift:
 *                         type: string
 *                         description: Shift of the operator.
 *                       site:
 *                         type: string
 *                         description: Site of the operator.
 *                       date_time:
 *                         type: string
 *                         description: Date and time of the entry.
 *                   description: Array containing today's PPP report data.
 *                 date:
 *                   type: string
 *                   description: Formatted today's date (DD-MM-YYYY).
 *       500:
 *         description: Internal Server Error.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: "Internal Server Error"
 *
 * @function
 * @name getTodayPPPReportData
 * @memberof module:Routes/PPP
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with the database query.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
app.get('/gettodaypppreportData', authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    const date = new Date().toLocaleDateString('en-GB', { timeZone: 'Africa/Lagos' });
    const parts = date.split('/');
    const formattedDay = parts[0].padStart(2, '0');
    const formattedMonth = parts[1].padStart(2, '0');
    const year = parts[2];
    const date1 = `${formattedDay}-${formattedMonth}-${year}`;

    const query = `
      SELECT
        worker_timesheet.*,
        item_masterr.item_description
      FROM
        worker_timesheet
        LEFT JOIN item_masterr ON item_masterr.id = worker_timesheet.product_name
      WHERE
        date_time = ?
      GROUP BY 
        worker_timesheet.product_name,
        worker_timesheet.date_time,
        worker_timesheet.shift,
        worker_timesheet.site,
        worker_timesheet.line
    `;

    const results = await executeQuery(connection,query, [date1]);

    res.json({
      timesheet: results,
      date: date1,
    });
  } catch (error) {
    console.error('Error:', error);
    return res.status(500).json({ error: 'Internal Server Error' });
  } finally {
    if (connection) {
      connection.release();
    }
  }
});


// Define the route for the getpppreportData API
/**
 * @swagger
 * /getpppreportData:
 *   post:
 *     summary: Get PPP Report Data
 *     description: Retrieves PPP (Production, Productivity, and Performance) report data based on provided parameters.
 *     tags:
 *       - PPP
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             properties:
 *               fromdate:
 *                 type: string
 *                 format: date
 *                 description: Start date for the report data (YYYY-MM-DD).
 *               todate:
 *                 type: string
 *                 format: date
 *                 description: End date for the report data (YYYY-MM-DD).
 *               shift:
 *                 type: string
 *                 description: Shift for the report data.
 *               site:
 *                 type: string
 *                 description: Site for the report data.
 *             required:
 *               - fromdate
 *               - todate
 *     responses:
 *       200:
 *         description: Successful response with PPP report data.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 timesheet:
 *                   type: array
 *                   items:
 *                     type: object
 *                     properties:
 *                       entry_id:
 *                         type: string
 *                         description: Entry ID.
 *                       operator_name:
 *                         type: string
 *                         description: Operator name.
 *                       item_description:
 *                         type: string
 *                         description: Description of the item.
 *                       line:
 *                         type: string
 *                         description: Line number.
 *                       shift:
 *                         type: string
 *                         description: Shift of the operator.
 *                       site:
 *                         type: string
 *                         description: Site of the operator.
 *                       date_time:
 *                         type: string
 *                         description: Date and time of the entry.
 *                   description: Array containing PPP report data.
 *                 fromdate:
 *                   type: string
 *                   description: Start date for the report data (YYYY-MM-DD).
 *                 todate:
 *                   type: string
 *                   description: End date for the report data (YYYY-MM-DD).
 *                 fromdatetimestamp:
 *                   type: integer
 *                   description: Timestamp of the start date.
 *                 todatetimestamp:
 *                   type: integer
 *                   description: Timestamp of the end date.
 *                 fromdate1:
 *                   type: string
 *                   description: Formatted start date (YYYY-MM-DD).
 *                 todate1:
 *                   type: string
 *                   description: Formatted end date (YYYY-MM-DD).
 *                 site:
 *                   type: string
 *                   description: Site for the report data.
 *                 shift:
 *                   type: string
 *                   description: Shift for the report data.
 *       500:
 *         description: Internal Server Error.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: "Internal Server Error"
 *
 * @function
 * @name getPPPReportData
 * @memberof module:Routes/PPP
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with the database query.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
app.post('/getpppreportData', authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    var fromdate = new Date(req.body.fromdate); // Convert to Date object
    var todate = new Date(req.body.todate); // Convert to Date object
    var shift = req.body.shift;
    var site = req.body.site;

    const newfromdate = `${fromdate.getFullYear()}-${(fromdate.getMonth() + 1).toString().padStart(2, '0')}-${fromdate.getDate().toString().padStart(2, '0')}`;
    const newtodate = `${todate.getFullYear()}-${(todate.getMonth() + 1).toString().padStart(2, '0')}-${todate.getDate().toString().padStart(2, '0')}`;

    const timestampfromdate = Math.floor(fromdate.getTime() / 1000);
    const timestamptodate = Math.floor(todate.getTime() / 1000);

    const timestampfromdate1 = Math.floor(new Date(timestampfromdate * 1000).setDate(new Date(timestampfromdate * 1000).getDate() - 1) / 1000);

    console.log('Received data:');
    console.log('From Date:', newfromdate);
    console.log('To Date:', newtodate);
    console.log('Timestamp From Date:', timestampfromdate);
    console.log('Timestamp To Date:', timestamptodate);

    let whereConditions = [
      `worker_timesheet.time_stamp BETWEEN '${timestampfromdate1}' AND '${timestamptodate}'`
    ];

    if (shift !== '') {
      whereConditions.push(`worker_timesheet.shift = '${shift}'`);
    }
    if (site !== '') {
      whereConditions.push(`worker_timesheet.site = '${site}'`);
    }

    const whereClause = whereConditions.join(' AND ');

    const query = `
      SELECT
        worker_timesheet.*,
        item_masterr.item_description
      FROM
        worker_timesheet
        LEFT JOIN item_masterr ON item_masterr.id = worker_timesheet.product_name
      WHERE
        ${whereClause}
      GROUP BY 
        worker_timesheet.product_name,
        worker_timesheet.date_time,
        worker_timesheet.shift,
        worker_timesheet.site,
        worker_timesheet.line
    `;

    console.log('query:', query);

    const results = await executeQuery(connection,query);

    const data = {
      timesheet: results,
      fromdate: fromdate,
      todate: todate,
      fromdatetimestamp: timestampfromdate,
      todatetimestamp: timestamptodate,
      fromdate1: newfromdate,
      todate1: newtodate,
      site: site,
      shift: shift,
    };

    res.json(data);
  } catch (error) {
    console.error('Error:', error);
    return res.status(500).json({ error: 'Internal Server Error' });
  } finally {
    if (connection) {
      connection.release();
    }
  }
});


// Endpoint to handle the POST request for sum
/**
 * @swagger
 * /sum:
 *   post:
 *     summary: Calculate Sum and Average
 *     description: Calculates the sum and average of fg_output from the fg_details table and the number of entries from the worker_timesheet table based on provided parameters.
 *     tags:
 *       - Calculation
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             properties:
 *               timestamp1:
 *                 type: integer
 *                 description: The first timestamp parameter.
 *               timestamp2:
 *                 type: integer
 *                 description: The second timestamp parameter.
 *               product_name:
 *                 type: string
 *                 description: The product name.
 *               date_time:
 *                 type: string
 *                 description: The date and time.
 *               shift:
 *                 type: string
 *                 description: The shift.
 *               site:
 *                 type: string
 *                 description: The site.
 *               line:
 *                 type: string
 *                 description: The line.
 *             required:
 *               - timestamp1
 *               - timestamp2
 *               - product_name
 *               - date_time
 *               - shift
 *               - site
 *               - line
 *     responses:
 *       200:
 *         description: Successful response with sum and average calculated.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 sum:
 *                   type: number
 *                   description: The sum calculated from fg_output.
 *                 avg:
 *                   type: integer
 *                   description: The average number of entries from worker_timesheet.
 *       500:
 *         description: Internal Server Error.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: "Internal Server Error"
 *
 * @function
 * @name calculateSumAndAverage
 * @memberof module:Routes/Calculation
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with the database query.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
app.post('/sum', authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    const timestamp1 = req.body.timestamp1;
    const timestamp2 = req.body.timestamp2;
    const product_name = req.body.product_name;
    const date_time = req.body.date_time;
    const shift = req.body.shift;
    const site = req.body.site;
    const line = req.body.line;

    const query1 = `SELECT SUM(a.tar) as res 
                    FROM (
                      SELECT SUM(fg_output) as tar
                      FROM fg_details
                      WHERE date_time = '${date_time}' AND product_name = '${product_name}' AND site = '${site}' AND shift = '${shift}' AND line = '${line}'
                      GROUP BY product_name, time_stamp, site, shift, line
                    ) a`;

    const query2 = `SELECT *
                    FROM worker_timesheet
                    WHERE date_time = '${date_time}' AND product_name = '${product_name}' AND site = '${site}' AND shift = '${shift}' AND line = '${line}'
                    GROUP BY product_name, time_stamp, entry_id, site, shift, line`;

    const results1 = await executeQuery(connection,query1);
    const results2 = await executeQuery(connection,query2);

    const sum = results1[0].res;
    const avg = results2.length;

    res.send({ sum: sum, avg: avg });
  } catch (error) {
    console.error('Error:', error);
    return res.status(500).json({ error: 'Internal Server Error' });
  } finally {
    if (connection) {
      connection.release();
    }
  }
});



//FG Output Report

//default fgoutput
/**
 * @swagger
 * /get_fgoutput_default:
 *   get:
 *     summary: Get FG Output with Worker Count
 *     description: Retrieves FG output data from the fg_details table for the current date and calculates the number of workers for each entry.
 *     tags:
 *       - FG Output
 *     responses:
 *       200:
 *         description: Successful response with FG output and worker count.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 timesheet:
 *                   type: array
 *                   description: An array of FG output data with worker count.
 *                   items:
 *                     type: object
 *                     properties:
 *                       entry_id:
 *                         type: string
 *                         description: The entry ID.
 *                       date_time:
 *                         type: string
 *                         description: The date and time.
 *                       product_name:
 *                         type: string
 *                         description: The product name.
 *                       line:
 *                         type: string
 *                         description: The line.
 *                       shift:
 *                         type: string
 *                         description: The shift.
 *                       site:
 *                         type: string
 *                         description: The site.
 *                       fg_output:
 *                         type: number
 *                         description: The FG output.
 *                       workerCount:
 *                         type: integer
 *                         description: The number of workers for the entry.
 *                 date:
 *                   type: string
 *                   description: The current date.
 *       500:
 *         description: Internal Server Error.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: "Internal Server Error"
 *
 * @function
 * @name getFGOutputWithWorkerCount
 * @memberof module:Routes/FGOutput
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with the database query.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
app.get('/get_fgoutput_default', authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    console.log("Request received for /get_fgoutput_default");

    const date = new Date().toLocaleDateString('en-GB', { timeZone: 'Africa/Lagos' });
    const parts = date.split('/');
    const formattedDay = parts[0].padStart(2, '0');
    const formattedMonth = parts[1].padStart(2, '0');
    const year = parts[2];
    const date1 = `${formattedDay}-${formattedMonth}-${year}`;

    const query = `
      SELECT fg_details.*, item_masterr.item_description, SUM(fg_details.fg_output) as tar
      FROM fg_details
      LEFT JOIN item_masterr ON fg_details.product_name = item_masterr.id
      WHERE fg_details.date_time = ?
      GROUP BY fg_details.product_name, fg_details.line, fg_details.shift, fg_details.site, fg_details.date_time
    `;

    const results = await executeQuery(connection,query, [date1]);

    const resultsWithWorkerCount = [];

    if (results.length === 0) {
      return res.json({ timesheet: [], date: date1 });
    }

    for (const row of results) {
      try {
        const innerQuery = `SELECT * FROM worker_timesheet 
                            WHERE product_name = '${row.product_name}' 
                            AND line = '${row.line}' 
                            AND site = '${row.site}' 
                            AND shift = '${row.shift}' 
                            AND date_time = '${row.date_time}' 
                            GROUP BY entry_id`;

        const workerResults = await executeQuery(connection,innerQuery);

        const workerCount = workerResults.length;
        row.workerCount = workerCount;
        resultsWithWorkerCount.push(row);
      } catch (error) {
        console.error('Error executing inner query: ', error);
        return res.status(500).json({ error: 'Internal Server Error' });
      }
    }

    const data = {
      timesheet: resultsWithWorkerCount,
      date: date1,
    };

    res.json(data);
  } catch (error) {
    console.error('Error: ', error);
    return res.status(500).json({ error: 'Internal Server Error' });
  } finally {
    if (connection) {
      connection.release();
    }
  }
});


//filter search data
/**
 * @swagger
 * /getfgoutputreport:
 *   post:
 *     summary: Get FG Output Report
 *     description: Retrieves the FG output report based on provided parameters such as shift, site, from date, and to date.
 *     tags:
 *       - Reports
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             properties:
 *               shift:
 *                 type: string
 *                 description: The shift.
 *               site:
 *                 type: string
 *                 description: The site.
 *               fromdate:
 *                 type: string
 *                 format: date
 *                 description: The start date in YYYY-MM-DD format.
 *               todate:
 *                 type: string
 *                 format: date
 *                 description: The end date in YYYY-MM-DD format.
 *             required:
 *               - shift
 *               - site
 *               - fromdate
 *               - todate
 *     responses:
 *       200:
 *         description: Successful response with FG output report.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 timesheet:
 *                   type: array
 *                   items:
 *                     type: object
 *                     properties:
 *                       <property1>:
 *                         type: string
 *                         description: Description of property1.
 *                       <property2>:
 *                         type: string
 *                         description: Description of property2.
 *                      
 *                       workerCount:
 *                         type: integer
 *                         description: The number of workers associated with the FG output entry.
 *                 shift:
 *                   type: string
 *                   description: The shift parameter.
 *                 site:
 *                   type: string
 *                   description: The site parameter.
 *                 fdate:
 *                   type: string
 *                   description: The formatted from date.
 *                 tdate:
 *                   type: string
 *                   description: The formatted to date.
 *       500:
 *         description: Internal Server Error.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: "Internal Server Error"
 *
 * @function
 * @name getFGOutputReport
 * @memberof module:Routes/Reports
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with the database query.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
app.post('/getfgoutputreport', authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    const shift = req.body.shift;
    const site = req.body.site;
    const fromdate = req.body.fromdate;
    const todate = req.body.todate;

    // Convert dates to the desired format
    const fdParts = fromdate.split('-');
    const fd = `${fdParts[2]}-${fdParts[1]}-${fdParts[0]}`;
    const tdParts = todate.split('-');
    const td = `${tdParts[2]}-${tdParts[1]}-${tdParts[0]}`;

    const fd2 = Math.floor(new Date(fromdate).getTime() / 1000);
    const td1 = Math.floor(new Date(todate).getTime() / 1000);
    const fd1 = Math.floor(new Date(fd2 * 1000).setDate(new Date(fd2 * 1000).getDate() - 1) / 1000);

    const newfd = fd1;
    const newtd = td1;

    let whereConditions = [];

    if (shift !== '') {
      whereConditions.push(`fg_details.shift = '${shift}'`);
    }
    if (site !== '') {
      whereConditions.push(`fg_details.site = '${site}'`);
    }
    whereConditions.push(`fg_details.time_stamp BETWEEN '${newfd}' AND '${newtd}'`);

    const whereClause = whereConditions.join(' AND ');

    // Construct the SQL query
    const query = `
      SELECT 
        fg_details.*, 
        item_masterr.item_description, 
        SUM(fg_details.fg_output) AS tar
      FROM 
        fg_details
      LEFT JOIN 
        item_masterr ON fg_details.product_name = item_masterr.id
      WHERE 
        ${whereClause}
      GROUP BY 
        fg_details.product_name, 
        fg_details.line, 
        fg_details.shift, 
        fg_details.site, 
        fg_details.date_time
    `;

    console.log('Query:', query);

    // Execute the SQL query
    const results = await executeQuery(connection,query);

    if (results.length === 0) {
      const emptyResponse = {
        timesheet: [],
        shift: shift,
        site: site,
        fdate: fd,
        tdate: td,
      };

      return res.json(emptyResponse);
    }

    // Create an array to store the results with workerCount
    const resultsWithWorkerCount = [];

    // Loop through the results
    for (const row of results) {
      const innerQuery = `
        SELECT * FROM worker_timesheet 
        WHERE 
          product_name = '${row.product_name}' AND 
          line = '${row.line}' AND 
          site = '${row.site}' AND 
          shift = '${row.shift}' AND 
          date_time = '${row.date_time}' 
        GROUP BY entry_id
      `;

      // Execute the inner SQL query
      const workerResults = await executeQuery(connection,innerQuery);

      const workerCount = workerResults.length;

      // Create a new object that combines the original result and workerCount
      const resultWithWorkerCount = {
        ...row,
        workerCount,
      };

      // Push the result with workerCount to the array
      resultsWithWorkerCount.push(resultWithWorkerCount);
    }

    // Send the response
    const data = {
      timesheet: resultsWithWorkerCount,
      shift: shift,
      site: site,
      fdate: fd,
      tdate: td,
    };

    res.json(data);
  } catch (error) {
    console.error('Error executing query: ', error);
    return res.status(500).json({ error: 'Internal Server Error' });
  } finally {
    if (connection) {
      connection.release();
    }
  }
});




//Productive Manpower

//Filter data search
/**
 * @swagger
 * /gethourlossreport:
 *   post:
 *     summary: Get Hour Loss Report
 *     description: Retrieves the hour loss report based on provided parameters such as product ID, line number, from date, and to date.
 *     tags:
 *       - Reports
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             properties:
 *               product_id:
 *                 type: string
 *                 description: The product ID.
 *               line_no:
 *                 type: string
 *                 description: The line number.
 *               fromdate:
 *                 type: string
 *                 format: date
 *                 description: The start date in YYYY-MM-DD format.
 *               todate:
 *                 type: string
 *                 format: date
 *                 description: The end date in YYYY-MM-DD format.
 *             required:
 *               - product_id
 *               - line_no
 *               - fromdate
 *               - todate
 *     responses:
 *       200:
 *         description: Successful response with hour loss report.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 timesheet:
 *                   type: array
 *                   items:
 *                     type: object
 *                     properties:
 *                       <property1>:
 *                         type: string
 *                         description: Description of property1.
 *                       <property2>:
 *                         type: string
 *                         description: Description of property2.
 *                      
 *                 product:
 *                   type: string
 *                   description: The product ID parameter.
 *                 line:
 *                   type: string
 *                   description: The line number parameter.
 *                 fdate:
 *                   type: string
 *                   description: The formatted from date.
 *                 tdate:
 *                   type: string
 *                   description: The formatted to date.
 *                 operatorname:
 *                   type: string
 *                   description: The name of the operator associated with the hour loss report.
 *                 employees:
 *                   type: array
 *                   items:
 *                     type: object
 *                     properties:
 *                       <property1>:
 *                         type: string
 *                         description: Description of property1.
 *                       <property2>:
 *                         type: string
 *                         description: Description of property2.
 *                       
 *       500:
 *         description: Internal Server Error.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: "Internal Server Error"
 *
 * @function
 * @name getHourLossReport
 * @memberof module:Routes/Reports
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with the database query.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
app.post('/gethourlossreport',authenticateJWT , async (req, res) => {
  try {
    var product_name = req.body.product_id;
    var line_no = req.body.line_no;
    const fromdate = req.body.fromdate;
    const fdParts = fromdate.split('-');
    const fd = `${fdParts[2]}-${fdParts[1]}-${fdParts[0]}`;
    
    const todate = req.body.todate;
    const tdParts = todate.split('-');
    const td = `${tdParts[2]}-${tdParts[1]}-${tdParts[0]}`;
    
    const dateObj = new Date(fromdate);
    const day = dateObj.getDate().toString().padStart(2, '0');
    const month = (dateObj.getMonth() + 1).toString().padStart(2, '0');
    const year = dateObj.getFullYear();
    
    const convertedDate = `${day}-${month}-${year}`;
    
    const dateObj1 = new Date(todate);
    const day1 = dateObj1.getDate().toString().padStart(2, '0');
    const month1 = (dateObj1.getMonth() + 1).toString().padStart(2, '0');
    const year1 = dateObj1.getFullYear();
    
    const convertedDate1 = `${day1}-${month1}-${year1}`;
    console.log('Converted:', convertedDate);
    console.log('Converted2:', convertedDate1);
    
    const fd2 = Math.floor(new Date(fromdate).getTime() / 1000);
    const td1 = Math.floor(new Date(todate).getTime() / 1000);
    const fd1 = Math.floor(new Date(fd2 * 1000).setDate(new Date(fd2 * 1000).getDate() - 1) / 1000);
    
    var newfd = fd1;
    var newtd = td1;
    
    // Log the received data
    console.log('Received data:');
    console.log('Product Name:', product_name);
    console.log('Line No:', line_no);
    console.log('From Date:', fd);
    console.log('To Date:', td);
    console.log('Converted Timestamp:', newfd);
    console.log('Converted Timestamp:', newtd);
    
    let whereConditions = [];
    
    if (product_name !== '') {
      whereConditions.push(`worker_timesheet.product_name = '${product_name}'`);
    }
    if (line_no !== '') {
      whereConditions.push(`worker_timesheet.line = '${line_no}'`);
    }
    whereConditions.push(`worker_timesheet.time_stamp BETWEEN '${newfd}' AND '${newtd}'`);
    
    const whereClause = whereConditions.join(' AND ');
    
    const query = `
      SELECT worker_timesheet.*,
      item_masterr.item_description,
      section.section_name
      FROM
      worker_timesheet
      LEFT JOIN item_masterr ON item_masterr.id = worker_timesheet.product_name
      LEFT JOIN section ON section.id = worker_timesheet.section
      WHERE 
      ${whereClause}
      GROUP BY
      worker_timesheet.date_time,
      worker_timesheet.entry_id,
      worker_timesheet.product_name,
      worker_timesheet.section,
      worker_timesheet.line
    `;

    console.log('query:', query);
    
    const results = await new Promise((resolve, reject) => {
      db.query(query, async (error, results) => {
        if (error) {
          console.error('Error executing MySQL query: ', error);
          return reject(error);
        }

        const reggMap = {}; // Create a map to associate regg with entry IDs

        for (const row of results) {
          const entryid = row.entry_id;
          const site = row.site;
          const date_time = row.date_time;

          let query1;
          let ss;
          if (site === 'both') {
            // Check the 'employees_ota' table first
            query1 = await new Promise((resolveQuery1, rejectQuery1) => {
              db.query(`SELECT * FROM employees_ota WHERE entryid='${entryid}'`, (error, results) => {
                if (error) {
                  console.error('MySQL Error:', error);
                  res.status(500).json({ error: 'Internal Server Error' });
                  return rejectQuery1(error);
                }

                if (results.length > 0) {
                  resolveQuery1(results[0]);
                } else {
                  // If no result is found in 'employees_ota', check 'geopos_employees' table
                  db.query(`SELECT * FROM geopos_employees WHERE entryid='${entryid}'`, (error, results2) => {
                    if (error) {
                      console.error('MySQL Error:', error);
                      res.status(500).json({ error: 'Internal Server Error' });
                      return rejectQuery1(error);
                    }

                    if (results2.length > 0) {
                      resolveQuery1(results2[0]);
                    } else {
                      resolveQuery1(null);
                    }
                  });
                }
              });
            });
          } else if (site === 'ikeja') {
            query1 = await new Promise((resolveQuery1, rejectQuery1) => {
              db.query(`SELECT * FROM geopos_employees WHERE entryid='${entryid}'`, (error, results) => {
                if (error) {
                  console.error('MySQL Error:', error);
                  res.status(500).json({ error: 'Internal Server Error' });
                  return rejectQuery1(error);
                }

                if (results.length > 0) {
                  resolveQuery1(results[0]);
                } else {
                  resolveQuery1(null);
                }
              });
            });
          } else if (site === 'ota') {
            query1 = await new Promise((resolveQuery1, rejectQuery1) => {
              db.query(`SELECT * FROM employees_ota WHERE entryid='${entryid}'`, (error, results) => {
                if (error) {
                  console.error('MySQL Error:', error);
                  res.status(500).json({ error: 'Internal Server Error' });
                  return rejectQuery1(error);
                }

                if (results.length > 0) {
                  resolveQuery1(results[0]);
                } else {
                  resolveQuery1(null);
                }
              });
            });
          } else {
            query1 = null;
          }

          /* if (query1) {
            const reg = query1.joindate;
            const regg = reg.split(' ')[0];
            
            //console.log('Received reg:', regg);

            // Store regg in the reggMap with entryid as the key
            reggMap[entryid] = regg;
          } else {
            // Handle the case where no results were found
          } */
          if (query1) {
            // Check if the result has the expected property 'joindate'
            if ('joindate' in query1) {
              const reg = query1.joindate;
        
              // Check if reg is a string before attempting to split
              if (typeof reg === 'string') {
                const regg = reg.split(' ')[0];
                // Store regg in the reggMap with entryid as the key
                reggMap[entryid] = regg;
              } else {
                // Handle the case where reg is not a string
              }
            } else {
              // Handle the case where 'joindate' is not present in the result
            }
          } else {
            // Handle the case where no results were found
          }
          
        }

        // Iterate through the timesheet results and add regg to each result object
        for (const row of results) {
          const entryid = row.entry_id;
          //row.regg = reggMap[entryid]; // Add regg to the timesheet result object
          row.regg = reggMap[entryid] || '';
        }

        resolve(results);
      });
    });

    // Extract entry_ids from the first query results
    const entryIds = results.map((result) => result.entry_id);
    const query2 = `
      SELECT * FROM employees_ota WHERE entryid IN ('${entryIds.join("','")}')
    `;
    
    const results2 = await new Promise((resolve, reject) => {
      db.query(query2, (error2, results2) => {
        if (error2) {
          console.error('Error executing second MySQL query: ', error2);
          return reject(error2);
        }
        resolve(results2);
      });
    });
    
    const data = {
      timesheet: results,
      product: product_name,
      line: line_no,
      fdate: convertedDate,
      tdate: convertedDate1,
      operatorname: results.length > 0 ? results[0].operator_name : null,
      employees: results2,
    };
    
    res.json(data);
  } catch (error) {
    console.error('Error:', error);
    return res.status(500).json({ error: 'Internal Server Error' });
  }
});


// default data
/**
 * @swagger
 * /gethourlossreportdefault:
 *   get:
 *     summary: Get Hour Loss Report Default
 *     description: Retrieves the default hour loss report for the current date.
 *     tags:
 *       - Reports
 *     responses:
 *       200:
 *         description: Successful response with default hour loss report for the current date.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 timesheet:
 *                   type: array
 *                   items:
 *                     type: object
 *                     properties:
 *                       <property1>:
 *                         type: string
 *                         description: Description of property1.
 *                       <property2>:
 *                         type: string
 *                         description: Description of property2.
 *                       
 *                 date:
 *                   type: string
 *                   description: The current date in DD-MM-YYYY format.
 *       500:
 *         description: Internal Server Error.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: "Internal Server Error"
 *
 * @function
 * @name getHourLossReportDefault
 * @memberof module:Routes/Reports
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with the database query.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
app.get('/gethourlossreportdefault',authenticateJWT , async (req, res) => {
  try {
    const date = new Date().toLocaleDateString('en-GB', { timeZone: 'Africa/Lagos' });
    const parts = date.split('/');
    const formattedDay = parts[0].padStart(2, '0');
    const formattedMonth = parts[1].padStart(2, '0');
    const year = parts[2];
    const date1 = `${formattedDay}-${formattedMonth}-${year}`;

    // Define the SQL query
    const query = `
      SELECT worker_timesheet.*, item_masterr.item_description, section.section_name,
        SUM(worker_timesheet.HOUR1+worker_timesheet.HOUR2+worker_timesheet.HOUR3+worker_timesheet.HOUR4+
          worker_timesheet.HOUR5+worker_timesheet.HOUR6+worker_timesheet.HOUR7+worker_timesheet.HOUR8+
          worker_timesheet.HOUR9+worker_timesheet.HOUR10+worker_timesheet.HOUR11) as value_sum
      FROM worker_timesheet
      LEFT JOIN item_masterr ON item_masterr.id = worker_timesheet.product_name
      LEFT JOIN section ON section.id = worker_timesheet.section
      WHERE date_time = ?
      GROUP BY worker_timesheet.entry_id, worker_timesheet.product_name, worker_timesheet.section, worker_timesheet.date_time
    `;

    // Execute the SQL query with the current date as a parameter
    const results = await new Promise((resolve, reject) => {
      db.query(query, [date1], async (err, results) => {
        if (err) {
          console.error('Error executing MySQL query:', err);
          reject(err);
        }
        resolve(results);
      });
    });

    const reggMap = {}; // Create a map to associate regg with entry IDs

    // Iterate through the timesheet results and add regg to each result object
    for (const row of results) {
      const entryid = row.entry_id;
      const site = row.site;
      const date_time = row.date_time;

      let query1;
      let ss;
      if (site === 'both') {
        // Check the 'employees_ota' table first
        query1 = await new Promise((resolveQuery1, rejectQuery1) => {
          db.query(`SELECT * FROM employees_ota WHERE entryid='${entryid}'`, (error, results) => {
            if (error) {
              console.error('MySQL Error:', error);
              res.status(500).json({ error: 'Internal Server Error' });
              return rejectQuery1(error);
            }

            if (results.length > 0) {
              resolveQuery1(results[0]);
            } else {
              // If no result is found in 'employees_ota', check 'geopos_employees' table
              db.query(`SELECT * FROM geopos_employees WHERE entryid='${entryid}'`, (error, results2) => {
                if (error) {
                  console.error('MySQL Error:', error);
                  res.status(500).json({ error: 'Internal Server Error' });
                  return rejectQuery1(error);
                }

                if (results2.length > 0) {
                  resolveQuery1(results2[0]);
                } else {
                  resolveQuery1(null);
                }
              });
            }
          });
        });
      } else if (site === 'ikeja') {
        query1 = await new Promise((resolveQuery1, rejectQuery1) => {
          db.query(`SELECT * FROM geopos_employees WHERE entryid='${entryid}'`, (error, results) => {
            if (error) {
              console.error('MySQL Error:', error);
              res.status(500).json({ error: 'Internal Server Error' });
              return rejectQuery1(error);
            }

            if (results.length > 0) {
              resolveQuery1(results[0]);
            } else {
              resolveQuery1(null);
            }
          });
        });
      } else if (site === 'ota') {
        query1 = await new Promise((resolveQuery1, rejectQuery1) => {
          db.query(`SELECT * FROM employees_ota WHERE entryid='${entryid}'`, (error, results) => {
            if (error) {
              console.error('MySQL Error:', error);
              res.status(500).json({ error: 'Internal Server Error' });
              return rejectQuery1(error);
            }

            if (results.length > 0) {
              resolveQuery1(results[0]);
            } else {
              resolveQuery1(null);
            }
          });
        });
      } else {
        query1 = null;
      }

      /* if (query1) {
        const reg = query1.joindate;
        const regg = reg.split(' ')[0];
        
        //console.log('Received reg:', regg);

        // Store regg in the reggMap with entryid as the key
        reggMap[entryid] = regg;
      } else {
        // Handle the case where no results were found
      } */
      if (query1) {
        // Check if the result has the expected property 'joindate'
        if ('joindate' in query1) {
          const reg = query1.joindate;
    
          // Check if reg is a string before attempting to split
          if (typeof reg === 'string') {
            const regg = reg.split(' ')[0];
            // Store regg in the reggMap with entryid as the key
            reggMap[entryid] = regg;
          } else {
            // Handle the case where reg is not a string
          }
        } else {
          // Handle the case where 'joindate' is not present in the result
        }
      } else {
        // Handle the case where no results were found
      }
      
    }

    // Iterate through the timesheet results and add regg to each result object
    for (const row of results) {
      const entryid = row.entry_id;
      row.regg = reggMap[entryid] || '';
    }

    const data = {
      timesheet: results,
      date: date1,
    };

    // Respond with the query results
    res.json(data);
  } catch (error) {
    console.error('Error:', error);
    return res.status(500).json({ error: 'Internal Server Error' });
  }
});


//Worker Efficiency Report

//Get worker efficiency Default data
/**
 * @swagger
 * /get_workereff_default:
 *   get:
 *     summary: Get Worker Efficiency Default
 *     description: Retrieves the default worker efficiency report for the current date.
 *     tags:
 *       - Reports
 *     responses:
 *       200:
 *         description: Successful response with default worker efficiency report for the current date.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 timesheet:
 *                   type: array
 *                   items:
 *                     type: object
 *                     properties:
 *                       <property1>:
 *                         type: string
 *                         description: Description of property1.
 *                       <property2>:
 *                         type: string
 *                         description: Description of property2.
 *                      
 *                 date:
 *                   type: string
 *                   description: The current date in DD-MM-YYYY format.
 *       500:
 *         description: Internal Server Error.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: "Internal Server Error"
 *
 * @function
 * @name getWorkerEfficiencyDefault
 * @memberof module:Routes/Reports
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with the database query.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
app.get('/get_workereff_default', authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    // Get the current date in the specified format
    const date = new Date().toLocaleDateString('en-GB', { timeZone: 'Africa/Lagos' });
    const parts = date.split('/');
    const formattedDay = parts[0].padStart(2, '0');
    const formattedMonth = parts[1].padStart(2, '0');
    const year = parts[2];
    const date1 = `${formattedDay}-${formattedMonth}-${year}`;

    // Construct the SQL query
    const query = `
      SELECT 
        worker_timesheet.*, 
        item_masterr.item_description, 
        section.section_name,
        SUM(worker_timesheet.HOUR1+worker_timesheet.HOUR2+worker_timesheet.HOUR3+worker_timesheet.HOUR4+
          worker_timesheet.HOUR5+worker_timesheet.HOUR6+worker_timesheet.HOUR7+worker_timesheet.HOUR8+
          worker_timesheet.HOUR9+worker_timesheet.HOUR10+worker_timesheet.HOUR11) as value_sum
      FROM 
        worker_timesheet
      LEFT JOIN 
        item_masterr ON item_masterr.id = worker_timesheet.product_name
      LEFT JOIN 
        section ON section.id = worker_timesheet.section
      WHERE 
        date_time = ?
      GROUP BY 
        worker_timesheet.entry_id, 
        worker_timesheet.product_name, 
        worker_timesheet.section,
        worker_timesheet.date_time
    `;

    // Execute the SQL query
    const results = await executeQuery(connection,query, [date1]);

    // Prepare the response data
    const data = {
      timesheet: results,
      date: date1,
    };

    // Send the response
    res.json(data);
  } catch (error) {
    console.error('Error:', error);
    return res.status(500).json({ error: 'Internal Server Error' });
  }
});


//Get worker efficiency search data
/**
 * @swagger
 * /get_workereff_search:
 *   post:
 *     summary: Get Worker Efficiency Report (Search)
 *     description: Retrieves the worker efficiency report based on search criteria.
 *     tags:
 *       - Reports
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             properties:
 *               product_id:
 *                 type: string
 *                 description: The ID of the product.
 *               line_no:
 *                 type: string
 *                 description: The line number.
 *               section_id:
 *                 type: string
 *                 description: The ID of the section.
 *               fromdate:
 *                 type: string
 *                 format: date
 *                 example: "DD-MM-YYYY"
 *                 description: The start date for the search.
 *               todate:
 *                 type: string
 *                 format: date
 *                 example: "DD-MM-YYYY"
 *                 description: The end date for the search.
 *     responses:
 *       200:
 *         description: Successful response with worker efficiency report based on search criteria.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 timesheet:
 *                   type: array
 *                   items:
 *                     type: object
 *                     properties:
 *                       <property1>:
 *                         type: string
 *                         description: Description of property1.
 *                       <property2>:
 *                         type: string
 *                         description: Description of property2.
 *                       
 *                 fdate:
 *                   type: string
 *                   description: The start date used for the search in DD-MM-YYYY format.
 *                 tdate:
 *                   type: string
 *                   description: The end date used for the search in DD-MM-YYYY format.
 *                 operatorname:
 *                   type: string
 *                   description: The name of the operator.
 *                 product:
 *                   type: string
 *                   description: The description of the product.
 *                 line:
 *                   type: string
 *                   description: The line number.
 *                 section:
 *                   type: string
 *                   description: The name of the section.
 *       500:
 *         description: Internal Server Error.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: "Internal Server Error"
 *
 * @function
 * @name getWorkerEfficiencySearch
 * @memberof module:Routes/Reports
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with the database query.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
app.post('/get_workereff_search', authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    var product_name = req.body.product_id;
    var line_no = req.body.line_no;
    var section = req.body.section_id;

    const fromdate = req.body.fromdate;
    const fdParts = fromdate.split('-');
    const fd = `${fdParts[2]}-${fdParts[1]}-${fdParts[0]}`;

    const todate = req.body.todate;
    const tdParts = todate.split('-');
    const td = `${tdParts[2]}-${tdParts[1]}-${tdParts[0]}`;

    const dateObj = new Date(fromdate);
    const day = dateObj.getDate().toString().padStart(2, '0');
    const month = (dateObj.getMonth() + 1).toString().padStart(2, '0');
    const year = dateObj.getFullYear();
    const convertedDate = `${day}-${month}-${year}`;

    const dateObj1 = new Date(todate);
    const day1 = dateObj1.getDate().toString().padStart(2, '0');
    const month1 = (dateObj1.getMonth() + 1).toString().padStart(2, '0');
    const year1 = dateObj1.getFullYear();
    const convertedDate1 = `${day1}-${month1}-${year1}`;

    const fd2 = Math.floor(new Date(fromdate).getTime() / 1000);
    const td1 = Math.floor(new Date(todate).getTime() / 1000);
    const fd1 = Math.floor(new Date(fd2 * 1000).setDate(new Date(fd2 * 1000).getDate() - 1) / 1000);
    var newfd = fd1;
    var newtd = td1;

    console.log('Received data:');
    console.log('Product Name:', product_name);
    console.log('Line No:', line_no);
    console.log('Section:', section);
    console.log('From Date:', fd);
    console.log('To Date:', td);
    console.log('Converted Timestamp:', newfd);
    console.log('Converted Timestamp:', newtd);

    let whereConditions = [];

    if (product_name !== '') {
      whereConditions.push(`worker_timesheet.product_name = '${product_name}'`);
    }
    if (line_no !== '') {
      whereConditions.push(`worker_timesheet.line = '${line_no}'`);
    }
    if (section !== '') {
      whereConditions.push(`worker_timesheet.section = '${section}'`);
    }

    whereConditions.push(`worker_timesheet.time_stamp BETWEEN '${newfd}' AND '${newtd}'`);

    const whereClause = whereConditions.join(' AND ');

    const query = `
      SELECT 
        worker_timesheet.*, 
        item_masterr.item_description, 
        section.section_name,
        SUM(worker_timesheet.HOUR1+worker_timesheet.HOUR2+worker_timesheet.HOUR3+worker_timesheet.HOUR4+
          worker_timesheet.HOUR5+worker_timesheet.HOUR6+worker_timesheet.HOUR7+worker_timesheet.HOUR8+
          worker_timesheet.HOUR9+worker_timesheet.HOUR10+worker_timesheet.HOUR11) as value_sum
      FROM 
        worker_timesheet
      LEFT JOIN 
        item_masterr ON item_masterr.id = worker_timesheet.product_name
      LEFT JOIN 
        section ON section.id = worker_timesheet.section
      WHERE 
        ${whereClause}
      GROUP BY 
        worker_timesheet.entry_id, 
        worker_timesheet.product_name, 
        worker_timesheet.section,
        worker_timesheet.date_time
    `;

    const results = await executeQuery(connection,query);

    // Extract product, line, and section from the timesheet results
    const productFromTimesheet = results.length > 0 ? results[0].item_description : null;
    const lineFromTimesheet = results.length > 0 ? results[0].line : null;
    const sectionFromTimesheet = results.length > 0 ? results[0].section_name : null;

    const data = {
      timesheet: results,
      fdate: convertedDate,
      tdate: convertedDate1,
      operatorname: results.length > 0 ? results[0].operator_name : null
    };

    // Conditionally include product, line, and section in the response
    if (product_name) {
      data.product = productFromTimesheet;
    }
    if (line_no) {
      data.line = lineFromTimesheet;
    }
    if (section) {
      data.section = sectionFromTimesheet;
    }

    res.json(data);
  } catch (error) {
    console.error('Error:', error);
    return res.status(500).json({ error: 'Internal Server Error' });
  } finally {
    if (connection) {
      connection.end();
    }
  }
});





//Operator Efficiency Report

//Get Operator eff default data
/**
 * @swagger
 * /get_supervisoreff_default:
 *   get:
 *     summary: Get Supervisor Efficiency Report (Default)
 *     description: Retrieves the default supervisor efficiency report for the current date.
 *     tags:
 *       - Reports
 *     responses:
 *       200:
 *         description: Successful response with supervisor efficiency report for the current date.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 timesheet:
 *                   type: array
 *                   items:
 *                     type: object
 *                     properties:
 *                       <property1>:
 *                         type: string
 *                         description: Description of property1.
 *                       <property2>:
 *                         type: string
 *                         description: Description of property2.
 *                       
 *                 date:
 *                   type: string
 *                   description: The current date in DD-MM-YYYY format.
 *       500:
 *         description: Internal Server Error.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: "Internal Server Error"
 *
 * @function
 * @name getSupervisorEfficiencyDefault
 * @memberof module:Routes/Reports
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with the database query.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
app.get('/get_supervisoreff_default', authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    const date = new Date().toLocaleDateString('en-GB', { timeZone: 'Africa/Lagos' });
    const parts = date.split('/');
    const formattedDay = parts[0].padStart(2, '0');
    const formattedMonth = parts[1].padStart(2, '0');
    const year = parts[2];
    const date1 = `${formattedDay}-${formattedMonth}-${year}`;

    // SQL query
    const query = `
      SELECT 
        worker_timesheet.*, 
        geopos_users.name AS operator_name, 
        item_masterr.item_description, 
        section.section_name, 
        COUNT(worker_timesheet.entry_id) AS num_rows,
        SUM(worker_timesheet.target) AS totalTarget1, 
        SUM(
          worker_timesheet.HOUR1 + worker_timesheet.HOUR2 + worker_timesheet.HOUR3 + 
          worker_timesheet.HOUR4 + worker_timesheet.HOUR5 + worker_timesheet.HOUR6 + 
          worker_timesheet.HOUR7 + worker_timesheet.HOUR8 + worker_timesheet.HOUR9 + 
          worker_timesheet.HOUR10 + worker_timesheet.HOUR11
        ) AS value_sum
      FROM 
        worker_timesheet
      JOIN 
        geopos_users ON geopos_users.id = worker_timesheet.operator_id
      JOIN 
        item_masterr ON item_masterr.id = worker_timesheet.product_name
      JOIN 
        section ON section.id = worker_timesheet.section
      WHERE 
        worker_timesheet.date_time = ?
      GROUP BY 
        worker_timesheet.product_name, 
        worker_timesheet.line, 
        worker_timesheet.section, 
        worker_timesheet.date_time`;

    const results = await executeQuery(connection,query, [date1]);

    const data = {
      timesheet: results,
      date: date1,
    };

    res.json(data);
  } catch (error) {
    console.error('Error:', error);
    return res.status(500).json({ error: 'Internal Server Error' });
  } finally {
    if (connection) {
      connection.end();
    }
  }
});

//Get operator search data
/**
 * @swagger
 * /get_supervisor_search:
 *   post:
 *     summary: Get Supervisor Efficiency Report (Search)
 *     description: Retrieves the supervisor efficiency report based on search criteria.
 *     tags:
 *       - Reports
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             properties:
 *               fromdate:
 *                 type: string
 *                 description: The start date for the search in DD-MM-YYYY format.
 *              
 *     responses:
 *       200:
 *         description: Successful response with supervisor efficiency report based on search criteria.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 timesheet:
 *                   type: array
 *                   items:
 *                     type: object
 *                     properties:
 *                       <property1>:
 *                         type: string
 *                         description: Description of property1.
 *                       <property2>:
 *                         type: string
 *                         description: Description of property2.
 *                       
 *                 date:
 *                   type: string
 *                   description: The start date used for the search in DD-MM-YYYY format.
 *       500:
 *         description: Internal Server Error.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: "Internal Server Error"
 *
 * @function
 * @name getSupervisorEfficiencySearch
 * @memberof module:Routes/Reports
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with the database query.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
app.post('/get_supervisor_search', authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    const fromdate = req.body.fromdate;
    const fdParts = fromdate.split('-');
    const fd = `${fdParts[2]}-${fdParts[1]}-${fdParts[0]}`;

    const dateObj = new Date(fromdate);
    const day = dateObj.getDate().toString().padStart(2, '0');
    const month = (dateObj.getMonth() + 1).toString().padStart(2, '0');
    const year = dateObj.getFullYear();
    const convertedDate = `${day}-${month}-${year}`;

    console.log('Converted:', convertedDate);

    const fd2 = Math.floor(new Date(fromdate).getTime() / 1000);
    const fd1 = Math.floor(new Date(fd2 * 1000).setDate(new Date(fd2 * 1000).getDate() - 1) / 1000);
    const newfd = fd2;

    // Log the received data
    console.log('Received data:');
    console.log('From Date:', fd);
    console.log('Converted Timestamp:', newfd);

    const query = `
      SELECT 
        worker_timesheet.*, 
        geopos_users.name AS operator_name, 
        item_masterr.item_description, 
        section.section_name, 
        COUNT(worker_timesheet.entry_id) AS num_rows, 
        SUM(worker_timesheet.target) AS totalTarget1,
        SUM(
          worker_timesheet.HOUR1 + worker_timesheet.HOUR2 + worker_timesheet.HOUR3 + 
          worker_timesheet.HOUR4 + worker_timesheet.HOUR5 + worker_timesheet.HOUR6 + 
          worker_timesheet.HOUR7 + worker_timesheet.HOUR8 + worker_timesheet.HOUR9 + 
          worker_timesheet.HOUR10 + worker_timesheet.HOUR11
        ) AS value_sum
      FROM 
        worker_timesheet
      JOIN 
        geopos_users ON geopos_users.id = worker_timesheet.operator_id
      JOIN 
        item_masterr ON item_masterr.id = worker_timesheet.product_name
      JOIN 
        section ON section.id = worker_timesheet.section
      WHERE 
        worker_timesheet.date_time = ?
      GROUP BY 
        worker_timesheet.product_name, 
        worker_timesheet.line, 
        worker_timesheet.section, 
        worker_timesheet.date_time`;

    const results = await executeQuery(connection,query, [convertedDate]);

    const data = {
      timesheet: results,
      date: convertedDate,
    };

    res.json(data);
  } catch (error) {
    console.error('Error:', error);
    return res.status(500).json({ error: 'Internal Server Error' });
  } finally {
    if (connection) {
      connection.release();
    }
  }
});

//Supervisor Efficiency Report

//get Supervisor efficiency default 
app.get('/eff_supervisor', authenticateJWT, async (req, res) => {
  let connection;
  try {
      connection = await getPoolConnection();
      
      // Get today's date in the required format
      const date = new Date().toLocaleDateString('en-GB', { timeZone: 'Africa/Lagos' });
      const parts = date.split('/');
      const formattedDay = parts[0].padStart(2, '0');
      const formattedMonth = parts[1].padStart(2, '0');
      const year = parts[2];
      const date1 = `${formattedDay}-${formattedMonth}-${year}`;

      // SQL query to fetch timesheet data
      const query = `
          SELECT 
              worker_timesheet.*, 
              section.section_name, 
              SUM(worker_timesheet.target) AS totalTarget1, 
              SUM(worker_timesheet.HOUR1 + worker_timesheet.HOUR2 + worker_timesheet.HOUR3 + 
                  worker_timesheet.HOUR4 + worker_timesheet.HOUR5 + worker_timesheet.HOUR6 + 
                  worker_timesheet.HOUR7 + worker_timesheet.HOUR8 + worker_timesheet.HOUR9 + 
                  worker_timesheet.HOUR10 + worker_timesheet.HOUR11) AS value_sum, 
              supervisor_assign.entryid AS entry, 
              supervisor_assign.site AS sup_site 
          FROM 
              worker_timesheet 
              JOIN section ON section.id = worker_timesheet.section 
              JOIN supervisor_assign ON supervisor_assign.line = worker_timesheet.line AND 
                  supervisor_assign.section = worker_timesheet.section AND 
                  supervisor_assign.shift = worker_timesheet.shift AND 
                  supervisor_assign.site = worker_timesheet.site 
          WHERE 
              worker_timesheet.date_time = '${date1}' 
          GROUP BY 
              worker_timesheet.line, worker_timesheet.section, worker_timesheet.date_time, 
              worker_timesheet.shift, worker_timesheet.site`;

      // Execute the query to fetch timesheet data
      const results = await executeQuery(connection, query, [date1]);

      // Initialize an empty object to store worker counts
      const worker_counts = {};

      // Iterate over each result to calculate worker counts and supervisor names
      for (const item of results) {
          const { line, section, shift, site, sup_site, entry } = item;
          
          // Ensure nested structures exist for line -> section -> shift -> site
          if (!worker_counts[line]) worker_counts[line] = {};
          if (!worker_counts[line][section]) worker_counts[line][section] = {};
          if (!worker_counts[line][section][shift]) worker_counts[line][section][shift] = {};
          if (!worker_counts[line][section][shift][site]) {
              // Fetch worker count asynchronously using the getWorkerCount function
              worker_counts[line][section][shift][site] = await getWorkerCount(line, section, shift, site);
          }

          let supervisor_name = '';

          let supervisorQuery; // Define a new variable for the supervisor query

          if (sup_site === 'ota') {
              supervisorQuery = `SELECT name FROM employees_ota WHERE entryid='${entry}'`;
          } else {
              supervisorQuery = `SELECT name FROM geopos_employees WHERE entryid='${entry}'`;
          }

          const result = await executeQuery(connection, supervisorQuery);
          supervisor_name = result.length > 0 ? result[0].name : 'Unknown'; // Handle case where no result is found
          console.log(`Supervisor name for ${item.id}: ${supervisor_name}`); // Debugging log
          
          // Assign supervisor_name to item object
          item.supervisor_name = supervisor_name; // Store supervisor_name in the item object
      }

      // Prepare the response data
      const data = {
          timesheet: results,
          date: date1,
          worker_counts: worker_counts
      };

      // Send JSON response
      res.json(data);
  } catch (error) {
      console.error('Error:', error);
      return res.status(500).json({ error: 'Internal Server Error' });
  } finally {
      if (connection) {
          connection.release();
      }
  }
});

// Function to fetch worker count for a specific line, section, shift, and site
const getWorkerCount = (line, section, shift, site) => {
  return new Promise((resolve, reject) => {
      const query = `
          SELECT COUNT(DISTINCT entry_id) AS worker_count 
          FROM worker_timesheet 
          WHERE line='${line}' AND section='${section}' AND site='${site}' AND shift='${shift}'`;
      
      // Replace with your actual database query function
      db.query(query, (err, result) => {
          if (err) return reject(err);
          resolve(result[0].worker_count);
      });
  });
};



//-------------------------REPORT ---------------------------//

//--------------------------Employee Timesheet ---------------------------//


// Get the filtered data for braid employees list
/**
 * @swagger
 * /getemployeetimesheetdata:
 *   post:
 *     summary: Get Employee Timesheet Data
 *     description: Retrieves timesheet data for employees based on search criteria.
 *     tags:
 *       - Timesheet
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             properties:
 *               product_name:
 *                 type: string
 *                 description: The name of the product.
 *               shift:
 *                 type: string
 *                 description: The shift of the employee.
 *               site:
 *                 type: string
 *                 description: The site where the employee works.
 *               fromdate:
 *                 type: string
 *                 format: date
 *                 description: The start date for the search in YYYY-MM-DD format.
 *               todate:
 *                 type: string
 *                 format: date
 *                 description: The end date for the search in YYYY-MM-DD format.
 *     responses:
 *       200:
 *         description: Successful response with timesheet data for employees.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 timesheet:
 *                   type: array
 *                   items:
 *                     type: object
 *                     properties:
 *                       <property1>:
 *                         type: string
 *                         description: Description of property1.
 *                       <property2>:
 *                         type: string
 *                         description: Description of property2.
 *                       
 *       500:
 *         description: Internal Server Error.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: "Internal Server Error"
 *
 * @function
 * @name getEmployeeTimesheetData
 * @memberof module:Routes/Timesheet
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with the database query.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
app.post('/getemployeetimesheetdata', authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    var product_name = req.body.product_name;
    var shift = req.body.shift;
    var site = req.body.site;

    const fromdate = new Date(req.body.fromdate)
    const fdParts = `${fromdate.getFullYear()}-${(fromdate.getMonth() + 1).toString().padStart(2, '0')}-${fromdate.getDate().toString().padStart(2, '0')}`;
    const fd = fdParts.split('-').reverse().join('-');

    const todate = new Date(req.body.todate)
    const tdParts = `${todate.getFullYear()}-${(todate.getMonth() + 1).toString().padStart(2, '0')}-${todate.getDate().toString().padStart(2, '0')}`;
    const td = tdParts.split('-').reverse().join('-');

    const fd2 = Math.floor(new Date(fromdate).getTime() / 1000);
    const td1 = Math.floor(new Date(todate).getTime() / 1000);
    const fd1 = Math.floor(new Date(fd2 * 1000).setDate(new Date(fd2 * 1000).getDate() - 1) / 1000);

    var newfd = fd2;
    var newtd = td1;

    // Log the received data
    console.log('Received data:');
    console.log('Product Name:', product_name);
    console.log('Shift:', shift);
    console.log('Site:', site);
    console.log('From Date:', fd);
    console.log('To Date:', td);
    console.log('From Date:', fromdate);
    console.log('To Date:', todate);
    console.log('Converted Timestamp:', newfd);
    console.log('Converted Timestamp:', newtd);

    let whereConditions = [];

    if (product_name !== '') {
      whereConditions.push(`geopos_operator.item = '${product_name}'`);
    }

    if (shift !== '') {
      whereConditions.push(`geopos_operator.shift = '${shift}'`);
    }
    if (site !== '') {
      whereConditions.push(`geopos_operator.site = '${site}'`);
    }
    whereConditions.push(`geopos_operator.timestamp BETWEEN '${newfd}' AND '${newtd}'`);

    const whereClause = whereConditions.join(' AND ');

    if (site === 'ikeja') {
      const query = `
        SELECT
          geopos_operator.*,
          geopos_employees.name,
          geopos_employees.entryid,
          geopos_employees.workertype,
          item_masterr.item_description,
          color_master.color_name
        FROM
          geopos_operator
        LEFT JOIN
          geopos_employees ON geopos_operator.emp_id = geopos_employees.id
        LEFT JOIN
          item_masterr ON geopos_operator.item = item_masterr.id
        LEFT JOIN
          color_master ON geopos_operator.color_id = color_master.id
        WHERE
          ${whereClause}
      `;
      console.log(query);

      const results = await executeQuery(connection,query);
      console.log('Query results ikeja:', results);
      const data = {
        timesheet: results,
      };
      res.json(data); // Send response back to client
    } else if (site === 'ota') {
      const query = `
        SELECT
          geopos_operator.*,
          employees_ota.name,
          employees_ota.entryid,
          employees_ota.workertype,
          item_masterr.item_description,
          color_master.color_name
        FROM
          geopos_operator
        LEFT JOIN
          employees_ota ON employees_ota.id = geopos_operator.emp_id
        LEFT JOIN
          item_masterr ON geopos_operator.item = item_masterr.id
        LEFT JOIN
          color_master ON geopos_operator.color_id = color_master.id
        WHERE
          ${whereClause}
      `;
      console.log(query);
      const results = await executeQuery(connection,query);
      console.log('Query results ota:', results);
      const data = {
        timesheet: results,
      };
      res.json(data); // Send response back to client
    } else {
      const query1 = `
        SELECT geopos_operator.*, geopos_employees.name, geopos_employees.entryid,
        geopos_employees.workertype, item_masterr.item_description,
        color_master.color_name
        FROM geopos_operator
        LEFT JOIN geopos_employees ON geopos_employees.id = geopos_operator.emp_id
        LEFT JOIN item_masterr ON geopos_operator.item = item_masterr.id
        LEFT JOIN color_master ON geopos_operator.color_id = color_master.id
        WHERE geopos_operator.site = 'ikeja' AND ${whereClause}
      `;
      const query2 = `
        SELECT geopos_operator.*, employees_ota.name, employees_ota.entryid,
        employees_ota.workertype, item_masterr.item_description,
        color_master.color_name
        FROM geopos_operator
        LEFT JOIN employees_ota ON employees_ota.id = geopos_operator.emp_id
        LEFT JOIN item_masterr ON geopos_operator.item = item_masterr.id
        LEFT JOIN color_master ON geopos_operator.color_id = color_master.id
        WHERE geopos_operator.site = 'ota' AND ${whereClause}
      `;

      // Execute the queries in parallel
      const [results1, results2] = await Promise.all([
        executeQuery(connection,query1),
        executeQuery(connection,query2)
      ]);

      // Combine the results
      const combinedResults = results1.concat(results2);
      console.log('Combined query results:', combinedResults);

      // Send response back to client
      const data = {
        timesheet: combinedResults,
      };
      res.json(data);
    }
  } catch (error) {
    console.error('Error executing query:', error);
    res.status(500).json({ error: 'Internal Server Error' });
  } finally {
    if (connection) {
      connection.release();
      //console.log("Connection released");
    }
  }
});



// Get the default employee data for current date
/**
 * @swagger
 * /getdefaultemployeetimesheetdatabraid:
 *   get:
 *     summary: Get Default Employee Timesheet Data (Braid)
 *     description: Retrieves the default timesheet data for employees with a specific role and site, particularly for the 'Braid' category.
 *     tags:
 *       - Timesheet
 *     responses:
 *       200:
 *         description: Successful response with timesheet data for employees.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 timesheet:
 *                   type: array
 *                   items:
 *                     type: object
 *                     properties:
 *                       <property1>:
 *                         type: string
 *                         description: Description of property1.
 *                       <property2>:
 *                         type: string
 *                         description: Description of property2.
 *                       
 *       500:
 *         description: Internal Server Error.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: "Internal Server Error"
 *
 * @function
 * @name getDefaultEmployeeTimesheetDataBraid
 * @memberof module:Routes/Timesheet
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with the database query.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
app.get('/getdefaultemployeetimesheetdatabraid', authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    const roleid = 5;
    const id = 9;

    const date = new Date().toLocaleDateString('en-GB', { timeZone: 'Africa/Lagos' });
    const parts = date.split('/');
    const formattedDay = parts[0].padStart(2, '0');
    const formattedMonth = parts[1].padStart(2, '0');
    const year = parts[2];
    const date1 = `${formattedDay}-${formattedMonth}-${year}`;

    // Log the received data
    console.log('Received data:');
    console.log('Date:', date1);

    let query;

    if (roleid === 5) {
      // Queries for roleid = 5
      const query1 = `
        SELECT geopos_operator.*, geopos_employees.name, geopos_employees.entryid, geopos_employees.workertype, item_masterr.item_description, color_master.color_name
        FROM geopos_operator
        LEFT JOIN geopos_employees ON geopos_employees.id = geopos_operator.emp_id
        LEFT JOIN item_masterr ON geopos_operator.item = item_masterr.id
        LEFT JOIN color_master ON geopos_operator.color_id = color_master.id
        WHERE geopos_operator.date = ? AND geopos_operator.site = 'ikeja'
      `;

      const query2 = `
        SELECT geopos_operator.*, employees_ota.name, employees_ota.entryid, employees_ota.workertype, item_masterr.item_description, color_master.color_name
        FROM geopos_operator
        LEFT JOIN employees_ota ON employees_ota.id = geopos_operator.emp_id
        LEFT JOIN item_masterr ON geopos_operator.item = item_masterr.id
        LEFT JOIN color_master ON geopos_operator.color_id = color_master.id
        WHERE geopos_operator.date = ? AND geopos_operator.site = 'ota'
      `;

      query = `${query1} UNION ${query2}`;
    } else {
      const id2 = 6;

      // Query the database for user data
      const userData = await executeQuery(connection,'SELECT * FROM geopos_users WHERE id = ?', [id2]);

      const site = userData[0].production_type;
      const ctype = userData[0].category_type;

      let data = {};

      if (site === 'ikeja' && ctype === 'BRAID') {
        // Perform the first database query
        const result = await executeQuery(connection,
          'SELECT geopos_employees.* FROM geopos_employees ' +
            'LEFT JOIN geopos_users ON geopos_employees.entryid = geopos_users.entryid ' +
            'WHERE geopos_users.id = ?',
          [id2]
        );

        const id = result[0].id;
        const date = new Date().toLocaleDateString('en-NG'); // Use 'en-NG' for Nigeria timezone

        // Define the MySQL query
        query = `
          SELECT geopos_operator.*, geopos_employees.name, geopos_employees.entryid, geopos_employees.workertype, item_masterr.item_description, color_master.color_name
          FROM geopos_operator
          LEFT JOIN geopos_employees ON geopos_employees.id = geopos_operator.emp_id
          LEFT JOIN item_masterr ON item_masterr.id = geopos_operator.item
          LEFT JOIN color_master ON color_master.id = geopos_operator.color_id
          WHERE geopos_operator.date = ? AND geopos_operator.emp_id = ?
          ORDER BY id DESC
          LIMIT 1
        `;

        const results = await executeQuery(connection,query, [date, id]);
        res.json(results);
      }

      if (site === 'ota' && ctype === 'BRAID') {
        // Perform the second database query
        const result = await executeQuery(connection,
          'SELECT employees_ota.* FROM employees_ota ' +
            'LEFT JOIN geopos_users ON employees_ota.entryid = geopos_users.entryid ' +
            'WHERE geopos_users.id = ?',
          [id2]
        );

        const id = result[0].id;
        const date = new Date().toLocaleDateString('en-NG'); // Use 'en-NG' for Nigeria timezone

        // Your SQL query
        query = `
          SELECT geopos_operator.*, employees_ota.name, employees_ota.entryid, employees_ota.workertype, item_masterr.item_description, color_master.color_name
          FROM geopos_operator
          LEFT JOIN employees_ota ON employees_ota.id = geopos_operator.emp_id
          LEFT JOIN item_masterr ON item_masterr.id = geopos_operator.item
          LEFT JOIN color_master ON color_master.id = geopos_operator.color_id
          WHERE geopos_operator.date = ? AND geopos_operator.emp_id = ?
          ORDER BY id DESC
          LIMIT 1
        `;

        const results = await executeQuery(connection,query, [date, id]);
        res.json(results);
      }
    }

    const results = await executeQuery(connection,query, [date1, date1]);

    const data = {
      timesheet: results,
    };

    res.json(data);
  } catch (error) {
    console.error('Error executing query:', error);
    res.status(500).json({ error: 'Query error' });
  } finally {
    if (connection) {
      connection.end();
    }
  }
});





// view comparision
/**
 * @swagger
 * /getviewcomparisonbraid/{itemId}:
 *   get:
 *     summary: Get Comparison Data for a Specific Item (Braid)
 *     description: Retrieves the comparison data for a specific item ID in the 'Braid' category.
 *     tags:
 *       - Comparison
 *     parameters:
 *       - in: path
 *         name: itemId
 *         required: true
 *         description: The ID of the item to retrieve comparison data for.
 *         schema:
 *           type: string
 *     responses:
 *       200:
 *         description: Successful response with comparison data for the specified item.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 comparison:
 *                   type: object
 *                   properties:
 *                     geopos_operator:
 *                       type: object
 *                       description: Operator data.
 *                       properties:
 *                         id:
 *                           type: string
 *                           description: ID of the operator.
 *                         item:
 *                           type: string
 *                           description: Item ID.
 *                         color_id:
 *                           type: string
 *                           description: Color ID.
 *                         date:
 *                           type: string
 *                           description: Date of the record.
 *                         
 *                     item_masterr:
 *                       type: object
 *                       description: Item master data.
 *                       properties:
 *                         item_description:
 *                           type: string
 *                           description: Description of the item.
 *                         net_weight:
 *                           type: number
 *                           description: Net weight of the item.
 *                         targeted_waste:
 *                           type: number
 *                           description: Targeted waste percentage.
 *                     color_master:
 *                       type: object
 *                       description: Color master data.
 *                       properties:
 *                         color_name:
 *                           type: string
 *                           description: Name of the color.
 *       500:
 *         description: Internal Server Error.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: "Internal Server Error"
 *
 * @function
 * @name getViewComparisonBraid
 * @memberof module:Routes/Comparison
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with the database query.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
app.get('/getviewcomparisonbraid/:itemId', authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getConnection();
    const itemId = req.params.itemId;
    console.log('Received ID:', itemId);
    
    const query = `
      SELECT geopos_operator.*, item_masterr.item_description, item_masterr.net_weight, 
             item_masterr.targeted_waste, color_master.color_name as color
      FROM geopos_operator
      LEFT JOIN item_masterr ON geopos_operator.item = item_masterr.id
      LEFT JOIN color_master ON geopos_operator.color_id = color_master.id
      WHERE geopos_operator.id = ?
    `;
  
    const results = await executeQuery(connection,query, [itemId]);
  
    const comparison = results[0]; // Assuming you expect only one row
    console.log(comparison);
    const data = {
      comparison,
    };
  
    res.json(data);
  } catch (error) {
    console.error('Error executing SQL query: ', error);
    res.status(500).json({ error: 'Internal Server Error' });
  } finally {
    if (connection) {
      connection.end();
    }
  }
});



//get employee productivity
/**
 * @swagger
 * /getemployeeproductivity/{id}:
 *   get:
 *     summary: Get Employee Productivity Data
 *     description: Retrieves productivity data for an employee based on their ID.
 *     tags:
 *       - Employee Productivity
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         description: The ID of the employee to retrieve productivity data for.
 *         schema:
 *           type: string
 *     responses:
 *       200:
 *         description: Successful response with employee productivity data.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 results:
 *                   type: array
 *                   items:
 *                     type: object
 *                     properties:
 *                       id:
 *                         type: integer
 *                         description: ID of the operator section record.
 *                       opmanual_id:
 *                         type: string
 *                         description: Operator manual ID.
 *                       empid:
 *                         type: string
 *                         description: Employee ID.
 *                       section_id:
 *                         type: integer
 *                         description: Section ID.
 *                       emp:
 *                         type: string
 *                         description: Employee name.
 *                       target:
 *                         type: string
 *                         description: Target value.
 *                       complete:
 *                         type: string
 *                         description: Completion status.
 *                       date:
 *                         type: string
 *                         description: Date of the record.
 *                       timestamp:
 *                         type: string
 *                         description: Timestamp of the record.
 *                       sectionName:
 *                         type: string
 *                         description: Name of the section.
 *       500:
 *         description: Internal Server Error.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: "Internal Server Error"
 *
 * @function
 * @name getEmployeeProductivity
 * @memberof module:Routes/EmployeeProductivity
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with the database query.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
app.get('/getemployeeproductivity/:id', authenticateJWT, async (req, res) => {
  const firstResponseId = req.params.id;

  // Query the database to retrieve data
  const sql = `
    SELECT * FROM operator_section
    WHERE opmanual_id LIKE '%${firstResponseId}%'
  `;
   let connection;
  try {
     connection = await getPoolConnection();
      const results = await executeQuery(connection,sql);

      console.log(results); // Corrected console.log statement

      // Create an array to store the response data
      const responseData = [];

      // Process the results and populate responseData
      for (const row of results) {
          const opid = row.opmanual_id.split(',');
          const k = opid.indexOf(firstResponseId);
          const complete = row.complete.split(',');
          const cmp = complete[k];
          const cnt = k + 1;
          const sectionId = row.section_id;

          // Log the relevant information to the console for debugging
          console.log('opid:', opid);
          console.log('k:', k);
          console.log('complete:', complete);
          console.log('cmp:', cmp);
          console.log('cnt:', cnt);
          console.log('sectionId:', sectionId);

          // Query the 'section' table to get the 'section_name'
          const sectionSql = `SELECT * FROM section WHERE id = ${sectionId}`;
          const sectionResults = await executeQuery(connection,sectionSql);

          const sec = sectionResults[0].section_name;
          console.log('sec:', sec);

          const employeeData = {
              id: row.id,
              opmanual_id: row.opmanual_id,
              empid: row.empid,
              section_id: row.section_id,
              emp: row.emp,
              target: row.target,
              complete: row.complete,
              date: row.date,
              timestamp: row.timestamp,
              sectionName: sec, // Include section_name
          };

          // Add employeeData to responseData
          responseData.push(employeeData);
      }

      const responseObj = {
          results: responseData,
      };
      
      // Send the response with responseData
      res.json(responseObj);
  } catch (error) {
      console.error('Error executing SQL query:', error);
      res.status(500).json({ error: 'Internal Server Error' });
  } finally {
      if (connection) {
          connection.end();
      }
  }
});



 
// Edit EmployeeTimesheet Braid Ikeja
/**
 * @swagger
 * /operator_edit/{id}:
 *   get:
 *     summary: Get Operator Edit Data
 *     description: Retrieves operator data for editing based on the provided ID.
 *     tags:
 *       - Operator
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         description: The ID of the operator to retrieve.
 *         schema:
 *           type: string
 *     responses:
 *       200:
 *         description: Successful response with operator data.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 comparison:
 *                   type: object
 *                   properties:
 *                     id:
 *                       type: integer
 *                       description: ID of the operator.
 *                     emp_id:
 *                       type: integer
 *                       description: Employee ID.
 *                     date:
 *                       type: string
 *                       format: date
 *                       description: Date of the record.
 *                     item:
 *                       type: string
 *                       description: Item associated with the record.
 *                     color_id:
 *                       type: integer
 *                       description: Color ID.
 *                     quantity:
 *                       type: integer
 *                       description: Quantity processed.
 *                
 *       500:
 *         description: Internal Server Error.
 *         content:
 *           application/json:
 *             schema:
 *               type: string
 *               example: "Internal Server Error"
 *
 * @function
 * @name getOperatorEdit
 * @memberof module:Routes/Operator
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with the database query.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
app.get('/operator_edit/:id', authenticateJWT, async (req, res) => {
  const id = req.params.id;
  const roleid = 5;
  console.log(`Requested operator_edit for ID: ${id}`);
  let connection;
  if (roleid === 5) {
    try {
      connection = await getPoolConnection();
      const catid = id;
      const query = 'SELECT * FROM geopos_operator WHERE id = ?';

      // Execute the database query
      const results = await executeQuery(connection,query, [catid]);

      const comparison = results[0] || {}; // Assuming you expect one row or an empty object
      console.log('Database query results:', comparison);

      // Wrap the comparison object inside an object with the 'comparison' key
      const response = {
        comparison: comparison
      };

      res.json(response); // Send the response object as JSON
    } catch (error) {
      console.error('Error executing MySQL query:', error);
      res.status(500).send('Internal Server Error');
    } finally {
      if (connection) {
        connection.end();
      }
    }
  } 
});


 // get operator
 /**
 * @swagger
 * /getOperator1/{empid}/{site}:
 *   get:
 *     summary: Get Operator by Employee ID and Site
 *     description: Retrieves operator details based on employee ID and site.
 *     tags:
 *       - Operator
 *     parameters:
 *       - in: path
 *         name: empid
 *         required: true
 *         description: The employee ID to retrieve.
 *         schema:
 *           type: string
 *       - in: path
 *         name: site
 *         required: true
 *         description: The site of the operator (e.g., 'ikeja' or 'ota').
 *         schema:
 *           type: string
 *     responses:
 *       200:
 *         description: Successful response with operator details.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 name:
 *                   type: string
 *                   description: Name of the operator.
 *                 id:
 *                   type: string
 *                   description: Entry ID of the operator.
 *       404:
 *         description: Site not found.
 *         content:
 *           text/plain:
 *             schema:
 *               type: string
 *               example: "Site not found"
 *       500:
 *         description: Internal Server Error.
 *         content:
 *           text/plain:
 *             schema:
 *               type: string
 *               example: "Internal Server Error"
 *
 * @function
 * @name getOperator1
 * @memberof module:Routes/Operator
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with the database query.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
 app.get('/getOperator1/:empid/:site', authenticateJWT, async (req, res) => {
  const empid = req.params.empid;
  const site = req.params.site;
  console.log(`Requested operator_edit for emp_id: ${empid}`);
  console.log(`Requested operator_edit for site: ${site}`);
  let connection;
  try {
    connection = await getPoolConnection();
    // Define the query to select operators
    const query = `
      SELECT geopos_employees.*
      FROM geopos_employees
      LEFT JOIN geopos_users ON geopos_employees.entryid = geopos_users.entryid
      WHERE geopos_users.roleid = 3
        AND geopos_users.production_type = 'ikeja'
        AND geopos_users.banned = 0
    `;

    // Execute the database query
    const operators = await executeQuery(connection,query);

    // Create an object to store name and id
    const responseObj = {
      name: '',
      id: ''
    };

    // Check conditions
    if (empid === '1') {
      responseObj.name = 'Admin';
      responseObj.id = '50000';
    } else if (site === 'ikeja') {
      // Query for 'ikeja' site
      const ikejaResults = await executeQuery(connection,
        'SELECT name, entryid FROM geopos_employees WHERE id = ?',
        [empid]
      );

      if (ikejaResults.length > 0) {
        responseObj.name = ikejaResults[0].name;
        responseObj.id = ikejaResults[0].entryid;
      }
    } else if (site === 'ota') {
      // Query for 'ota' site
      const otaResults = await executeQuery(connection,
        'SELECT name, entryid FROM employees_ota WHERE id = ?',
        [empid]
      );

      if (otaResults.length > 0) {
        responseObj.name = otaResults[0].name;
        responseObj.id = otaResults[0].entryid;
      }
    } else {
      // Handle other cases or send an appropriate response
      console.log('Site not found:', site);
      res.status(404).send('Site not found');
      return;
    }

    // Send the response
    console.log('Response:', responseObj);
    res.json(responseObj);
  } catch (error) {
    console.error('Error executing MySQL query:', error);
    res.status(500).send('Internal Server Error');
  } finally {
    if (connection) {
      connection.end();
    }
  }
});

/**
 * @swagger
 * /getOperator/{empid}/{site}:
 *   get:
 *     summary: Get Operator by Employee ID and Site
 *     description: Retrieves operator details based on employee ID and site.
 *     tags:
 *       - Operator
 *     parameters:
 *       - in: path
 *         name: empid
 *         required: true
 *         description: The employee ID to retrieve.
 *         schema:
 *           type: string
 *       - in: path
 *         name: site
 *         required: true
 *         description: The site of the operator (e.g., 'ikeja' or 'ota').
 *         schema:
 *           type: string
 *     responses:
 *       200:
 *         description: Successful response with operator details.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 name:
 *                   type: string
 *                   description: Name of the operator.
 *                   example: Admin
 *                 id:
 *                   type: string
 *                   description: Entry ID of the operator.
 *                   example: 50000
 *       404:
 *         description: Site not found.
 *         content:
 *           text/plain:
 *             schema:
 *               type: string
 *               example: "Site not found"
 *       500:
 *         description: Internal Server Error.
 *         content:
 *           text/plain:
 *             schema:
 *               type: string
 *               example: "Internal Server Error"
 *
 * @function
 * @name getOperator
 * @memberof module:Routes/Operator
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with the database query.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
app.get('/getOperator/:empid/:site', authenticateJWT, async (req, res) => {
  const empid = req.params.empid;
  const site = req.params.site;
  console.log(`Requested operator_edit forr emp_id: ${empid}`);
  console.log(`Requested operator_edit forr site: ${site}`);

  // Create an object to store name and id
  const responseObj = {
    name: '',
    id: ''
  };
 let connection;
  try {
    connection = await getPoolConnection();
    // Check conditions
    if (empid === '1') {
      responseObj.name = 'Admin';
      responseObj.id = '50000';
      res.json(responseObj);
    } else if (site === 'ikeja' || site === 'ota') {
      const tableName = (site === 'ikeja') ? 'geopos_employees' : 'employees_ota';

      // Query for the specified site
      const results = await executeQuery(connection,
        `SELECT name, entryid FROM ${tableName} WHERE id = ?`,
        [empid]
      );

      if (results.length > 0) {
        responseObj.name = results[0].name;
        responseObj.id = results[0].entryid;
      }

      // Send the response
      console.log(`Response for ${site} site:`, responseObj);
      res.json(responseObj);
    } else {
      // Handle other cases or send an appropriate response
      console.log('Site not found:', site);
      res.status(404).send('Site not found');
    }
  } catch (error) {
    console.error('Error executing MySQL query:', error);
    res.status(500).send('Internal Server Error');
  } finally {
    if (connection) {
      connection.end();
    }
  }
});




// get operator section
/**
 * @swagger
 * /operatorsection/{id}:
 *   get:
 *     summary: Get Operator Section by ID
 *     description: Retrieves operator section details based on the provided ID.
 *     tags:
 *       - Operator Section
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         description: The operator section ID to retrieve.
 *         schema:
 *           type: string
 *     responses:
 *       200:
 *         description: Successful response with operator section details.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 rows:
 *                   type: array
 *                   items:
 *                     type: object
 *                     properties:
 *                       id:
 *                         type: integer
 *                       opmanual_id:
 *                         type: string
 *                       empid:
 *                         type: string
 *                       section_id:
 *                         type: integer
 *                       emp:
 *                         type: string
 *                       target:
 *                         type: string
 *                       complete:
 *                         type: string
 *                       date:
 *                         type: string
 *                       timestamp:
 *                         type: string
 *                       sec:
 *                         type: string
 *                       cmp:
 *                         type: string
 *       500:
 *         description: Internal Server Error.
 *         content:
 *           text/plain:
 *             schema:
 *               type: string
 *               example: "Internal server error"
 *
 * @function
 * @name getOperatorSection
 * @memberof module:Routes/OperatorSection
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with the database query.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
app.get('/operatorsection/:id', authenticateJWT, async (req, res) => {
  const comparisonId = req.params.id;
  console.log('comparisonId:', comparisonId);
 let connection;
  try {
    connection = await getPoolConnection();
    // SQL query to retrieve data
    const sql = `
      SELECT os.*, s.section_name
      FROM operator_section os
      LEFT JOIN section s ON os.section_id = s.id
      WHERE os.opmanual_id LIKE '%${comparisonId}%'
    `;

    // Execute the SQL query
    const rows = await executeQuery(connection,sql);

    const results = [];

    for (const row of rows) {
      const opid = row.opmanual_id.split(',');

      if (opid.includes(comparisonId)) {
        const k = opid.indexOf(comparisonId);
        const complete = row.complete.split(',');
        const cmp = complete[k];

        console.log('k:', k);
        console.log('complete:', complete);
        console.log('cmp:', cmp);

        const cnt = k + 1;

        // Determine if 'read' should be 'disabled'
        const read = [24, 23, 7].includes(row.section_id) ? 'disabled' : '';

        // Include the 'section_name' directly in the 'rows' response
        row.sec = row.section_name;

        // Remove the 'section_name' property from the row if desired
        delete row.section_name;

        // Include 'cmp' value in the record
        row.cmp = cmp;

        results.push(row);
      }
    }

    // Send the response
    const responseObj = {
      rows: results,
    };
    res.json(responseObj);
  } catch (error) {
    console.error('Error executing SQL query:', error);
    res.status(500).json({ error: 'Internal server error' });
  } finally {
    if (connection) {
      connection.end();
    }
  }
});





//nbraid ota list

//search data
/**
 * @swagger
 * /getemployeetimesheetdatanbraidota:
 *   post:
 *     summary: Get Employee Timesheet Data
 *     description: Retrieves employee timesheet data based on the provided filters.
 *     tags:
 *       - Timesheet
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             properties:
 *               product_name:
 *                 type: string
 *                 description: The name of the product.
 *               shift:
 *                 type: string
 *                 description: The shift.
 *               line_no:
 *                 type: string
 *                 description: The line number.
 *               section:
 *                 type: string
 *                 description: The section.
 *               fromdate:
 *                 type: string
 *                 format: date
 *                 description: The start date for the timesheet data.
 *               todate:
 *                 type: string
 *                 format: date
 *                 description: The end date for the timesheet data.
 *     responses:
 *       200:
 *         description: Successful response with timesheet data.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 timesheet:
 *                   type: array
 *                   items:
 *                     type: object
 *                     properties:
 *                       entry_id:
 *                         type: integer
 *                       product_name:
 *                         type: string
 *                       section:
 *                         type: string
 *                       shift:
 *                         type: string
 *                       date_time:
 *                         type: string
 *                       worker:
 *                         type: string
 *                       value_sum:
 *                         type: number
 *       500:
 *         description: Internal Server Error.
 *         content:
 *           text/plain:
 *             schema:
 *               type: string
 *               example: "Internal Server Error"
 *
 * @function
 * @name getEmployeeTimesheetData
 * @memberof module:Routes/Timesheet
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with the database query.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
app.post('/getemployeetimesheetdatanbraidota', authenticateJWT, async (req, res) => {
  var product_name = req.body.product_name;
  var shift = req.body.shift;
  var line = req.body.line_no;
  var section = req.body.section;
  
  const fromdate = new Date(req.body.fromdate)
  const fdParts = `${fromdate.getFullYear()}-${(fromdate.getMonth() + 1).toString().padStart(2, '0')}-${fromdate.getDate().toString().padStart(2, '0')}`;
  const fd = fdParts.split('-').reverse().join('-');

  const todate = new Date(req.body.todate)
  const tdParts = `${todate.getFullYear()}-${(todate.getMonth() + 1).toString().padStart(2, '0')}-${todate.getDate().toString().padStart(2, '0')}`;
  const td = tdParts.split('-').reverse().join('-');

  const fd2 = Math.floor(new Date(fromdate).getTime() / 1000);
  const td1 = Math.floor(new Date(todate).getTime() / 1000);
  const fd1 = Math.floor(new Date(fd2 * 1000).setDate(new Date(fd2 * 1000).getDate() - 1) / 1000);

  var newfd = fd1;
  var newtd = td1;

  // Log the received data
  console.log('Received data:');
  console.log('Product Name:', product_name);
  console.log('Shift:', shift);
  console.log('Line:', line);
  console.log('Section:', section);
  console.log('From Date:', fd);
  console.log('To Date:', td);
  console.log('From Date:', fromdate);
  console.log('To Date:', todate);
  console.log('Converted Timestamp:', newfd);
  console.log('Converted Timestamp:', newtd);
  
  let whereConditions = [];

  if (product_name !== '') {
    whereConditions.push(`worker_timesheet.product_name = '${product_name}'`);
  }
 
  if (shift !== '') {
    whereConditions.push(`worker_timesheet.shift = '${shift}'`);
  }

  if (line !== '') {
    whereConditions.push(`worker_timesheet.line = '${line}'`);
  }

  if (section !== '') {
    whereConditions.push(`worker_timesheet.section = '${section}'`);
  }
  whereConditions.push(`worker_timesheet.time_stamp BETWEEN '${newfd}' AND '${newtd}'`);

  const whereClause = whereConditions.join(' AND ');

  const query = `
    SELECT
      worker_timesheet.*, section.section_name, item_masterr.item_description,
      SUM(
        worker_timesheet.HOUR1 + worker_timesheet.HOUR2 + worker_timesheet.HOUR3 +
        worker_timesheet.HOUR4 + worker_timesheet.HOUR5 + worker_timesheet.HOUR6 +
        worker_timesheet.HOUR7 + worker_timesheet.HOUR8 + worker_timesheet.HOUR9 +
        worker_timesheet.HOUR10 + worker_timesheet.HOUR11
      ) AS value_sum
    FROM worker_timesheet
    LEFT JOIN item_masterr ON worker_timesheet.product_name = item_masterr.id
    LEFT JOIN section ON worker_timesheet.section = section.id
    WHERE
      ${whereClause}
    GROUP BY
      worker_timesheet.entry_id,
      worker_timesheet.product_name,
      worker_timesheet.section,
      worker_timesheet.shift,
      worker_timesheet.date_time
    ORDER BY worker_timesheet.worker ASC
  `;
let connection   
  try {
    connection = await getPoolConnection();
    const results = await executeQuery(connection,query);
    console.log('Query results ota:', results);
    
    const data = {
      timesheet: results,
    };
    
    res.json(data); // Send response back to client 
  } catch (error) {
    console.error('Error executing MySQL query: ', error);
    res.status(500).json({ error: 'Internal Server Error' });
  } finally {
    if (connection) {
      connection.end();
    }
  }
});



//default data
/**
 * @swagger
 * /getemployeetimesheetdatanbraidota:
 *   post:
 *     summary: Get Employee Timesheet Data
 *     description: Retrieves employee timesheet data based on the provided filters.
 *     tags:
 *       - Timesheet
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             properties:
 *               product_name:
 *                 type: string
 *                 description: The name of the product.
 *               shift:
 *                 type: string
 *                 description: The shift.
 *               line_no:
 *                 type: string
 *                 description: The line number.
 *               section:
 *                 type: string
 *                 description: The section.
 *               fromdate:
 *                 type: string
 *                 format: date
 *                 description: The start date for the timesheet data.
 *               todate:
 *                 type: string
 *                 format: date
 *                 description: The end date for the timesheet data.
 *     responses:
 *       200:
 *         description: Successful response with timesheet data.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 timesheet:
 *                   type: array
 *                   items:
 *                     type: object
 *                     properties:
 *                       entry_id:
 *                         type: integer
 *                       product_name:
 *                         type: string
 *                       section:
 *                         type: string
 *                       shift:
 *                         type: string
 *                       date_time:
 *                         type: string
 *                       worker:
 *                         type: string
 *                       value_sum:
 *                         type: number
 *       500:
 *         description: Internal Server Error.
 *         content:
 *           text/plain:
 *             schema:
 *               type: string
 *               example: "Internal Server Error"
 *
 * @function
 * @name getEmployeeTimesheetData
 * @memberof module:Routes/Timesheet
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with the database query.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */  
app.get('/getdefaultemployeetimesheetdatanbraidota/:roleId/:userid',  authenticateJWT, async (req, res) => {
  const { roleId, userid } = req.params;
  console.log('roleid:', roleId);
  console.log('userid:', userid);

  const date = new Date().toLocaleDateString('en-GB', { timeZone: 'Africa/Lagos' });
  const parts = date.split('/');
  const formattedDay = parts[0].padStart(2, '0');
  const formattedMonth = parts[1].padStart(2, '0');
  const year = parts[2];
  const date1 = `${formattedDay}-${formattedMonth}-${year}`;

  let query = `
    SELECT
      worker_timesheet.*, section.section_name, item_masterr.item_description,
      SUM(
        worker_timesheet.HOUR1 + worker_timesheet.HOUR2 + worker_timesheet.HOUR3 +
        worker_timesheet.HOUR4 + worker_timesheet.HOUR5 + worker_timesheet.HOUR6 +
        worker_timesheet.HOUR7 + worker_timesheet.HOUR8 + worker_timesheet.HOUR9 +
        worker_timesheet.HOUR10 + worker_timesheet.HOUR11
      ) AS value_sum
    FROM worker_timesheet
    LEFT JOIN item_masterr ON worker_timesheet.product_name = item_masterr.id
    LEFT JOIN section ON worker_timesheet.section = section.id
    WHERE worker_timesheet.date_time = ?
  `;

  if (roleId === '3') {
    query += ' AND worker_timesheet.operator_id = ?';
  }

  query += `
    GROUP BY
      worker_timesheet.entry_id,
      worker_timesheet.product_name,
      worker_timesheet.section,
      worker_timesheet.shift,
      worker_timesheet.date_time
    ORDER BY worker_timesheet.worker ASC
  `;

  console.log('query:', query);

  const queryParams = roleId === '3' ? [date1, userid] : [date1];
  let connection;
  try {
    connection = await getPoolConnection();
    const results = await executeQuery(connection,query, queryParams);
    const data = {
      timesheet: results,
    };
    res.json(data); 
  } catch (error) {
    console.error('Error executing query:', error);
    res.status(500).json({ error: 'Internal Server Error' });
  } finally {
    if (connection) {
      connection.end();
    }
  }
});


//default data for operator login
/**
 * @swagger
 * /getdefaultemployeetimesheetdatanbraidotaop/{roleId}/{userid}:
 *   get:
 *     summary: Get Default Employee Timesheet Data NBRAIDOTAOP.
 *     description: Retrieves the default timesheet data for a specific employee based on their role and user ID.
 *     tags:
 *       - Timesheet
 *     parameters:
 *       - in: path
 *         name: roleId
 *         required: true
 *         schema:
 *           type: string
 *         description: The role ID of the employee.
 *       - in: path
 *         name: userid
 *         required: true
 *         schema:
 *           type: string
 *         description: The user ID of the employee.
 *     responses:
 *       200:
 *         description: Successful response with default employee timesheet data.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 timesheet:
 *                   type: array
 *                   items:
 *                     type: object
 *                     properties:
 *                       entry_id:
 *                         type: string
 *                         description: The entry ID of the timesheet.
 *                         example: "1"
 *                       product_name:
 *                         type: string
 *                         description: The name of the product.
 *                         example: "Product A"
 *                       section_name:
 *                         type: string
 *                         description: The name of the section.
 *                         example: "Section 1"
 *                       value_sum:
 *                         type: number
 *                         description: The sum of hours worked for the timesheet entry.
 *                         example: 40
 *       500:
 *         description: Internal Server Error.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: "Internal Server Error"
 *
 * @function
 * @name getDefaultEmployeeTimesheetDataNBRAIDOTAOP
 * @memberof module:Routes/Timesheet
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with the database query.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
app.get('/getdefaultemployeetimesheetdatanbraidotaop/:roleId/:userid',  authenticateJWT, async (req, res) => {
  const { roleId, userid } = req.params;
  console.log('roleid:', roleId);
  console.log('userid:', userid);

  const date = new Date().toLocaleDateString('en-GB', { timeZone: 'Africa/Lagos' });
  const parts = date.split('/');
  const formattedDay = parts[0].padStart(2, '0');
  const formattedMonth = parts[1].padStart(2, '0');
  const year = parts[2];
  const date1 = `${formattedDay}-${formattedMonth}-${year}`;

  let query = `
    SELECT
      worker_timesheet.*, section.section_name, item_masterr.item_description,
      SUM(
        worker_timesheet.HOUR1 + worker_timesheet.HOUR2 + worker_timesheet.HOUR3 +
        worker_timesheet.HOUR4 + worker_timesheet.HOUR5 + worker_timesheet.HOUR6 +
        worker_timesheet.HOUR7 + worker_timesheet.HOUR8 + worker_timesheet.HOUR9 +
        worker_timesheet.HOUR10 + worker_timesheet.HOUR11
      ) AS value_sum
    FROM worker_timesheet
    LEFT JOIN item_masterr ON worker_timesheet.product_name = item_masterr.id
    LEFT JOIN section ON worker_timesheet.section = section.id
    WHERE worker_timesheet.date_time = ? 
      AND worker_timesheet.operator_id = ?
  `;

  query += `
    GROUP BY
      worker_timesheet.entry_id,
      worker_timesheet.product_name,
      worker_timesheet.section,
      worker_timesheet.shift,
      worker_timesheet.date_time
    ORDER BY worker_timesheet.worker ASC
  `;
 let connection;
  try {
    connection = await getPoolConnection();
    const results = await executeQuery(connection,query, [date1, userid]);
    const data = {
      timesheet: results,
    };
    res.json(data); // Send response back to client
  } catch (error) {
    console.error('Error executing query:', error);
    res.status(500).json({ error: 'Internal Server Error' });
  } finally {
    if (connection) {
      connection.end();
    }
  }
});



// API Endpoint to handle edit requests
/**
 * @swagger
 * /updatenbraidotadata:
 *   post:
 *     summary: Update NBRAIDOTA Data.
 *     description: Update the NBRAIDOTA data for a specific record in the worker timesheet.
 *     tags:
 *       - NBRAIDOTA Data
 *     security:
 *       - JWTAuth: []
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             properties:
 *               id:
 *                 type: string
 *                 description: The ID of the record to update.
 *               product_name:
 *                 type: string
 *                 description: The name of the product.
 *               section:
 *                 type: string
 *                 description: The section of the worker timesheet.
 *               line_no:
 *                 type: string
 *                 description: The line number of the worker timesheet.
 *             example:
 *               id: "1"
 *               product_name: "Product A"
 *               section: "Section 1"
 *               line_no: "Line 1"
 *     responses:
 *       200:
 *         description: Successful response with status and message.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 status:
 *                   type: string
 *                   example: "Success"
 *                 message:
 *                   type: string
 *                   example: "Record updated successfully"
 *       404:
 *         description: Record not found.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 status:
 *                   type: string
 *                   example: "Error"
 *                 message:
 *                   type: string
 *                   example: "Record not found"
 *       500:
 *         description: Internal Server Error.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 status:
 *                   type: string
 *                   example: "Error"
 *                 message:
 *                   type: string
 *                   example: "Internal server error"
 *
 * @function
 * @name updateNBRAIDOTAData
 * @memberof module:Routes/NBRAIDOTAData
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with updating the record.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
app.post('/updatenbraidotadata', authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    const eid = req.body.id;
    const product_name = req.body.product_name;
    const section = req.body.section;
    const line = req.body.line_no;

    console.log('eid:', eid);
    console.log('product_name:', product_name);
    console.log('section:', section);
    console.log('line:', line);

    // Update the record in the 'worker_timesheet' table
    const sql = `UPDATE worker_timesheet SET product_name=?, section=?, line=? WHERE id=?`;

    const result = await executeQuery(connection,sql, [product_name, section, line, eid]);

    if (result.affectedRows === 0) {
      return res.status(404).json({ status: 'Error', message: 'Record not found' });
    }

    return res.json({ status: 'Success', message: 'Record updated successfully' });
  } catch (err) {
    console.error('Error updating employee timesheet:', err);
    return res.status(500).json({ status: 'Error', message: 'Internal server error' });
  } finally {
    if (connection) {
      connection.release();
    }
  }
});

//get employees for non braid employeetimesheet add
app.post('/getaddemployeetimesheetfilterdatanbraidota',  authenticateJWT, (req, res) => {
  // Extract data from the request body
  const shift = req.body.shift;
  const hour = req.body.hour;
  const line = req.body.line_no;
  const section = req.body.section;
  const sites = req.body.site;

  console.log('Received data:');
  console.log('Line No:', line);
  console.log('Section:', section);
  console.log('Shift:', shift);
  console.log('Hour:', hour);
  console.log('Site:', sites);

  let date1 = '';
  let sectionName = ''; // Initialize sectionName

  // Check if the site is 'ota'
  if (sites === 'ota') {
    // Query to fetch data from 'employees_ota' table
    const query1 = 'SELECT * FROM employees_ota ORDER BY id ASC LIMIT 1';
    
    // Execute query1 to get the date value
    db.query(query1, (error1, results1, fields) => {
      if (error1) {
        console.error('Error executing query1:', error1);
        res.status(500).json({ error: 'Internal Server Error' });
      } else {
        // Set the date1 variable with the fetched date value
        date1 = results1[0].date;
        //console.log('date for ota:', date1);

        // Check if data already exists for the specified parameters
        const checkQuery = `
  SELECT *
  FROM worker_timesheet
  WHERE line = '${line}' 
  AND section = '${section}' 
  AND shift = '${shift}' 
  AND date_time = '${date1}' 
  AND ${hour} > 0
  AND site = '${sites}';
`;

        //console.log('Check Query:', checkQuery);
        //console.log('Values:', [line, section, shift, date1, sites]);

        // Execute checkQuery to see if data exists
        db.query(checkQuery,  (checkError, checkResults) => {
          if (checkError) {
            console.error('Error executing checkQuery:', checkError);
            res.status(500).json({ error: 'Internal Server Error' });
          } else {
           
            // Check if data exists
            const dataExists = checkResults.length > 0;
            //console.log('dataExists:', dataExists);
            //console.log('Check Results:', checkResults);
            /* if (dataExists) {
              // Data already exists, send a message back to the client along with additional information
              const message = `You have already inserted data for product, line ${line}, section ${section}, and ${hour} hour. For editing, click on `;
              const additionalData = {
                sectionname: sectionName,
                tdate: 0,
                sites,
                hour,
                line,
                section,
                shiftt: shift,
              };
            
              res.status(200).json({ message, ...additionalData });
            } */
            
            if (dataExists) {
              // Fetch section name based on sectionId
              const querySectionName = `
                SELECT section_name
                FROM section
                WHERE id = ?;
              `;
            
              db.query(querySectionName, [section], (errorSection, resultsSection) => {
                if (errorSection) {
                  console.error('Error fetching section name:', errorSection);
                  res.status(500).json({ error: 'Internal Server Error' });
                } else {
                  // Extract sectionName from the query results
                  const sectionName = resultsSection.length > 0 ? resultsSection[0].section_name : '';
            
                  // Continue with constructing the response
                  const message = `You have already inserted data for product, line ${line}, section ${sectionName}, and hour ${hour}. For editing, click on `;
                  const additionalData = {
                    sectionname: sectionName,
                    tdate: 0,
                    sites,
                    hour,
                    line,
                    section,
                    shiftt: shift,
                  };
            
                  res.status(200).json({ message, ...additionalData });
                }
              });
            } else {
              // Continue with the main logic

              // Query to fetch data from 'operator_assign' table
              const query2 = `
                SELECT operator_assign.*, geopos_users.name, operator_assign.name_id as opid
                FROM operator_assign
                LEFT JOIN geopos_users ON operator_assign.name_id = geopos_users.id
                WHERE operator_assign.line = ? 
                AND operator_assign.section = ? 
                AND operator_assign.shift = ? 
                AND operator_assign.category_type = 'NBRAID';
              `;
              db.query(query2, [line, section, shift], (error2, results2, fields) => {
                if (error2) {
                  console.error('Error executing query2:', error2);
                  res.status(500).json({ error: 'Internal Server Error' });
                } else {
                  // Execute query4 to fetch the section name
                  const sectionId = section; // Assuming 'section' holds the section_id
                  const query4 = `
                    SELECT section_name
                    FROM section
                    WHERE id = ?;
                  `;
                  db.query(query4, [sectionId], (error4, results4, fields) => {
                    if (error4) {
                      console.error('Error fetching section name:', error4);
                      res.status(500).json({ error: 'Internal Server Error' });
                    } else {
                      if (results4.length > 0) {
                        sectionName = results4[0].section_name;
                        //console.log('Section Name:', sectionName);
                      }
      
                      // Query to check if data exists in 'worker_timesheet'
                      const query3 = `
                        SELECT *
                        FROM worker_timesheet
                        WHERE line = ? 
                        AND section = ? 
                        AND shift = ? 
                        AND date_time = ? 
                        AND ? > 0 
                        AND site = ?;
                      `;

                      db.query(query3, [line, section, shift, date1, hour, sites], (error3, results3, fields) => {
                        if (error3) {
                          console.error('Error executing query3:', error3);
                          res.status(500).json({ error: 'Internal Server Error' });
                        } else {
                          // Log the results of query3 to the console
                          //console.log('Query3 Results:', results3);

                          // If no data exists in 'worker_timesheet', execute additional query
                          if (results3.length === 0) {
                            // Query to fetch data from 'employees_ota' based on specific conditions
                            const query9 = `
  SELECT *
  FROM employees_ota
  WHERE section_id = ? 
  AND line = ? 
  AND roleid = '1' 
  AND passive_type = 'ACT' 
  AND workertype = 'DIRECT' 
  AND shift = ? 
  AND category_type = 'NBRAID'
  ORDER BY name;
`;

db.query(query9, [section, line, shift], (error9, results9) => {
  if (error9) {
    console.error('Error executing query9:', error9);
    res.status(500).json({ error: 'Internal Server Error' });
  } else {
    // Log the results of query9 to the console
    console.log('Query9 Results:', results9);

    // Initialize the data object outside the loop
    const data = {
      op: results2,
      filteredResults: [], // Initialize filteredResults as an empty array
      abs: [], // Initialize abs as an empty array for absent entryid values
      additionalResults: [], // Initialize additionalResults as an empty array for 'P' case
      sectionname: sectionName, // Set sectionName here
      tdate: 0,
      sites,
      hour,
      line,
      section,
      shiftt: shift,
    };

    // Function to execute the inner query and handle the result
    const executeInnerQuery = (row) => {
      return new Promise((resolve, reject) => {
        const queryInner = `
          SELECT * 
          FROM worker_timesheet 
          WHERE entry_id = ? 
          AND ${hour} > 0 
          AND date_time = ?;
        `;
    
        console.log('Inner Query:', queryInner); // Log the SQL query
    
        db.query(queryInner, [row.entryid, date1], (errorInner, wrk) => {
          if (errorInner) {
            console.error('Error executing worker_timesheet query:', errorInner);
            reject(errorInner);
          } else {
            const row1 = wrk.length; // Use the length property for the number of rows
            console.log('row1:', row1);
    
            if (row1 === 0) {
              // Include the entire 'row' object in filteredResults for 'P' case
              data.filteredResults.push(row);
            } else {
              // Handle the case when rows are found in the inner query
              // Add your logic here for the 'else' condition
    
              // Extract relevant information from the query 9 results for 'non-P' case
              const { name } = row;
    
              // Include the relevant information in additionalResults for 'non-P' case
              data.additionalResults.push({ name });
            }
    
            resolve();
          }
        });
      });
    };

    // Array to store promises for inner queries
    const innerQueryPromises = [];

    results9.forEach((row) => {
      const entryId = row.entryid;
      if (row.status === 'P') {
        // Execute the inner query and push the promise to the array
        innerQueryPromises.push(executeInnerQuery(row));
      } else {
        // Include the entryid in abs for 'non-P' case
        data.abs.push(entryId);
      }
    });

    // Wait for all inner queries to complete before sending the response
    Promise.all(innerQueryPromises)
      .then(() => {
        // Send the modified 'data' object as a response
        res.status(200).json(data);
      })
      .catch((error) => {
        console.error('Error in inner queries:', error);
        res.status(500).json({ error: 'Internal Server Error' });
      });
  }
});
                          } else {
                            // Data already exists in 'worker_timesheet'
                            const data = {
                              op: results2,
                              filteredResults: results3, // Include results from query3
                              sectionname: sectionName, // Set sectionName here
                              tdate: 0,
                              sites,
                              hour,
                              line,
                              section,
                              shiftt: shift,
                            };

                            // Send the 'data' object as a response with the results of query3
                            res.status(200).json(data);
                          }
                        }
                      });
                    }
                  });
                }
              });
            }
          }
        });
      }
    });
  } else if (sites === 'ikeja') {
    // Query to fetch data from 'geopos_employees' table
    const query5 = 'SELECT * FROM geopos_employees ORDER BY id ASC LIMIT 1';
    
    // Execute query5 to get the date value
    db.query(query5, (error5, results5, fields) => {
      if (error5) {
        console.error('Error executing query5:', error5);
        res.status(500).json({ error: 'Internal Server Error' });
      } else {
        // Set the date1 variable with the fetched date value
        date1 = results5[0].date;
        console.log('date for ikeja:', date1);

       // Check if data already exists for the specified parameters
       const checkQuery = `
       SELECT *
       FROM worker_timesheet
       WHERE line = '${line}' 
       AND section = '${section}' 
       AND shift = '${shift}' 
       AND date_time = '${date1}' 
       AND ${hour} > 0
       AND site = '${sites}';
     `;
     
             console.log('Check Query:', checkQuery);
             //console.log('Values:', [line, section, shift, date1, sites]);
     
             // Execute checkQuery to see if data exists
             db.query(checkQuery,  (checkError, checkResults) => {
               if (checkError) {
                 console.error('Error executing checkQuery:', checkError);
                 res.status(500).json({ error: 'Internal Server Error' });
               } else {
                
                 // Check if data exists
                 const dataExists = checkResults.length > 0;
                 console.log('dataExists:', dataExists);
                 console.log('Check Results:', checkResults);
                 if (dataExists) {
                  // Fetch section name based on sectionId
                  const querySectionName = `
                    SELECT section_name
                    FROM section
                    WHERE id = ?;
                  `;
                
                  db.query(querySectionName, [section], (errorSection, resultsSection) => {
                    if (errorSection) {
                      console.error('Error fetching section name:', errorSection);
                      res.status(500).json({ error: 'Internal Server Error' });
                    } else {
                      // Extract sectionName from the query results
                      const sectionName = resultsSection.length > 0 ? resultsSection[0].section_name : '';
                
                      // Continue with constructing the response
                      const message = `You have already inserted data for product, line ${line}, section ${sectionName}, and hour ${hour}. For editing, click on `;
                      const additionalData = {
                        sectionname: sectionName,
                        tdate: 0,
                        sites,
                        hour,
                        line,
                        section,
                        shiftt: shift,
                      };
                
                      res.status(200).json({ message, ...additionalData });
                    }
                  });
                }  else {
              // Continue with the main logic

              // Query to fetch data from 'operator_assign_ikeja' table
              const query6 = `
                SELECT operator_assign_ikeja.*, geopos_users.name, operator_assign_ikeja.operator_id as opid
                FROM operator_assign_ikeja
                LEFT JOIN geopos_users ON operator_assign_ikeja.operator_id = geopos_users.id
                WHERE operator_assign_ikeja.line = ? 
                AND operator_assign_ikeja.section = ? 
                AND operator_assign_ikeja.shift = ? 
                AND operator_assign_ikeja.category_type = 'NBRAID';
              `;
              db.query(query6, [line, section, shift], (error6, results6, fields) => {
                if (error6) {
                  console.error('Error executing query6:', error6);
                  res.status(500).json({ error: 'Internal Server Error' });
                } else {
                  // Execute query4 to fetch the section name
                  const sectionId = section; // Assuming 'section' holds the section_id
                  const query7 = `
                    SELECT section_name
                    FROM section
                    WHERE id = ?;
                  `;
                  db.query(query7, [sectionId], (error7, results7, fields) => {
                    if (error7) {
                      console.error('Error fetching section name:', error7);
                      res.status(500).json({ error: 'Internal Server Error' });
                    } else {
                      if (results7.length > 0) {
                        sectionName = results7[0].section_name;
                        console.log('Section Name:', sectionName);
                      }
      
                      // Query to check if data exists in 'worker_timesheet'
                      const query3 = `
                        SELECT *
                        FROM worker_timesheet
                        WHERE line = ? 
                        AND section = ? 
                        AND shift = ? 
                        AND date_time = ? 
                        AND ? > 0 
                        AND site = ?;
                      `;

                      db.query(query3, [line, section, shift, date1, hour, sites], (error3, results3, fields) => {
                        if (error3) {
                          console.error('Error executing query3:', error3);
                          res.status(500).json({ error: 'Internal Server Error' });
                        } else {
                          // Log the results of query3 to the console
                          console.log('Query3 Results:', results3);

                          // If no data exists in 'worker_timesheet', execute additional query
                          if (results3.length === 0) {
                            // Query to fetch data from 'geopos_employees' based on specific conditions
                            /* const query10 = `
                              SELECT *
                              FROM geopos_employees
                              WHERE section_id = ? 
                              AND line = ? 
                              AND roleid = '1' 
                              AND passive_type = 'ACT' 
                              AND workertype = 'DIRECT' 
                              AND shift = ? 
                              AND category_type = 'NBRAID'
                              ORDER BY name;
                            `;

                            db.query(query10, [section, line, shift], (error10, results10) => {
                              if (error10) {
                                console.error('Error executing query10:', error10);
                                res.status(500).json({ error: 'Internal Server Error' });
                              } else {
                                // Log the results of query10 to the console
                                console.log('Query10 Results:', results10);

                                // Include the results of query10 as filteredResults
                                const data = {
                                  op: results6,
                                  filteredResults: results10, // Include results from query10
                                  sectionname: sectionName, // Set sectionName here
                                  tdate: 0,
                                  sites,
                                  hour,
                                  line,
                                  section,
                                  shiftt: shift,
                                };

                                // Send the 'data' object as a response with the results of query10
                                res.status(200).json(data);
                              }
                            }); */
                            const query10 = `
                              SELECT *
                              FROM geopos_employees
                              WHERE section_id = ? 
                              AND line = ? 
                              AND roleid = '1' 
                              AND passive_type = 'ACT' 
                              AND workertype = 'DIRECT' 
                              AND shift = ? 
                              AND category_type = 'NBRAID'
                              ORDER BY name;
                            `;

                            db.query(query10, [section, line, shift], (error10, results10) => {
                              if (error10) {
                                console.error('Error executing query10:', error10);
                                res.status(500).json({ error: 'Internal Server Error' });
                              } else {
                                // Log the results of query10 to the console
                                console.log('Query10 Results:', results10);

    // Initialize the data object outside the loop
    const data = {
      op: results6,
      filteredResults: [], // Initialize filteredResults as an empty array
      abs: [], // Initialize abs as an empty array for absent entryid values
      additionalResults: [], // Initialize additionalResults as an empty array for 'P' case
      sectionname: sectionName, // Set sectionName here
      tdate: 0,
      sites,
      hour,
      line,
      section,
      shiftt: shift,
    };

    // Function to execute the inner query and handle the result
    const executeInnerQuery = (row) => {
      return new Promise((resolve, reject) => {
        const queryInner = `
          SELECT * 
          FROM worker_timesheet 
          WHERE entry_id = ? 
          AND ${hour} > 0 
          AND date_time = ?;
        `;

        console.log('Inner Query:', queryInner); // Log the SQL query

        db.query(queryInner, [row.entryid, date1], (errorInner, wrk) => {
          if (errorInner) {
            console.error('Error executing worker_timesheet query:', errorInner);
            reject(errorInner);
          } else {
            const row1 = wrk.length; // Use the length property for the number of rows
            console.log('row1:', row1);

            if (row1 === 0) {
              // Include the entire 'row' object in filteredResults for 'P' case
              data.filteredResults.push(row);
            } else {
              // Handle the case when rows are found in the inner query
              // Add your logic here for the 'else' condition
    
              // Extract relevant information from the query 9 results for 'non-P' case
              const { name } = row;
    
              // Include the relevant information in additionalResults for 'non-P' case
              data.additionalResults.push({ name });
            }
            resolve();
          }
        });
      });
    };

    // Array to store promises for inner queries
    const innerQueryPromises = [];

    results10.forEach((row) => {
      const entryId = row.entryid;
      if (row.status === 'P') {
        // Execute the inner query and push the promise to the array
        innerQueryPromises.push(executeInnerQuery(row));
      } else {
        // Include the entryid in abs for 'non-P' case
        data.abs.push(entryId);
      }
    });

    // Wait for all inner queries to complete before sending the response
    Promise.all(innerQueryPromises)
      .then(() => {
        // Send the modified 'data' object as a response
        res.status(200).json(data);
      })
      .catch((error) => {
        console.error('Error in inner queries:', error);
        res.status(500).json({ error: 'Internal Server Error' });
      });
  }
});


                          } else {
                            // Data already exists in 'worker_timesheet'
                            const data = {
                              op: results6,
                              filteredResults: results3, // Include results from query3
                              sectionname: sectionName, // Set sectionName here
                              tdate: 0,
                              sites,
                              hour,
                              line,
                              section,
                              shiftt: shift,
                            };

                            // Send the 'data' object as a response with the results of query3
                            res.status(200).json(data);
                          }
                        }
                      });
                    }
                  });
                }
              });
            }
          }
        });
      }
    });
  }
});

//get employees for non braid employeetimesheet add op login
app.post('/getaddemployeetimesheetfilterdatanbraidotaoplogin/:userid',  authenticateJWT, (req, res) => {
  // Extract data from the request body
  const shift = req.body.shift;
  const hour = req.body.hour;
  const line = req.body.line_no;
  const section = req.body.section;
  const { userid } = req.params;
  

  console.log('Received data:');
  console.log('Line No:', line);
  console.log('Section:', section);
  console.log('Shift:', shift);
  console.log('Hour:', hour);
  console.log('userid:', userid);

  const date = new Date().toLocaleDateString('en-GB', { timeZone: 'Africa/Lagos' });
  const parts = date.split('/');
  const day = parts[0].padStart(2, '0');
  const month = parts[1].padStart(2, '0');
  const year = parts[2];
  const currentMonth = `${month}-${year}`;
  const currentdate = `${day}-${month}-${year}`;

  let date1 = '';
  let sectionName = ''; // Initialize sectionName
 

  // Execute the MySQL query
  db.query(`SELECT * FROM geopos_users WHERE id='${userid}'`, (error, results, fields) => {
    if (error) {
      console.error('Error executing MySQL query:', error);
      res.status(500).send('Internal Server Error');
    } else {
      // Retrieve the necessary data from the MySQL results
      const site = results[0].production_type;
      const ctype = results[0].category_type;
      console.log('site:', site);
      console.log('ctype:', ctype);

     
        if (site === 'ota' && ctype ==='NBRAID') {
          // Query to fetch data from 'employees_ota' table
          const query1 = 'SELECT * FROM employees_ota ORDER BY id ASC LIMIT 1';
          
          // Execute query1 to get the date value
          db.query(query1, (error1, results1, fields) => {
            if (error1) {
              console.error('Error executing query1:', error1);
              res.status(500).json({ error: 'Internal Server Error' });
            } else {
              // Set the date1 variable with the fetched date value
              date1 = results1[0].date;
              //console.log('date for ota:', date1);

              // Check if data already exists for the specified parameters
              const checkQuery = `
              SELECT *
              FROM worker_timesheet
              WHERE line = '${line}' 
              AND section = '${section}' 
              AND shift = '${shift}' 
              AND date_time = '${date1}' 
              AND ${hour} > 0
              AND site = '${site}';
            `;

              //console.log('Check Query:', checkQuery);
              //console.log('Values:', [line, section, shift, date1, site]);

              // Execute checkQuery to see if data exists
              db.query(checkQuery,  (checkError, checkResults) => {
                if (checkError) {
                  console.error('Error executing checkQuery:', checkError);
                  res.status(500).json({ error: 'Internal Server Error' });
                } else {
                
                  // Check if data exists
                  const dataExists = checkResults.length > 0;
                  
                  if (dataExists) {
                    // Fetch section name based on sectionId
                    const querySectionName = `
                      SELECT section_name
                      FROM section
                      WHERE id = ?;
                    `;
                  
                    db.query(querySectionName, [section], (errorSection, resultsSection) => {
                      if (errorSection) {
                        console.error('Error fetching section name:', errorSection);
                        res.status(500).json({ error: 'Internal Server Error' });
                      } else {
                        // Extract sectionName from the query results
                        const sectionName = resultsSection.length > 0 ? resultsSection[0].section_name : '';
                  
                        // Continue with constructing the response
                        const message = `You have already inserted data for product, line ${line}, section ${sectionName}, and hour ${hour}. For editing, click on `;
                        const additionalData = {
                          sectionname: sectionName,
                          tdate: 0,
                          site,
                          hour,
                          line,
                          section,
                          shiftt: shift,
                        };
                  
                        res.status(200).json({ message, ...additionalData });
                      }
                    });
                  } else {
                    // Continue with the main logic

                    // Query to fetch data from 'operator_assign' table
                    const query2 = `
                      SELECT operator_assign.*, geopos_users.name, operator_assign.name_id as opid
                      FROM operator_assign
                      LEFT JOIN geopos_users ON operator_assign.name_id = geopos_users.id
                      WHERE operator_assign.line = ? 
                      AND operator_assign.section = ? 
                      AND operator_assign.shift = ? 
                      AND operator_assign.category_type = 'NBRAID';
                    `;
                    db.query(query2, [line, section, shift], (error2, results2, fields) => {
                      if (error2) {
                        console.error('Error executing query2:', error2);
                        res.status(500).json({ error: 'Internal Server Error' });
                      } else {
                        // Execute query4 to fetch the section name
                        const sectionId = section; // Assuming 'section' holds the section_id
                        const query4 = `
                          SELECT section_name
                          FROM section
                          WHERE id = ?;
                        `;
                        db.query(query4, [sectionId], (error4, results4, fields) => {
                          if (error4) {
                            console.error('Error fetching section name:', error4);
                            res.status(500).json({ error: 'Internal Server Error' });
                          } else {
                            if (results4.length > 0) {
                              sectionName = results4[0].section_name;
                              //console.log('Section Name:', sectionName);
                            }
            
                            // Query to check if data exists in 'worker_timesheet'
                            const query3 = `
                              SELECT *
                              FROM worker_timesheet
                              WHERE line = ? 
                              AND section = ? 
                              AND shift = ? 
                              AND date_time = ? 
                              AND ? > 0 
                              AND site = ?;
                            `;

                            db.query(query3, [line, section, shift, date1, hour, site], (error3, results3, fields) => {
                              if (error3) {
                                console.error('Error executing query3:', error3);
                                res.status(500).json({ error: 'Internal Server Error' });
                              } else {
                                // Log the results of query3 to the console
                                //console.log('Query3 Results:', results3);

                                // If no data exists in 'worker_timesheet', execute additional query
                                if (results3.length === 0) {
                                  // Query to fetch data from 'employees_ota' based on specific conditions
                                  const query9 = `
                                  SELECT *
                                  FROM employees_ota
                                  WHERE section_id = ? 
                                  AND line = ? 
                                  AND roleid = '1' 
                                  AND passive_type = 'ACT' 
                                  AND workertype = 'DIRECT' 
                                  AND shift = ? 
                                  AND category_type = 'NBRAID'
                                  ORDER BY name;
                                `;

                                db.query(query9, [section, line, shift], (error9, results9) => {
                                  if (error9) {
                                    console.error('Error executing query9:', error9);
                                    res.status(500).json({ error: 'Internal Server Error' });
                                  } else {
                                    // Log the results of query9 to the console
                                    console.log('Query9 Results:', results9);

                                    // Initialize the data object outside the loop
                                    const data = {
                                      op: results2,
                                      filteredResults: [], // Initialize filteredResults as an empty array
                                      abs: [], // Initialize abs as an empty array for absent entryid values
                                      additionalResults: [], // Initialize additionalResults as an empty array for 'P' case
                                      sectionname: sectionName, // Set sectionName here
                                      tdate: 0,
                                      site,
                                      hour,
                                      line,
                                      section,
                                      shiftt: shift,
                                    };

                                    // Function to execute the inner query and handle the result
                                    const executeInnerQuery = (row) => {
                                      return new Promise((resolve, reject) => {
                                        const queryInner = `
                                          SELECT * 
                                          FROM worker_timesheet 
                                          WHERE entry_id = ? 
                                          AND ${hour} > 0 
                                          AND date_time = ?;
                                        `;
                                    
                                        console.log('Inner Query:', queryInner); // Log the SQL query
                                    
                                        db.query(queryInner, [row.entryid, date1], (errorInner, wrk) => {
                                          if (errorInner) {
                                            console.error('Error executing worker_timesheet query:', errorInner);
                                            reject(errorInner);
                                          } else {
                                            const row1 = wrk.length; // Use the length property for the number of rows
                                            console.log('row1:', row1);
                                    
                                            if (row1 === 0) {
                                              // Include the entire 'row' object in filteredResults for 'P' case
                                              data.filteredResults.push(row);
                                            } else {
                                              // Handle the case when rows are found in the inner query
                                              // Add your logic here for the 'else' condition
                                    
                                              // Extract relevant information from the query 9 results for 'non-P' case
                                              const { name } = row;
                                    
                                              // Include the relevant information in additionalResults for 'non-P' case
                                              data.additionalResults.push({ name });
                                            }
                                    
                                            resolve();
                                          }
                                        });
                                      });
                                    };

                                    // Array to store promises for inner queries
                                    const innerQueryPromises = [];

                                    results9.forEach((row) => {
                                      const entryId = row.entryid;
                                      if (row.status === 'P') {
                                        // Execute the inner query and push the promise to the array
                                        innerQueryPromises.push(executeInnerQuery(row));
                                      } else {
                                        // Include the entryid in abs for 'non-P' case
                                        data.abs.push(entryId);
                                      }
                                    });

                                    // Wait for all inner queries to complete before sending the response
                                    Promise.all(innerQueryPromises)
                                      .then(() => {
                                        // Send the modified 'data' object as a response
                                        res.status(200).json(data);
                                      })
                                      .catch((error) => {
                                        console.error('Error in inner queries:', error);
                                        res.status(500).json({ error: 'Internal Server Error' });
                                      });
                                  }
                                });
                                } else {
                                  // Data already exists in 'worker_timesheet'
                                  const data = {
                                    op: results2,
                                    filteredResults: results3, // Include results from query3
                                    sectionname: sectionName, // Set sectionName here
                                    tdate: 0,
                                    site,
                                    hour,
                                    line,
                                    section,
                                    shiftt: shift,
                                  };

                                  // Send the 'data' object as a response with the results of query3
                                  res.status(200).json(data);
                                }
                              }
                            });
                          }
                        });
                      }
                    });
                  }
                }
              });
            }
          });
        } 
        else if (site === 'ikeja' && ctype ==='NBRAID') {
          // Query to fetch data from 'geopos_employees' table
          const query5 = 'SELECT * FROM geopos_employees ORDER BY id ASC LIMIT 1';
          
          // Execute query5 to get the date value
          db.query(query5, (error5, results5, fields) => {
            if (error5) {
              console.error('Error executing query5:', error5);
              res.status(500).json({ error: 'Internal Server Error' });
            } else {
              // Set the date1 variable with the fetched date value
              date1 = results5[0].date;
              console.log('date for ikeja:', date1);

            // Check if data already exists for the specified parameters
            const checkQuery = `
            SELECT *
            FROM worker_timesheet
            WHERE line = '${line}' 
            AND section = '${section}' 
            AND shift = '${shift}' 
            AND date_time = '${date1}' 
            AND ${hour} > 0
            AND site = '${site}';
          `;
          
                  console.log('Check Query:', checkQuery);
                  //console.log('Values:', [line, section, shift, date1, site]);
          
                  // Execute checkQuery to see if data exists
                  db.query(checkQuery,  (checkError, checkResults) => {
                    if (checkError) {
                      console.error('Error executing checkQuery:', checkError);
                      res.status(500).json({ error: 'Internal Server Error' });
                    } else {
                      
                      // Check if data exists
                      const dataExists = checkResults.length > 0;
                      console.log('dataExists:', dataExists);
                      console.log('Check Results:', checkResults);
                      if (dataExists) {
                        // Fetch section name based on sectionId
                        const querySectionName = `
                          SELECT section_name
                          FROM section
                          WHERE id = ?;
                        `;
                      
                        db.query(querySectionName, [section], (errorSection, resultsSection) => {
                          if (errorSection) {
                            console.error('Error fetching section name:', errorSection);
                            res.status(500).json({ error: 'Internal Server Error' });
                          } else {
                            // Extract sectionName from the query results
                            const sectionName = resultsSection.length > 0 ? resultsSection[0].section_name : '';
                      
                            // Continue with constructing the response
                            const message = `You have already inserted data for product, line ${line}, section ${sectionName}, and hour ${hour}. For editing, click on `;
                            const additionalData = {
                              sectionname: sectionName,
                              tdate: 0,
                              site,
                              hour,
                              line,
                              section,
                              shiftt: shift,
                            };
                      
                            res.status(200).json({ message, ...additionalData });
                          }
                        });
                      }  else {
                    // Continue with the main logic

                    // Query to fetch data from 'operator_assign_ikeja' table
                    const query6 = `
                      SELECT operator_assign_ikeja.*, geopos_users.name, operator_assign_ikeja.operator_id as opid
                      FROM operator_assign_ikeja
                      LEFT JOIN geopos_users ON operator_assign_ikeja.operator_id = geopos_users.id
                      WHERE operator_assign_ikeja.line = ? 
                      AND operator_assign_ikeja.section = ? 
                      AND operator_assign_ikeja.shift = ? 
                      AND operator_assign_ikeja.category_type = 'NBRAID';
                    `;
                    db.query(query6, [line, section, shift], (error6, results6, fields) => {
                      if (error6) {
                        console.error('Error executing query6:', error6);
                        res.status(500).json({ error: 'Internal Server Error' });
                      } else {
                        // Execute query4 to fetch the section name
                        const sectionId = section; // Assuming 'section' holds the section_id
                        const query7 = `
                          SELECT section_name
                          FROM section
                          WHERE id = ?;
                        `;
                        db.query(query7, [sectionId], (error7, results7, fields) => {
                          if (error7) {
                            console.error('Error fetching section name:', error7);
                            res.status(500).json({ error: 'Internal Server Error' });
                          } else {
                            if (results7.length > 0) {
                              sectionName = results7[0].section_name;
                              console.log('Section Name:', sectionName);
                            }
            
                            // Query to check if data exists in 'worker_timesheet'
                            const query3 = `
                              SELECT *
                              FROM worker_timesheet
                              WHERE line = ? 
                              AND section = ? 
                              AND shift = ? 
                              AND date_time = ? 
                              AND ? > 0 
                              AND site = ?;
                            `;

                            db.query(query3, [line, section, shift, date1, hour, site], (error3, results3, fields) => {
                              if (error3) {
                                console.error('Error executing query3:', error3);
                                res.status(500).json({ error: 'Internal Server Error' });
                              } else {
                                // Log the results of query3 to the console
                                console.log('Query3 Results:', results3);

                                // If no data exists in 'worker_timesheet', execute additional query
                                if (results3.length === 0) {
                                  // Query to fetch data from 'geopos_employees' based on specific conditions
                                 
                                  const query10 = `
                                    SELECT *
                                    FROM geopos_employees
                                    WHERE section_id = ? 
                                    AND line = ? 
                                    AND roleid = '1' 
                                    AND passive_type = 'ACT' 
                                    AND workertype = 'DIRECT' 
                                    AND shift = ? 
                                    AND category_type = 'NBRAID'
                                    ORDER BY name;
                                  `;

                                  db.query(query10, [section, line, shift], (error10, results10) => {
                                    if (error10) {
                                      console.error('Error executing query10:', error10);
                                      res.status(500).json({ error: 'Internal Server Error' });
                                    } else {
                                      // Log the results of query10 to the console
                                      console.log('Query10 Results:', results10);

                                    // Initialize the data object outside the loop
                                    const data = {
                                      op: results6,
                                      filteredResults: [], // Initialize filteredResults as an empty array
                                      abs: [], // Initialize abs as an empty array for absent entryid values
                                      additionalResults: [], // Initialize additionalResults as an empty array for 'P' case
                                      sectionname: sectionName, // Set sectionName here
                                      tdate: 0,
                                      site,
                                      hour,
                                      line,
                                      section,
                                      shiftt: shift,
                                    };

                                    // Function to execute the inner query and handle the result
                                    const executeInnerQuery = (row) => {
                                      return new Promise((resolve, reject) => {
                                        const queryInner = `
                                          SELECT * 
                                          FROM worker_timesheet 
                                          WHERE entry_id = ? 
                                          AND ${hour} > 0 
                                          AND date_time = ?;
                                        `;

                                        console.log('Inner Query:', queryInner); // Log the SQL query

                                        db.query(queryInner, [row.entryid, date1], (errorInner, wrk) => {
                                          if (errorInner) {
                                            console.error('Error executing worker_timesheet query:', errorInner);
                                            reject(errorInner);
                                          } else {
                                            const row1 = wrk.length; // Use the length property for the number of rows
                                            console.log('row1:', row1);

                                            if (row1 === 0) {
                                              // Include the entire 'row' object in filteredResults for 'P' case
                                              data.filteredResults.push(row);
                                            } else {
                                              // Handle the case when rows are found in the inner query
                                              // Add your logic here for the 'else' condition
                                    
                                              // Extract relevant information from the query 9 results for 'non-P' case
                                              const { name } = row;
                                    
                                              // Include the relevant information in additionalResults for 'non-P' case
                                              data.additionalResults.push({ name });
                                            }
                                            resolve();
                                          }
                                        });
                                      });
                                    };

                                    // Array to store promises for inner queries
                                    const innerQueryPromises = [];

                                    results10.forEach((row) => {
                                      const entryId = row.entryid;
                                      if (row.status === 'P') {
                                        // Execute the inner query and push the promise to the array
                                        innerQueryPromises.push(executeInnerQuery(row));
                                      } else {
                                        // Include the entryid in abs for 'non-P' case
                                        data.abs.push(entryId);
                                      }
                                    });

                                    // Wait for all inner queries to complete before sending the response
                                    Promise.all(innerQueryPromises)
                                      .then(() => {
                                        // Send the modified 'data' object as a response
                                        res.status(200).json(data);
                                      })
                                      .catch((error) => {
                                        console.error('Error in inner queries:', error);
                                        res.status(500).json({ error: 'Internal Server Error' });
                                      });
                                  }
                                });
                                } else {
                                  // Data already exists in 'worker_timesheet'
                                  const data = {
                                    op: results6,
                                    filteredResults: results3, // Include results from query3
                                    sectionname: sectionName, // Set sectionName here
                                    tdate: 0,
                                    site,
                                    hour,
                                    line,
                                    section,
                                    shiftt: shift,
                                  };

                                  // Send the 'data' object as a response with the results of query3
                                  res.status(200).json(data);
                                }
                              }
                            });
                          }
                        });
                      }
                    });
                  }
                }
              });
            }
          });
        }
        else if (site === 'both' && ctype ==='both') {
          date1 = currentdate;
        }

    }
  }); 
});

// Fetch target based on product 
app.get('/gettargetnbraid/:selectedProduct', authenticateJWT, async (req, res) => {
  const { selectedProduct } = req.params;
  const selectedSection = req.query.section; // Retrieve the section from the query parameters

  // Define the query as a constant
  const query = `
    SELECT target
    FROM item_section_ota
    WHERE section_id = ? AND item_id = ?;
  `;
  let connection;
  try {
    connection = await getPoolConnection();
    // Execute the query and await its result
    const results = await executeQuery(connection,query, [selectedSection, selectedProduct]);

    if (results.length > 0) {
      const target = results[0].target;
      res.json({ target });
    } else {
      res.status(404).json({ error: 'Data not found' });
    }
  } catch (error) {
    console.error('Error executing database query:', error);
    res.status(500).json({ error: 'Internal Server Error' });
  } finally {
    // Release the connection back to the pool in case of success or error
    if (connection) {
      connection.release();
      //console.log("Connection released");
    }
  }
});


//insert employeetimesheet new data
app.post('/insertemployeetimesheetnbraidotadata',authenticateJWT , async (req, res) => {
  const tableData = req.body;
  let date1;
  let joindate;
  let success = true; // Flag to track if any error occurs
  const errors = [];
  let connection;
  try {
     connection = await getPoolConnection();
    await Promise.all(tableData.map(async (data) => {
      const worker_names = data.worker_names;
      const emp_ids = data.emp_ids;
      const shifts = data.shifts;
      const user_id = data.op_id;
      const section = data.section;
      const product_name = data.product_name;
      const line = data.line;
      const sectionname = data.sectionname;
      const hour = data.hour;
      const target = data.target;
      const fg = data.fg;
      const completes = data.completes;
      const color = data.color;
      const sites = data.sites;

      // Add console logs for debugging or tracing
   //console.log('Processing data:', data);
  /* console.log('completes:', completes);
  console.log('target:', target);
  console.log('user_id:', user_id); */

      if (sites === 'ota') {
        const query = `SELECT * FROM employees_ota ORDER BY id ASC LIMIT 1`;
        try {
          const employeeResults = await executeQuery(connection,query);
          //console.log('Employee Results:', employeeResults);
          if (employeeResults.length > 0) {
            date1 = employeeResults[0].date;
            joindate = employeeResults[0].joindate;

            /* console.log('Date1:', date1);
            console.log('Join Date:', joindate); */

           // Split the date string into day, month, and year
const [day, month, year] = date1.split('-');

// Create a new Date using the components
const dayy1 = new Date(`${year}-${month}-${day}`);
//console.log('dayy1:', dayy1);

const formattedMonth = (dayy1.getMonth() + 1).toString().padStart(2, '0');
const formattedYear = dayy1.getFullYear();
const formattedDate = `${formattedMonth}-${formattedYear}`;

//console.log('Formatted Month-Year:', formattedDate);

const currentDate = new Date().toISOString();
//console.log('currentDate:', currentDate);

const milliseconds = dayy1.getTime();
const timestamp = Math.floor(milliseconds / 1000);
//console.log('timestamp:', timestamp);

            const query = `SELECT * FROM worker_timesheet
              WHERE product_name IN (?) AND line IN (?) AND section IN (?) AND shift IN (?) AND entry_id IN (?) AND date_time = ? AND site = ?`;

            const timesheetResults = await executeQuery(connection,query, [product_name, line, section, shifts, emp_ids, date1, sites]);

            //console.log('Timesheet Results:', timesheetResults);

            if (timesheetResults.length > 0) {
              const existingEntry = timesheetResults;
              const hr = hour[4];
              //console.log('hr:', hr);

              const postedTarget = target;
              //console.log('Posted target:', postedTarget);

              const resultTarget = existingEntry[0].target;
              //console.log('target:', resultTarget);

              const tar = parseFloat(target) + parseFloat(resultTarget);
              //console.log('tar:', tar);

              const updateQuery = `UPDATE worker_timesheet SET ${hour} = ?, target = ?
                WHERE product_name = ? AND line = ? AND section = ? AND shift = ?
                AND date_time = ? AND worker = ? AND entry_id = ?`;

              try {
                await executeQuery(connection,updateQuery, [completes, tar, product_name, line, section, shifts, date1, worker_names, emp_ids]);
              } catch (err) {
                console.error('Error updating entry: ' + err.stack);
                errors.push('Error updating entry: ' + err.message);
                success = false;
              }
            } else {
              const hr = hour[4];
              //console.log('hr:', hr);
              const insertQuery = `INSERT INTO worker_timesheet (product_name, line, section, shift, worker, entry_id, joindate, ${hour}, target, actual_target, date_time, time_stamp, mon, color_id, date, operator_id, site)
                VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`;

             
              console.log('Insert Query:', insertQuery);
              console.log('Insert Values:', [product_name, line, section, shifts, worker_names, emp_ids, joindate, completes, target, target, date1, timestamp, month, color, currentDate, user_id, sites]);


              try {
                await executeQuery(connection,insertQuery, [product_name, line, section, shifts, worker_names, emp_ids, joindate, completes, target, target, date1, timestamp, formattedDate, color, currentDate, user_id, sites]);
              } catch (err) {
                console.error('Error inserting new entry: ' + err.stack);
                errors.push('Error inserting new entry: ' + err.message);
                success = false;
              }
            }
          } else {
            console.error('No data found in employees_ota');
            errors.push('No data found in employees_ota');
            success = false;
          }
        } catch (err) {
          console.error('Error querying employees_ota: ' + err.stack);
          errors.push('Error querying employees_ota: ' + err.message);
          success = false;
        }
      } else if (sites === 'ikeja') {
        const query = `SELECT * FROM geopos_employees ORDER BY id ASC LIMIT 1`;
        try {
          const employeeResults = await executeQuery(connection,query);
          if (employeeResults.length > 0) {
            date1 = employeeResults[0].date;
            joindate = employeeResults[0].joindate;

            // Split the date string into day, month, and year
const [day, month, year] = date1.split('-');

// Create a new Date using the components
const dayy1 = new Date(`${year}-${month}-${day}`);
//console.log('dayy1:', dayy1);

const formattedMonth = (dayy1.getMonth() + 1).toString().padStart(2, '0');
const formattedYear = dayy1.getFullYear();
const formattedDate = `${formattedMonth}-${formattedYear}`;

//console.log('Formatted Month-Year:', formattedDate);

const currentDate = new Date().toISOString();
//console.log('currentDate:', currentDate);

const milliseconds = dayy1.getTime();
const timestamp = Math.floor(milliseconds / 1000);
//console.log('timestamp:', timestamp);

            const query = `SELECT * FROM worker_timesheet
              WHERE product_name IN (?) AND line IN (?) AND section IN (?) AND shift IN (?) AND entry_id IN (?) AND date_time = ? AND site = ?`;

            const timesheetResults = await executeQuery(connection,query, [product_name, line, section, shifts, emp_ids, date1, sites]);

            if (timesheetResults.length > 0) {
              const existingEntry = timesheetResults[0];
              const hr = hour[4];
              const tar = existingEntry.target + target;

              const updateQuery = `UPDATE worker_timesheet SET ${hour} = ?, target = ?
                WHERE product_name = ? AND line = ? AND section = ? AND shift = ?
                AND date_time = ? AND worker = ? AND entry_id = ?`;

              try {
                await executeQuery(connection,updateQuery, [completes, tar, product_name, line, section, shifts, date1, worker_names, emp_ids]);
              } catch (err) {
                console.error('Error updating entry: ' + err.stack);
                errors.push('Error updating entry: ' + err.message);
                success = false;
              }
            } else {
              const hr = hour[4];

              const insertQuery = `INSERT INTO worker_timesheet (product_name, line, section, shift, worker, entry_id, joindate, ${hour}, target, actual_target, date_time, time_stamp, mon, color_id, date, operator_id, site)
                VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`;

              //console.log('Insert Query:', insertQuery);

              try {
                await executeQuery(connection,insertQuery, [product_name, line, section, shifts, worker_names, emp_ids, joindate, completes, target, target, date1, timestamp, formattedDate, color, currentDate, user_id, sites]);
              } catch (err) {
                console.error('Error inserting new entry: ' + err.stack);
                errors.push('Error inserting new entry: ' + err.message);
                success = false;
              }
            }
          } else {
            console.error('No data found in geopos_employees');
            errors.push('No data found in geopos_employees');
            success = false;
          }
        } catch (err) {
          console.error('Error querying geopos_employees: ' + err.stack);
          errors.push('Error querying geopos_employees: ' + err.message);
          success = false;
        }
      } else {
        console.error('Invalid site value');
        errors.push('Invalid site value');
        success = false;
      }
    }));

    if (success) {
      return res.json({ status: 1, message: 'Details added successfully' });
    } else {
      // If there are errors, send a response with the collected error messages.
      return res.json({ status: 0, errors });
    }
  } catch (error) {
    console.error('Error processing data: ' + error.stack);
    errors.push('Error processing data: ' + error.message);
    return res.json({ status: 0, errors });
  } finally {
    // Release the connection back to the pool in case of success or error
    if (connection) {
      connection.release();
      //console.log("Connection released");
    }
  }
});


// Function to execute a database query and return a Promise
// function executeQuery(query, values) {
//   return new Promise((resolve, reject) => {
//     db.query(query, values, (err, results) => {
//       if (err) {
//         reject(err);
//       } else {
//         resolve(results);
//       }
//     });
//   });
// }


//insert employeetimesheet new data operator login
app.post('/insertemployeetimesheetnbraidotadataoplogin/:userid',authenticateJWT , async (req, res) => {
  const tableData = req.body;
  let date1;
  let joindate;
  let success = true; // Flag to track if any error occurs
  const errors = [];
  const { userid } = req.params;

  const date = new Date().toLocaleDateString('en-GB', { timeZone: 'Africa/Lagos' });
  const parts = date.split('/');
  const day = parts[0].padStart(2, '0');
  const month = parts[1].padStart(2, '0');
  const year = parts[2];
  const currentMonth = `${month}-${year}`;
  const currentDate = `${day}-${month}-${year}`;
  let connection; 
  try {
     // Get a connection from the pool
    connection = await getPoolConnection();
    await Promise.all(tableData.map(async (data) => {
      const worker_names = data.worker_names;
      const emp_ids = data.emp_ids;
      const shifts = data.shifts;
      const section = data.section;
      const product_name = data.product_name;
      const line = data.line;
      const sectionname = data.sectionname;
      const hour = data.hour;
      const target = data.target;
      const fg = data.fg;
      const completes = data.completes;
      const color = data.color;

       console.log('Processing data:', data);

      const queryResult = await new Promise((resolve, reject) => {
        db.query(`SELECT * FROM geopos_users WHERE id='${userid}'`, (error, results, fields) => {
          if (error) {
            console.error('Error executing MySQL query:', error);
            reject(error);
          } else {
            resolve(results);
          }
        });
      });

      const site = queryResult[0].production_type;
      const ctype = queryResult[0].category_type;
      console.log('site:', site);
      console.log('ctype:', ctype);

      if (site === 'ota' && ctype === 'NBRAID') {
        const query = `SELECT * FROM employees_ota ORDER BY id ASC LIMIT 1`;
        try {
          const employeeResults = await executeQuery(connection,query);
          //console.log('Employee Results:', employeeResults);
          if (employeeResults.length > 0) {
            date1 = employeeResults[0].date;
            joindate = employeeResults[0].joindate;

            /* console.log('Date1:', date1);
            console.log('Join Date:', joindate); */

            // Split the date string into day, month, and year
            const [day, month, year] = date1.split('-');

            // Create a new Date using the components
            const dayy1 = new Date(`${year}-${month}-${day}`);
            //console.log('dayy1:', dayy1);

            const formattedMonth = (dayy1.getMonth() + 1).toString().padStart(2, '0');
            const formattedYear = dayy1.getFullYear();
            const formattedDate = `${formattedMonth}-${formattedYear}`;

            //console.log('Formatted Month-Year:', formattedDate);

            const currentDate = new Date().toISOString();
            //console.log('currentDate:', currentDate);

            const milliseconds = dayy1.getTime();
            const timestamp = Math.floor(milliseconds / 1000);
            //console.log('timestamp:', timestamp);

            const query = `SELECT * FROM worker_timesheet
              WHERE product_name IN (?) AND line IN (?) AND section IN (?) AND shift IN (?) AND entry_id IN (?) AND date_time = ? AND site = ?`;

            const timesheetResults = await executeQuery(connection,query, [product_name, line, section, shifts, emp_ids, date1, site]);

            //console.log('Timesheet Results:', timesheetResults);

            if (timesheetResults.length > 0) {
              const existingEntry = timesheetResults;
              const hr = hour[4];
              //console.log('hr:', hr);

              const postedTarget = target;
              //console.log('Posted target:', postedTarget);

              const resultTarget = existingEntry[0].target;
              //console.log('target:', resultTarget);

              const tar = parseFloat(target) + parseFloat(resultTarget);
              //console.log('tar:', tar);

              const updateQuery = `UPDATE worker_timesheet SET ${hour} = ?, target = ?
                WHERE product_name = ? AND line = ? AND section = ? AND shift = ?
                AND date_time = ? AND worker = ? AND entry_id = ?`;

              try {
                await executeQuery(connection,updateQuery, [completes, tar, product_name, line, section, shifts, date1, worker_names, emp_ids]);
              } catch (err) {
                console.error('Error updating entry: ' + err.stack);
                errors.push('Error updating entry: ' + err.message);
                success = false;
              }
            } else {
              const hr = hour[4];
              //console.log('hr:', hr);
              const insertQuery = `INSERT INTO worker_timesheet (product_name, line, section, shift, worker, entry_id, joindate, ${hour}, target, actual_target, date_time, time_stamp, mon, color_id, date, operator_id, site)
                VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`;

             
              console.log('Insert Query:', insertQuery);
              console.log('Insert Values:', [product_name, line, section, shifts, worker_names, emp_ids, joindate, completes, target, target, date1, timestamp, month, color, currentDate, userid, site]);


              try {
                await executeQuery(connection,insertQuery, [product_name, line, section, shifts, worker_names, emp_ids, joindate, completes, target, target, date1, timestamp, formattedDate, color, currentDate, userid, site]);
              } catch (err) {
                console.error('Error inserting new entry: ' + err.stack);
                errors.push('Error inserting new entry: ' + err.message);
                success = false;
              }
            }
          } else {
            console.error('No data found in employees_ota');
            errors.push('No data found in employees_ota');
            success = false;
          }
        } catch (err) {
          console.error('Error querying employees_ota: ' + err.stack);
          errors.push('Error querying employees_ota: ' + err.message);
          success = false;
        }
      } else if (site === 'ikeja' && ctype === 'NBRAID') {
        const query = `SELECT * FROM geopos_employees ORDER BY id ASC LIMIT 1`;
        try {
          const employeeResults = await executeQuery(connection,query);
          if (employeeResults.length > 0) {
            date1 = employeeResults[0].date;
            joindate = employeeResults[0].joindate;

            // Split the date string into day, month, and year
            const [day, month, year] = date1.split('-');

            // Create a new Date using the components
            const dayy1 = new Date(`${year}-${month}-${day}`);
            //console.log('dayy1:', dayy1);

            const formattedMonth = (dayy1.getMonth() + 1).toString().padStart(2, '0');
            const formattedYear = dayy1.getFullYear();
            const formattedDate = `${formattedMonth}-${formattedYear}`;

            //console.log('Formatted Month-Year:', formattedDate);

            const currentDate = new Date().toISOString();
            //console.log('currentDate:', currentDate);

            const milliseconds = dayy1.getTime();
            const timestamp = Math.floor(milliseconds / 1000);
            //console.log('timestamp:', timestamp);

            const query = `SELECT * FROM worker_timesheet
              WHERE product_name IN (?) AND line IN (?) AND section IN (?) AND shift IN (?) AND entry_id IN (?) AND date_time = ? AND site = ?`;

            const timesheetResults = await executeQuery(connection,query, [product_name, line, section, shifts, emp_ids, date1, site]);

            if (timesheetResults.length > 0) {
              const existingEntry = timesheetResults[0];
              const hr = hour[4];
              const tar = existingEntry.target + target;

              const updateQuery = `UPDATE worker_timesheet SET ${hour} = ?, target = ?
                WHERE product_name = ? AND line = ? AND section = ? AND shift = ?
                AND date_time = ? AND worker = ? AND entry_id = ?`;

              try {
                await executeQuery(connection,updateQuery, [completes, tar, product_name, line, section, shifts, date1, worker_names, emp_ids]);
              } catch (err) {
                console.error('Error updating entry: ' + err.stack);
                errors.push('Error updating entry: ' + err.message);
                success = false;
              }
            } else {
              const hr = hour[4];

              const insertQuery = `INSERT INTO worker_timesheet (product_name, line, section, shift, worker, entry_id, joindate, ${hour}, target, actual_target, date_time, time_stamp, mon, color_id, date, operator_id, site)
                VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`;

              //console.log('Insert Query:', insertQuery);

              try {
                await executeQuery(connection,insertQuery, [product_name, line, section, shifts, worker_names, emp_ids, joindate, completes, target, target, date1, timestamp, formattedDate, color, currentDate, userid, site]);
              } catch (err) {
                console.error('Error inserting new entry: ' + err.stack);
                errors.push('Error inserting new entry: ' + err.message);
                success = false;
              }
            }
          } else {
            console.error('No data found in geopos_employees');
            errors.push('No data found in geopos_employees');
            success = false;
          }
        } catch (err) {
          console.error('Error querying geopos_employees: ' + err.stack);
          errors.push('Error querying geopos_employees: ' + err.message);
          success = false;
        }
      } else if (site === 'both' && ctype === 'both') {
        date1 = currentDate;
      }

    }));

    if (success) {
      return res.json({ status: 1, message: 'Details added successfully' });
    } else {
      return res.json({ status: 0, errors });
    }
  } catch (error) {
    console.error('Error processing data: ' + error.stack);
    errors.push('Error processing data: ' + error.message);
    return res.json({ status: 0, errors });
  } finally {
    // Release the connection back to the pool in case of success or error
    if (connection) {
      connection.release();
      //console.log("Connection released");
    }
  }
});


// // Function to execute a database query and return a Promise
// function executeQuery(query, values) {
//   return new Promise((resolve, reject) => {
//     db.query(query, values, (err, results) => {
//       if (err) {
//         reject(err);
//       } else {
//         resolve(results);
//       }
//     });
//   });
// }



// Get the default employee data for current date
/**
 * @swagger
 * /getinitialemployeetimesheetdatabraid:
 *   get:
 *     summary: Get Initial Employee Timesheet Data for NBRAID.
 *     description: Retrieve initial employee timesheet data for NBRAID from the database.
 *     tags:
 *       - NBRAID Employee Timesheet Data
 *     security:
 *       - JWTAuth: []
 *     responses:
 *       200:
 *         description: Successful response with initial employee timesheet data.
 *         content:
 *           application/json:
 *             schema:
 *               type: array
 *               items:
 *                 type: object
 *                 properties:
 *                   id:
 *                     type: string
 *                     description: The ID of the record.
 *                   name:
 *                     type: string
 *                     description: The name of the employee.
 *                   entryid:
 *                     type: string
 *                     description: The entry ID of the employee.
 *                   workertype:
 *                     type: string
 *                     description: The type of worker.
 *                   item_description:
 *                     type: string
 *                     description: The description of the item.
 *                   color_name:
 *                     type: string
 *                     description: The name of the color.
 *                 example:
 *                   - id: "1"
 *                     name: "John Doe"
 *                     entryid: "EMP001"
 *                     workertype: "Worker"
 *                     item_description: "Product A"
 *                     color_name: "Red"
 *                   - id: "2"
 *                     name: "Jane Smith"
 *                     entryid: "EMP002"
 *                     workertype: "Supervisor"
 *                     item_description: "Product B"
 *                     color_name: "Blue"
 *       500:
 *         description: Internal Server Error.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: "Internal server error"
 *
 * @function
 * @name getInitialEmployeeTimesheetDataNBRAID
 * @memberof module:Routes/NBRAIDEmployeeTimesheetData
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with retrieving the data.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
app.get('/getinitialemployeetimesheetdatabraid',  authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    const date = new Date().toLocaleDateString('en-GB', { timeZone: 'Africa/Lagos' });
    const parts = date.split('/');
    const formattedDay = parts[0].padStart(2, '0');
    const formattedMonth = parts[1].padStart(2, '0');
    const year = parts[2];
    const date1 = `${formattedDay}-${formattedMonth}-${year}`;

    // Log the received data
    console.log('Received data:');
    console.log('Date:', date1);

    // Query for the first site 'ikeja'
    const query1 = `
      SELECT geopos_operator.*, geopos_employees.name, geopos_employees.entryid,
        geopos_employees.workertype, item_masterr.item_description, color_master.color_name
      FROM geopos_operator
      LEFT JOIN geopos_employees ON geopos_employees.id = geopos_operator.emp_id
      LEFT JOIN item_masterr ON geopos_operator.item = item_masterr.id
      LEFT JOIN color_master ON geopos_operator.color_id = color_master.id
      WHERE geopos_operator.date = '${date1}'
        AND geopos_operator.site = 'ikeja';
    `;

    // Query for the second site 'ota'
    const query2 = `
      SELECT geopos_operator.*, employees_ota.name, employees_ota.entryid,
        employees_ota.workertype, item_masterr.item_description, color_master.color_name
      FROM geopos_operator
      LEFT JOIN employees_ota ON employees_ota.id = geopos_operator.emp_id
      LEFT JOIN item_masterr ON geopos_operator.item = item_masterr.id
      LEFT JOIN color_master ON geopos_operator.color_id = color_master.id
      WHERE geopos_operator.date = '${date1}'
        AND geopos_operator.site = 'ota';
    `;

    const combinedQuery = `${query1}; ${query2}`;

    const results = await executeQuery(connection,combinedQuery);

    // Combine the results from both queries
    const combinedResults = [...results[0], ...results[1]];

    res.json(combinedResults);
  } catch (error) {
    console.error(error);
    res.status(500).json({ error: 'Internal server error' });
  } finally {
    if (connection) {
      connection.release();
      //console.log("Connection released");
    }
  }
});


//fetch section
/**
 * @swagger
 * /getsectionsforaddemployee:
 *   post:
 *     summary: Get Sections for Adding Employee.
 *     description: Retrieve sections for adding employee based on provided parameters.
 *     tags:
 *       - Add Employee
 *     security:
 *       - JWTAuth: []
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             properties:
 *               product_name:
 *                 type: string
 *                 description: The name of the product.
 *               color_description:
 *                 type: string
 *                 description: The description of the color.
 *               site:
 *                 type: string
 *                 description: The site name.
 *               zone:
 *                 type: string
 *                 description: The zone.
 *               shift:
 *                 type: string
 *                 description: The shift.
 *               machine1:
 *                 type: string
 *                 description: The machine.
 *             example:
 *               product_name: "Product A"
 *               color_description: "Red"
 *               site: "Site A"
 *               zone: "Zone A"
 *               shift: "Shift A"
 *               machine1: "Machine 1"
 *     responses:
 *       200:
 *         description: Successful response with sections for adding employee.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 pr:
 *                   type: string
 *                   description: The JSON string containing employee details for the sections.
 *                 ab:
 *                   type: string
 *                   description: The comma-separated string containing absent employee IDs.
 *             example:
 *               pr: '{"id": "1", "name": "John Doe", "entryid": "EMP001", "workertype": "Worker", "section_name": "Section A", "target": "10"}'
 *               ab: "EMP002,EMP003"
 *       500:
 *         description: Internal Server Error.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: "Internal Server Error"
 *
 * @function
 * @name getSectionsForAddEmployee
 * @memberof module:Routes/AddEmployee
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with retrieving the data.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
app.post('/getsectionsforaddemployee',  authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    let site, zone, shift, machine, cat, color;
    if (req.body) {
      cat = req.body.product_name;
      color = req.body.color_description;
      site = req.body.site;
      zone = req.body.zone;
      shift = req.body.shift;
      machine = req.body.machine1 + ',';
    }

    const date = new Date().toLocaleDateString('en-GB', { timeZone: 'Africa/Lagos' });
    const parts = date.split('/');
    const formattedDay = parts[0].padStart(2, '0');
    const formattedMonth = parts[1].padStart(2, '0');
    const year = parts[2];
    const date1 = `${formattedDay}-${formattedMonth}-${year}`;

    const query = 'SELECT * FROM item_section_ota WHERE item_id = ?';
    const results = await executeQuery(query, [cat]);

    let output = '';
    let absent = '';

    const processResults = async (row) => {
      const querya = `SELECT * FROM employees_ota WHERE roleid != 3 AND zone='${zone}' AND shift='${shift}' AND machine LIKE '%${machine}%' AND status='A' AND workertype='DIRECT' AND section_id = ${row.section_id}`;
      const querye = `SELECT * FROM employees_ota WHERE roleid != 3 AND zone='${zone}' AND shift='${shift}' AND machine LIKE '%${machine}%' AND status='P' AND workertype='DIRECT' AND section_id = ${row.section_id}`;

      const resultsa = await executeQuery(connection,querya);
      const resultse = await executeQuery(connection,querye);

      const sectionQuery = `SELECT * FROM section WHERE id = ${row.section_id}`;
      const resultSection = await executeQuery(connection,sectionQuery);

      resultse.forEach(roww => {
        // Add section_name and target to the current row
        roww.section_name = resultSection[0].section_name;
        roww.target = row.target;

        // Add the modified row to the output array
        output += JSON.stringify(roww, null, 2);
      });

      resultsa.forEach(rowa => {
        absent += rowa.entryid + ',';
      });
    };

    await Promise.all(results.map(async (row) => {
      await processResults(row);
    }));

    const dataArray = {
      pr: output.replace(/\n/g, ''),
      ab: absent
    };

    res.json(dataArray);
  } catch (error) {
    console.error('Error:', error);
    res.status(500).json({ error: 'Internal Server Error' });
  } finally {   
    if (connection) {
      connection.release();
    }
  }
});



//insert employee timesheet data
/**
 * @swagger
 * /insertemployeetimesheetfilterdata:
 *   post:
 *     summary: Insert Employee Timesheet Filter Data.
 *     description: Insert employee timesheet filter data into the database.
 *     tags:
 *       - Employee Timesheet
 *     security:
 *       - JWTAuth: []
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: array
 *             items:
 *               type: object
 *             example:
 *               - zone: "Zone A"
 *                 machinec: "Machine 1"
 *                 shift: "Shift A"
 *                 fdate: "2023-11-21"
 *                 
 *     responses:
 *       200:
 *         description: Successful response after inserting data.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 success:
 *                   type: string
 *                   example: "MySQL operation successful."
 *                 successMessage:
 *                   type: string
 *                   description: Message indicating the success of the MySQL operation.
 *             example:
 *               success: "MySQL operation successful."
 *               successMessage: "Data inserted successfully."
 *       500:
 *         description: Internal Server Error.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: "MySQL operation failed."
 *                 errorMessage:
 *                   type: string
 *                   description: Error message indicating the cause of the failure.
 *             example:
 *               error: "MySQL operation failed."
 *               errorMessage: "Error: Something went wrong with the MySQL operation."
 *
 * @function
 * @name insertEmployeeTimesheetFilterData
 * @memberof module:Routes/EmployeeTimesheet
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with inserting the data into the database.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
app.post('/insertemployeetimesheetfilterdata',  authenticateJWT, (req, res) => {
  const receivedData = req.body;
 // console.log('Received Form Data:', receivedData);

  const formDataToSend = receivedData[0];
  const { zone, machinec, shift, fdate } = formDataToSend;
  
  const date1 = fdate;
  const fdParts = date1.split('-');
  const fd = `${fdParts[2]}-${fdParts[1]}-${fdParts[0]}`;

  const dateObj = new Date(date1);
  const day = dateObj.getDate().toString().padStart(2, '0');
  const month = (dateObj.getMonth() + 1).toString().padStart(2, '0');
  const year = dateObj.getFullYear();

  const date = `${day}-${month}-${year}`;
  const date2 = `${month}-${year}`;

  const fd2 = Math.floor(new Date(date1).getTime() / 1000);


var dayy1 = fd2;

const originalDate = new Date(fdate);

const year1 = originalDate.getFullYear();
const month1 = String(originalDate.getMonth() + 1).padStart(2, '0');
const day1 = String(originalDate.getDate()).padStart(2, '0');
const hour = '12';
const minute = '00';
const second = '00';

const date3 = `${year1}-${month1}-${day1} ${hour}:${minute}:${second}`;


console.log('Date:', date);
console.log('date2:', date2);
console.log('dayy1:', dayy1);
console.log('date3:', date3);

 /* const dayy1 = '1700524800';
  const date2 = '11-2023';
  const date3 = '2023-11-21 12:00:00';*/

  const tableRowsData = receivedData.slice(1);

  //const machineCondition = `machine LIKE '%${machinec}%'`;
  //const machineCondition = `machine = '${machinec}'`;
  const machineCondition = `FIND_IN_SET('${machinec}', machine) > 0`;
  const whereConditionIndirect = `zone='${zone}' AND shift='${shift}' AND ${machineCondition} AND workertype='INDIRECT' AND status='P'`;
  const whereConditionDirect = `zone='${zone}' AND shift='${shift}' AND ${machineCondition} AND workertype='DIRECT' AND status='P'`;

  const queryIndirect = `SELECT * FROM geopos_employees WHERE ${whereConditionIndirect}`;
  const queryDirect = `SELECT * FROM geopos_employees WHERE ${whereConditionDirect}`;

  console.log('queryIndirect:', queryIndirect); // Log the value of ire here
  console.log('queryDirect:', queryDirect); // Log the value of ire here


  db.query(queryIndirect, (err, resultIndirect) => {
    if (err) throw err;

    let ire = 0;
    resultIndirect.forEach((ws) => {
      //ire += parseInt(ws.emp_count, 10);
      ire += parseFloat(ws.emp_count);

    });

    const roundedIre = parseFloat(ire.toFixed(4));
    console.log('roundedIre:', roundedIre); // Log the value of ire here

    db.query(queryDirect, (err, resultDirect) => {
      if (err) throw err;

      let dre = 0;
      resultDirect.forEach((ws1) => {
        //dre += parseInt(ws1.emp_count, 10);
        dre += parseFloat(ws1.emp_count);
      });

      const roundeddre = parseFloat(dre.toFixed(4));
    console.log('roundeddre:', roundeddre); // Log the value of ire here

      const combinedData = {
        dataArray: [
          {
            ...formDataToSend,
            indirectCount: roundedIre,
            directCount: roundeddre,
            date,
            dayy1,
            date2,
            date3,
          },
          ...tableRowsData,
        ],
        dataArray1: tableRowsData,
      };

      // Call the function to perform MySQL operations
      performMySQLOperations(combinedData, (mysqlErr, mysqlResult) => {
        if (mysqlErr) {
          console.error('MySQL operation failed:', mysqlErr);
      
          res.status(500).json({
            error: 'MySQL operation failed.',
            errorMessage: mysqlErr.message // Include the error message from mysqlErr
          });
        } else {
          res.json({ success: 'MySQL operation successful.', successMessage: mysqlResult });
        }
      });
    });
  });
});


function performMySQLOperations(combinedData, callback) {
  // Log dataArray to the console
 // console.log('Received combinedData:', combinedData);

  const { emp_id, shift, item, color_id, zone, machine, machinec, hr_start, hr_end, fiber, fg_output, waste1, waste2, waste3, waste_weight, date, temp0, temp1, temp2, temp3, temp4, temp5, site, indirectCount, directCount, dayy1, date2, date3 } = combinedData.dataArray[0];

  const data = {
    emp_id: emp_id,
    shift: shift,
    item: item,
    color_id: color_id,
    zone: zone,
    machine: machine,
    hr_start: hr_start,
    hr_end: hr_end,
    fiber: fiber,
    fg_output: fg_output,
    waste1: waste1,
    waste2: waste2,
    waste3: waste3,
    waste_weight: waste_weight,
    date: date,
    timestamp: dayy1,
    datetime: date3,
    month: date2,
    iemp_count: indirectCount,
    demp_count: directCount,
    upper: temp0,
    lower: temp1,
    perheating: temp2,
    machine_speed: temp3,
    tension: temp4,
    spreading: temp5,
    site: site,
  };


  
  /* const { emp_ids, worker_names, section, target, section_id, completes } = combinedData.dataArray1;
  const empIdsArray = emp_ids.split(',').map(id => id.trim()); */

  const selectQuery = `SELECT * FROM geopos_operator WHERE hr_start = '${hr_start}' AND zone = '${zone}' AND machine = '${machine}' AND date = '${date}'`;

  console.log('selectQuery:', selectQuery);

  db.query(selectQuery, (selectError, selectResults) => {
    if (selectError) {
      res.json({ status: 'Error', message: 'Database error' });
    } else {
      const numRows = selectResults.length;
      console.log('selectResults:', selectResults);
      console.log('numRows:', numRows);

      if (numRows > 0) {
        const errorMessage = `Sorry, you have already entered ${hr_start} start hour for ${zone} and ${machine} on ${date}`;
        console.log('Error Message:', errorMessage);
        const errorResponse = {
          status: 'Error',
          message: errorMessage,
        };
       // Sending the error response to the client
         return callback(errorResponse);
      } else {
        const insertQuery = 'INSERT INTO geopos_operator SET ?';

        db.query(insertQuery, data, (insertError, insertResults) => {
          if (insertError) {
            res.json({ status: 'Error', message: 'Failed to insert data' });
          }
          else {
            const opid = insertResults.insertId;
            console.log('opid:', opid);
            const dataArray = combinedData.dataArray1;

              for (let i = 0; i < dataArray.length; i++) {
                const { emp_ids, worker_names, section, target, section_id, completes } = dataArray[i];
                const empIdsArray = emp_ids.split(',').map(id => id.trim());
                
                console.log('Emp IDs:', emp_ids);
                console.log('Worker Names:', worker_names);
                console.log('Section:', section);
                console.log('Target:', target);
                console.log('Section ID:', section_id);
                console.log('Completes:', completes);
              

                
            
              if (section) {
                const selectSectionQuery = 'SELECT * FROM geopos_operator ORDER BY id DESC LIMIT 1';

                db.query(selectSectionQuery, (selectSectionError, selectSectionResults) => {
                  const lastOperatorId = selectSectionResults[0].id;
                  console.log('lastOperatorId:', lastOperatorId);

                  //console.log('empIdsArray:', empIdsArray);

                  empIdsArray.forEach((emid, index) => {
                    const comp = completes;
                    console.log(`Before data1 construction (Index ${index}):`, worker_names, section_id, target);


                    const data1 = {
                      empid: emid,
                      opmanual_id: `${lastOperatorId},`,
                      section_id: section_id,
                      emp: worker_names,
                      target: target,
                      complete: `${comp},`,
                      date,
                      timestamp: dayy1,
                    };

                    console.log(`data1 (Index ${index}):`, data1);

                    const selectOperatorSectionQuery = 'SELECT * FROM operator_section WHERE empid = ? AND date = ?';
                    const selectOperatorSectionValues = [emid, date];

                    db.query(
                      selectOperatorSectionQuery,
                      selectOperatorSectionValues,
                      (selectOSQueryError, selectOSQueryResults) => {
                        const numOSRows = selectOSQueryResults.length;

                        if (numOSRows > 0) {
                          const cid = selectOSQueryResults[0].id;
                          const op = `${selectOSQueryResults[0].opmanual_id}${opid},`;
                          const cm = `${selectOSQueryResults[0].complete}${comp},`;

                          const updateOperatorSectionQuery =
                            'UPDATE operator_section SET opmanual_id = ?, complete = ? WHERE id = ?';
                          const updateOperatorSectionValues = [op, cm, cid];

                          db.query(
                            updateOperatorSectionQuery,
                            updateOperatorSectionValues,
                            (updateOSError) => {
                              if (updateOSError) {
                                console.error(updateOSError);
                              }
                            }
                          );
                        } else {
                          const insertOperatorSectionQuery = 'INSERT INTO operator_section SET ?';

                          db.query(
                            insertOperatorSectionQuery,
                            data1,
                            (insertOSQueryError) => {
                              if (insertOSQueryError) {
                                console.error(insertOSQueryError);
                              }
                            }
                          );
                        }
                      }
                    );
                  });
                });
              }
            } 
            // Send success message to the client
            const successMessage = 'Details added successfully!';
            return callback(null, successMessage);
          }
        });
      }
    }
  });
}




//Add employee timesheet filter values and click enter
/**
 * @swagger
 * /getaddemployeetimesheetfilterdata:
 *   post:
 *     summary: Get Additional Employee Timesheet Filter Data.
 *     description: Get additional employee timesheet filter data based on the provided parameters.
 *     tags:
 *       - Employee Timesheet
 *     security:
 *       - JWTAuth: []
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             properties:
 *               product_name:
 *                 type: string
 *               line_no:
 *                 type: string
 *               section:
 *                 type: string
 *               shift:
 *                 type: number
 *               hour:
 *                 type: string
 *               day_night:
 *                 type: string
 *             example:
 *               product_name: "Product A"
 *               line_no: "Line 1"
 *               section: "Section 1"
 *               shift: 8.5
 *               hour: "08:00 AM"
 *               day_night: "Day"
 *     responses:
 *       200:
 *         description: Successful response with additional employee timesheet filter data.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 r:
 *                   type: number
 *                   description: A numerical value.
 *                 target:
 *                   type: string
 *                   description: The target value.
 *                 hour:
 *                   type: string
 *                   description: The hour value.
 *                 product:
 *                   type: string
 *                   description: The product name.
 *                 line:
 *                   type: string
 *                   description: The line number.
 *                 section:
 *                   type: string
 *                   description: The section name.
 *                 day_night:
 *                   type: string
 *                   description: Indicates whether it's day or night.
 *                 date:
 *                   type: string
 *                   description: The date.
 *                 op_id:
 *                   type: number
 *                   description: The operation ID.
 *                 shiftt:
 *                   type: number
 *                   description: The shift value.
 *                 tdate:
 *                   type: number
 *                   description: The target date.
 *                 productid:
 *                   type: string
 *                   description: The product ID.
 *                 sectionid:
 *                   type: string
 *                   description: The section ID.
 *                 query3Results:
 *                   type: array
 *                   items:
 *                     type: object
 *                   description: Results from Query 3.
 *               example:
 *                 r: 0
 *                 target: "20"
 *                 hour: "08:00 AM"
 *                 product: "Product A"
 *                 line: "Line 1"
 *                 section: "Section 1"
 *                 day_night: "Day"
 *                 date: "01-01-2024"
 *                 op_id: 9
 *                 shiftt: 8.5
 *                 tdate: 0
 *                 productid: "A123"
 *                 sectionid: "S456"
 *                 query3Results: []
 *       404:
 *         description: No rows found for the provided parameters.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   description: Error message indicating no rows found.
 *               example:
 *                 error: "No rows found."
 *       500:
 *         description: Internal Server Error.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: "Internal Server Error"
 *             example:
 *               error: "Internal Server Error"
 *
 * @function
 * @name getAdditionalEmployeeTimesheetFilterData
 * @memberof module:Routes/EmployeeTimesheet
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with fetching the additional data.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
app.post('/getaddemployeetimesheetfilterdata',  authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    const shift = parseFloat(req.body.shift);
    const shf = Math.round(shift * 100) / 100;
    const shf1 = shift + 'HRS';
    const hour = req.body.hour;
    const product = req.body.product_name;
    const line = req.body.line_no;
    const section = req.body.section;
    const dayNight = req.body.day_night;
    const op_id = 9;

    // Log the received data
    console.log('Received data:');
    console.log('Product Name:', product);
    console.log('Line No:', line);
    console.log('Section:', section);
    console.log('Shift:', shf);
    console.log('Hour:', hour);
    console.log('Day/Night:', dayNight);

    const date = new Date().toLocaleDateString('en-GB', { timeZone: 'Africa/Lagos' });
    const parts = date.split('/');
    const formattedDay = parts[0].padStart(2, '0');
    const formattedMonth = parts[1].padStart(2, '0');
    const year = parts[2];
    const date1 = `${formattedDay}-${formattedMonth}-${year}`;

    console.log('Date:', date1);

    const query1 = `SELECT im.item_description as item_description, s.section_name as section_name, ism.utarget 
      FROM item_section_moz ism
      INNER JOIN item_masterr im ON ism.item_id = im.id
      INNER JOIN section s ON ism.section_id = s.id
      WHERE im.id = "${product}" AND s.id = "${section}"`;

    const results1 = await executeQuery(connection,query1);

    if (results1.length > 0) {
      const utarget = results1[0].utarget;
      const target = results1[0].utarget;
      const productName = results1[0].item_description;
      const sectionName = results1[0].section_name;

      // Log the retrieved data
      console.log('utarget:', utarget);
      console.log('target:', target);
      console.log('Product Name:', product);
      console.log('Line No:', line);
      console.log('Section:', section);
      console.log('Shift:', shf);
      console.log('Shift1:', shf1);
      console.log('Hour:', hour);
      console.log('Day/Night:', dayNight);
      console.log('Date:', date1);
      console.log('Product Name:', productName);
      console.log('Section Name:', sectionName);

      const data = {
        r: 0,
        target: target,
        hour: hour,
        product: productName,
        line: line,
        section: sectionName,
        day_night: dayNight,
        date: date1,
        op_id: op_id,
        shiftt: shift,
        tdate: 0,
        productid: product,
        sectionid: section,
        query3Results: [] // Initialize an empty array for query3 results
      };

      // Perform the query to fetch absent entry IDs
      const queryAbsent =
        'SELECT entryid FROM employees_moz WHERE product = ? AND section_id = ? AND line = ? AND shift = ? AND roleid = ? AND passive_type = ? AND status = ? ORDER BY name ASC';

      const array = {
        product: product,
        section_id: section,
        line: line,
        shift: shf1,
        roleid: '1',
        passive_type: 'ACT'
      };

      const ret = await executeQuery(connection,'SELECT * FROM employees_moz WHERE ?', array);

      // Log Query 3 results
      console.log('Query 3 Results:', ret);

      // Add the query3 results to the data object
      data.query3Results = ret;

      const retAbsent = await executeQuery(connection,queryAbsent, [array.product, array.section_id, array.line, array.shift, array.roleid, array.passive_type, 'A']);

      // Log QueryAbsent results
      console.log('QueryAbsent Results:', retAbsent);

      // Add absent entry IDs to the data object
      data.absentEntryIds = retAbsent.map((entry) => entry.entryid);

      res.json(data);
    } else {
      // No matching rows found
      console.log('No rows found.');
      res.status(404).json({ error: 'No rows found.' });
    }
  } catch (error) {
    console.error('Error:', error);
    res.status(500).json({ error: 'Internal Server Error' });
  } finally {    
    if (connection) {
      connection.release();
    }
  }
});




//edit and update braid employeetimesheet
/**
 * @swagger
 * /updateemployeetimesheetfilterdata:
 *   post:
 *     summary: Update Employee Timesheet Filter Data.
 *     description: Update employee timesheet filter data based on the provided parameters.
 *     tags:
 *       - Employee Timesheet
 *     security:
 *       - JWTAuth: []
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             properties:
 *               zone:
 *                 type: string
 *               machinec:
 *                 type: string
 *               shift:
 *                 type: number
 *               fdate:
 *                 type: string
 *             example:
 *               zone: "Zone A"
 *               machinec: "Machine A"
 *               shift: 8.5
 *               fdate: "2023-11-21"
 *     responses:
 *       200:
 *         description: Successful response with updated employee timesheet filter data.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 success:
 *                   type: string
 *                   description: Indicates success of the operation.
 *                 successMessage:
 *                   type: string
 *                   description: Success message.
 *               example:
 *                 success: "MySQL operation successful."
 *                 successMessage: "Record updated successfully."
 *       500:
 *         description: Internal Server Error.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: "MySQL operation failed."
 *                 errorMessage:
 *                   type: string
 *                   example: "Error message detailing the cause of failure."
 *             example:
 *               error: "MySQL operation failed."
 *               errorMessage: "Error message detailing the cause of failure."
 *
 * @function
 * @name updateEmployeeTimesheetFilterData
 * @memberof module:Routes/EmployeeTimesheet
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with updating the data.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
app.post('/updateemployeetimesheetfilterdata',  authenticateJWT, (req, res) => {
  const receivedData = req.body;
  console.log('Received Form Data:', receivedData);

  const formDataToSend = receivedData[0];
  const { zone, machinec, shift, fdate } = formDataToSend;

  /*const date = '21-11-2023';
  const dayy1 = '1700524800';
  const date2 = '11-2023';
  const date3 = '2023-11-21 12:00:00';*/

  const date1 = fdate;
  const fdParts = date1.split('-');
  const fd = `${fdParts[2]}-${fdParts[1]}-${fdParts[0]}`;

  const dateObj = new Date(date1);
  const day = dateObj.getDate().toString().padStart(2, '0');
  const month = (dateObj.getMonth() + 1).toString().padStart(2, '0');
  const year = dateObj.getFullYear();

  const date = `${day}-${month}-${year}`;
  const date2 = `${month}-${year}`;

  const fd2 = Math.floor(new Date(date1).getTime() / 1000);


var dayy1 = fd2;

const originalDate = new Date(fdate);

const year1 = originalDate.getFullYear();
const month1 = String(originalDate.getMonth() + 1).padStart(2, '0');
const day1 = String(originalDate.getDate()).padStart(2, '0');
const hour = '12';
const minute = '00';
const second = '00';

const date3 = `${year1}-${month1}-${day1} ${hour}:${minute}:${second}`;


console.log('Date:', date);
console.log('date2:', date2);
console.log('dayy1:', dayy1);
console.log('date3:', date3);

  const tableRowsData = receivedData.slice(1);

  const machineCondition = `machine LIKE '%${machinec}%'`;
  const whereConditionIndirect = `zone='${zone}'  AND ${machineCondition} AND workertype='INDIRECT' AND status='P'`;
  const whereConditionDirect = `zone='${zone}'  AND ${machineCondition} AND workertype='DIRECT' AND status='P'`;

  const queryIndirect = `SELECT * FROM geopos_employees WHERE ${whereConditionIndirect}`;
  const queryDirect = `SELECT * FROM geopos_employees WHERE ${whereConditionDirect}`;

  db.query(queryIndirect, (err, resultIndirect) => {
    /* if (err) throw err;

    let ire = 0;
    resultIndirect.forEach((ws) => {
      ire += parseInt(ws.emp_count, 10);
    });

    db.query(queryDirect, (err, resultDirect) => {
      if (err) throw err;

      let dre = 0;
      resultDirect.forEach((ws1) => {
        dre += parseInt(ws1.emp_count, 10);
      }); */

      if (err) throw err;

    let ire = 0;
    resultIndirect.forEach((ws) => {
      //ire += parseInt(ws.emp_count, 10);
      ire += parseFloat(ws.emp_count);

    });

    const roundedIre = parseFloat(ire.toFixed(4));
    console.log('roundedIre:', roundedIre); // Log the value of ire here

    db.query(queryDirect, (err, resultDirect) => {
      if (err) throw err;

      let dre = 0;
      resultDirect.forEach((ws1) => {
        //dre += parseInt(ws1.emp_count, 10);
        dre += parseFloat(ws1.emp_count);
      });

      const roundeddre = parseFloat(dre.toFixed(4));
    console.log('roundeddre:', roundeddre); // Log the value of ire here

      const combinedData = {
        dataArray: [
          {
            ...formDataToSend,
            indirectCount: roundedIre,
            directCount: roundeddre,
            date,
            dayy1,
            date2,
            date3,
          },
          ...tableRowsData,
        ],
      };

      // Call the function to perform MySQL operations
      performMySQLOperations1(combinedData, (mysqlErr, mysqlResult) => {
        if (mysqlErr) {
          console.error('MySQL operation failed:', mysqlErr);
      
          res.status(500).json({
            error: 'MySQL operation failed.',
            errorMessage: mysqlErr.message // Include the error message from mysqlErr
          });
        } else {
          res.json({ success: 'MySQL operation successful.', successMessage: mysqlResult });
        }
      });
    });
  });
});

function performMySQLOperations1(combinedData, callback) {
  // Log dataArray to the console
  console.log('Received combinedData:', combinedData);

  const {catid,shift,product_name,color_description,zone,machine,machinec,hr_start,hr_end,fiber,fg_output,waste1,waste2,waste3,waste_weight,date,temp0,temp1,temp2,temp3,temp4,temp5,site,indirectCount,directCount,dayy1,date2,date3} = combinedData.dataArray[0];
  /* console.log('Zone:', zone);
  console.log('Machine:', machine);
  console.log('hr_start:', hr_start);
  console.log('date:', date); */

  const data = {
		color_id: color_description,
    hr_start: hr_start,
    hr_end: hr_end,
    item: product_name,
    fiber: fiber,
    fg_output: fg_output,
    waste1: waste1,
    waste2: waste2,
	  waste3:waste3,
    waste_weight: waste_weight,
    date: date,
    timestamp: dayy1,
    datetime: date3,
    month: date2,
	  iemp_count: indirectCount,
		demp_count: directCount,
		upper: temp0,
	  lower: temp1,
		perheating: temp2,
		machine_speed: temp3,
		tension: temp4,
		spreading: temp5,
  };
 console.log(data);
const cat_id = catid;
console.log(cat_id);
 

  db.query('UPDATE geopos_operator SET ? WHERE id = ?', [data, cat_id], (error, results) => {
    if (error) {
      console.error('Error updating data in MySQL:', error);
      res.status(500).json({ status: 'Error', message: 'Internal server error.' });
      return;
    }
             

      
      const dataArray = combinedData.dataArray;

        for (let i = 1; i < dataArray.length; i++) {
          const { emp_ids, worker_names, section, target, section_id, secid,  completes } = dataArray[i];
          const sec_idArray = secid.split(',').map(id => id.trim());
          
          console.log('Emp IDs:', emp_ids);
          console.log('Worker Names:', worker_names);
          console.log('Section:', section);
          console.log('Target:', target);
          console.log('Section ID:', section_id);
          console.log('Completes:', completes);
          console.log('Secid:', secid);
        

          
      
        if (section_id) {
          

          sec_idArray.forEach((secid, index) => {
              
              console.log(`Before data1 construction (Index ${index}):`, secid);

              const selectOperatorSectionQuery = 'SELECT * FROM operator_section WHERE id = ? ';
              const selectOperatorSectionValues = [secid];

              db.query(
                selectOperatorSectionQuery,
                selectOperatorSectionValues,
                (selectOSQueryError, selectOSQueryResults) => {
                  const numOSRows = selectOSQueryResults.length;
                  console.log('numOSRows:', numOSRows);
                  if (numOSRows > 0) {
                    
                    const op = `${selectOSQueryResults[0].opmanual_id}`;
                    const cm = `${selectOSQueryResults[0].complete}`.trim();
                    const opi = op.split(',').map(Number);
                    console.log('op ID:', op);
                    console.log('cm:', cm);
                    console.log('opi:', opi);

                     

                    if (opi.includes(+cat_id)) {
                      /* const ky = opi.indexOf(+cat_id);
                      const com = cm.split(',').map(item => item.trim()).filter(Boolean);

                      com[ky] = cm[index];
                      const cmn = com.join(','); */

                      const ky = opi.indexOf(+cat_id);
                      const com = cm.split(',').map(item => item.trim());
                  

                      // Replace the value at ky with the new value (completes)
                      if (ky >= 0 && ky < com.length) {
                        com[ky] = String(completes); // Convert to string before replacing
                      }
                  
                      const cmn = com.join(',');
                  
                      console.log('ky:', ky);
                      console.log('com:', com);
                      console.log('newcom:', cmn); // Log the joined array with commas
                      console.log('cmn:', cmn);
                    
                      const updateOperatorSectionQuery = 'UPDATE operator_section SET complete = ? WHERE id = ?';
                      const updateOperatorSectionValues = [cmn, secid];
                    
                      db.query(updateOperatorSectionQuery, updateOperatorSectionValues, (updateOSError) => {
                        if (updateOSError) {
                          console.error(updateOSError);
                        }
                      });
                    }

                   /*  const updateOperatorSectionQuery =
                      'UPDATE operator_section SET complete = ? WHERE id = ?';
                    const updateOperatorSectionValues = [ cm, secid];

                    db.query(
                      updateOperatorSectionQuery,
                      updateOperatorSectionValues,
                      (updateOSError) => {
                        if (updateOSError) {
                          console.error(updateOSError);
                        }
                      }
                    ); */
                  } 

                 
                  
                }
              );
            });
        
        }
      } 
     // Send success message to the client
     const successMessage = 'Details added successfully!';
     return callback(null, successMessage);
  });
} 


// Function to delete operator section data
function deleteOperatorSectionData1(deletedManualId, callback) {
  console.log(`Deleting operator section data for manual ID: ${deletedManualId}`);
  
  const query = `SELECT * FROM operator_section WHERE opmanual_id LIKE '%${deletedManualId}%'`;

  db.query(query, (error, result) => {
    if (error) {
      console.error('Error executing MySQL query:', error);
      callback(error, null);
      return;
    }

    result.forEach(value => {
      const opSecId = value.id;
      const opmanualIds = value.opmanual_id;

      // Log the values
      console.log(`opSecId: ${opSecId}`);
      console.log(`opmanualIds: ${opmanualIds}`);

      const opidArray = opmanualIds.split(',');

      // Check if the array contains only one element and it matches the deletedManualId
      if (opidArray.length === 1 && opidArray[0] === deletedManualId) {
        // If it matches, delete the entire row
        const deleteQuery = `DELETE FROM operator_section WHERE id = ${opSecId}`;
        db.query(deleteQuery, (deleteError) => {
          if (deleteError) {
            console.error('Error deleting MySQL row:', deleteError);
            callback(deleteError, null);
            return;
          }
          console.log(`Deleted operator section data with ID ${opSecId}`);
          console.log('Operator section data deletion process completed');
          callback(null, 'Operator section data deleted successfully');
        });
      } else if (opidArray.includes(deletedManualId)) {
        // If the array has multiple elements, remove the deletedManualId and update the row
        const index = opidArray.indexOf(deletedManualId);
        opidArray.splice(index, 1);

        const newOpidStr = opidArray.join(',');

        // Update opmanual_id in the MySQL database
        const updateQuery = `UPDATE operator_section SET opmanual_id = '${newOpidStr}' WHERE id = ${opSecId}`;
        db.query(updateQuery, (updateError) => {
          if (updateError) {
            console.error('Error updating MySQL row:', updateError);
            callback(updateError, null);
            return;
          }
          console.log(`Updated operator section data with ID ${opSecId}`);
          
          // Check if the updated opmanualIds still include the deletedManualId
          if (newOpidStr.includes(deletedManualId)) {
            console.log('Operator section data deletion process completed');
            callback(null, 'Operator section data not found for deletion');
          } else {
            console.log('Operator section data deletion process completed');
            callback(null, 'Operator section data deleted successfully');
          }
        });
      }
    });
  });
}

// Function to delete operator section data
function deleteOperatorSectionData(deletedManualId, callback) {
  console.log(`Deleting operator section data for manual ID: ${deletedManualId}`);
  
  // Delete directly from the operator_section table based on the opmanual_id condition
  const deleteQuery = `DELETE FROM operator_section WHERE opmanual_id LIKE '%${deletedManualId}%'`;

  db.query(deleteQuery, (deleteError, deleteResults) => {
    if (deleteError) {
      console.error('Error deleting MySQL rows:', deleteError);
      callback(deleteError, null);
      return;
    }

    // Log the deleted rows
    console.log(`Deleted operator section data for manual ID ${deletedManualId}: ${JSON.stringify(deleteResults)}`);

    console.log('Operator section data deletion process completed');
    callback(null, 'Operator section data deleted successfully');
  });
}

// API endpoint for deleting employee timesheet data
app.post('/emptimesheet_delete',  authenticateJWT, (req, res) => {
  const id = req.body.deleteid;
  console.log('Received id:', id); // Log the value of id

  if (!id) {
    console.error('Invalid request: Missing deleteid parameter');
    return res.status(400).json({ status: 'Error', message: 'Invalid request' });
  }

  // Delete data from the operator_section table
  deleteOperatorSectionData(id, (deleteError, deleteResult) => {
    if (deleteError) {
      console.error('Error deleting operator section data:', deleteError);
      return res.status(500).json({ status: 'Error', message: 'Internal server error' });
    }

    console.log(deleteResult);

    // Delete data from the geopos_operator table
    const deleteOperatorQuery = `DELETE FROM geopos_operator WHERE id = ${id}`;
    db.query(deleteOperatorQuery, (error, results) => {
      if (error) {
        console.error('Error deleting geopos_operator data:', error);
        return res.status(500).json({ status: 'Error', message: 'Internal server error' });
      }

      // Check if any rows were affected (successful delete)
      if (results.affectedRows > 0) {
        console.log(`Successfully deleted geopos_operator data with ID ${id}`);
        return res.json({ status: 'Success', message: 'Successfully Deleted' });
      } else {
        console.warn(`Record not found for ID ${id}`);
        return res.status(404).json({ status: 'Error', message: 'Record not found' });
      }
    });
  });
});



// delete worker from workertimesheet by ID
/**
 * @swagger
 * /workerdelete/{id}:
 *   delete:
 *     summary: Delete a worker timesheet entry.
 *     description: Delete a worker timesheet entry by ID.
 *     tags:
 *       - Worker Timesheet
 *     security:
 *       - JWTAuth: []
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: integer
 *         description: The ID of the worker timesheet entry to delete.
 *         example: 1
 *     responses:
 *       200:
 *         description: Worker timesheet entry deleted successfully.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 message:
 *                   type: string
 *                   example: "Employee deleted successfully."
 *       500:
 *         description: Internal Server Error.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: "An error occurred while deleting the item."
 *             example:
 *               error: "An error occurred while deleting the item."
 *
 * @function
 * @name deleteWorkerTimesheet
 * @memberof module:Routes/WorkerTimesheet
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with deleting the item.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
app.delete("/workerdelete/:id", authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    const id = req.params.id;
    console.log('id:', id);

    const deleteQuery = "DELETE FROM worker_timesheet WHERE id = ?";
    const result = await executeQuery(connection,deleteQuery, [id]);

    console.log(result);
    res.json({ message: 'Employee deleted successfully.' });
  } catch (error) {
    console.error(error);
    res.status(500).json({ error: 'An error occurred while deleting the item.' });
  } finally {
    if (connection) {
      connection.release();
    }
  }
});





// API Endpoint to handle edit requests
/**
 * @swagger
 * /updateHourValue:
 *   post:
 *     summary: Update a specific field value in the worker timesheet.
 *     description: Updates the specified field with the given value in the worker timesheet entry identified by ID.
 *     tags:
 *       - Worker Timesheet
 *     security:
 *       - JWTAuth: []
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             properties:
 *               id:
 *                 type: integer
 *                 description: The ID of the worker timesheet entry to update.
 *                 example: 1
 *               field:
 *                 type: string
 *                 description: The field in the worker timesheet to update.
 *                 example: hours_worked
 *               value:
 *                 type: string
 *                 description: The new value for the specified field.
 *                 example: "8"
 *     responses:
 *       200:
 *         description: Field value updated successfully.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 status:
 *                   type: string
 *                   example: "Success"
 *                 message:
 *                   type: string
 *                   example: "UPDATED"
 *       500:
 *         description: Database error.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 status:
 *                   type: string
 *                   example: "Error"
 *                 message:
 *                   type: string
 *                   example: "Database error"
 *             example:
 *               status: "Error"
 *               message: "Database error"
 *
 * @function
 * @name updateHourValue
 * @memberof module:Routes/WorkerTimesheet
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {DatabaseError} Will throw an error if there's an issue with the database operation.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
app.post('/updateHourValue', authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    const { id, field, value } = req.body;
    const data = { [field]: value };

    const updateQuery = 'UPDATE worker_timesheet SET ? WHERE id = ?';
    const result = await executeQuery(connection,updateQuery, [data, id]);

    if (result.affectedRows > 0) {
      return res.json({ status: 'Success', message: 'UPDATED' });
    } else {
      return res.json({ status: 'Error', message: 'ERROR' });
    }
  } catch (error) {
    console.error('Error executing query:', error);
    return res.status(500).json({ status: 'Error', message: 'Database error' });
  } finally {
    if (connection) {
      connection.release();
      //console.log("Connection released");
    }
  }
});





//-------------------------- Employee Timesheet ---------------------------//




//--------------------------Fg Output--------------------------------------//

/**
 * @swagger
 * /fg_output:
 *   post:
 *     summary: Fetch FG details for a specific date.
 *     description: Fetches finished goods (FG) details including product description, code, color, and user information for a given date.
 *     tags:
 *       - FG Output
 *     security:
 *       - BearerAuth: []
 *     requestBody:
 *       description: JSON object containing the date for which FG details are to be fetched.
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             properties:
 *               date:
 *                 type: string
 *                 format: date
 *                 example: "2024-05-20"
 *     responses:
 *       200:
 *         description: Successful response containing FG details.
 *         content:
 *           application/json:
 *             schema:
 *               type: array
 *               items:
 *                 type: object
 *                 properties:
 *                   id:
 *                     type: integer
 *                   product_name:
 *                     type: string
 *                   product_code:
 *                     type: string
 *                   line:
 *                     type: string
 *                   hour:
 *                     type: string
 *                   shift:
 *                     type: string
 *                   fg_output:
 *                     type: integer
 *                   user:
 *                     type: string
 *                   date_time:
 *                     type: string
 *                     format: date-time
 *                   color_name:
 *                     type: string
 *             example:
 *                 id: 1
 *                 product_name: "Item Description"
 *                 product_code: "123ABC"
 *                 line: "Line 1"
 *                 hour: "08:00"
 *                 shift: "Morning"
 *                 fg_output: 100
 *                 user: "John Doe"
 *                 date_time: "2024-05-20 08:00:00"
 *                 color_name: "Red"
 *       400:
 *         description: Bad Request response indicating a validation error.
 *         content:
 *           application/json:
 *             example:
 *               error: "Date value is missing"
 *       500:
 *         description: Internal server error.
 *         content:
 *           application/json:
 *             example:
 *               error: "An error occurred"
 *
 * @function
 * @name fgOutput
 * @memberof module:Routes/FGOutput
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with the database query.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */

//search data fetch
app.post('/fg_output', authenticateJWT, async (req, res) => {
  let connection
  try {
    connection = await getPoolConnection();
    // Extract the date from the request body
    const { date } = req.body;

    // Validate if the date is provided
    if (!date) {
      return res.status(400).json({ error: 'Date value is missing' });
    }

    // Format the date to match the database format
    const formattedDate = date.split('-').reverse().join('-');

    // Define the MySQL query to fetch fg_details
    const query =
      'SELECT fg_details.*, item_masterr.item_description, item_code.product_code, color_master.color_name, geopos_users.name AS user_name ' +
      'FROM fg_details ' +
      'LEFT JOIN item_masterr ON fg_details.product_name = item_masterr.id ' +
      'LEFT JOIN item_code ON fg_details.product_code = item_code.id ' +
      'LEFT JOIN color_master ON item_code.color_id = color_master.id ' +
      'LEFT JOIN geopos_users ON fg_details.user = geopos_users.id ' +
      'WHERE fg_details.date_time = ?';

    // Execute the MySQL query with the formatted date using executeQuery
    const results = await new Promise((resolve, reject) => {
      executeQuery(connection,query, [formattedDate], (error, results) => {
        if (error) {
          reject(error);
        } else {
          resolve(results);
        }
      });
    });

    // Process the query results
    const fgDetails = results.map((row) => ({
      id: row.id,
      product_name: row.item_description,
      product_code: row.product_code,
      line: row.line,
      hour: row.hour,
      shift: row.shift,
      fg_output: row.fg_output,
      user: row.user_name,
      date_time: row.date_time,
      color_name: row.color_name, // Include color_name in the response
    }));

    // Return the processed data as JSON response
    res.json(fgDetails);
  } catch (error) {
    console.error('Error executing MySQL query:', error);
    res.status(500).json({ error: 'An error occurred' });
  } finally {
    if (connection) {
      connection.end();
    }
  }
});



//FgOutput Ikeja Braid
/**
 * @swagger
 * /get_fg_output_default_ikeja:
 *   get:
 *     summary: Fetch default FG output for Ikeja site.
 *     description: Retrieves the finished goods (FG) output details for the current date at the Ikeja site, including operator, color, item description, and total output.
 *     tags:
 *       - FG Output
 *     security:
 *       - BearerAuth: []
 *     responses:
 *       200:
 *         description: Successful response containing FG output details for Ikeja site.
 *         content:
 *           application/json:
 *             schema:
 *               type: array
 *               items:
 *                 type: object
 *                 properties:
 *                   id:
 *                     type: integer
 *                   emp_id:
 *                     type: integer
 *                   item:
 *                     type: integer
 *                   color_id:
 *                     type: integer
 *                   date:
 *                     type: string
 *                     format: date
 *                   shift:
 *                     type: string
 *                   fg_output:
 *                     type: integer
 *                   site:
 *                     type: string
 *                   color_name:
 *                     type: string
 *                   item_description:
 *                     type: string
 *                   name:
 *                     type: string
 *                   tar:
 *                     type: integer
 *             example:
 *                 id: 1
 *                 emp_id: 101
 *                 item: 202
 *                 color_id: 303
 *                 date: "21-05-2024"
 *                 shift: "Morning"
 *                 fg_output: 150
 *                 site: "ikeja"
 *                 color_name: "Red"
 *                 item_description: "Item A"
 *                 name: "John Doe"
 *                 tar: 450
 *       500:
 *         description: Internal server error.
 *         content:
 *           application/json:
 *             example:
 *               error: "Internal Server Error"
 *
 * @function
 * @name getFgOutputDefaultIkeja
 * @memberof module:Routes/FGOutput
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with the database query.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */

// default data fetch for ikeja braid fgoutput
app.get('/get_fg_output_default_ikeja', authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    const date = new Date().toLocaleDateString('en-GB', { timeZone: 'Africa/Lagos' });
    const parts = date.split('/');
    const day = parts[0].padStart(2, '0');
    const month = parts[1].padStart(2, '0');
    const year = parts[2];
    const newcurrentDate1 = `${day}-${month}-${year}`;

    const query = `
      SELECT geopos_operator.*, color_master.color_name, item_masterr.item_description, geopos_employees.name,
             SUM(fg_output) AS tar
      FROM geopos_operator
      LEFT JOIN geopos_employees ON geopos_operator.emp_id = geopos_employees.id
      LEFT JOIN item_masterr ON geopos_operator.item = item_masterr.id
      LEFT JOIN color_master ON geopos_operator.color_id = color_master.id
      WHERE geopos_operator.date = ? AND geopos_operator.site = 'ikeja'
      GROUP BY geopos_operator.item, geopos_operator.color_id`;

    // Execute the MySQL query with the current date using async-await
    const results = await executeQuery(connection,query, [newcurrentDate1]);

    // Send the results as JSON response
    res.json(results);
  } catch (error) {
    console.error('Error querying database:', error);
    res.status(500).json({ error: 'Internal Server Error' });
  } finally {
    if (connection) {
      connection.end();
    }
  }
});


/**
 * @swagger
 * /get_fg_output_search_ikeja:
 *   post:
 *     summary: Search FG output for Ikeja site by date.
 *     description: Retrieves the finished goods (FG) output details for a specific date at the Ikeja site, including operator, color, item description, and total output.
 *     tags:
 *       - FG Output
 *     security:
 *       - BearerAuth: []
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             properties:
 *               date:
 *                 type: string
 *                 format: date
 *                 description: Date to search for FG output in dd-mm-yyyy format.
 *             required:
 *               - date
 *             example:
 *               date: "21-05-2024"
 *     responses:
 *       200:
 *         description: Successful response containing FG output details for Ikeja site on the specified date.
 *         content:
 *           application/json:
 *             schema:
 *               type: array
 *               items:
 *                 type: object
 *                 properties:
 *                   id:
 *                     type: integer
 *                   emp_id:
 *                     type: integer
 *                   item:
 *                     type: integer
 *                   color_id:
 *                     type: integer
 *                   date:
 *                     type: string
 *                     format: date
 *                   shift:
 *                     type: string
 *                   fg_output:
 *                     type: integer
 *                   site:
 *                     type: string
 *                   color_name:
 *                     type: string
 *                   item_description:
 *                     type: string
 *                   name:
 *                     type: string
 *                   tar:
 *                     type: integer
 *             example:
 *                 id: 1
 *                 emp_id: 101
 *                 item: 202
 *                 color_id: 303
 *                 date: "21-05-2024"
 *                 shift: "Morning"
 *                 fg_output: 150
 *                 site: "ikeja"
 *                 color_name: "Red"
 *                 item_description: "Item A"
 *                 name: "John Doe"
 *                 tar: 450
 *       400:
 *         description: Bad request error due to missing date value.
 *         content:
 *           application/json:
 *             example:
 *               error: "Date value is missing"
 *       500:
 *         description: Internal server error.
 *         content:
 *           application/json:
 *             example:
 *               error: "Internal Server Error"
 *
 * @function
 * @name getFgOutputSearchIkeja
 * @memberof module:Routes/FGOutput
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with the database query.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
// date wise data fetch for ikeja braid fgoutput
app.post('/get_fg_output_search_ikeja', authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    const date = req.body.date;
    console.log(date);
    if (!date) {
      return res.status(400).json({ error: 'Date value is missing' });
    }

    const formattedDate = date.split('-').reverse().join('-');
    console.log('formattedDate', formattedDate);
    
    const query = `
      SELECT
        geopos_operator.*,
        color_master.color_name,
        item_masterr.item_description,
        geopos_employees.name,
        SUM(fg_output) as tar
      FROM
        geopos_operator
      LEFT JOIN
        geopos_employees ON geopos_operator.emp_id = geopos_employees.id
      LEFT JOIN
        item_masterr ON geopos_operator.item = item_masterr.id
      LEFT JOIN
        color_master ON geopos_operator.color_id = color_master.id
      WHERE
        geopos_operator.date = ? AND
        geopos_operator.site = 'ikeja'
      GROUP BY
        geopos_operator.item, geopos_operator.color_id`;

    // Execute the MySQL query with the provided date using async-await
    const results = await executeQuery(connection,query, [formattedDate]);

    // Send the results as JSON response
    res.json(results);
  } catch (error) {
    console.error('Error querying database:', error);
    res.status(500).json({ error: 'Internal Server Error' });
  } finally {
    if (connection) {
      connection.end();
    }
  }
});


//FgOutput Ikeja Non Braid
/**
 * @swagger
 * /get_fg_output_default_ikeja_nbraid:
 *   get:
 *     summary: Get FG output for Ikeja site with category NBRAID on current date.
 *     description: Retrieves the finished goods (FG) output details for the current date at the Ikeja site, specifically for the NBRAID category.
 *     tags:
 *       - FG Output
 *     security:
 *       - BearerAuth: []
 *     responses:
 *       200:
 *         description: Successful response containing FG output details for Ikeja site with category NBRAID on the current date.
 *         content:
 *           application/json:
 *             schema:
 *               type: array
 *               items:
 *                 type: object
 *                 properties:
 *                   id:
 *                     type: integer
 *                   product_name:
 *                     type: integer
 *                   product_code:
 *                     type: integer
 *                   line:
 *                     type: string
 *                   hour:
 *                     type: string
 *                   shift:
 *                     type: string
 *                   fg_output:
 *                     type: integer
 *                   user:
 *                     type: integer
 *                   date_time:
 *                     type: string
 *                     format: date-time
 *                   site:
 *                     type: string
 *                   category_type:
 *                     type: string
 *                   name:
 *                     type: string
 *                   item_description:
 *                     type: string
 *                   color_name:
 *                     type: string
 *                   product_des:
 *                     type: string
 *             example:
 *                 id: 1
 *                 product_name: 101
 *                 product_code: 202
 *                 line: "Line 1"
 *                 hour: "08:00-09:00"
 *                 shift: "Morning"
 *                 fg_output: 150
 *                 user: 1
 *                 date_time: "21-05-2024"
 *                 site: "ikeja"
 *                 category_type: "NBRAID"
 *                 name: "John Doe"
 *                 item_description: "Item A"
 *                 color_name: "Red"
 *                 product_des: "Product A"
 *       500:
 *         description: Internal server error.
 *         content:
 *           application/json:
 *             example:
 *               error: "Internal Server Error"
 *
 * @function
 * @name getFgOutputDefaultIkejaNbraid
 * @memberof module:Routes/FGOutput
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with the database query.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */

// default data fetch for ikeja nbraid fgoutput
app.get('/get_fg_output_default_ikeja_nbraid', authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    const date = new Date().toLocaleDateString('en-GB', { timeZone: 'Africa/Lagos' });
    const parts = date.split('/');
    const day = parts[0].padStart(2, '0');
    const month = parts[1].padStart(2, '0');
    const year = parts[2];
    const newcurrentDate1 = `${day}-${month}-${year}`;

    const query = `
      SELECT
        fg_details.*,
        geopos_users.name,
        item_masterr.item_description,
        color_master.color_name,
        item_code.product_code,
        item_code.product_des
      FROM
        fg_details
      LEFT JOIN
        geopos_users ON fg_details.user = geopos_users.id
      LEFT JOIN
        item_masterr ON fg_details.product_name = item_masterr.id
      LEFT JOIN
        item_code ON fg_details.product_code = item_code.id
      LEFT JOIN
        color_master ON item_code.color_id = color_master.id
      WHERE
        fg_details.date_time = ? AND
        fg_details.site = 'ikeja' AND
        fg_details.category_type = 'NBRAID'`;

    // Execute the MySQL query with the current date using async-await
    const results = await executeQuery(connection,query, [newcurrentDate1]);
    // Send the results as JSON response
    res.json(results);
  } catch (error) {
    console.error('Error querying database:', error);
    res.status(500).json({ error: 'Internal Server Error' });
  } finally {
    if (connection) {
      connection.end();
    }
  }
});


/**
 * @swagger
 * /get_fg_output_search_ikeja_nbraid:
 *   post:
 *     summary: Search FG output for Ikeja site with category NBRAID on a specific date.
 *     description: Retrieves the finished goods (FG) output details for a specific date at the Ikeja site, specifically for the NBRAID category.
 *     tags:
 *       - FG Output
 *     security:
 *       - BearerAuth: []
 *     requestBody:
 *       description: Date for which to retrieve FG output details.
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             properties:
 *               date:
 *                 type: string
 *                 format: date
 *                 example: "2024-05-21"
 *     responses:
 *       200:
 *         description: Successful response containing FG output details for Ikeja site with category NBRAID on the specified date.
 *         content:
 *           application/json:
 *             schema:
 *               type: array
 *               items:
 *                 type: object
 *                 properties:
 *                   id:
 *                     type: integer
 *                   product_name:
 *                     type: integer
 *                   line:
 *                     type: string
 *                   hour:
 *                     type: string
 *                   shift:
 *                     type: string
 *                   fg_output:
 *                     type: integer
 *                   user:
 *                     type: integer
 *                   date_time:
 *                     type: string
 *                     format: date-time
 *                   site:
 *                     type: string
 *                   category_type:
 *                     type: string
 *                   name:
 *                     type: string
 *                   item_description:
 *                     type: string
 *                   color_name:
 *                     type: string
 *                   product_des:
 *                     type: string
 *             example:
 *               - id: 1
 *                 product_name: 101
 *                 line: "Line 1"
 *                 hour: "08:00-09:00"
 *                 shift: "Morning"
 *                 fg_output: 150
 *                 user: 1
 *                 date_time: "21-05-2024"
 *                 site: "ikeja"
 *                 category_type: "NBRAID"
 *                 name: "John Doe"
 *                 item_description: "Item A"
 *                 color_name: "Red"
 *                 product_des: "Product A"
 *       400:
 *         description: Bad Request - Date value is missing.
 *         content:
 *           application/json:
 *             example:
 *               error: "Date value is missing"
 *       500:
 *         description: Internal server error.
 *         content:
 *           application/json:
 *             example:
 *               error: "Internal Server Error"
 *
 * @function
 * @name getFgOutputSearchIkejaNbraid
 * @memberof module:Routes/FGOutput
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with the database query.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
//date wise search data fetch for ikeja nbraid fgoutput
app.post('/get_fg_output_search_ikeja_nbraid', authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    const date = req.body.date;
    console.log(date);
    if (!date) {
      return res.status(400).json({ error: 'Date value is missing' });
    }

    const formattedDate = date.split('-').reverse().join('-');
    console.log('formattedDate', formattedDate);

    const query = `
      SELECT
        fg_details.*,
        geopos_users.name,
        item_masterr.item_description,
        color_master.color_name,
        item_code.product_code,
        item_code.product_des
      FROM
        fg_details
      LEFT JOIN
        geopos_users ON fg_details.user = geopos_users.id
      LEFT JOIN
        item_masterr ON fg_details.product_name = item_masterr.id
      LEFT JOIN
        item_code ON fg_details.product_code = item_code.id
      LEFT JOIN
        color_master ON item_code.color_id = color_master.id
      WHERE
        fg_details.date_time = ? AND
        fg_details.site = 'ikeja' AND
        fg_details.category_type = 'NBRAID'`;

    // Execute the MySQL query with the formatted date using async-await
    const results = await executeQuery(connection,query, [formattedDate]);

    // Send the results as JSON response
    res.json(results);
  } catch (error) {
    console.error('Error querying database:', error);
    res.status(500).json({ error: 'Internal Server Error' });
  } finally {
    if (connection) {
      connection.end();
    }
  }
});


/**
 * @swagger
 * /fgoutputdelete/{id}:
 *   delete:
 *     summary: Delete FG details by ID
 *     description: Deletes an entry from the fg_details table based on the provided ID.
 *     tags:
 *       - FG Output
 *     security:
 *       - BearerAuth: []
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         description: ID of the FG detail to be deleted
 *         schema:
 *           type: integer
 *     responses:
 *       200:
 *         description: FG Details deleted successfully.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 message:
 *                   type: string
 *             example:
 *               message: 'FG Details deleted successfully.'
 *       404:
 *         description: Item not found.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *             example:
 *               error: 'Item not found.'
 *       500:
 *         description: Internal server error.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *             example:
 *               error: 'An error occurred while deleting the item.'
 *
 * @function
 * @name deleteFgOutput
 * @memberof module:Routes/FGOutput
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with the database query.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */

// delete fg output
app.delete("/fgoutputdelete/:id", authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    const id = req.params.id;
    // Execute the MySQL query to delete the item with the provided ID using async-await
    const result = await executeQuery(connection,"DELETE FROM fg_details WHERE id = ?", [id]);

    // Check if the delete operation was successful
    if (result.affectedRows === 0) {
      // If no rows were affected, the item with the provided ID does not exist
      return res.status(404).json({ error: 'Item not found.' });
    }

    // Send a success message as JSON response
    res.json({ message: 'FG Details deleted successfully.' });
  } catch (error) {
    console.error('Error deleting item:', error);
    res.status(500).json({ error: 'An error occurred while deleting the item.' });
  } finally {
    if (connection) {
      connection.end();
    }
  }
});

/**
 * @swagger
 * /getcolordescription/{selectedProduct}:
 *   get:
 *     summary: Get color descriptions by selected product
 *     description: Retrieves color descriptions for a specified product from the database.
 *     tags:
 *       - Color
 *     security:
 *       - BearerAuth: []
 *     parameters:
 *       - in: path
 *         name: selectedProduct
 *         required: true
 *         description: ID of the selected product
 *         schema:
 *           type: integer
 *     responses:
 *       200:
 *         description: Color descriptions retrieved successfully.
 *         content:
 *           application/json:
 *             schema:
 *               type: array
 *               items:
 *                 type: object
 *                 properties:
 *                   id:
 *                     type: integer
 *                     description: The ID of the color.
 *                   product_des:
 *                     type: string
 *                     description: The description of the color.
 *             example:
 *               - id: 1
 *                 product_des: "Red"
 *               - id: 2
 *                 product_des: "Blue"
 *       500:
 *         description: Internal server error.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *             example:
 *               error: "An error occurred while fetching color descriptions."
 *
 * @function
 * @name getColorDescription
 * @memberof module:Routes/Color
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with the database query.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */


// Define a route for fetching color options
app.get('/getcolordescription/:selectedProduct', authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    const { selectedProduct } = req.params;

    // Perform a database query to fetch the color descriptions for the specified product using async-await
    const query = `SELECT id, product_des FROM item_code WHERE product_id = ?`;
    const results = await executeQuery(connection,query, [selectedProduct]);

    // Map the results to the desired format
    const colorDescriptions = results.map((row) => ({
      id: row.id,
      product_des: row.product_des,
    }));

    // Send the color descriptions as JSON response
    res.json(colorDescriptions);
  } catch (error) {
    console.error('Error fetching color descriptions:', error);
    res.status(500).json({ error: 'An error occurred while fetching color descriptions.' });
  } finally {
    if (connection) {
      connection.end();
    }
  }
});



/**
 * @swagger
 * /getcolordescriptionss/{item}:
 *   get:
 *     summary: Get color descriptions by item
 *     description: Retrieves color descriptions for a specified item from the database.
 *     tags:
 *       - Color
 *     security:
 *       - BearerAuth: []
 *     parameters:
 *       - in: path
 *         name: item
 *         required: true
 *         description: ID of the item
 *         schema:
 *           type: integer
 *     responses:
 *       200:
 *         description: Color descriptions retrieved successfully.
 *         content:
 *           application/json:
 *             schema:
 *               type: array
 *               items:
 *                 type: object
 *                 properties:
 *                   id:
 *                     type: integer
 *                     description: The ID of the color.
 *                   product_des:
 *                     type: string
 *                     description: The description of the color.
 *             example:
 *               - id: 1
 *                 product_des: "Red"
 *               - id: 2
 *                 product_des: "Blue"
 *       500:
 *         description: Internal server error.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *             example:
 *               error: "An error occurred while fetching color descriptions."
 *
 * @function
 * @name getColorDescriptionsByItem
 * @memberof module:Routes/Color
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with the database query.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */

// Define a route for fetching color options
app.get('/getcolordescriptionss/:item', authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    const { item } = req.params;

    // Perform a database query to fetch the color descriptions for the specified product using async-await
    const query = `SELECT id, product_des FROM item_code WHERE product_id = ?`;
    const results = await executeQuery(connection,query, [item]);

    // Map the results to the desired format
    const colorDescriptions = results.map((row) => ({
      id: row.id,
      product_des: row.product_des,
    }));

    // Send the color descriptions as JSON response
    res.json(colorDescriptions);
  } catch (error) {
    console.error('Error fetching color descriptions:', error);
    res.status(500).json({ error: 'An error occurred while fetching color descriptions.' });
  } finally {
    if (connection) {
      connection.end();
    }
  }
});


/**
 * @swagger
 * /getproductcode/{selectedColor}:
 *   get:
 *     summary: Get product code by color
 *     description: Retrieves product codes for a specified color from the database.
 *     tags:
 *       - Product
 *     security:
 *       - BearerAuth: []
 *     parameters:
 *       - in: path
 *         name: selectedColor
 *         required: true
 *         description: ID of the selected color
 *         schema:
 *           type: integer
 *     responses:
 *       200:
 *         description: Product codes retrieved successfully.
 *         content:
 *           application/json:
 *             schema:
 *               type: array
 *               items:
 *                 type: object
 *                 properties:
 *                   product_code:
 *                     type: string
 *                     description: The product code.
 *             example:
 *               - product_code: "ABC123"
 *               - product_code: "XYZ456"
 *       500:
 *         description: Internal server error.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *             example:
 *               error: "An error occurred while fetching color codes."
 *
 * @function
 * @name getProductCodesByColor
 * @memberof module:Routes/Product
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with the database query.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
// Define a route for fetching product_code options
app.get('/getproductcode/:selectedColor', authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    const { selectedColor } = req.params;

    // Perform a database query to fetch the product_code options for the specified color using async-await
    const query = `SELECT product_code FROM item_code WHERE id = ?`;
    const results = await executeQuery(connection,query, [selectedColor]);

    // Map the results to the desired format
    const colorCodes = results.map((row) => ({
      product_code: row.product_code,
    }));

    // Send the color codes as JSON response
    res.json(colorCodes);
  } catch (error) {
    console.error('Error fetching color code:', error);
    res.status(500).json({ error: 'An error occurred while fetching color codes.' });
  } finally {
    if (connection) {
      connection.end();
    }
  }
});

/**
 * @swagger
 * /addfgoutput:
 *   post:
 *     summary: Add FG output
 *     description: Adds FG output details to the database.
 *     tags:
 *       - FG Output
 *     security:
 *       - BearerAuth: []
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             properties:
 *               product_name:
 *                 type: string
 *                 description: The name of the product.
 *               color_description:
 *                 type: string
 *                 description: The description of the color.
 *               line_no:
 *                 type: string
 *                 description: The line number.
 *               fgoutput:
 *                 type: number
 *                 description: The FG output quantity.
 *               hour:
 *                 type: string
 *                 description: The hour of the output.
 *               shift:
 *                 type: string
 *                 description: The shift during which the output was generated.
 *               fromdate:
 *                 type: string
 *                 format: date
 *                 description: The date when the output was generated (YYYY-MM-DD).
 *     responses:
 *       200:
 *         description: FG output added successfully.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 status:
 *                   type: string
 *                   description: The status of the operation (Success).
 *                 message:
 *                   type: string
 *                   description: A success message.
 *             example:
 *               status: "Success"
 *               message: "FG Details added successfully"
 *       400:
 *         description: Error adding FG output.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 status:
 *                   type: string
 *                   description: The status of the operation (Error).
 *                 message:
 *                   type: string
 *                   description: The error message.
 *             example:
 *               status: "Error"
 *               message: "Sorry, for today you have already added the FG OUTPUT for this Product Name and Line!!!"
 *       500:
 *         description: Internal server error.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 status:
 *                   type: string
 *                   description: The status of the operation (Error).
 *                 message:
 *                   type: string
 *                   description: A general error message.
 *             example:
 *               status: "Error"
 *               message: "An error occurred while adding FG output"
 *
 * @function
 * @name addFGOutput
 * @memberof module:Routes/FGOutput
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with the database query.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */

// add fgoutput ikeja nbraid
app.post('/addfgoutput', authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    const {
      product_name,
      color_description,
      line_no,
      fgoutput,
      hour,
      shift,
      fromdate
    } = req.body;

    const date = new Date(fromdate);
    const formattedDate = `${date.getDate().toString().padStart(2, '0')}-${(date.getMonth() + 1).toString().padStart(2, '0')}-${date.getFullYear()}`;
    const timestampInSeconds = Math.floor(new Date(date).getTime() / 1000);
    const userid = 9; // Replace with the actual way to get the user ID
    const site = 'ikeja';
    const cat = 'NBRAID';

    const selectQuery = `SELECT * FROM fg_details WHERE product_name = ? AND product_code = ? AND line = ? AND shift = ? AND hour = ? AND date_time = ? AND site = ?`;
    const selectValues = [product_name, color_description, line_no, shift, hour, formattedDate, site];

    const selectResult = await executeQuery(connection,selectQuery, selectValues);

    if (selectResult.length > 0) {
      return res.status(400).json({
        status: 'Error',
        message: 'Sorry, for today you have already added the FG OUTPUT for this Product Name and Line!!!',
      });
    }

    const insertData = {
      product_name,
      line: line_no,
      product_code: color_description,
      hour,
      shift,
      fg_output: fgoutput,
      user: userid,
      date_time: formattedDate,
      time_stamp: timestampInSeconds,
      site,
      category_type: cat,
    };

    const insertQuery = 'INSERT INTO fg_details SET ?';
    const insertResult = await executeQuery(connection,insertQuery, insertData);

    if (insertResult.affectedRows > 0) {
      // Insert operation successful
      const successResponse = { status: 'Success', message: 'FG Details added successfully' };
      return res.status(200).json(successResponse);
    } else {
      // No rows were affected (record already exists)
      const failureResponse = { status: 'Error', message: 'Record already exists' };
      return res.status(400).json(failureResponse);
    }
  } catch (error) {
    console.error('Error while adding FG output:', error);
    return res.status(500).json({ status: 'Error', message: 'An error occurred while adding FG output' });
  } finally {
    if (connection) {
      connection.end();
    }
  }
});

/**
 * @swagger
 * /getfgoutputData/{id}:
 *   get:
 *     summary: Get FG output data by ID
 *     description: Retrieves FG output data from the database based on the provided ID.
 *     tags:
 *       - FG Output
 *     security:
 *       - BearerAuth: []
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         schema:
 *           type: integer
 *         description: The ID of the FG output data to retrieve.
 *     responses:
 *       200:
 *         description: FG output data retrieved successfully.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 id:
 *                   type: integer
 *                   description: The ID of the FG output data.
 *                 product_name:
 *                   type: string
 *                   description: The name of the product.
 *                 line:
 *                   type: string
 *                   description: The line number.
 *                 product_code:
 *                   type: string
 *                   description: The product code.
 *                 hour:
 *                   type: string
 *                   description: The hour of the output.
 *                 shift:
 *                   type: string
 *                   description: The shift during which the output was generated.
 *                 fg_output:
 *                   type: number
 *                   description: The FG output quantity.
 *                 user:
 *                   type: string
 *                   description: The user associated with the FG output data.
 *                 date_time:
 *                   type: string
 *                   format: date-time
 *                   description: The date and time when the output was generated.
 *                 time_stamp:
 *                   type: integer
 *                   description: The timestamp of when the FG output data was recorded.
 *                 site:
 *                   type: string
 *                   description: The site where the output was generated.
 *                 category_type:
 *                   type: string
 *                   description: The category type of the FG output data.
 *                 pcode:
 *                   type: string
 *                   description: The product code associated with the FG output data.
 *       404:
 *         description: FG output data not found.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   description: Error message indicating that the FG output data was not found.
 *             example:
 *               error: "FG data not found"
 *       500:
 *         description: Internal server error.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   description: A general error message.
 *             example:
 *               error: "Internal server error"
 *
 * @function
 * @name getFGOutputDataByID
 * @memberof module:Routes/FGOutput
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with the database query.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
// API endpoint to fetch data from fg_details table
app.get('/getfgoutputData/:id', authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    const id = req.params.id;
    console.log(id);

    const query = `
      SELECT fg_details.*, item_code.product_code as pcode
      FROM fg_details
      JOIN item_code ON fg_details.product_code = item_code.id
      WHERE fg_details.id = ?
    `;

    // Execute the query
    const rows = await executeQuery(connection,query, [id]);

    if (rows.length === 0) {
      return res.status(404).json({ error: 'FG data not found' });
    }

    // Send the retrieved data as the response
    res.json(rows[0]);
  } catch (error) {
    console.error('Error fetching FG data:', error);
    res.status(500).json({ error: 'Internal server error' });
  } finally {
    if (connection) {
      connection.end();
    }
  }
});



/**
 * @swagger
 * /fg_output_update/:
 *   post:
 *     summary: Update FG output data
 *     description: Update FG output data in the database based on the provided parameters.
 *     tags:
 *       - FG Output
 *     security:
 *       - BearerAuth: []
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             properties:
 *               id:
 *                 type: integer
 *                 description: The ID of the FG output data to update.
 *               product_name:
 *                 type: string
 *                 description: The name of the product.
 *               color_description:
 *                 type: string
 *                 description: The color description of the product.
 *               line_no:
 *                 type: string
 *                 description: The line number.
 *               code:
 *                 type: string
 *                 description: The product code.
 *               hour:
 *                 type: string
 *                 description: The hour of the output.
 *               shift:
 *                 type: string
 *                 description: The shift during which the output was generated.
 *               fgoutput:
 *                 type: number
 *                 description: The updated FG output quantity.
 *     responses:
 *       200:
 *         description: FG output data updated successfully.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 status:
 *                   type: string
 *                   description: Indicates the status of the operation.
 *                 message:
 *                   type: string
 *                   description: Success message indicating that the FG output data was updated successfully.
 *             example:
 *               status: "Success"
 *               message: "FG output updated successfully"
 *       400:
 *         description: Bad request.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   description: Error message indicating that FG data already exists for the provided parameters.
 *             example:
 *               error: "FG data already exists for this hour"
 *       500:
 *         description: Internal server error.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   description: A general error message.
 *             example:
 *               error: "Internal server error"
 *
 * @function
 * @name updateFGOutputData
 * @memberof module:Routes/FGOutput
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with the database query.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
// PUT endpoint to edit FG output
app.post('/fg_output_update/', authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    // Extracting request body parameters
    const {
      id,
      product_name,
      color_description,
      line_no,
      code,
      hour,
      shift,
      fgoutput,
    } = req.body;

    // Check if FG output already exists for the given parameters
    const selectQuery = `
      SELECT * 
      FROM fg_details 
      WHERE product_name = ? 
        AND product_code = ? 
        AND line = ? 
        AND hour = ? 
        AND shift = ? 
        AND date_time = CURDATE()
    `;
    const selectValues = [product_name, color_description, line_no, hour, shift];

    const existingRows = await executeQuery(connection,selectQuery, selectValues);

    if (existingRows.length > 0) {
      return res.status(400).json({ error: 'FG data already exists for this hour' });
    }

    // Update FG output
    const updateQuery = `
      UPDATE fg_details 
      SET product_name = ?, line = ?, product_code = ?, hour = ?, shift = ?, fg_output = ? 
      WHERE id = ?
    `;
    const updateValues = [product_name, line_no, color_description, hour, shift, fgoutput, id];

    const result = await executeQuery(connection,updateQuery, updateValues);

    // Handle success response
    res.json({ status: 'Success', message: 'FG output updated successfully' });
  } catch (error) {
    console.error('Error updating FG data:', error);
    res.status(500).json({ error: 'Internal server error' });
  } finally {
    if (connection) {
      connection.end();
    }
  }
});


/**
 * @swagger
 * /getColorOptions:
 *   get:
 *     summary: Get color options
 *     description: Retrieve all color options from the database.
 *     tags:
 *       - Color Options
 *     security:
 *       - BearerAuth: []
 *     responses:
 *       200:
 *         description: An array of color options.
 *         content:
 *           application/json:
 *             schema:
 *               type: array
 *               items:
 *                 type: object
 *                 properties:
 *                   id:
 *                     type: integer
 *                     description: The ID of the color option.
 *                   product_id:
 *                     type: integer
 *                     description: The ID of the product associated with the color option.
 *                   product_des:
 *                     type: string
 *                     description: The description of the color option.
 *                   product_code:
 *                     type: string
 *                     description: The code of the color option.
 *             example:
 *               - id: 1
 *                 product_id: 123
 *                 product_des: "Red"
 *                 product_code: "RD"
 *               - id: 2
 *                 product_id: 456
 *                 product_des: "Blue"
 *                 product_code: "BL"
 *       500:
 *         description: Internal server error.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   description: A general error message.
 *             example:
 *               error: "Failed to fetch color options"
 *
 * @function
 * @name getColorOptions
 * @memberof module:Routes/ColorOptions
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with the database query.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
//get product name 
app.get('/getColorOptions', authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    // Perform a database query to fetch all color options
    const query = `SELECT * FROM item_code`;

    // Execute the query asynchronously using the existing executeQuery function
    const results = await executeQuery(connection,query);

    // Send the results as JSON response
    res.json(results);
  } catch (error) {
    console.error('Error fetching color options:', error);
    res.status(500).json({ error: 'Failed to fetch color options' });
  }  finally {
    if (connection) {
      connection.end();
    }
  }
});


/**
 * @swagger
 * /getColorOptionsedit/{product_code}:
 *   get:
 *     summary: Get color option by ID
 *     description: Retrieve a color option from the database based on its ID.
 *     tags:
 *       - Color Options
 *     security:
 *       - BearerAuth: []
 *     parameters:
 *       - in: path
 *         name: product_code
 *         schema:
 *           type: integer
 *         required: true
 *         description: The ID of the color option to retrieve.
 *     responses:
 *       200:
 *         description: A color option object.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 id:
 *                   type: integer
 *                   description: The ID of the color option.
 *                 product_id:
 *                   type: integer
 *                   description: The ID of the product associated with the color option.
 *                 product_des:
 *                   type: string
 *                   description: The description of the color option.
 *                 product_code:
 *                   type: string
 *                   description: The code of the color option.
 *             example:
 *               id: 1
 *               product_id: 123
 *               product_des: "Red"
 *               product_code: "RD"
 *       500:
 *         description: Internal server error.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   description: A general error message.
 *             example:
 *               error: "Failed to fetch item data"
 *
 * @function
 * @name getColorOptionsEdit
 * @memberof module:Routes/ColorOptions
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with the database query.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
//get product name 
app.get('/getColorOptionsedit/:product_code', authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    const itemId = req.params.product_code;
    console.log('Received ID:', itemId);

    // Perform a database query to fetch the data based on the itemId
    const query = `SELECT * FROM item_code WHERE id = ?`;

    // Execute the query asynchronously
    const results = await executeQuery(connection,query, [itemId]);

    // Send the results as JSON response
    res.json(results);
  } catch (error) {
    console.error('Error fetching item data:', error);
    res.status(500).json({ error: 'Failed to fetch item data' });
  } finally {
    if (connection) {
      connection.end();
    }
  }
});



//Fg Output Ota Braid

/**
 * @swagger
 * /get_fg_output_default_ota:
 *   get:
 *     summary: Get default FG output data for OTA site
 *     description: Retrieve default FG output data for the OTA site based on the current date in the Africa/Lagos timezone.
 *     tags:
 *       - FG Output
 *     security:
 *       - BearerAuth: []
 *     responses:
 *       200:
 *         description: Default FG output data for OTA site.
 *         content:
 *           application/json:
 *             schema:
 *               type: array
 *               items:
 *                 type: object
 *                 properties:
 *                   id:
 *                     type: integer
 *                     description: The ID of the FG output data.
 *                   emp_id:
 *                     type: integer
 *                     description: The ID of the employee associated with the FG output.
 *                   item:
 *                     type: integer
 *                     description: The ID of the item associated with the FG output.
 *                   color_id:
 *                     type: integer
 *                     description: The ID of the color associated with the FG output.
 *                   fg_output:
 *                     type: integer
 *                     description: The FG output quantity.
 *                   date:
 *                     type: string
 *                     format: date
 *                     description: The date of the FG output.
 *                   site:
 *                     type: string
 *                     description: The site associated with the FG output.
 *                   name:
 *                     type: string
 *                     description: The name of the employee associated with the FG output.
 *                   item_description:
 *                     type: string
 *                     description: The description of the item associated with the FG output.
 *                   color_name:
 *                     type: string
 *                     description: The name of the color associated with the FG output.
 *                   tar:
 *                     type: integer
 *                     description: The total FG output for the item and color.
 *             example:
 *               - id: 1
 *                 emp_id: 123
 *                 item: 456
 *                 color_id: 789
 *                 fg_output: 100
 *                 date: "2024-05-24"
 *                 site: "ota"
 *                 name: "John Doe"
 *                 item_description: "Product A"
 *                 color_name: "Red"
 *                 tar: 200
 *       500:
 *         description: Internal server error.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   description: A general error message.
 *             example:
 *               error: "Internal Server Error"
 *
 * @function
 * @name getDefaultFGOutputOTA
 * @memberof module:Routes/FGOutput
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with the database query.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
// default data fetch for ota braid fgoutput
app.get('/get_fg_output_default_ota', authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    // Get the current date in the Africa/Lagos timezone
    const date = new Date().toLocaleDateString('en-GB', { timeZone: 'Africa/Lagos' });
    const parts = date.split('/');
    const day = parts[0].padStart(2, '0');
    const month = parts[1].padStart(2, '0');
    const year = parts[2];
    const newcurrentDate1 = `${day}-${month}-${year}`;

    // Query to retrieve FG output data for OTA site
    const query = `
      SELECT 
        geopos_operator.*, 
        color_master.color_name, 
        item_masterr.item_description, 
        employees_ota.name,
        SUM(fg_output) AS tar
      FROM 
        geopos_operator
      LEFT JOIN 
        employees_ota ON geopos_operator.emp_id = employees_ota.id
      LEFT JOIN 
        item_masterr ON geopos_operator.item = item_masterr.id
      LEFT JOIN 
        color_master ON geopos_operator.color_id = color_master.id
      WHERE 
        geopos_operator.date = '${newcurrentDate1}' AND 
        geopos_operator.site = 'ota'
      GROUP BY 
        geopos_operator.item, geopos_operator.color_id`;

    // Execute the query asynchronously using your existing executeQuery function
    const results = await executeQuery(connection,query);

    res.json(results); // Send the results as JSON response
  } catch (error) {
    console.error('Error querying database:', error);
    res.status(500).json({ error: 'Internal Server Error' });
  } finally {
    if (connection) {
      connection.end();
    }
  }
});


/**
 * @swagger
 * /get_fg_output_search_ota:
 *   post:
 *     summary: Retrieve FG output search results for OTA site.
 *     description: Fetches FG output search results for the OTA site based on the provided date.
 *     tags:
 *       - FG Output
 *     security:
 *       - BearerAuth: []
 *     requestBody:
 *       description: JSON object containing the date for the search.
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             properties:
 *               date:
 *                 type: string
 *                 format: date
 *                 example: "2024-05-25"
 *     responses:
 *       200:
 *         description: Successful response with FG output search results.
 *         content:
 *           application/json:
 *             schema:
 *               type: array
 *               items:
 *                 type: object
 *                 properties:
 *                   emp_id:
 *                     type: integer
 *                     example: 1
 *                   color_name:
 *                     type: string
 *                     example: "Red"
 *                   item_description:
 *                     type: string
 *                     example: "Product A"
 *                   name:
 *                     type: string
 *                     example: "John Doe"
 *                   tar:
 *                     type: integer
 *                     example: 100
 *       400:
 *         description: Bad request indicating missing date value.
 *         content:
 *           application/json:
 *             example:
 *               error: "Date value is missing"
 *       500:
 *         description: Internal server error.
 *         content:
 *           application/json:
 *             example:
 *               error: "Internal Server Error"
 *
 * @function
 * @name getFgOutputSearchOta
 * @memberof module:Routes/FGOutput
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with the database query.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */

// date wise data fetch for ota braid fgoutput
app.post('/get_fg_output_search_ota', authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    const date = req.body.date;
    console.log(date);
    if (!date) {
      return res.status(400).json({ error: 'Date value is missing' });
    }

    const formattedDate = date.split('-').reverse().join('-');
    console.log('formattedDate', formattedDate);

    const query = `
      SELECT
        geopos_operator.*,
        color_master.color_name,
        item_masterr.item_description,
        employees_ota.name,
        SUM(fg_output) as tar
      FROM
        geopos_operator
      LEFT JOIN
        employees_ota ON geopos_operator.emp_id = employees_ota.id
      LEFT JOIN
        item_masterr ON geopos_operator.item = item_masterr.id
      LEFT JOIN
        color_master ON geopos_operator.color_id = color_master.id
      WHERE
        geopos_operator.date = '${formattedDate}' AND
        geopos_operator.site = 'ota'
      GROUP BY
        geopos_operator.item, geopos_operator.color_id`;

    // Execute the query asynchronously
    const results = await executeQuery(connection,query);

    res.json(results);
  } catch (error) {
    console.error('Error querying database:', error);
    res.status(500).json({ error: 'Internal Server Error' });
  } finally {
    if (connection) {
      connection.end();
    }
  }
});


/**
 * @swagger
 * /get_fg_output_default_ota_nbraid:
 *   get:
 *     summary: Get default FG output data for OTA site (NBRAID)
 *     description: Retrieve default FG output data for the OTA site with category type NBRAID for the current date.
 *     tags:
 *       - FG Output
 *     security:
 *       - BearerAuth: []
 *     responses:
 *       200:
 *         description: Default FG output data for OTA site (NBRAID) for the current date.
 *         content:
 *           application/json:
 *             schema:
 *               type: array
 *               items:
 *                 type: object
 *                 properties:
 *                   id:
 *                     type: integer
 *                     description: The ID of the FG output data.
 *                   user:
 *                     type: string
 *                     description: The name of the user associated with the FG output.
 *                   color_name:
 *                     type: string
 *                     description: The name of the color associated with the FG output.
 *                   product_code:
 *                     type: string
 *                     description: The code of the product associated with the FG output.
 *                   product_description:
 *                     type: string
 *                     description: The description of the product associated with the FG output.
 *                   fg_output:
 *                     type: integer
 *                     description: The FG output quantity.
 *                   date_time:
 *                     type: string
 *                     format: date-time
 *                     description: The date and time of the FG output.
 *             example:
 *               - id: 1
 *                 user: "John Doe"
 *                 product_description: "Product A"
 *                 color_name: "Red"
 *                 product_code: "ABC123"
 *                 fg_output: 100
 *                 date_time: "2024-05-24T12:30:45Z"
 *       500:
 *         description: Internal server error.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   description: A general error message.
 *             example:
 *               error: "Internal Server Error"
 *
 * @function
 * @name getDefaultFGOutputOTA_NBRAID
 * @memberof module:Routes/FGOutput
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with the database query.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
// default data fetch for ota nbraid fgoutput
app.get('/get_fg_output_default_ota_nbraid', authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    const date = new Date().toLocaleDateString('en-GB', { timeZone: 'Africa/Lagos' });
    const parts = date.split('/');
    const day = parts[0].padStart(2, '0');
    const month = parts[1].padStart(2, '0');
    const year = parts[2];
    const newcurrentDate1 = `${day}-${month}-${year}`;

    const query = `
      SELECT fg_details.*, geopos_users.name AS user_name, item_masterr.item_description,
             color_master.color_name, item_code.product_code, item_code.product_des
      FROM fg_details
      LEFT JOIN geopos_users ON fg_details.user = geopos_users.id
      LEFT JOIN item_masterr ON fg_details.product_name = item_masterr.id
      LEFT JOIN item_code ON fg_details.product_code = item_code.id
      LEFT JOIN color_master ON item_code.color_id = color_master.id
      WHERE fg_details.date_time = '${newcurrentDate1}' AND fg_details.site = 'ota'
            AND fg_details.category_type = 'NBRAID';
    `;

    // Execute the query asynchronously
    const results = await executeQuery(connection,query);

    res.json(results);
  } catch (error) {
    console.error('Error querying database:', error);
    res.status(500).json({ error: 'Internal Server Error' });
  } finally {
    if (connection) {
      connection.end();
    }
  }
});


/**
 * @swagger
 * /get_fg_output_search_ota_nbraid:
 *   post:
 *     summary: Get FG output data for OTA site (NBRAID) within a specified date range
 *     description: Retrieve FG output data for the OTA site with category type NBRAID within the specified date range.
 *     tags:
 *       - FG Output
 *     security:
 *       - BearerAuth: []
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             properties:
 *               fromdate:
 *                 type: string
 *                 format: date
 *                 description: The start date of the date range.
 *               todate:
 *                 type: string
 *                 format: date
 *                 description: The end date of the date range.
 *             example:
 *               fromdate: "2024-05-01"
 *               todate: "2024-05-15"
 *     responses:
 *       200:
 *         description: FG output data for OTA site (NBRAID) within the specified date range.
 *         content:
 *           application/json:
 *             schema:
 *               type: array
 *               items:
 *                 $ref: '#/components/schemas/FGOutput'
 *       400:
 *         description: Invalid request body format or missing parameters.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   description: Error message indicating the reason for the bad request.
 *       500:
 *         description: Internal server error.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   description: A general error message.
 *             example:
 *               error: "Internal Server Error"
 *
 * @function
 * @name getFGOutputSearchOTA_NBRAID
 * @memberof module:Routes/FGOutput
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with the database query.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */

//date wise search data fetch for ota nbraid fgoutput
app.post('/get_fg_output_search_ota_nbraid', authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    const fromdate = req.body.fromdate;
    const todate = req.body.todate;

    const fdParts = fromdate.split('-');
    const tdParts = todate.split('-');

    const fd = `${fdParts[2]}-${fdParts[1]}-${fdParts[0]}`;
    const td = `${tdParts[2]}-${tdParts[1]}-${tdParts[0]}`;

    const dateObj = new Date(fromdate);
    const day = dateObj.getDate().toString().padStart(2, '0');
    const month = (dateObj.getMonth() + 1).toString().padStart(2, '0');
    const year = dateObj.getFullYear();
    const convertedDate = `${day}-${month}-${year}`;

    const dateObj1 = new Date(todate);
    const day1 = dateObj1.getDate().toString().padStart(2, '0');
    const month1 = (dateObj1.getMonth() + 1).toString().padStart(2, '0');
    const year1 = dateObj1.getFullYear();
    const convertedDate1 = `${day1}-${month1}-${year1}`;

    const fd2 = Math.floor(new Date(fromdate).getTime() / 1000) - (2 * 24 * 60 * 60);
    const td1 = Math.floor(new Date(todate).getTime() / 1000);
    const fd1 = Math.floor(new Date(fd2 * 1000).setDate(new Date(fd2 * 1000).getDate() - 1) / 1000);

    const timestampFDate = fd2;
    const timestampTDate = td1;

    const query = `
      SELECT fg_details.*, geopos_users.name AS user_name, item_masterr.item_description,
             color_master.color_name, item_code.product_code, item_code.product_des
      FROM fg_details
      LEFT JOIN geopos_users ON fg_details.user = geopos_users.id
      LEFT JOIN item_masterr ON fg_details.product_name = item_masterr.id
      LEFT JOIN item_code ON fg_details.product_code = item_code.id
      LEFT JOIN color_master ON item_code.color_id = color_master.id
      WHERE fg_details.time_stamp BETWEEN ? AND ? 
      AND fg_details.site = 'ota'
      AND fg_details.category_type = 'NBRAID';
    `;

    // Execute the query asynchronously
    const results = await executeQuery(connection,query, [timestampFDate, timestampTDate]);

    res.json(results);
  } catch (error) {
    console.error('Error querying database:', error);
    res.status(500).json({ error: 'Internal Server Error' });
  } finally {
    if (connection) {
      connection.end();
    }
  }
});
 

/**
 * @swagger
 * /addfgoutputotanbraid1:
 *   post:
 *     summary: Add FG output for OTA site - NBRAID category.
 *     description: Add FG output details for the OTA site under the NBRAID category.
 *     tags:
 *       - FG Output
 *     security:
 *       - BearerAuth: []
 *     requestBody:
 *       description: JSON object containing FG output details.
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             properties:
 *               product_name:
 *                 type: string
 *                 example: "Product A"
 *               color_description:
 *                 type: string
 *                 example: "Red"
 *               line_no:
 *                 type: integer
 *                 example: 1
 *               fgoutput:
 *                 type: integer
 *                 example: 100
 *               hour:
 *                 type: integer
 *                 example: 8
 *               shift:
 *                 type: string
 *                 example: "Day"
 *               fromdate:
 *                 type: string
 *                 format: date
 *                 example: "2024-05-25"
 *     responses:
 *       200:
 *         description: Successful response indicating FG output details added successfully.
 *         content:
 *           application/json:
 *             example:
 *               status: "Success"
 *               message: "FG Details added successfully"
 *       400:
 *         description: Bad request indicating that the record already exists for the provided details.
 *         content:
 *           application/json:
 *             example:
 *               status: "Error"
 *               message: "Record already exists"
 *       500:
 *         description: Internal server error.
 *         content:
 *           application/json:
 *             example:
 *               status: "Error"
 *               message: "Database error"
 *
 * @function
 * @name addFgOutputOtaNbraid
 * @memberof module:Routes/FGOutput
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with the database query.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
// add fgoutput ota nbraid
app.post('/addfgoutputotanbraid1', authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    const product = req.body.product_name;
    const code = req.body.color_description;
    const line = req.body.line_no;
    const fg_output = req.body.fgoutput;
    const hour = req.body.hour;
    const shift = req.body.shift;
    const date = new Date(req.body.fromdate);

    const formattedDate = `${date.getDate().toString().padStart(2, '0')}-${(date.getMonth() + 1).toString().padStart(2, '0')}-${date.getFullYear()}`;
    const timestampInSeconds = Math.floor(new Date(date).getTime() / 1000);

    const userid = 9; // Replace with the actual way to get the user ID
    const site = 'ota';
    const cat = 'NBRAID';

    const selectQuery = `SELECT * FROM fg_details WHERE product_name = ? AND product_code = ? AND line = ? AND  shift = ? AND hour = ? AND date_time = ? AND site = ?`;
    const values = [product, code, line, shift, hour, formattedDate, site];

    // Execute select query asynchronously
    const selectResult = await executeQuery(connection,selectQuery, values);

    if (selectResult.length > 0) {
      return res.status(400).json({
        status: 'Error',
        message: 'Sorry, for today you have already added the FG OUTPUT for this Product Name and Line!!!',
      });
    }

    const insertData = {
      product_name: product,
      line: line,
      product_code: code,
      hour: hour,
      shift: shift,
      fg_output: fg_output,
      user: userid,
      date_time: formattedDate,
      time_stamp: timestampInSeconds,
      site: site,
      category_type: cat,
    };

    const insertQuery = 'INSERT INTO fg_details SET ?';

    // Execute insert query asynchronously
    const insertResult = await executeQuery(connection,insertQuery, insertData);

    if (insertResult.affectedRows > 0) {
      // Insert operation successful
      const successResponse = { status: 'Success', message: 'FG Details added successfully' };
      return res.status(200).json(successResponse);
    } else {
      // No rows were affected (record already exists)
      const failureResponse = { status: 'Error', message: 'Record already exists' };
      return res.status(400).json(failureResponse);
    }
  } catch (error) {
    console.error('Database error:', error);
    return res.status(500).json({ status: 'Error', message: 'Database error' });
  }  finally {
    if (connection) {
      connection.end();
    }
  }
});

/**
 * @swagger
 * /addfgoutputotanbraid:
 *   post:
 *     summary: Add FG output for OTA site - NBRAID category.
 *     description: Add FG output details for the OTA site under the NBRAID category.
 *     tags:
 *       - FG Output
 *     security:
 *       - BearerAuth: []
 *     requestBody:
 *       description: JSON object containing FG output details.
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             properties:
 *               product_name:
 *                 type: string
 *                 example: "Product A"
 *               line_no:
 *                 type: integer
 *                 example: 1
 *               color_description:
 *                 type: string
 *                 example: "Red"
 *               shift:
 *                 type: string
 *                 example: "Day"
 *               fgoutput:
 *                 type: integer
 *                 example: 100
 *               hour:
 *                 type: integer
 *                 example: 8
 *               fromdate:
 *                 type: string
 *                 format: date
 *                 example: "2024-05-25"
 *     responses:
 *       200:
 *         description: Successful response indicating FG output details added successfully.
 *         content:
 *           application/json:
 *             example:
 *               status: "Success"
 *               message: "FG OUTPUT added successfully!"
 *       400:
 *         description: Bad request indicating that the record already exists for the provided details.
 *         content:
 *           application/json:
 *             example:
 *               status: "Error"
 *               message: "Record already exists"
 *       500:
 *         description: Internal server error.
 *         content:
 *           application/json:
 *             example:
 *               status: "Error"
 *               message: "Internal Server Error"
 *
 * @function
 * @name addFgOutputOtaNbraid
 * @memberof module:Routes/FGOutput
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with the database query.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
// Express route
app.post('/addfgoutputotanbraid', authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    if (!req.body) {
      return res.status(400).json({ status: 'Error', message: 'Invalid request' });
    }
    
    const product = req.body.product_name;
    const line = req.body.line_no;
    const code = req.body.color_description;
    const shifts = req.body.shift;
    const fg_output = req.body.fgoutput;
    const hour = req.body.hour;
    const date = new Date(req.body.fromdate);
    const formattedDate = `${date.getDate().toString().padStart(2, '0')}-${(date.getMonth() + 1).toString().padStart(2, '0')}-${date.getFullYear()}`;
    const timestampInSeconds = Math.floor(new Date(date).getTime() / 1000);

    const userid = req.query.userid;
    const site = 'ota';
    const cat = 'NBRAID';

    const ppQuery = `SELECT item_description FROM item_masterr WHERE id = ${product}`;

    const ppResult = await executeQuery(connection,ppQuery);

    if (ppResult.length === 0) {
      return res.json({ status: 'Error', message: 'Product description not found' });
    }

    const pp = ppResult[0].item_description;

    const workerTimesheetQuery = 'SELECT * FROM worker_timesheet WHERE product_name = ? AND line = ? AND shift = ? AND date_time = ? AND site = ?';
    const workerTimesheetValues = [product, line, shifts, formattedDate, site];

    const wtResult = await executeQuery(connection,workerTimesheetQuery, workerTimesheetValues);
    const num1 = wtResult.length;

    if (num1 === 0) {
      return res.json({
        status: 'Error',
        message: `Production of ${pp} - Line: ${line} - Shift: ${shifts} - Site: ${site} has not started yet for today or the selected date`,
      });
    }

    const data = {
      product_name: product,
      product_code: code,
      line,
      hour,
      shift: shifts,
      fg_output,
      user: userid,
      date_time: formattedDate,
      time_stamp: timestampInSeconds,
      site,
      category_type: cat,
    };

    const isDuplicateQuery = 'SELECT * FROM fg_details WHERE product_name = ? AND line = ? AND shift = ? AND date_time = ? AND hour = ?';
    const isDuplicateValues = [product, line, shifts, formattedDate, hour];

    const duResult = await executeQuery(connection,isDuplicateQuery, isDuplicateValues);
    const isDuplicate = duResult.length > 0;

    if (isDuplicate) {
      return res.json({
        status: 'Error',
        message: `FG output for ${pp} - Line: ${line} - Shift: ${shifts} - Site: ${site} already exists for today or the selected date`,
      });
    }

    const insertFgOutputQuery = 'INSERT INTO fg_details SET ?';
    const insertResult = await executeQuery(connection,insertFgOutputQuery, data);
    const fgoutput_id = insertResult.insertId;

    return res.json({ status: 'Success', message: 'FG OUTPUT added successfully!' });
  } catch (error) {
    console.error('Error adding FG output: ', error);
    return res.status(500).json({ status: 'Error', message: 'Internal Server Error' });
  } finally {
    if (connection) {
      connection.end();  
    }
  }
});




/**
 * @swagger
 * /fg_output_update_ota_nbraid/:
 *   post:
 *     summary: Update FG output for OTA site - NBRAID category.
 *     description: Update FG output details for the OTA site under the NBRAID category.
 *     tags:
 *       - FG Output
 *     security:
 *       - BearerAuth: []
 *     requestBody:
 *       description: JSON object containing FG output details.
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             properties:
 *               id:
 *                 type: integer
 *                 description: The ID of the FG output entry to be updated.
 *                 example: 1
 *               product_name:
 *                 type: string
 *                 description: The name of the product.
 *                 example: "Product A"
 *               color_description:
 *                 type: string
 *                 description: The description of the color.
 *                 example: "Red"
 *               line_no:
 *                 type: integer
 *                 description: The line number.
 *                 example: 1
 *               code:
 *                 type: string
 *                 description: The color code.
 *                 example: "R123"
 *               hour:
 *                 type: integer
 *                 description: The hour of production.
 *                 example: 8
 *               shift:
 *                 type: string
 *                 description: The shift name.
 *                 example: "Day"
 *               fgoutput:
 *                 type: integer
 *                 description: The FG output value.
 *                 example: 100
 *     responses:
 *       200:
 *         description: Successful response indicating FG output details updated successfully.
 *         content:
 *           application/json:
 *             example:
 *               status: "Success"
 *               message: "FG output updated successfully"
 *       400:
 *         description: Bad request indicating that FG data already exists for the provided hour.
 *         content:
 *           application/json:
 *             example:
 *               error: "FG data already exists for this hour"
 *       500:
 *         description: Internal server error.
 *         content:
 *           application/json:
 *             example:
 *               error: "Internal server error"
 *
 * @function
 * @name updateFgOutputOtaNbraid
 * @memberof module:Routes/FGOutput
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with the database query.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */

// PUT endpoint to edit FG output
app.post('/fg_output_update_ota_nbraid/', authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = getPoolConnection();
    const {
      id,
      product_name,
      color_description,
      line_no,
      code,
      hour,
      shift,
      fgoutput
    } = req.body;

    const product_code = color_description;

    console.log('Received Request Body:', req.body);
    console.log('Extracted Values:');
    console.log('id:', id);
    console.log('product_name:', product_name);
    console.log('line_no:', line_no);
    console.log('code:', code);
    console.log('hour:', hour);
    console.log('shift:', shift);
    console.log('fgoutput:', fgoutput);
    console.log('product_code:', product_code);

    // Check if FG output already exists for the given parameters
    const query = `
      SELECT * 
      FROM fg_details 
      WHERE product_name = ? 
        AND product_code = ? 
        AND line = ? 
        AND hour = ? 
        AND shift = ? 
        AND date_time = CURDATE()
    `;
    const values = [product_name, product_code, line_no, hour, shift];

    const rows = await executeQuery(connection,query, values);

    if (rows.length > 0) {
      return res.status(400).json({ error: 'FG data already exists for this hour' });
    }

    // Update FG output
    const updateQuery = `
      UPDATE fg_details 
      SET product_name = ?, line = ?, product_code = ?, hour = ?, shift = ?, fg_output = ? 
      WHERE id = ?
    `;
    const updateValues = [product_name, line_no, product_code, hour, shift, fgoutput, id];

    await executeQuery(connection,updateQuery, updateValues);

    res.json({ status: 'Success', message: 'FG output updated successfully' });
  } catch (error) {
    console.error('Error updating FG data:', error);
    res.status(500).json({ error: 'Internal server error' });
  } finally {
    if (connection) {
      connection.end();
    }
  }
});


//--------------------------Fg Output--------------------------------------//

//-------------------------Import Module-----------------------------------//

/**
 * @swagger
 * /uploadcolor:
 *   post:
 *     summary: Upload color data from a CSV file.
 *     description: Upload color data from a CSV file and import it into the database.
 *     tags:
 *       - Color
 *     security:
 *       - BearerAuth: []
 *     consumes:
 *       - multipart/form-data
 *     parameters:
 *       - in: formData
 *         name: userfile
 *         type: file
 *         description: The CSV file containing color data.
 *     responses:
 *       200:
 *         description: Successful response indicating data imported successfully.
 *         content:
 *           application/json:
 *             example:
 *               status: "Success"
 *               message: "Data Imported Successfully!"
 *       400:
 *         description: Bad request indicating no file uploaded or no new colors to import.
 *         content:
 *           application/json:
 *             example:
 *               status: "Error"
 *               message: "No file uploaded"  # or "No new colors to import"
 *       500:
 *         description: Internal server error or database import error.
 *         content:
 *           application/json:
 *             example:
 *               status: "Error"
 *               message: "Database Import Error! Please check your file and its content."
 *
 * @function
 * @name uploadColorData
 * @memberof module:Routes/Color
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with the database import.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */


//Import Color
app.post('/uploadcolor', upload.single('userfile'), authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    if (!req.file) {
      return res.status(400).json({ message: 'No file uploaded' });
    }

    const file = req.file;

    const filePath = file.path;
    const parser = csv({ delimiter: ',' });

    const colorEntries = [];

    parser.on('readable', () => {
      let record;
      while ((record = parser.read())) {
        console.log('Records:', record); // Log the record to the console

        const colorEntry = {
          name: record.colorname
        };
        console.log('Color Entry:', colorEntry);

        if (record) {
          colorEntries.push(colorEntry);
        } else {
          console.log('Skipping invalid record:', record);
        }
      }
    });

    parser.on('end', () => {
      fs.unlinkSync(filePath); // Delete the uploaded file

      const colorNames = colorEntries.map(entry => entry.name);

      const selectQuery = `SELECT color_name FROM color_master WHERE color_name IN (?)`;

      db.query(selectQuery, [colorNames], (selectError, selectResults) => {
        if (selectError) {
          console.error(selectError);
          res.status(500).json({ status: 'Error', message: 'Database Import Error! Please try again later.' });
          return;
        }

        const existingColors = selectResults.map(row => row.color_name);
        const newColors = colorNames.filter(name => !existingColors.includes(name));

        if (newColors.length === 0) {
          res.status(400).json({ status: 'Error', message: 'No new colors to import' });
          return;
        }

        const insertQuery = `INSERT INTO color_master (color_name) VALUES ?`;

        db.query(insertQuery, [newColors.map(name => [name])], (insertError, insertResult) => {
          if (insertError) {
            console.error(insertError);
            res.status(500).json({ status: 'Error', message: 'Database Import Error! Please check your file and its content.' });
            return;
          }

          res.json({ status: 'Success', message: 'Data Imported Successfully!' });
        });
      });
    });

    fs.createReadStream(filePath).pipe(parser);
  } catch (error) {
    console.error(error);
    res.status(500).json({ status: 'Error', message: 'Database Import Error! Please check your file and its content.' });
  } finally {
    if (connection) {
      connection.release();
      //console.log("Connection released");
    }
  }
});


/**
 * @swagger
 * /uploadline:
 *   post:
 *     summary: Upload line data from a CSV file.
 *     description: Upload line data from a CSV file and import it into the database.
 *     tags:
 *       - Line
 *     security:
 *       - BearerAuth: []
 *     consumes:
 *       - multipart/form-data
 *     parameters:
 *       - in: formData
 *         name: userfile
 *         type: file
 *         description: The CSV file containing line data.
 *     responses:
 *       200:
 *         description: Successful response indicating data imported successfully.
 *         content:
 *           application/json:
 *             example:
 *               status: "Success"
 *               message: "Data Imported Successfully!"
 *       400:
 *         description: Bad request indicating no file uploaded or no new lines to import.
 *         content:
 *           application/json:
 *             example:
 *               status: "Error"
 *               message: "No file uploaded"  # or "No new lines to import"
 *       500:
 *         description: Internal server error or database import error.
 *         content:
 *           application/json:
 *             example:
 *               status: "Error"
 *               message: "Database Import Error! Please check your file and its content."
 *
 * @function
 * @name uploadLineData
 * @memberof module:Routes/Line
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with the database import.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */

//Import Line
app.post('/uploadline', upload.single('userfile'), authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    if (!req.file) {
      return res.status(400).json({ message: 'No file uploaded' });
    }

    const file = req.file;
    const filePath = file.path;
    const parser = csv({ delimiter: ',' });

    const lineNames = [];

    parser.on('readable', () => {
      let record;
      while ((record = parser.read())) {
        console.log('Records:', record); // Log the record to the console

        const lineName = record.linename; 
        console.log('Line Name:', lineName);
        console.log('Record Length:', Object.keys(record).length);
    
        if (record) {
          lineNames.push(lineName);
        } else {
          console.log('Skipping invalid record:', record);
        }
      }
    });

    parser.on('end', () => {
      fs.unlinkSync(filePath); // Delete the uploaded file

      const values = lineNames.map((lineName) => [lineName]);
      const flattenedValues = values.flat();
      console.log('flattenedValues:', flattenedValues);

      const selectQuery = `SELECT line_name FROM line_master WHERE line_name IN (?)`;

      db.query(selectQuery, [flattenedValues], (selectError, selectResults) => {
        if (selectError) {
          console.error(selectError);
          res.status(500).json({ status: 'Error', message: 'Database Import Error! Please try again later.' });
          return;
        }

        const existingLines = selectResults.map(row => row.line_name);
        const newLines = lineNames.filter(name => !existingLines.includes(name));

        if (newLines.length === 0) {
          res.status(400).json({ status: 'Error', message: 'No new lines to import' });
          return;
        }

        const insertQuery = `INSERT INTO line_master (line_name) VALUES ?`;

        db.query(insertQuery, [newLines.map(name => [name])], (insertError, insertResult) => {
          if (insertError) {
            console.error(insertError);
            res.status(500).json({ status: 'Error', message: 'Database Import Error! Please check your file and its content.' });
            return;
          }

          res.json({ status: 'Success', message: 'Data Imported Successfully!' });
        });
      });
    });

    fs.createReadStream(filePath).pipe(parser);
  } catch (error) {
    console.error(error);
    res.status(500).json({ status: 'Error', message: 'Database Import Error! Please check your file and its content.' });
  } finally {
    if (connection) {
      connection.release();
      //console.log("Connection released");
    }
  }
});




//Import Section
/**
 * @swagger
 * /uploadsection:
 *   post:
 *     summary: Uploads a CSV file to import section data.
 *     description: Uploads a CSV file containing section data and imports it into the database. The file should contain columns for section name, target unit, and section type.
 *     tags:
 *       - Section
 *     security:
 *       - JWTAuth: []
 *     requestBody:
 *       required: true
 *       content:
 *         multipart/form-data:
 *           schema:
 *             type: object
 *             properties:
 *               userfile:
 *                 type: string
 *                 format: binary
 *                 description: The CSV file to upload.
 *     responses:
 *       200:
 *         description: Data imported successfully.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 status:
 *                   type: string
 *                   example: "Success"
 *                 message:
 *                   type: string
 *                   example: "Data Imported Successfully!"
 *       400:
 *         description: No file uploaded or no new sections to import.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 status:
 *                   type: string
 *                   example: "Error"
 *                 message:
 *                   type: string
 *                   example: "No file uploaded"
 *       500:
 *         description: Database import error.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 status:
 *                   type: string
 *                   example: "Error"
 *                 message:
 *                   type: string
 *                   example: "Database Import Error! Please check your file and its content."
 *
 * @function
 * @name uploadsection
 * @memberof module:Routes/Section
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {DatabaseError} Will throw an error if there's an issue with the database operation.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
app.post('/uploadsection', upload.single('userfile'), authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    if (!req.file) {
      return res.status(400).json({ message: 'No file uploaded' });
    }

    const file = req.file;
    const filePath = file.path;
    const parser = csv({ delimiter: ',' });

    const sectionData = [];

    parser.on('readable', () => {
      let record;
      while ((record = parser.read())) {
        console.log('Records:', record); // Log the record to the console

        const sectionName = record.sectionname; 
        console.log('Section Name:', sectionName);
        console.log('Record Length:', Object.keys(record).length);
    
        if (record) {
          const newSection = {
            section_name: record.sectionname,
            target_unit: record.targetunit,
            section_type: record.itemcategory,
          };
          sectionData.push(newSection);
        } else {
          console.log('Skipping invalid record:', record);
        }
      }
    });

    parser.on('end', () => {
      fs.unlinkSync(filePath); // Delete the uploaded file

      const sectionNames = sectionData.map(section => section.section_name);

      const selectQuery = `SELECT section_name FROM section WHERE section_name IN (?)`;

      db.query(selectQuery, [sectionNames], (selectError, selectResults) => {
        if (selectError) {
          console.error(selectError);
          res.status(500).json({ status: 'Error', message: 'Database Import Error! Please try again later.' });
          return;
        }

        const existingSections = selectResults.map(row => row.section_name);
        const newSections = sectionData.filter(section => !existingSections.includes(section.section_name));

        if (newSections.length === 0) {
          res.status(400).json({ status: 'Error', message: 'No new sections to import' });
          return;
        }

        const values = newSections.map(section => [section.section_name, section.target_unit, section.section_type]);
        const placeholders = values.map(() => '(?, ?, ?)').join(', ');
        const insertQuery = `INSERT INTO section (section_name, target_unit, section_type) VALUES ${placeholders}`;

        const flattenedValues = values.flat();
        db.query(insertQuery, flattenedValues, (insertError, insertResult) => {
          if (insertError) {
            console.error(insertError);
            res.status(500).json({ status: 'Error', message: 'Database Import Error! Please check your file and its content.' });
            return;
          }

          res.json({ status: 'Success', message: 'Data Imported Successfully!' });
        });
      });
    });

    fs.createReadStream(filePath).pipe(parser);
  } catch (error) {
    console.error(error);
    res.status(500).json({ status: 'Error', message: 'Database Import Error! Please check your file and its content.' });
  } finally {
    if (connection) {
      connection.release();
      //console.log("Connection released");
    }
  }
});



//Import Item
/**
 * @swagger
 * /uploaditem:
 *   post:
 *     summary: Upload item data from a CSV file.
 *     description: Upload item data from a CSV file and import it into the database.
 *     tags:
 *       - Item
 *     security:
 *       - BearerAuth: []
 *     consumes:
 *       - multipart/form-data
 *     parameters:
 *       - in: formData
 *         name: userfile
 *         type: file
 *         description: The CSV file containing item data.
 *     responses:
 *       200:
 *         description: Successful response indicating data imported successfully or no new data to import.
 *         content:
 *           application/json:
 *             example:
 *               status: "Success"
 *               message: "Data Imported Successfully!"  # or "No new data to import."
 *       400:
 *         description: Bad request indicating no file uploaded or duplicate item descriptions found.
 *         content:
 *           application/json:
 *             example:
 *               status: "Error"
 *               message: "No file uploaded"  # or "Duplicate item descriptions found: item1, item2"
 *       500:
 *         description: Internal server error or database import error.
 *         content:
 *           application/json:
 *             example:
 *               status: "Error"
 *               message: "Database Import Error! Please check your file and its content."
 *
 * @function
 * @name uploadItemData
 * @memberof module:Routes/Item
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with the database import.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */

app.post('/uploaditem', upload.single('userfile'), authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    if (!req.file) {
      return res.status(400).json({ message: 'No file uploaded' });
    }

    const file = req.file;
    const filePath = file.path;
    const parser = csv({ delimiter: ',' });

    const itemNames = [];
    let totalRecords = 0;
    let processedRecords = 0;

    parser.on('readable', () => {
      let record;
      while ((record = parser.read())) {
        console.log('Records:', record); // Log the record to the console
        totalRecords++;
        const itemGroup = record.etacode;
        const itemCategory = record['itemcategory(BRAIDS/NON-BRAIDS/ALL)']; // Accessing 'category type(BRAID/NBRAID)' column
        const itemDescription = record.itemdescription;
        const tppp = record.targetppp;
        const netWeight = record.netweight;
        const targetedWaste = record.targetedwaste;

        // Adding console logs
        console.log("Item Group:", itemGroup);
        console.log("Item Category:", itemCategory);
        console.log("Item Description:", itemDescription);
        console.log("Target PPP:", tppp);
        console.log("Net Weight:", netWeight);
        console.log("Targeted Waste:", targetedWaste);

        const catQuery = `SELECT id FROM item_category WHERE category_name='${itemCategory}'`;
        console.log("catQuery:", catQuery); // Check the query being executed

        db.query(catQuery, (error, results) => {
          if (error) throw error;

          if (results.length === 0) {
            console.log('No category found for:', itemCategory);
            // Handle the case where no category is found
            // You may want to insert a default category or handle it in another appropriate way
          } else {
            const cat = results[0].id;

            const duplicateCheckQuery = `SELECT id FROM item_masterr WHERE item_description='${itemDescription}'`;
            db.query(duplicateCheckQuery, (error, results) => {
              if (error) throw error;

              processedRecords++; // Increment processed records

              if (results.length === 0) {
                itemNames.push({
                  item_group: itemGroup,
                  item_description: itemDescription,
                  category_id: cat,
                  tppp: tppp,
                  net_weight: netWeight,
                  targeted_waste: targetedWaste,
                });
              } else {
                console.log('Record already exists:', itemDescription);
              }

              if (processedRecords === totalRecords) {
                // Process item names after all records are processed
                processItemNames();
              }
            });
          }
        });
      }
    });

    parser.on('end', () => {
      fs.unlinkSync(filePath); // Delete the uploaded file
    });

    fs.createReadStream(filePath).pipe(parser);

    function processItemNames() {
      if (itemNames.length === 0) {
        console.log('No items to process.');
        res.json({ status: 'Success', message: 'No new data to import.' });
        return;
      }

      const values = itemNames.map(Object.values);
      console.log('Values:', values);

      const flattenedValues = values.flat();
      console.log('flattenedValues:', flattenedValues);

      const duplicateCheckQuery = `SELECT item_description FROM item_masterr WHERE item_description IN (?)`;

      db.query(duplicateCheckQuery, [itemNames.map(item => item.item_description)], (error, results) => {
        if (error) {
          console.error(error);
          res.status(500).json({ status: 'Error', message: 'Database Import Error! Please check your file and its content.' });
          return;
        }

        const duplicateItems = results.map((row) => row.item_description);

        if (duplicateItems.length > 0) {
          res.status(400).json({ status: 'Error', message: `Duplicate item descriptions found: ${duplicateItems.join(', ')}` });
          return;
        }

        const placeholders = values.map(() => '(?, ?, ?, ?, ?, ?)').join(', ');

        const insertQuery = `INSERT INTO item_masterr (item_group, item_description, category_id, tppp, net_weight, targeted_waste) VALUES ${placeholders}`;

        db.query(insertQuery, flattenedValues, (insertError, insertResult) => {
          if (insertError) {
            console.error(insertError);
            res.status(500).json({ status: 'Error', message: 'Database Import Error! Please check your file and its content.' });
            return;
          }

          res.json({ status: 'Success', message: 'Data Imported Successfully!' });
        });
      });
    }
  } catch (error) {
    console.error(error);
    res.status(500).json({ status: 'Error', message: 'Database Import Error! Please check your file and its content.' });
  } finally {
    connection.end();
    console.log('Database connection closed.');
  }
});

//Import Plan vs Target

// Define the dbQuery function
function dbQuery(query, values) {
  return new Promise((resolve, reject) => {
    db.query(query, values, (error, results) => {
      if (error) {
        reject(error);
      } else {
        resolve(results);
      }
    });
  });
}


/**
 * @swagger
 * /uploadplanvstarget:
 *   post:
 *     summary: Upload plan vs target data from a CSV file.
 *     description: Upload plan vs target data from a CSV file and import it into the database.
 *     tags:
 *       - Plan vs Target
 *     security:
 *       - BearerAuth: []
 *     consumes:
 *       - multipart/form-data
 *     parameters:
 *       - in: formData
 *         name: userfile
 *         type: file
 *         description: The CSV file containing plan vs target data.
 *     responses:
 *       200:
 *         description: Successful response indicating data imported successfully.
 *         content:
 *           application/json:
 *             example:
 *               status: "Success"
 *               message: "Data Imported Successfully!"
 *       400:
 *         description: Bad request indicating no file uploaded.
 *         content:
 *           application/json:
 *             example:
 *               status: "Error"
 *               message: "No file uploaded"
 *       500:
 *         description: Internal server error or database import error.
 *         content:
 *           application/json:
 *             example:
 *               status: "Error"
 *               message: "Database Import Error! Please check your file and its content."
 *
 * @function
 * @name uploadPlanVsTarget
 * @memberof module:Routes/PlanVsTarget
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with the database import.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
app.post('/uploadplanvstarget', upload.single('userfile'), authenticateJWT,async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    if (!req.file) {
      return res.status(400).json({ message: 'No file uploaded' });
    }

    const file = req.file;
    const filePath = file.path;
    const parser = csv({ delimiter: ',' });

    const targetNames = [];

    await new Promise((resolve, reject) => {
      parser.on('readable', () => {
        let record;
        while ((record = parser.read())) {
          console.log('Records:', record); // Log the record to the console
          const productcode = record.productcode;
          const productdescription = record.productdescription;

          // Print date keys and values
          const dateKeys = Object.keys(record).filter(key => key !== 'productcode' && key !== 'productdescription');

          dateKeys.forEach(async (key, index) => {
            const modifiedKey = key; // Modify the key
            const [day, month, year] = modifiedKey.split('-');
            const isoDate = new Date(`${year}-${month}-${day}`).toISOString();
            const timestamp = Math.floor(new Date(isoDate).getTime() / 1000);
            const dateValue = record[key]; // Store the value in a variable

            try {
              // Query to fetch the ID based on the product code
              const results = await dbQuery('SELECT * FROM item_code WHERE product_code = ?', [productcode]);
              if (results.length > 0) {
                const product = results[0].id;
                const product_id = results[0].product_id;

                // Second query using the retrieved product_id
                const results2 = await executeQuery(connection,'SELECT * FROM item_masterr WHERE id = ?', [product_id]);
                if (results2.length > 0) {
                  const categoryid = results2[0].category_id;

                  // Third query using the retrieved categoryid
                  const results3 = await executeQuery(connection,'SELECT id FROM target_plan_ota WHERE item_code_id = ? AND date = ?', [product, modifiedKey]);
                  if (results3.length === 0) {
                    targetNames.push({
                      item_code_id: product,
                      category: categoryid,
                      target_plan: dateValue,
                      date: modifiedKey,
                      timestamp: timestamp,
                    });
                  }
                } else {
                  console.log('Category Id not found for product ID:', product_id);
                }
              } else {
                console.log('Product code not found:', productcode);
              }

              if (index === dateKeys.length - 1) {
                console.log('targetNames:', targetNames);
                resolve(); // Resolve the promise when all dates are processed
              }
            } catch (error) {
              console.error('Error:', error);
              reject(error); // Reject the promise if there's an error
            }
          });

          console.log('Record Length:', Object.keys(record).length);
        }
      });

      parser.on('end', () => {
        fs.unlinkSync(filePath); // Delete the uploaded file
      });

      fs.createReadStream(filePath).pipe(parser);
    });

    if (targetNames.length === 0) {
      console.log('No targets to process.');
      return;
    }

    // Process targetNames
    for (const entry of targetNames) {
      try {
        const insertResult = await executeQuery(connection,'INSERT INTO target_plan_ota (item_code_id, category, target_plan, date, timestamp) VALUES (?, ?, ?, ?, ?)', [
          entry.item_code_id,
          entry.category,
          entry.target_plan,
          entry.date,
          entry.timestamp,
        ]);
        console.log('Row inserted:', entry);
      } catch (insertError) {
        console.error('Error inserting data:', insertError);
        // Handle the error as needed
      }
    }
    // Send success response after successful insert
    res.json({ status: 'Success', message: 'Data Imported Successfully!' });
    
  } catch (error) {
    console.error('Error:', error);
    res.status(500).json({ status: 'Error', message: 'Database Import Error! Please check your file and its content.' });
  } finally {
    if (connection) {
      connection.end();
    }
  }
});


/**
 * @swagger
 * /uploaditemcolorcode:
 *   post:
 *     summary: Upload item color code data from a CSV file.
 *     description: Upload item color code data from a CSV file and import it into the database.
 *     tags:
 *       - Item Color Code
 *     security:
 *       - BearerAuth: []
 *     consumes:
 *       - multipart/form-data
 *     parameters:
 *       - in: formData
 *         name: userfile
 *         type: file
 *         description: The CSV file containing item color code data.
 *     responses:
 *       200:
 *         description: Successful response indicating data imported successfully.
 *         content:
 *           application/json:
 *             example:
 *               status: "Success"
 *               message: "Data Imported Successfully!"
 *       400:
 *         description: Bad request indicating no file uploaded.
 *         content:
 *           application/json:
 *             example:
 *               status: "Error"
 *               message: "No file uploaded"
 *       500:
 *         description: Internal server error or database import error.
 *         content:
 *           application/json:
 *             example:
 *               status: "Error"
 *               message: "Database Import Error! Please check your file and its content."
 *
 * @function
 * @name uploadItemColorCode
 * @memberof module:Routes/ItemColorCode
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with the database import.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */

//Import Item Color Code
app.post('/uploaditemcolorcode', upload.single('userfile'), authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    if (!req.file) {
      return res.status(400).json({ message: 'No file uploaded' });
    }

    const file = req.file;
    const filePath = file.path;
    const parser = csv({ delimiter: ',' });

    const itemcolorNames = [];

    parser.on('readable', () => {
      let record;
      while ((record = parser.read())) {
        console.log('Records:', record); // Log the record to the console
        const itemcode = record.itemcode;
        const productname = record.productname;
        const productdescription = record.productdescription;
        const colorcode = record.colorcode;
        console.log('Item Code:', itemcode);
        console.log('Product Name:', productname);
        console.log('Product Description:', productdescription);
        console.log('Color Code:', colorcode);
        console.log('Record Length:', Object.keys(record).length);

        itemcolorNames.push({
          itemcode: itemcode,
          productname: productname,
          productdescription: productdescription,
          colorcode: colorcode
        });
      }
    });

    parser.on('end', async () => {
      fs.unlinkSync(filePath); // Delete the uploaded file

      // Process itemcolorNames only if there are items to process
      if (itemcolorNames.length > 0) {
        await processItemColorNames();
      } else {
        console.log('No items to process.');
      }
    });

    fs.createReadStream(filePath).pipe(parser);

    async function processItemColorNames() {
      const promises = itemcolorNames.map(async (item) => {
        try {
          // Execute MySQL queries to fetch IDs
          const productResults = await executeQuery(connection,'SELECT * FROM item_masterr WHERE item_description = ?', [item.productname]);
          const productId = productResults.length > 0 ? productResults[0].id : null;

          const colorResults = await executeQuery(connection,'SELECT * FROM color_master WHERE color_name = ?', [item.colorcode]);
          const colorId = colorResults.length > 0 ? colorResults[0].id : null;

          console.log('Product ID:', productId);
          console.log('Color ID:', colorId);

          if (colorResults.length > 0) {
            console.log('Color information not found, pushing item to itemcolorNames:', item.itemcode);
            return {
              itemcode: item.itemcode,
              product_id: productId,
              product_des: item.productdescription,
              color_id: colorId,
            };
          } else {
            console.log('Color found, skipping item:', item.itemcode, item.productname, item.colorcode);
            return null;
          }
        } catch (error) {
          console.error(error);
          return null;
        }
      });

      const resolvedItems = await Promise.all(promises);
      const validItems = resolvedItems.filter(item => item !== null);

      if (validItems.length === 0) {
        console.log('No valid items to process.');
        return;
      }

      const values = validItems.map(Object.values);
      console.log('Values:', values);

      // Generate placeholders for each row
      const placeholders = values.map(() => '(?, ?, ?, ?)').join(', ');

      // Flatten the values array to pass as parameters to the query
      const flattenedValues = values.flat();
      console.log('flattenedValues:', flattenedValues);

      const insertQuery = `INSERT INTO item_code(product_code, product_id, product_des, color_id) VALUES ${placeholders}`;

      await executeQuery(connection,insertQuery, flattenedValues);

      res.json({ status: 'Success', message: 'Data Imported Successfully!' });
    }
  } catch (error) {
    console.error(error);
    res.status(500).json({ status: 'Error', message: 'Database Import Error! Please check your file and its content.' });
  } finally {
    if (connection) {
      connection.end();
    }
  }
});
  

//Import Employee
const { promisify } = require('util');
const writeFileAsync = promisify(fs.writeFile);
const unlinkAsync = promisify(fs.unlink);

// Use an array to store accumulated CSV responses
let accumulatedCsvData = [];


/**
 * @swagger
 * /downloademployeebackup:
 *   get:
 *     summary: Download employee backup data.
 *     description: Fetch and accumulate CSV data of active employees with role ID 1.
 *     tags:
 *       - Employee Backup
 *     security:
 *       - BearerAuth: []
 *     responses:
 *       200:
 *         description: CSV data accumulated successfully.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 status:
 *                   type: string
 *                   example: Success
 *                 message:
 *                   type: string
 *                   example: CSV data accumulated successfully
 *       500:
 *         description: Internal Server Error.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 status:
 *                   type: string
 *                   example: Error
 *                 message:
 *                   type: string
 *                   example: Internal Server Error
 * @function
 * @name downloademployeebackup
 * @memberof module:Routes/EmployeeBackup
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */

app.get('/downloademployeebackup', authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    const query = `
      SELECT entryid as EntryId, status as Status, staff as Site
      FROM employees_ota
      WHERE passive_type='ACT' AND roleid='1'
    `;

    console.log('Query:', query);

    const results = await executeQuery(connection,query);

    console.log('Query Results:', results);

    const data = results.map((row) => ({
      Entryid: row.Entryid,
      Status: row.Status,
      Site: row.Site,
    }));

    const csvData = [
      ['Entryid', 'Status', 'Site'],
      ...data.map((row) => Object.values(row)),
    ];

    accumulatedCsvData.push(...csvData);

    res.status(200).json({ status: 'Success', message: 'CSV data accumulated successfully' });
  } catch (error) {
    console.error('Error:', error);
    res.status(500).json({ status: 'Error', message: 'Internal Server Error' });
  } finally {
    if (connection) {
      connection.end();
    }
  }
});


/**
 * @swagger
 * /saveaccumulatedcsv:
 *   get:
 *     summary: Save and download the accumulated CSV data.
 *     description: Save the accumulated CSV data to a file and initiate a download for the client.
 *     tags:
 *       - Employee Backup
 *     security:
 *       - BearerAuth: []
 *     responses:
 *       200:
 *         description: CSV file downloaded successfully.
 *         content:
 *           text/csv:
 *             schema:
 *               type: string
 *               format: binary
 *       400:
 *         description: No accumulated CSV data.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 status:
 *                   type: string
 *                   example: Error
 *                 message:
 *                   type: string
 *                   example: No accumulated CSV data
 *       500:
 *         description: Internal Server Error.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 status:
 *                   type: string
 *                   example: Error
 *                 message:
 *                   type: string
 *                   example: Internal Server Error
 * @function
 * @name saveaccumulatedcsv
 * @memberof module:Routes/EmployeeBackup
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
app.get('/saveaccumulatedcsv',authenticateJWT, async (req, res) => {
  try {
    if (accumulatedCsvData.length === 0) {
      res.status(400).json({ status: 'Error', message: 'No accumulated CSV data' });
      return;
    }

    const fileName = 'Employee-Master.csv';
    const csvFolderPath = path.join(__dirname, 'csv_files');
    const filePath = path.join(csvFolderPath, fileName);

    const csvContent = accumulatedCsvData.map((row) => row.join(',')).join('\n');

    // Write CSV content to file
    await writeFileAsync(filePath, csvContent);

    // Set the response headers for file download
    res.setHeader('Content-Type', 'text/csv');
    res.setHeader('Content-Disposition', `attachment; filename="${fileName}"`);
    res.setHeader('Content-Length', Buffer.byteLength(csvContent, 'utf-8'));

    // Pipe the file to the response
    const readStream = fs.createReadStream(filePath);
    readStream.pipe(res);

    readStream.on('end', async () => {
      // Delete the file after it has been sent
      await unlinkAsync(filePath);
      console.log('File downloaded and deleted successfully');

      // Clear accumulated responses for the next download
      accumulatedCsvData = [];
    });
  } catch (error) {
    console.error('Error:', error);
    res.status(500).json({ status: 'Error', message: 'Internal Server Error' });
  }
});

/**
 * @swagger
 * /uploadfgdetails2:
 *   post:
 *     summary: Upload FG details from CSV file.
 *     description: Upload FG (Finished Goods) details from a CSV file and save them to the database.
 *     tags:
 *       - FG Details
 *     security:
 *       - BearerAuth: []
 *     requestBody:
 *       required: true
 *       content:
 *         multipart/form-data:
 *           schema:
 *             type: object
 *             properties:
 *               userfile:
 *                 type: string
 *                 format: binary
 *     responses:
 *       200:
 *         description: FG details uploaded successfully.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 status:
 *                   type: string
 *                   example: Success
 *                 message:
 *                   type: string
 *                   example: Data Imported Successfully!
 *       400:
 *         description: No file uploaded.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 message:
 *                   type: string
 *                   example: No file uploaded
 *       500:
 *         description: Database Import Error.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 status:
 *                   type: string
 *                   example: Error
 *                 message:
 *                   type: string
 *                   example: Database Import Error! Please check your file and its content.
 * @function
 * @name uploadfgdetails2
 * @memberof module:Routes/FGDetails
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */

//Import Fg Details Nbraid
app.post('/uploadfgdetails2', upload.single('userfile'), authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    if (!req.file) {
      return res.status(400).json({ message: 'No file uploaded' });
    }

    const file = req.file;

    const filePath = file.path;
    const parser = csv({ delimiter: ',' });

    const itemfgDetails = [];

    parser.on('readable', () => {
      let record;
      while ((record = parser.read())) {
        console.log('Records:', record); // Log the record to the console
        
        const productname = record.productname;
        const productcode = record.productcode;
        const line = record.line;
        const hour = record.hour;
        const fgoutput = record.fgoutput;
        const datetime = record.datetime;
        const userid = 9;
    
        // Read additional columns
        const shift = record['shift(DAY/NIGHT)']; // Accessing 'shift(DAY/NIGHT)' column
        const site = record['site(ikeja/ota)']; // Accessing 'site(ikeja/ota)' column
        const categoryType = record['category type(BRAID/NBRAID)']; // Accessing 'category type(BRAID/NBRAID)' column
        //const timestamp = 9;
    
        // Convert datetime to timestamp
        const [day, month, year] = datetime.split('-');
        const timestamp = new Date(`${year}-${month}-${day}`).getTime() / 1000; // Convert to Unix timestamp
        
        console.log('Product Name:', productname);
        console.log('Product Code:', productcode);
        console.log('Line:', line);
        console.log('Hour:', hour);
        console.log('FgOutput:', fgoutput);
        console.log('Date Time:', datetime);
        console.log('UserId:', userid);
        console.log('categoryType:', categoryType);
        console.log('shift:', shift);
        console.log('site:', site);
        console.log('Record Length:', Object.keys(record).length);
    
        // Execute MySQL queries to fetch IDs
        executeQuery(connection,'SELECT id FROM item_masterr WHERE item_description = ?', [productname])
          .then(productResults => {
            const productId = productResults.length > 0 ? productResults[0].id : null;
    
            executeQuery(connection,'SELECT id FROM item_code WHERE product_code = ?', [productcode])
              .then(codeResults => {
                const code = codeResults.length > 0 ? codeResults[0].id : null;
    
                console.log('Product ID:', productId);
                console.log('Code Id:', code);
    
                if (codeResults.length > 0) {
                  console.log('Code information found, pushing item to itemfgDetails:', productcode);
                  itemfgDetails.push({
                    product_name: productId,
                    product_code: code,
                    line: line,
                    hour: hour,
                    fg_output: fgoutput,
                    date_time: datetime,
                    time_stamp: timestamp,
                    user: userid,
                    shift: shift,
                    site: site,
                    category_type: categoryType
                  });
                  console.log('Pushed Item:', productcode);
                  console.log('Updated itemfgDetails:', itemfgDetails);
                  processItemCodeNames(); // Call the function to process itemcolorNames
                } else {
                  console.log('Code not found, skipping item:', productcode, productname, code);
                }
              })
              .catch(codeError => {
                console.error('Error fetching product code:', codeError);
              });
          })
          .catch(productError => {
            console.error('Error fetching product ID:', productError);
          });
      }
    });
    

    
    parser.on('end', () => {
      fs.unlinkSync(filePath); // Delete the uploaded file
      processItemCodeNames(); // Call the function to process itemfgDetails
    });

    fs.createReadStream(filePath).pipe(parser);

    function processItemCodeNames() {
      if (itemfgDetails.length === 0) {
        console.log('No items to process.');
        return;
      }

      const values = itemfgDetails.map(item => [item.product_name, item.product_code, item.line, item.hour, item.fg_output, item.date_time, item.time_stamp, item.user, item.shift, item.site, item.category_type]);
      console.log('Values:', values);
      
      const insertQuery = `INSERT INTO fg_details (product_name, product_code, line, hour, fg_output, date_time, time_stamp, user, shift, site, category_type) VALUES ?`;

      executeQuery(connection,insertQuery, [values])
        .then(insertResult => {
          res.json({ status: 'Success', message: 'Data Imported Successfully!' });
        })
        .catch(insertError => {
          console.error(insertError);
          res.status(500).json({ status: 'Error', message: 'Database Import Error! Please check your file and its content.' });
        });
    }
  } catch (error) {
    console.error(error);
    res.status(500).json({ status: 'Error', message: 'Database Import Error! Please check your file and its content.' });
  } finally {
    connection.end();
    console.log('Database connection closed.');
  }
});


/**
 * @swagger
 * /uploadfgdetails:
 *   post:
 *     summary: Upload FG details from CSV file.
 *     description: Upload FG (Finished Goods) details from a CSV file and save them to the database.
 *     tags:
 *       - FG Details
 *     security:
 *       - BearerAuth: []
 *     requestBody:
 *       required: true
 *       content:
 *         multipart/form-data:
 *           schema:
 *             type: object
 *             properties:
 *               userfile:
 *                 type: string
 *                 format: binary
 *     responses:
 *       200:
 *         description: FG details uploaded successfully.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 status:
 *                   type: string
 *                   example: Success
 *                 message:
 *                   type: string
 *                   example: Data Imported Successfully!
 *       400:
 *         description: No file uploaded.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 message:
 *                   type: string
 *                   example: No file uploaded
 *       500:
 *         description: Database Import Error.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 status:
 *                   type: string
 *                   example: Error
 *                 message:
 *                   type: string
 *                   example: Database Import Error! Please check your file and its content.
 * @function
 * @name uploadfgdetails
 * @memberof module:Routes/FGDetails
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */

app.post('/uploadfgdetails', upload.single('userfile'),authenticateJWT,async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
      if (!req.file) {
          return res.status(400).json({ message: 'No file uploaded' });
      }

      const file = req.file;
      const filePath = file.path;
      const parser = csv({ delimiter: ',' });

      const itemfgDetails = [];

      parser.on('readable', () => {
          let record;
          while ((record = parser.read())) {
              console.log('Records:', record); // Log the record to the console

              const productname = record.productname;
              const productcode = record.productcode;
              const line = record.line;
              const hour = record.hour;
              const fgoutput = record.fgoutput;
              const datetime = record.datetime;
              const userid = 9;

              // Read additional columns
              const shift = record['shift(DAY/NIGHT)']; // Accessing 'shift(DAY/NIGHT)' column
              const site = record['site(ikeja/ota)']; // Accessing 'site(ikeja/ota)' column
              const categoryType = record['category type(BRAID/NBRAID)']; // Accessing 'category type(BRAID/NBRAID)' column

              // Convert datetime to timestamp
              const [day, month, year] = datetime.split('-');
              const timestamp = new Date(`${year}-${month}-${day}`).getTime() / 1000; // Convert to Unix timestamp

              console.log('Product Name:', productname);
              console.log('Product Code:', productcode);
              console.log('Line:', line);
              console.log('Hour:', hour);
              console.log('FgOutput:', fgoutput);
              console.log('Date Time:', datetime);
              console.log('UserId:', userid);
              console.log('Category Type:', categoryType);
              console.log('Shift:', shift);
              console.log('Site:', site);
              console.log('Record Length:', Object.keys(record).length);

              itemfgDetails.push({
                  productname: productname,
                  productcode: productcode,
                  line: line,
                  hour: hour,
                  fgoutput: fgoutput,
                  datetime: datetime,
                  userid: userid,
                  shift: shift,
                  site: site,
                  categoryType: categoryType,
                  timestamp: timestamp
              });
          }
      });

      parser.on('end', () => {
          fs.unlinkSync(filePath); // Delete the uploaded file
          processItemCodeNames(); // Call the function to process itemfgDetails
      });

    

      // Process itemfgDetails using promises
      async function processItemCodeNames() {
          if (itemfgDetails.length === 0) {
              console.log('No items to process.');
              return;
          }

          const promises = itemfgDetails.map(async (item) => {
              try {
                  const productResults = await executeQuery(connection,'SELECT * FROM item_masterr WHERE item_description = ?', [item.productname]);
                  const productId = productResults.length > 0 ? productResults[0].id : null;

                  const codeResults = await executeQuery(connection,'SELECT * FROM item_code WHERE product_code = ?', [item.productcode]);
                  const code = codeResults.length > 0 ? codeResults[0].id : null;

                  console.log('Product ID:', productId);
                  console.log('Code Id:', code);

                  if (codeResults.length > 0) {
                      console.log('Code information found, pushing item to itemfgDetails:', item.productcode);
                      return {
                          productId: productId,
                          codeId: code,
                          line: item.line,
                          hour: item.hour,
                          fgoutput: item.fgoutput,
                          datetime: item.datetime,
                          userid: item.userid,
                          shift: item.shift,
                          site: item.site,
                          categoryType: item.categoryType,
                          timestamp: item.timestamp
                      };
                  } else {
                      console.log('Code not found, skipping item:', item.productcode, item.productname, code);
                      return null;
                  }
              } catch (error) {
                  console.error('Error:', error);
                  throw error;
              }
          });

          try {
              const resolvedItems = await Promise.all(promises);
              const validItems = resolvedItems.filter(item => item !== null);
              console.log('Valid Items:', validItems);

              const values = validItems.map(item => [item.productId, item.codeId, item.line, item.hour, item.fgoutput, item.datetime, item.timestamp, item.userid, item.shift, item.site, item.categoryType]);
              console.log('Values:', values);

              const insertQuery = `INSERT INTO fg_details (product_name, product_code, line, hour, fg_output, date_time, time_stamp, user, shift, site, category_type) VALUES ?`;
              await executeQuery(connection,insertQuery, [values]);

              res.json({ status: 'Success', message: 'Data Imported Successfully!' });
          } catch (error) {
              console.error(error);
              res.status(500).json({ status: 'Error', message: 'Database Import Error! Please check your file and its content.' });
          }
      }

      fs.createReadStream(filePath).pipe(parser);
  } catch (error) {
      console.error(error);
      res.status(500).json({ status: 'Error', message: 'An error occurred while processing the file.' });
  } finally {
      if (connection) {
          connection.end();
          //console.log("Connection released");
      }
  }
});


/**
 * @swagger
 * /updateattendancenbraid:
 *   post:
 *     summary: Update attendance for NBRAID category from CSV file.
 *     description: Update attendance status for NBRAID category employees based on the data provided in a CSV file.
 *     tags:
 *       - Attendance
 *     security:
 *       - BearerAuth: []
 *     requestBody:
 *       required: true
 *       content:
 *         multipart/form-data:
 *           schema:
 *             type: object
 *             properties:
 *               userfile:
 *                 type: string
 *                 format: binary
 *     responses:
 *       200:
 *         description: CSV processing completed.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 message:
 *                   type: string
 *                   example: CSV processing completed
 *       400:
 *         description: No file uploaded.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 message:
 *                   type: string
 *                   example: No file uploaded
 *       500:
 *         description: An error occurred.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 message:
 *                   type: string
 *                   example: An error occurred
 * @function
 * @name updateattendancenbraid
 * @memberof module:Routes/Attendance
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
//Import Update Attendance Nbraid
app.post('/updateattendancenbraid', upload.single('userfile'), authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    if (!req.file) {
      return res.status(400).json({ message: 'No file uploaded' });
    }

    const file = req.file;

    const filePath = file.path;
    const parser = csv({ delimiter: ',' });

    parser.on('readable', async () => {
      let record;
      while ((record = parser.read())) {
        console.log('Records:', record);

        const entryid = record.Entryid;
        const status = record.Status;

        console.log('entryid:', entryid);
        console.log('status:', status);

        const date = new Date().toLocaleDateString('en-GB', { timeZone: 'Africa/Lagos' });
        const parts = date.split('/');
        const formattedDay = parts[0].padStart(2, '0');
        const formattedMonth = parts[1].padStart(2, '0');
        const year = parts[2];
        const currentDate = `${formattedDay}-${formattedMonth}-${year}`;
        console.log('currentDate:', currentDate);

        const updateQuery = `UPDATE employees_ota SET status=?, passive_type='ACT', date=? WHERE entryid=?`;

        try {
          await executeQuery(connection,updateQuery, [status, currentDate, entryid]);
          console.log('Attendance status updated successfully.');

          const secondQuery = `UPDATE employees_ota SET status=?, passive_type='ACT', date=? WHERE entryid=?`;

          await executeQuery(connection,secondQuery, [status, currentDate, entryid]);
          console.log('Second query executed successfully.');
        } catch (error) {
          console.error('An error occurred:', error);
        }
      }
    });

    parser.on('end', () => {
      console.log('CSV parsing ended');
      // Respond when everything is complete
      return res.status(200).json({ message: 'CSV processing completed' });
    });

    // Pipe the file stream to the parser
    fs.createReadStream(filePath).pipe(parser);
  } catch (error) {
    console.error('An error occurred:', error);
    return res.status(500).json({ message: 'An error occurred' });
  } finally {
    if (connection) {
      connection.end();
      //console.log("Connection released");
    }
  }
});


/**
 * @swagger
 * /updateattendancebraid:
 *   post:
 *     summary: Update attendance for BRAID category from CSV file.
 *     description: Update attendance status for BRAID category employees based on the data provided in a CSV file.
 *     tags:
 *       - Attendance
 *     security:
 *       - BearerAuth: []
 *     requestBody:
 *       required: true
 *       content:
 *         multipart/form-data:
 *           schema:
 *             type: object
 *             properties:
 *               userfile:
 *                 type: string
 *                 format: binary
 *     responses:
 *       200:
 *         description: CSV processing completed.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 message:
 *                   type: string
 *                   example: CSV processing completed
 *       400:
 *         description: No file uploaded.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 message:
 *                   type: string
 *                   example: No file uploaded
 *       500:
 *         description: An error occurred.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 message:
 *                   type: string
 *                   example: An error occurred
 * @function
 * @name updateattendancebraid
 * @memberof module:Routes/Attendance
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */

//Import Update Attendance Braid
app.post('/updateattendancebraid', upload.single('userfile'), authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    if (!req.file) {
      return res.status(400).json({ message: 'No file uploaded' });
    }

    const file = req.file;

    const filePath = file.path;
    const parser = csv({ delimiter: ',' });

    parser.on('readable', async () => {
      let record;
      while ((record = parser.read())) {
        console.log('Records:', record);

        const entryid = record.Entryid;
        const status = record.Status;

        console.log('entryid:', entryid);
        console.log('status:', status);

        const date = new Date().toLocaleDateString('en-GB', { timeZone: 'Africa/Lagos' });
        const parts = date.split('/');
        const formattedDay = parts[0].padStart(2, '0');
        const formattedMonth = parts[1].padStart(2, '0');
        const year = parts[2];
        const currentDate = `${formattedDay}-${formattedMonth}-${year}`;
        console.log('currentDate:', currentDate);

        const updateQuery = `UPDATE geopos_employees SET status=?, passive_type='ACT', date=? WHERE entryid=?`;

        try {
          await executeQuery(connection,updateQuery, [status, currentDate, entryid]);
          console.log('Attendance status updated successfully.');

          const secondQuery = `UPDATE geopos_employees SET status=?, passive_type='ACT', date=? WHERE entryid=?`;

          await executeQuery(connection,secondQuery, [status, currentDate, entryid]);
          console.log('Second query executed successfully.');
        } catch (error) {
          console.error('An error occurred:', error);
        }
      }
    });

    parser.on('end', () => {
      console.log('CSV parsing ended');
      // Respond when everything is complete
      return res.status(200).json({ message: 'CSV processing completed' });
    });

    // Pipe the file stream to the parser
    fs.createReadStream(filePath).pipe(parser);
  } catch (error) {
    console.error('An error occurred:', error);
    return res.status(500).json({ message: 'An error occurred' });
  } finally {
    if (connection) {
      connection.end();
      //console.log("Connection released");
    }
  }
});


//Export File braid
// // Function to execute a query and return a promise
// function queryAsync(sql) {
//   return new Promise((resolve, reject) => {
//     db.query(sql, (error, results) => {
//       if (error) {
//         reject(error);
//       } else {
//         resolve(results);
//       }
//     });
//   });
// }

//get download backup Braid
/**
 * @swagger
 * /downloademployeebackupBraid:
 *   get:
 *     summary: Download employee backup for BRAID category as a CSV file.
 *     description: Retrieves and downloads a CSV file containing employee backup data for the BRAID category where passive_type is 'ACT' and roleid is '1'.
 *     tags:
 *       - Employee Backup
 *     security:
 *       - BearerAuth: []
 *     responses:
 *       200:
 *         description: CSV file download initiated.
 *         content:
 *           text/csv:
 *             schema:
 *               type: string
 *               format: binary
 *       500:
 *         description: Server error.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 status:
 *                   type: string
 *                   example: Error
 *                 message:
 *                   type: string
 *                   example: Server error
 * @function
 * @name downloademployeebackupBraid
 * @memberof module:Routes/EmployeeBackup
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */

app.get('/downloademployeebackupBraid', authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    const query = `
      SELECT entryid as EntryId, status as Status FROM geopos_employees WHERE passive_type='ACT' and roleid='1'
    `;

    console.log('Query:', query);

    // Use the custom promise-based query method
    const results = await executeQuery(connection,query);
   console.log(results)
    // Extract the relevant data from the database query results
    const data = results.map((row) => ({
      Entryid: row.EntryId,
      Status: row.Status,
    }));

    // Prepare CSV data
    const csvData = [
      ['Entryid', 'Status'],
      ...data.map((row) => Object.values(row)),
    ];

    // Create CSV file
    const fileName = 'Employee-Master.csv';
    const csvFolderPath = path.join(__dirname, 'csv_files');
    const filePath = path.join(csvFolderPath, fileName);
    const csvContent = csvData.map((row) => row.join(',')).join('\n');

    // Use fs.promises.writeFile for asynchronous file writing
    await fs.promises.writeFile(filePath, csvContent);

    // Check if the file is created successfully
    const fileExists = await fs.promises.access(filePath).then(() => true).catch(() => false);

    if (!fileExists) {
      console.error('Error creating the CSV file.');
      res.status(500).json({ status: 'Error', message: 'Server error' });
      return;
    }

    // Set response headers and send the file as an attachment
    res.download(filePath, fileName, (err) => {
      if (err) {
        console.error('Error sending file:', err);
        res.status(500).json({ status: 'Error', message: 'Server error' });
      } else {
        console.log('File sent successfully');
        // Delete the file after it has been sent
        fs.promises.unlink(filePath).then(() => console.log('File deleted successfully'));
      }
    });
  } catch (error) {
    console.error('Error executing query or processing data:', error);
    res.status(500).json({ status: 'Error', message: 'Server error' });
  } finally  {
    if (connection) {
      connection.release();
      //console.log("Connection released");
    }
  }
});

//Export File Non-braid
// Function to execute a query and return a promise
function queryAsync1(sql) {
  return new Promise((resolve, reject) => {
    db.query(sql, (error, results) => {
      if (error) {
        reject(error);
      } else {
        resolve(results);
      }
    });
  });
}


/**
 * @swagger
 * /downloademployeebackupNbraid:
 *   get:
 *     summary: Download employee backup for NBRAID category as a CSV file.
 *     description: Retrieves and downloads a CSV file containing employee backup data for the NBRAID category where passive_type is 'ACT' and roleid is '1'.
 *     tags:
 *       - Employee Backup
 *     security:
 *       - BearerAuth: []
 *     responses:
 *       200:
 *         description: CSV file download initiated.
 *         content:
 *           text/csv:
 *             schema:
 *               type: string
 *               format: binary
 *       500:
 *         description: Server error.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 status:
 *                   type: string
 *                   example: Error
 *                 message:
 *                   type: string
 *                   example: Server error
 * @function
 * @name downloademployeebackupNbraid
 * @memberof module:Routes/EmployeeBackup
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */

//get download backup NBraid
app.get('/downloademployeebackupNbraid', authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    const query = `
      SELECT entryid as EntryId, status as Status,staff as Site FROM employees_ota WHERE passive_type='ACT' and roleid='1'
    `;

    console.log('Query:', query);

    // Use the custom promise-based query method
    const results = await executeQuery(connection,query);
   console.log(results)
    // Extract the relevant data from the database query results
    const data = results.map((row) => ({
      Entryid: row.EntryId,
      Status: row.Status,
      Site: row.Site,
    }));

    // Prepare CSV data
    const csvData = [
      ['Entryid', 'Status', 'Site'],
      ...data.map((row) => Object.values(row)),
    ];

    // Create CSV file
    const fileName = 'Employee-Master.csv';
    const csvFolderPath = path.join(__dirname, 'csv_files');
    const filePath = path.join(csvFolderPath, fileName);
    const csvContent = csvData.map((row) => row.join(',')).join('\n');

    // Use fs.promises.writeFile for asynchronous file writing
    await fs.promises.writeFile(filePath, csvContent);

    // Check if the file is created successfully
    const fileExists = await fs.promises.access(filePath).then(() => true).catch(() => false);

    if (!fileExists) {
      console.error('Error creating the CSV file.');
      res.status(500).json({ status: 'Error', message: 'Server error' });
      return;
    }

    // Set response headers and send the file as an attachment
    res.download(filePath, fileName, (err) => {
      if (err) {
        console.error('Error sending file:', err);
        res.status(500).json({ status: 'Error', message: 'Server error' });
      } else {
        console.log('File sent successfully');
        // Delete the file after it has been sent
        fs.promises.unlink(filePath).then(() => console.log('File deleted successfully'));
      }
    });
  } catch (error) {
    console.error('Error executing query or processing data:', error);
    res.status(500).json({ status: 'Error', message: 'Server error' });
  } finally  {
    if (connection) {
      connection.release();
      //console.log("Connection released");
    }
  }
});

//-------------------------Import Module-----------------------------------//

//-------------------------Tv Display NBraid-----------------------------------//
/**
 * @swagger
 * /fetchtotalemployees:
 *   get:
 *     summary: Fetch the total number of active employees for the current date.
 *     description: Returns the total count of employees in the 'employees_ota' table with a 'passive_type' of 'ACT' and a date matching the current date in the 'Africa/Lagos' timezone.
 *     tags:
 *       - Employee
 *     security:
 *       - BearerAuth: []
 *     responses:
 *       200:
 *         description: Successfully retrieved total employees count.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 total_emp:
 *                   type: integer
 *                   example: 100
 *       500:
 *         description: Error fetching total items.
 *         content:
 *           application/json:
 *             schema:
 *               type: string
 *               example: Error fetching total items
 * @function
 * @name fetchtotalemployees
 * @memberof module:Routes/Employee
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */

//total employees
app.get('/fetchtotalemployees', authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    const date = new Date().toLocaleDateString('en-GB', { timeZone: 'Africa/Lagos' });
    const parts = date.split('/');
    const day = parts[0].padStart(2, '0');
    const month = parts[1].padStart(2, '0');
    const year = parts[2];
    const currentMonth = `${month}-${year}`;
    const currentDate = `${day}-${month}-${year}`;

    const query = `SELECT COUNT(id) AS total_emp FROM employees_ota WHERE passive_type='ACT' AND date='${currentDate}'`;

    const result = await executeQuery(connection,query);

    const total_emp = result[0].total_emp;
    const response = {
      total_emp: total_emp, // Use "totalItem" as the key instead of "rowCount"
    };
    res.send(response);
  } catch (err) {
    console.log(err);
    res.status(500).send('Error fetching total items');
  } finally  {
    if (connection) {
      connection.release();
      //console.log("Connection released");
    }
  }
});

/**
 * @swagger
 * /fetchtotalpresentemployees:
 *   get:
 *     summary: Fetch the total number of present employees for the current date.
 *     description: Returns the total count of employees in the 'employees_ota' table with a 'passive_type' of 'ACT', status 'P', and a date matching the current date in the 'Africa/Lagos' timezone.
 *     tags:
 *       - Employee
 *     security:
 *       - BearerAuth: []
 *     responses:
 *       200:
 *         description: Successfully retrieved total present employees count.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 p_emp:
 *                   type: integer
 *                   example: 100
 *       500:
 *         description: Error fetching total present employees.
 *         content:
 *           application/json:
 *             schema:
 *               type: string
 *               example: Error fetching total present employees
 * @function
 * @name fetchtotalpresentemployees
 * @memberof module:Routes/Employee
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */

//total present employees
app.get('/fetchtotalpresentemployees', authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    const date = new Date().toLocaleDateString('en-GB', { timeZone: 'Africa/Lagos' });
    const parts = date.split('/');
    const day = parts[0].padStart(2, '0');
    const month = parts[1].padStart(2, '0');
    const year = parts[2];
    const currentMonth = `${month}-${year}`;
    const currentDate = `${day}-${month}-${year}`;

    const query = `SELECT COUNT(id) AS total_emp FROM employees_ota WHERE passive_type='ACT' AND status='P' AND date='${currentDate}'`;

    const result = await executeQuery(connection,query);

    const total_emp = result[0].total_emp;
    const response = {
      p_emp: total_emp, // Use "p_emp" as the key instead of "totalItem"
    };
    res.send(response);
  } catch (err) {
    console.log(err);
    res.status(500).send('Error fetching total present employees');
  } finally  {
    if (connection) {
      connection.release();
      //console.log("Connection released");
    }
  }
});

/**
 * @swagger
 * /fetchtotalabsentemployees:
 *   get:
 *     summary: Fetch the total number of absent employees for the current date.
 *     description: Returns the total count of employees in the 'employees_ota' table with a 'passive_type' of 'ACT', status 'A', and a date matching the current date in the 'Africa/Lagos' timezone.
 *     tags:
 *       - Employee
 *     security:
 *       - BearerAuth: []
 *     responses:
 *       200:
 *         description: Successfully retrieved total absent employees count.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 a_emp:
 *                   type: integer
 *                   example: 50
 *       500:
 *         description: Error fetching total absent employees.
 *         content:
 *           application/json:
 *             schema:
 *               type: string
 *               example: Error fetching total absent employees
 * @function
 * @name fetchtotalabsentemployees
 * @memberof module:Routes/Employee
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */

//total absent employees
app.get('/fetchtotalabsentemployees', authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    const date = new Date().toLocaleDateString('en-GB', { timeZone: 'Africa/Lagos' });
    const parts = date.split('/');
    const day = parts[0].padStart(2, '0');
    const month = parts[1].padStart(2, '0');
    const year = parts[2];
    const currentMonth = `${month}-${year}`;
    const currentDate = `${day}-${month}-${year}`;

    const query = `SELECT COUNT(id) AS total_emp FROM employees_ota WHERE passive_type='ACT' AND status='A' AND date='${currentDate}'`;

    const result = await executeQuery(connection,query);

    const total_emp = result[0].total_emp;
    const response = {
      a_emp: total_emp, // Use "a_emp" as the key instead of "totalItem"
    };
    res.send(response);
  } catch (err) {
    console.log(err);
    res.status(500).send('Error fetching total absent employees');
  } finally  {
    if (connection) {
      connection.release();
      //console.log("Connection released");
    }
  }
});

/**
 * @swagger
 * /fetchtotalactiveemployees:
 *   get:
 *     summary: Fetch the total number of active employees for the current date.
 *     description: Returns the total count of unique employees in the 'worker_timesheet' table with a date matching the current date in the 'Africa/Lagos' timezone.
 *     tags:
 *       - Employee
 *     security:
 *       - BearerAuth: []
 *     responses:
 *       200:
 *         description: Successfully retrieved total active employees count.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 actemp:
 *                   type: integer
 *                   example: 120
 *       500:
 *         description: Error fetching total active employees.
 *         content:
 *           application/json:
 *             schema:
 *               type: string
 *               example: Error fetching total active employees
 * @function
 * @name fetchtotalactiveemployees
 * @memberof module:Routes/Employee
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */

//total active employees
app.get('/fetchtotalactiveemployees', authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    const date = new Date().toLocaleDateString('en-GB', { timeZone: 'Africa/Lagos' });
    const parts = date.split('/');
    const day = parts[0].padStart(2, '0');
    const month = parts[1].padStart(2, '0');
    const year = parts[2];
    const currentMonth = `${month}-${year}`;
    const currentDate = `${day}-${month}-${year}`;

    const query = `SELECT COUNT(*) AS noOfEmp FROM worker_timesheet WHERE date_time = '${currentDate}' group by date_time,entry_id`;

    const result = await executeQuery(connection,query);

    // Count the number of rows returned
    const actemp = result.length;

    const response = {
      actemp: actemp,
    };
    res.send(response);
  } catch (err) {
    console.log(err);
    res.status(500).send('Error fetching total active employees');
  } finally  {
    if (connection) {
      connection.release();
      //console.log("Connection released");
    }
  }
});


/**
 * @swagger
 * /fetchmtdavgoutput:
 *   get:
 *     summary: Fetch the Month-to-Date average FG output.
 *     description: Returns the sum of fg_output from the fg_details table for the current month.
 *     tags:
 *       - FG Output
 *     security:
 *       - BearerAuth: []
 *     responses:
 *       200:
 *         description: Successfully retrieved total FG output for the current month.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 total_fg_outputK:
 *                   type: number
 *                   example: 15000
 *       500:
 *         description: Error fetching total FG output.
 *         content:
 *           application/json:
 *             schema:
 *               type: string
 *               example: Error fetching total FG output
 * @function
 * @name fetchmtdavgoutput
 * @memberof module:Routes/FGOutput
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
//mtd fg output
app.get('/fetchmtdavgoutput', authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    const date = new Date().toLocaleDateString('en-GB', { timeZone: 'Africa/Lagos' });
    const parts = date.split('/');
    const day = parts[0].padStart(2, '0');
    const month = parts[1].padStart(2, '0');
    const year = parts[2];
    const currentMonth = `${month}-${year}`;
    const currentDate = `${day}-${month}-${year}`;

    const query = `SELECT SUM(fg_output) AS tar FROM fg_details WHERE SUBSTRING(date_time, 4) = '${currentMonth}'`;

    const results = await executeQuery(connection,query);

    // Extract the total FG output from the query results
    const total_fg_outputK = results.length > 0 ? results[0].tar || 0 : 0;

    const response = {
      total_fg_outputK: total_fg_outputK,
    };
    res.send(response);
  } catch (err) {
    console.log(err);
    res.status(500).send('Error fetching total FG output');
  } finally  {
    if (connection) {
      connection.release();
      //console.log("Connection released");
    }
  }
});


/**
 * @swagger
 * /fetchtotalfgoutput:
 *   get:
 *     summary: Fetch the total FG output for the current date.
 *     description: Returns the total finished goods output for the current date by querying the worker_timesheet and fg_details tables.
 *     tags:
 *       - FG Output
 *     security:
 *       - BearerAuth: []
 *     responses:
 *       200:
 *         description: Successfully retrieved total FG output for the current date.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 total_fg_outputf:
 *                   type: number
 *                   example: 5000
 *       500:
 *         description: Error fetching total FG output.
 *         content:
 *           application/json:
 *             schema:
 *               type: string
 *               example: Error fetching total FG output
 * @function
 * @name fetchtotalfgoutput
 * @memberof module:Routes/FGOutput
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */

//total fg output
app.get('/fetchtotalfgoutput', authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    const date = new Date().toLocaleDateString('en-GB', { timeZone: 'Africa/Lagos' });
    const parts = date.split('/');
    const day = parts[0].padStart(2, '0');
    const month = parts[1].padStart(2, '0');
    const year = parts[2];
    const currentDate = `${day}-${month}-${year}`;

    let total_fg_outputf = 0;

    const query = `SELECT * FROM worker_timesheet AS w JOIN item_masterr AS f ON w.product_name = f.id WHERE w.date_time = '${currentDate}' GROUP BY w.product_name, w.date_time`;

    const results = await executeQuery(connection,query);

    // Iterate over the results and calculate the total_fg_outputf
    for (const row of results) {
      const subQuery = `SELECT *, SUM(fg_output) AS tar FROM fg_details WHERE date_time = '${currentDate}' AND product_name = '${row.product_name}' GROUP BY product_name, date_time`;
      const subResult = await executeQuery(connection,subQuery);
      const sum = subResult.length > 0 ? subResult[0].tar : 0;
      total_fg_outputf += sum;
    }

    const response = {
      total_fg_outputf: total_fg_outputf,
    };
    res.send(response);
  } catch (err) {
    console.log(err);
    res.status(500).send('Error fetching total FG output');
  } finally  {
    if (connection) {
      connection.release();
      //console.log("Connection released");
    }
  }
});


/**
 * @swagger
 * /fetchmtdppp:
 *   get:
 *     summary: Fetch Month-to-Date (MTD) PPP.
 *     description: Returns the sum of the number of employees for the current month from the worker_timesheet table.
 *     tags:
 *       - PPP
 *     security:
 *       - BearerAuth: []
 *     responses:
 *       200:
 *         description: Successfully retrieved MTD PPP.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 resk:
 *                   type: number
 *                   example: 123
 *       500:
 *         description: Error calculating total PPP.
 *         content:
 *           application/json:
 *             schema:
 *               type: string
 *               example: Error calculating total PPP
 * @function
 * @name fetchmtdppp
 * @memberof module:Routes/PPP
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */

//mtd ppp
app.get('/fetchmtdppp', authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    const date = new Date().toLocaleDateString('en-GB', { timeZone: 'Africa/Lagos' });
    const parts = date.split('/');
    const day = parts[0].padStart(2, '0');
    const month = parts[1].padStart(2, '0');
    const year = parts[2];
    const currentDate = `${day}-${month}-${year}`;
    const currentMonth = `${month}-${year}`;

    // Query to calculate the sum of noOfEmp for the given monthK
    const query = `
      SELECT SUM(a.noOfEmp) as res
      FROM (SELECT COUNT(*) AS noOfEmp
            FROM worker_timesheet
            WHERE mon = '${currentMonth}'
            GROUP BY entry_id, date_time) a
    `;

    const result = await executeQuery(connection,query);

    const ros1K = result[0]; // Assuming you have a single result row
    const resk = ros1K.res; // Assuming you have a single result row
    console.log(resk);
    //const total_fg_outputK = 12345; // Replace with your actual total_fg_outputK value
    //const ppK = total_fg_outputK / ros1K.res;
    //const total_pppK = ppK.toFixed(2); // Format the result to two decimal places
    res.json({ resk });
  } catch (err) {
    console.error('Error calculating total PPP:', err);
    res.status(500).send('Error calculating total PPP');
  } finally  {
    if (connection) {
      connection.release();
      //console.log("Connection released");
    }
  }
});



/**
 * @swagger
 * /fetchfgoutputslide:
 *   get:
 *     summary: Fetch FG output for slide presentation.
 *     description: Returns the FG output data for the current date, grouped by product code, along with product descriptions and color names.
 *     tags:
 *       - FG Output
 *     security:
 *       - BearerAuth: []
 *     responses:
 *       200:
 *         description: Successfully retrieved FG output data.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 data:
 *                   type: array
 *                   items:
 *                     type: object
 *                     properties:
 *                       product_desc:
 *                         type: string
 *                         description: The description of the product.
 *                         example: Product A
 *                       color_name:
 *                         type: string
 *                         description: The name of the color.
 *                         example: Red
 *                       tar:
 *                         type: number
 *                         description: The total FG output for the product on the current date.
 *                         example: 100
 *       500:
 *         description: Internal server error.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: Internal server error
 * @function
 * @name fetchfgoutputslide
 * @memberof module:Routes/FGOutput
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
// FG OUTPUT Slide
app.get('/fetchfgoutputslide', authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    const date = new Date().toLocaleDateString('en-GB', { timeZone: 'Africa/Lagos' });
    const parts = date.split('/');
    const day = parts[0].padStart(2, '0');
    const month = parts[1].padStart(2, '0');
    const year = parts[2];
    const currentDate = `${day}-${month}-${year}`;
    const currentMonth = `${month}-${year}`;

    const query = `
      SELECT fg_details.*, item_code.product_des, color_master.color_name, SUM(fg_details.fg_output) as tar
      FROM fg_details
      JOIN item_code ON fg_details.product_code = item_code.id
      JOIN color_master ON item_code.color_id = color_master.id
      WHERE fg_details.date_time = ?
      GROUP BY fg_details.product_code
    `;

    const results = await executeQuery(connection, query, [currentDate]);

    const data = results.map((row) => ({
      product_desc: row.product_des,
      color_name: row.color_name,
      tar: row.tar,
    }));

    res.json({ data: data });
  } catch (err) {
    console.error('Error executing the SQL query:', err);
    res.status(500).json({ error: 'Internal server error' });
  } finally  {
    if (connection) {
      connection.release();
      //console.log("Connection released");
    }
  }
});


/**
 * @swagger
 * /fetchplanvstargetslide:
 *   get:
 *     summary: Fetch planned target vs actual output for slide presentation.
 *     description: Returns data comparing the planned target with actual output for a specific date.
 *     tags:
 *       - Plan vs Target
 *     security:
 *       - BearerAuth: []
 *     responses:
 *       200:
 *         description: Successfully retrieved planned target vs actual output data.
 *         content:
 *           application/json:
 *             schema:
 *               type: array
 *               items:
 *                 type: object
 *                 properties:
 *                   itemCode:
 *                     type: string
 *                     description: The description of the item code.
 *                   targetPlan:
 *                     type: number
 *                     description: The planned target value.
 *                   c:
 *                     type: string
 *                     description: The actual output value. If empty, display as a red dash.
 *                   b:
 *                     type: number
 *                     description: The difference between the planned target and actual output.
 *       500:
 *         description: Internal server error.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: An error occurred
 * @function
 * @name fetchplanvstargetslide
 * @memberof module:Routes/PlanVsTarget
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @returns {void} Void.
 */    

// plan vs target slide
app.get('/fetchplanvstargetslide',  authenticateJWT, (req, res) => {
  const date = new Date().toLocaleDateString('en-GB', { timeZone: 'Africa/Lagos' });
  const parts = date.split('/');
  const day = parts[0].padStart(2, '0');
  const month = parts[1].padStart(2, '0');
  const year = parts[2];
  const currentDate = `${day}-${month}-${year}`;
  const currentMonth = `${month}-${year}`;

  const dt = `06-10-2023`;

  const query1 = `
    SELECT * FROM target_plan_ota
    WHERE date = ? AND target_plan > 0 AND (category = '2' OR category = '3')
  `;

  db.query(query1, [currentDate], (err, result) => {
    if (err) {
      console.error('Error executing SQL query:', err);
      res.status(500).json({ error: 'An error occurred' });
      return;
    }

    const responseArray = [];

    const processNextRow = (index) => {
      if (index >= result.length) {
        // All data processed, send the response
        res.json(responseArray);
        //console.log(responseArray, '--------------');
        return;
      }

      const row = result[index];
      const itemCodeId = row.item_code_id;

      const query2 = `
        SELECT *, SUM(fg_output) as tar FROM fg_details
        WHERE date_time = ? AND product_code = ?
        ORDER BY fg_output DESC
      `;

      db.query(query2, [currentDate, itemCodeId], (err, result2) => {
        if (err) {
          console.error('Error executing SQL query:', err);
          res.status(500).json({ error: 'An error occurred' });
        } else {
          const row2 = result2[0];
          const sump = row2 ? row2.tar : '';

          const query3 = `
            SELECT * FROM item_code
            WHERE id = ?
          `;

          db.query(query3, [itemCodeId], (err, result3) => {
            if (err) {
              console.error('Error executing SQL query:', err);
              res.status(500).json({ error: 'An error occurred' });
            } else {
              const row3 = result3[0];
              const productDes = row3 ? row3.product_des : '';

              const t = row.target_plan;
              const c = sump;

              const responseObject = {
                itemCode: productDes,
                targetPlan: t,
                c: (c === '') ? '<span style="color:red">-</span>' : c,
                b: t - c,
              };

              responseArray.push(responseObject);
              

              // Process the next row
              processNextRow(index + 1);
            }
          });
        }
      });
    };

    // Start processing the first row
    processNextRow(0);
  });
});

/**
 * @swagger
 * /fetchitemwisepppslide:
 *   get:
 *     summary: Fetch item-wise data including actual FG output, TPPP, and REW for slide presentation.
 *     description: Returns item-wise data including actual FG output, TPPP (Targeted Price Per Piece), and REW (Realized Efficiency in Work) for a specific date.
 *     tags:
 *       - Item Wise Data
 *     security:
 *       - BearerAuth: []
 *     responses:
 *       200:
 *         description: Successfully retrieved item-wise data.
 *         content:
 *           application/json:
 *             schema:
 *               type: array
 *               items:
 *                 type: object
 *                 properties:
 *                   itemDescription:
 *                     type: string
 *                     description: The description of the item.
 *                   fgOutput:
 *                     type: number
 *                     description: The actual FG output for the item.
 *                   tppp:
 *                     type: number
 *                     description: The targeted price per piece for the item.
 *                   rew:
 *                     type: string
 *                     description: The realized efficiency in work for the item (rounded to two decimal places).
 *       500:
 *         description: Internal server error.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: An error occurred
 * @function
 * @name fetchitemwisepppslide
 * @memberof module:Routes/ItemWiseData
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @returns {void} Void.
 */

//itemwise ppp slide
app.get('/fetchitemwisepppslide',  authenticateJWT, (req, res) => {
  const date = new Date().toLocaleDateString('en-GB', { timeZone: 'Africa/Lagos' });
  const parts = date.split('/');
  const day = parts[0].padStart(2, '0');
  const month = parts[1].padStart(2, '0');
  const year = parts[2];
  const currentDate = `${day}-${month}-${year}`;
  const currentMonth = `${month}-${year}`;

  const dt = `06-10-2023`;

  const query1 = `
    SELECT w.*, f.item_description,f.tppp
    FROM worker_timesheet w
    JOIN item_masterr f ON w.product_name = f.id
    WHERE w.date_time = ?
    GROUP BY w.product_name, w.date_time
  `;

  let totalFgOutput = 0;
  let totalPpp = 0;

  db.query(query1, [currentDate], (err, result) => {
    if (err) {
      console.error('Error executing SQL query:', err);
      res.status(500).json({ error: 'An error occurred' });
      return; // Return early to avoid further execution
    }

    const responseData = [];

    const processNextRow = (index) => {
      if (index >= result.length) {
        // All data processed, send the response
        res.json(responseData);
        return;
      }

      const row = result[index];
      const productName = row.product_name;
      const tppp = row.tppp;
      const query2 = `
        SELECT *, SUM(fg_output) as tar
        FROM fg_details
        WHERE date_time = ? AND product_name = ?
        GROUP BY product_name, date_time
      `;

      db.query(query2, [dt, productName], (err, result2) => {
        if (err) {
          console.error('Error executing SQL query:', err);
          res.status(500).json({ error: 'An error occurred' });
        } else {
          const row2 = result2[0];
          const sum = row2 ? row2.tar : 0;
          

          const query3 = `
            SELECT COUNT(*) AS res
            FROM worker_timesheet
            WHERE date_time = ? AND product_name = ?
          `;

          db.query(query3, [dt, productName], (err, result3) => {
            if (err) {
              console.error('Error executing SQL query:', err);
              res.status(500).json({ error: 'An error occurred' });
            } else {
              const res1 = result3[0];
              const resCount = res1.res;
         
              let rew = resCount !== 0 ? sum / resCount : 0;

              if (isNaN(rew)) {
                rew = 0.00;
              }

              totalFgOutput += sum;
              totalPpp += rew;

              const itemData = {
                itemDescription: row.item_description,
                fgOutput: sum,
                tppp:tppp,
                rew: rew.toFixed(2),
              };

              responseData.push(itemData);
             // console.log(responseData,'---')
              processNextRow(index + 1);
            }
          });
        }
      });
    };

    // Start processing the first row
    processNextRow(0);
  });
});



/**
 * @swagger
 * /fetchmtdpppslide:
 *   get:
 *     summary: Fetch monthly TPPP slide data.
 *     description: Fetch monthly TPPP slide data for display.
 *     tags:
 *       - TPPP
 *     security:
 *       - BearerAuth: []
 *     responses:
 *       200:
 *         description: Successfully retrieved monthly TPPP slide data.
 *         content:
 *           application/json:
 *             schema:
 *               type: array
 *               items:
 *                 type: object
 *                 properties:
 *                   itemDescription:
 *                     type: string
 *                     description: The description of the item.
 *                   tppp:
 *                     type: number
 *                     description: The TPPP value.
 *                   sumk:
 *                     type: number
 *                     description: The sum of FG output.
 *                   rew:
 *                     type: number
 *                     description: The calculated reward value.
 *       500:
 *         description: Internal server error.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: An error occurred
 * @function
 * @name fetchmtdpppslide
 * @memberof module:Routes/TPPP
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue retrieving monthly TPPP slide data.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
//MTD PPP slide
app.get('/fetchmtdpppslide', authenticateJWT,async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    const date = new Date().toLocaleDateString('en-GB', { timeZone: 'Africa/Lagos' });
    const parts = date.split('/');
    const day = parts[0].padStart(2, '0');
    const month = parts[1].padStart(2, '0');
    const year = parts[2];
    const currentDate = `${day}-${month}-${year}`;
    const currentMonth = `${month}-${year}`;

    const monthK = '10-2023';

    const query1 = `
      SELECT w.*, f.item_description,f.tppp
      FROM worker_timesheet w
      JOIN item_masterr f ON w.product_name = f.id
      WHERE w.mon = ?
      GROUP BY w.product_name, w.mon
    `;

    executeQuery(connection,query1, [currentMonth], (err, result) => {
      if (err) {
        console.error('Error executing SQL query:', err);
        res.status(500).json({ error: 'An error occurred' });
        return; // Return early to avoid further execution
      }

      const responseData = [];

      const processNextRow = (index) => {
        if (index >= result.length) {
          // All data processed, send the response
          res.json(responseData);
          return;
        }

        const row = result[index];
        const productName = row.product_name;

        const query2 = `
          SELECT *, SUM(fg_output) as tar
          FROM fg_details
          WHERE substr(date_time, 4) = ? AND product_name = ?
          GROUP BY product_name
        `;

        executeQuery(connection,query2, [currentMonth, productName], (err, result2) => {
          if (err) {
            console.error('Error executing SQL query:', err);
            res.status(500).json({ error: 'An error occurred' });
          } else {
            const row2 = result2[0];
            const sumk = row2 ? row2.tar : 0;
            const tppp = row.tppp;

            const query3 = `
              SELECT COUNT(*) AS res
              FROM worker_timesheet
              WHERE mon = ? AND product_name = ?
            `;

            executeQuery(connection,query3, [currentMonth, productName], (err, result3) => {
              if (err) {
                console.error('Error executing SQL query:', err);
                res.status(500).json({ error: 'An error occurred' });
              } else {
                const res1 = result3[0];
                const resCount = res1.res;

                let rew = sumk / resCount;
                if (rew === Infinity) {
                  rew = 0;
                }

                const itemData = {
                  itemDescription: row.item_description,
                  tppp,
                  sumk,
                  rew: rew.toFixed(2),
                };

                responseData.push(itemData);
                processNextRow(index + 1);
              }
            });
          }
        });
      };

      // Start processing the first row
      processNextRow(0);
    });
  } catch (error) {
    console.error('An error occurred:', error);
    res.status(500).json({ error: 'An error occurred' });
  } finally {
    if (connection) {
      connection.end();
    }
  }
});

//Top 10 Best worker based on efficiency slide
/**
 * @swagger
 * /fetchTop10Workersslide:
 *   get:
 *     summary: Fetch top 10 workers by productivity.
 *     description: Fetch the top 10 workers by productivity for display.
 *     tags:
 *       - Workers
 *     security:
 *       - BearerAuth: []
 *     responses:
 *       200:
 *         description: Successfully retrieved top 10 workers by productivity.
 *         content:
 *           application/json:
 *             schema:
 *               type: array
 *               items:
 *                 type: object
 *                 properties:
 *                   entryId:
 *                     type: string
 *                     description: The entry ID of the worker.
 *                   worker:
 *                     type: string
 *                     description: The name of the worker.
 *                   sectionName:
 *                     type: string
 *                     description: The name of the section where the worker is assigned.
 *                   productivity:
 *                     type: string
 *                     description: The productivity percentage of the worker.
 *       500:
 *         description: Internal server error.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: An error occurred
 * @function
 * @name fetchTop10Workersslide
 * @memberof module:Routes/Workers
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue retrieving top 10 workers by productivity.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */

app.get('/fetchTop10Workersslide', authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    const date = new Date().toLocaleDateString('en-GB', { timeZone: 'Africa/Lagos' });
    const parts = date.split('/');
    const day = parts[0].padStart(2, '0');
    const month = parts[1].padStart(2, '0');
    const year = parts[2];
    const currentDate = `${day}-${month}-${year}`;
    const currentMonth = `${month}-${year}`;

    const query = `
      SELECT wt.entry_id, wt.worker, s.section_name, ((wt.HOUR1 + wt.HOUR2 + wt.HOUR3 + wt.HOUR4 + wt.HOUR5 + wt.HOUR6 + wt.HOUR7 + wt.HOUR8 + wt.HOUR9 + wt.HOUR10 + wt.HOUR11) / wt.target) * 100 AS productivity
      FROM worker_timesheet wt
      JOIN section s ON wt.section = s.id
      WHERE wt.date_time = ? AND wt.target > 0 AND wt.actual_target > 0
      ORDER BY productivity DESC
      LIMIT 10
    `;

    const result = await executeQuery(connection, query, [currentDate]);

    const responseData = result.map((row) => ({
      entryId: row.entry_id,
      worker: row.worker,
      sectionName: row.section_name,
      productivity: `${row.productivity.toFixed(2)}%`,
    }));

    res.json(responseData);
  } catch (err) {
    console.error('Error executing SQL query:', err);
    res.status(500).json({ error: 'An error occurred' });
  } finally {
    if (connection) {
      connection.release();
    }
  }
});

/**
 * @swagger
 * /fetchTop10Workersmtdslide:
 *   get:
 *     summary: Fetch top 10 workers by monthly average productivity.
 *     description: Fetch the top 10 workers by monthly average productivity for display.
 *     tags:
 *       - Workers
 *     security:
 *       - BearerAuth: []
 *     responses:
 *       200:
 *         description: Successfully retrieved top 10 workers by monthly average productivity.
 *         content:
 *           application/json:
 *             schema:
 *               type: array
 *               items:
 *                 type: object
 *                 properties:
 *                   entryId:
 *                     type: string
 *                     description: The entry ID of the worker.
 *                   worker:
 *                     type: string
 *                     description: The name of the worker.
 *                   sectionName:
 *                     type: string
 *                     description: The name of the section where the worker is assigned.
 *                   avgProductivity:
 *                     type: string
 *                     description: The monthly average productivity of the worker.
 *       500:
 *         description: Internal server error.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: An error occurred
 * @function
 * @name fetchTop10Workersmtdslide
 * @memberof module:Routes/Workers
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue retrieving top 10 workers by monthly average productivity.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */

//Top 10 Best worker MTD slide
app.get('/fetchTop10Workersmtdslide', authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    const date = new Date().toLocaleDateString('en-GB', { timeZone: 'Africa/Lagos' });
    const parts = date.split('/');
    const day = parts[0].padStart(2, '0');
    const month = parts[1].padStart(2, '0');
    const year = parts[2];
    const currentDate = `${day}-${month}-${year}`;
    const currentMonth = `${month}-${year}`;

    const query = `
      SELECT wt.entry_id, wt.worker, s.section_name, AVG((wt.HOUR1 + wt.HOUR2 + wt.HOUR3 + wt.HOUR4 + wt.HOUR5 + wt.HOUR6 + wt.HOUR7 + wt.HOUR8 + wt.HOUR9 + wt.HOUR10 + wt.HOUR11) / wt.target) * 100 AS avg_productivity
      FROM worker_timesheet wt
      JOIN section s ON wt.section = s.id
      WHERE wt.mon = ? AND wt.target > 0 AND wt.actual_target > 0
      GROUP BY wt.entry_id, wt.worker, s.section_name
      ORDER BY avg_productivity DESC
      LIMIT 10
    `;

    const result = await executeQuery(connection,query, [currentMonth]);

    const responseData = [];

    for (const row of result) {
      const entryId = row.entry_id;
      const worker = row.worker;
      const sectionName = row.section_name;
      const avgProductivity = (row.avg_productivity).toFixed(2) + '%';
      
      responseData.push({ entryId, worker, sectionName, avgProductivity });
    }

    res.json(responseData);
  } catch (err) {
    console.error('Error executing SQL query:', err);
    res.status(500).json({ error: 'An error occurred' });
  } finally {
    if (connection) {
      connection.release();
    }
  }
});



//-------------------------Tv Display Nbraid-----------------------------------//

//-------------------------Tv Display BRAID-------------------------------//
/**
 * @swagger
 * /fetchtotalemployees1:
 *   get:
 *     summary: Fetch total active employees.
 *     description: Fetch the total number of active employees for display.
 *     tags:
 *       - Employees
 *     security:
 *       - BearerAuth: []
 *     responses:
 *       200:
 *         description: Successfully retrieved total active employees.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 total_emp:
 *                   type: integer
 *                   description: The total number of active employees.
 *       500:
 *         description: Internal server error.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: Error fetching total items
 * @function
 * @name fetchtotalemployees1
 * @memberof module:Routes/Employees
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue fetching the total active employees.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */

//total employees
app.get('/fetchtotalemployees1', authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    const date = new Date().toLocaleDateString('en-GB', { timeZone: 'Africa/Lagos' });
    const parts = date.split('/');
    const day = parts[0].padStart(2, '0');
    const month = parts[1].padStart(2, '0');
    const year = parts[2];
    const currentMonth = `${month}-${year}`;
    const currentDate = `${day}-${month}-${year}`;

    const query = `SELECT COUNT(id) AS total_emp FROM geopos_employees WHERE roleid != '5' AND passive_type = 'ACT' AND date = ?`;

    const result = await executeQuery(connection, query, [currentDate]);

    const total_emp = result[0].total_emp;
    const response = {
      total_emp: total_emp,
    };
    res.send(response);
  } catch (err) {
    console.log(err);
    res.status(500).send('Error fetching total items');
  } finally {
    if (connection) {
      connection.release();
      }
  }
});


/**
 * @swagger
 * /fetchtotalpresentemployees1:
 *   get:
 *     summary: Fetch total present active employees.
 *     description: Fetch the total number of active employees who are present for display.
 *     tags:
 *       - Employees
 *     security:
 *       - BearerAuth: []
 *     responses:
 *       200:
 *         description: Successfully retrieved total present active employees.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 p_emp:
 *                   type: integer
 *                   description: The total number of present active employees.
 *       500:
 *         description: Internal server error.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: Error fetching total items
 * @function
 * @name fetchtotalpresentemployees1
 * @memberof module:Routes/Employees
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue fetching the total present active employees.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
//total present employees
app.get('/fetchtotalpresentemployees1', authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    const date = new Date().toLocaleDateString('en-GB', { timeZone: 'Africa/Lagos' });
    const parts = date.split('/');
    const day = parts[0].padStart(2, '0');
    const month = parts[1].padStart(2, '0');
    const year = parts[2];
    const currentMonth = `${month}-${year}`;
    const currentDate = `${day}-${month}-${year}`;

    const query = `SELECT COUNT(id) AS total_emp FROM geopos_employees WHERE roleid != '5' AND passive_type = 'ACT' AND status = 'P' AND date = ?`;

    const result = await executeQuery(connection,query, [currentDate]);

    const total_emp = result[0].total_emp;
    const response = {
      p_emp: total_emp,
    };
    res.send(response);
  } catch (err) {
    console.log(err);
    res.status(500).send('Error fetching total items');
  } finally {
    if (connection) {
      connection.release();
    }
  }
});

/**
 * @swagger
 * /fetchtotalpresentemployees1:
 *   get:
 *     summary: Fetch total present active employees.
 *     description: Fetch the total number of active employees who are present for display.
 *     tags:
 *       - Employees
 *     security:
 *       - BearerAuth: []
 *     responses:
 *       200:
 *         description: Successfully retrieved total present active employees.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 p_emp:
 *                   type: integer
 *                   description: The total number of present active employees.
 *       500:
 *         description: Internal server error.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: Error fetching total items
 * @function
 * @name fetchtotalpresentemployees1
 * @memberof module:Routes/Employees
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue fetching the total present active employees.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */

//total absent employees
app.get('/fetchtotalabsentemployees1', authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    const date = new Date().toLocaleDateString('en-GB', { timeZone: 'Africa/Lagos' });
    const parts = date.split('/');
    const day = parts[0].padStart(2, '0');
    const month = parts[1].padStart(2, '0');
    const year = parts[2];
    const currentMonth = `${month}-${year}`;
    const currentDate = `${day}-${month}-${year}`;

    const query = `SELECT COUNT(id) AS total_emp FROM geopos_employees WHERE roleid != '5' AND passive_type = 'ACT' AND status = 'A' AND date = ?`;

    const result = await executeQuery(connection, query, [currentDate]);

    const total_emp = result[0].total_emp;
    const response = {
      a_emp: total_emp,
    };
    res.send(response);
  } catch (err) {
    console.log(err);
    res.status(500).send('Error fetching total items');
  } finally {
    if (connection) {
      connection.release();
    }
  }
});


/**
 * @swagger
 * /fetchtotalactiveemployees1:
 *   get:
 *     summary: Fetch total active employees.
 *     description: Fetch the total number of active employees for a specific date.
 *     tags:
 *       - Employees
 *     security:
 *       - BearerAuth: []
 *     responses:
 *       200:
 *         description: Successfully retrieved total active employees.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 actemp:
 *                   type: integer
 *                   description: The total number of active employees.
 *       500:
 *         description: Internal server error.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: Error fetching total items
 * @function
 * @name fetchtotalactiveemployees1
 * @memberof module:Routes/Employees
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue fetching the total active employees.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */

//total active employees
app.get('/fetchtotalactiveemployees1', authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    const date = new Date().toLocaleDateString('en-GB', { timeZone: 'Africa/Lagos' });
    const parts = date.split('/');
    const day = parts[0].padStart(2, '0');
    const month = parts[1].padStart(2, '0');
    const year = parts[2];
    const currentMonth = `${month}-${year}`;
    const currentDate = `${day}-${month}-${year}`;

    const query = `SELECT COUNT(*) AS noOfEmp FROM operator_section WHERE date = ? GROUP BY empid`;

    const result = await executeQuery(connection, query, [currentDate]);

    const actemp = result.length;
    const response = {
      actemp: actemp,
    };
    res.send(response);
  } catch (err) {
    console.error('Error executing SQL query:', err);
    res.status(500).send('Error fetching total items');
  } finally {
    if (connection) {
      connection.release();
    }
  }
});

/**
 * @swagger
 * /fetchmtdavgoutput1:
 *   get:
 *     summary: Fetch month-to-date average output.
 *     description: Fetch the total FG output for the current month.
 *     tags:
 *       - Output
 *     security:
 *       - BearerAuth: []
 *     responses:
 *       200:
 *         description: Successfully retrieved total FG output.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 total_fg_outputK:
 *                   type: integer
 *                   description: The total FG output for the current month.
 *                   example: 12345
 *       500:
 *         description: Internal server error.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: Error fetching total FG output
 * @function
 * @name fetchmtdavgoutput1
 * @memberof module:Routes/Output
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue fetching the total FG output.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */

//mtd fg output
app.get('/fetchmtdavgoutput1', authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    const date = new Date().toLocaleDateString('en-GB', { timeZone: 'Africa/Lagos' });
    const parts = date.split('/');
    const day = parts[0].padStart(2, '0');
    const month = parts[1].padStart(2, '0');
    const year = parts[2];
    const currentMonth = `${month}-${year}`;
    const currentDate = `${day}-${month}-${year}`;

    const query = `SELECT SUM(fg_output) AS tar FROM geopos_operator WHERE month = ?`;

    const results = await executeQuery(connection, query, [currentMonth]);

    const total_fg_outputK = results[0].tar || 0;
    const response = {
      total_fg_outputK: total_fg_outputK,
    };
    res.send(response);
  } catch (err) {
    console.error('Error executing SQL query:', err);
    res.status(500).send('Error fetching total FG output');
  } finally {
    if (connection) {
      connection.release();
    }
  }
});

/**
 * @swagger
 * /fetchtotalfgoutput1:
 *   get:
 *     summary: Fetch total FG output for the current date.
 *     description: Retrieve the total FG output for all items on the current date.
 *     tags:
 *       - Output
 *     security:
 *       - BearerAuth: []
 *     responses:
 *       200:
 *         description: Successfully retrieved total FG output for the current date.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 total_fg_outputf:
 *                   type: number
 *                   description: The total FG output for all items on the current date.
 *                   example: 5000
 *       500:
 *         description: Internal server error.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: Error fetching data
 * @function
 * @name fetchtotalfgoutput1
 * @memberof module:Routes/Output
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue fetching the total FG output.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
//total fg output
app.get('/fetchtotalfgoutput1', authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    const date = new Date().toLocaleDateString('en-GB', { timeZone: 'Africa/Lagos' });
    const parts = date.split('/');
    const day = parts[0].padStart(2, '0');
    const month = parts[1].padStart(2, '0');
    const year = parts[2];
    const currentDate = `${day}-${month}-${year}`;

    let total_fg_outputf = 0;

    const query = `SELECT * FROM geopos_operator WHERE date = ? GROUP BY item, date`;

    const results = await executeQuery(connection, query, [currentDate]);

    const promises = results.map((row) => {
      return new Promise((resolve) => {
        const subQuery = `SELECT SUM(fg_output) AS tar FROM geopos_operator WHERE date = ? AND item = ?`;
        db.query(subQuery, [currentDate, row.item], (err, result) => {
          if (!err) {
            const sum = result.length > 0 ? result[0].tar : 0;
            total_fg_outputf += sum;
          }
          resolve();
        });
      });
    });

    await Promise.all(promises);

    const response = {
      total_fg_outputf: total_fg_outputf,
    };
    res.send(response);
  } catch (err) {
    console.error('Error executing SQL query:', err);
    res.status(500).send('Error fetching data');
  } finally {
    if (connection) {
      connection.release();
    }
  }
});


/**
 * @swagger
 * /fetchmtdppp1:
 *   get:
 *     summary: Fetch the sum of the number of employees for the given month.
 *     description: Retrieve the sum of the number of employees for the given month.
 *     tags:
 *       - Employees
 *     security:
 *       - BearerAuth: []
 *     responses:
 *       200:
 *         description: Successfully retrieved the sum of the number of employees for the given month.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 resk:
 *                   type: number
 *                   description: The sum of the number of employees for the given month.
 *                   example: 150
 *       500:
 *         description: Internal server error.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: Error calculating total PPP
 * @function
 * @name fetchmtdppp1
 * @memberof module:Routes/Employees
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue calculating the total PPP.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */

//mtd ppp
app.get('/fetchmtdppp1', authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    const date = new Date().toLocaleDateString('en-GB', { timeZone: 'Africa/Lagos' });
    const parts = date.split('/');
    const day = parts[0].padStart(2, '0');
    const month = parts[1].padStart(2, '0');
    const year = parts[2];
    const currentDate = `${day}-${month}-${year}`;
    const currentMonth = `${month}-${year}`;

    // Query to calculate the sum of noOfEmp for the given monthK
    const query = `
      SELECT SUM(a.noOfEmp) as res
      FROM (SELECT COUNT(*) AS noOfEmp
            FROM geopos_operator
            WHERE month = ?
            GROUP BY emp_id,date) a
    `;

    const result = await executeQuery(connection, query, [currentMonth]);

    const ros1K = result[0]; // Assuming you have a single result row
    const resk = ros1K.res; // Assuming you have a single result row

    res.json({ resk });
  } catch (err) {
    console.error('Error executing SQL query:', err);
    res.status(500).send('Error calculating total PPP');
  } finally {
    if (connection) {
      connection.release();
    }
  }
});


/**
 * @swagger
 * /fetchfgoutputslide1:
 *   get:
 *     summary: Fetch FG output data for the current date.
 *     description: Retrieve the total FG output grouped by item and color for the current date.
 *     tags:
 *       - FG Output
 *     security:
 *       - BearerAuth: []
 *     responses:
 *       200:
 *         description: Successfully retrieved FG output data.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 data:
 *                   type: array
 *                   items:
 *                     type: object
 *                     properties:
 *                       item_description:
 *                         type: string
 *                         description: The description of the item.
 *                         example: Item A
 *                       color_name:
 *                         type: string
 *                         description: The name of the color.
 *                         example: Red
 *                       tar:
 *                         type: number
 *                         description: The total FG output.
 *                         example: 150
 *       500:
 *         description: Internal server error.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: Internal server error
 * @function
 * @name fetchfgoutputslide1
 * @memberof module:Routes/FGOutput
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue fetching FG output data.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
// FG OUTPUT Slide
app.get('/fetchfgoutputslide1', authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    const date = new Date().toLocaleDateString('en-GB', { timeZone: 'Africa/Lagos' });
    const parts = date.split('/');
    const day = parts[0].padStart(2, '0');
    const month = parts[1].padStart(2, '0');
    const year = parts[2];
    const currentDate = `${day}-${month}-${year}`;

    const query = `
      SELECT geopos_operator.*, color_master.color_name, item_masterr.item_description, SUM(geopos_operator.fg_output) as tar
      FROM geopos_operator
      JOIN color_master ON geopos_operator.color_id = color_master.id
      JOIN item_masterr ON geopos_operator.item = item_masterr.id
      WHERE geopos_operator.date = ?
      GROUP BY geopos_operator.item, geopos_operator.color_id
    `;

    const results = await executeQuery(connection,query, [currentDate]);

    const data = results.map((row) => ({
      item_description: row.item_description,
      color_name: row.color_name,
      tar: row.tar,
    }));

    res.json({ data: data }); // Wrap the response in a data object
  } catch (err) {
    console.error('Error executing SQL query:', err);
    res.status(500).json({ error: 'Internal server error' });
  } finally {
    if (connection) {
      connection.release();
    }
  }
});


/**
 * @swagger
 * /fetchplanvstargetslide1:
 *   get:
 *     summary: Fetch plan vs. target data for the current date.
 *     description: Retrieve the plan versus target data for items for the current date, including item descriptions, target plans, actual outputs, and deviations.
 *     tags:
 *       - Plan vs Target
 *     security:
 *       - BearerAuth: []
 *     responses:
 *       200:
 *         description: Successfully retrieved plan vs. target data.
 *         content:
 *           application/json:
 *             schema:
 *               type: array
 *               items:
 *                 type: object
 *                 properties:
 *                   itemCode:
 *                     type: string
 *                     description: The description of the item.
 *                     example: Item A
 *                   targetPlan:
 *                     type: number
 *                     description: The target plan.
 *                     example: 1000
 *                   c:
 *                     type: string
 *                     description: The actual output or a placeholder if no output.
 *                     example: 900
 *                   b:
 *                     type: number
 *                     description: The deviation from the target plan.
 *                     example: 100
 *       500:
 *         description: Internal server error.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: An error occurred
 * @function
 * @name fetchplanvstargetslide1
 * @memberof module:Routes/PlanVsTarget
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue fetching plan vs. target data.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */

// plan vs target slide
app.get('/fetchplanvstargetslide1', authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    const date = new Date().toLocaleDateString('en-GB', { timeZone: 'Africa/Lagos' });
    const parts = date.split('/');
    const day = parts[0].padStart(2, '0');
    const month = parts[1].padStart(2, '0');
    const year = parts[2];
    const currentDate = `${day}-${month}-${year}`;

    const query1 = `
      SELECT * FROM target_plan_ota
      WHERE date = ? AND target_plan > 0 AND (category = '1' OR category = '3')
    `;

    const result = await executeQuery(connection, query1, [currentDate]);

    const responseArray = [];

    for (const row of result) {
      const itemCodeId = row.item_code_id;
      const itemQuery = `SELECT * FROM item_code WHERE id = ?`;
      const itemResult = await executeQuery(connection, itemQuery, [itemCodeId]);
      const itemRow = itemResult[0];
      const productDes = itemRow ? itemRow.product_des : '';
      const product_id = row.product_id;
      const color_id = row.color_id;

      const query3 = `
        SELECT *, SUM(fg_output) as tar FROM geopos_operator
        WHERE date = ? AND item = ? AND color_id = ?
        ORDER BY item, date
      `;

      const result3 = await executeQuery(connection ,query3, [currentDate, product_id, color_id]);
      const row3 = result3[0];
      const sump = row3 ? row3.tar : '';

      const t = row.target_plan;
      const c = sump;

      const responseObject = {
        itemCode: productDes,
        targetPlan: t,
        c: (c === '') ? '<span style="color:red">-</span>' : c,
        b: t - c,
      };

      responseArray.push(responseObject);
    }

    res.json(responseArray);
  } catch (err) {
    console.error('Error executing SQL query:', err);
    res.status(500).json({ error: 'An error occurred' });
  } finally {
    if (connection) {
      connection.release();
    }
  }
});

/**
 * @swagger
 * /fetchitemwisepppslide1:
 *   get:
 *     summary: Fetch item-wise PPP slide data for the current date.
 *     description: Retrieve the item-wise planned production performance (PPP) data for the current date, including item descriptions, finished goods output, target PPP, and real-time equivalent working (REW).
 *     tags:
 *       - Item-wise PPP
 *     security:
 *       - BearerAuth: []
 *     responses:
 *       200:
 *         description: Successfully retrieved item-wise PPP data.
 *         content:
 *           application/json:
 *             schema:
 *               type: array
 *               items:
 *                 type: object
 *                 properties:
 *                   itemDescription:
 *                     type: string
 *                     description: The description of the item.
 *                     example: Item A
 *                   fgOutput:
 *                     type: number
 *                     description: The finished goods output.
 *                     example: 1000
 *                   tppp:
 *                     type: number
 *                     description: The target planned production performance.
 *                     example: 1200
 *                   rew:
 *                     type: string
 *                     description: The real-time equivalent working (REW).
 *                     example: 0.95
 *       500:
 *         description: Internal server error.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: An error occurred
 * @function
 * @name fetchitemwisepppslide1
 * @memberof module:Routes/ItemWisePPP
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue fetching item-wise PPP data.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
//itemwise ppp slide
app.get('/fetchitemwisepppslide1', authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    const date = new Date().toLocaleDateString('en-GB', { timeZone: 'Africa/Lagos' });
    const parts = date.split('/');
    const day = parts[0].padStart(2, '0');
    const month = parts[1].padStart(2, '0');
    const year = parts[2];
    const currentDate = `${day}-${month}-${year}`;

    const query1 = `
      SELECT w.*, f.item_description, f.tppp
      FROM geopos_operator w
      JOIN item_masterr f ON w.item = f.id
      WHERE w.date = ?
      GROUP BY w.item, w.date
    `;

    const result = await executeQuery(connection,query1, [currentDate]);

    let totalFgOutput = 0;
    let totalPpp = 0;

    const responseData = [];

    for (const row of result) {
      const productName = row.item;
      const tppp = row.tppp;
      
      const query2 = `
        SELECT *, SUM(fg_output) as tar
        FROM geopos_operator
        WHERE date = ? AND item = ?
      `;

      const result2 = await executeQuery(connection,query2, [currentDate, productName]);
      const row2 = result2[0];
      const sum = row2 ? row2.tar : 0;

      const query3 = `
        SELECT COUNT(*) AS res
        FROM geopos_operator
        WHERE date = ? AND item = ?
      `;

      const result3 = await executeQuery(connection,query3, [currentDate, productName]);
      const res1 = result3[0];
      const resCount = res1.res;

      let rew = resCount !== 0 ? sum / resCount : 0;

      if (isNaN(rew)) {
        rew = 0.00;
      }

      totalFgOutput += sum;
      totalPpp += rew;

      const itemData = {
        itemDescription: row.item_description,
        fgOutput: sum,
        tppp: tppp,
        rew: rew.toFixed(2),
      };

      responseData.push(itemData);
    }

    res.json(responseData);
  } catch (err) {
    console.error('Error executing SQL query:', err);
    res.status(500).json({ error: 'An error occurred' });
  } finally {
    if (connection) {
      connection.release();
    }
  }
});



/**
 * @swagger
 * /fetchmtdpppslide1:
 *   get:
 *     summary: Fetch month-to-date (MTD) PPP slide data.
 *     description: Retrieve the item-wise planned production performance (PPP) data for the current month, including item descriptions, finished goods output, target PPP, and real-time equivalent working (REW).
 *     tags:
 *       - MTD PPP
 *     security:
 *       - BearerAuth: []
 *     responses:
 *       200:
 *         description: Successfully retrieved MTD PPP data.
 *         content:
 *           application/json:
 *             schema:
 *               type: array
 *               items:
 *                 type: object
 *                 properties:
 *                   itemDescription:
 *                     type: string
 *                     description: The description of the item.
 *                     example: Item A
 *                   tppp:
 *                     type: number
 *                     description: The target planned production performance.
 *                     example: 1200
 *                   sumk:
 *                     type: number
 *                     description: The sum of finished goods output.
 *                     example: 10000
 *                   rew:
 *                     type: string
 *                     description: The real-time equivalent working (REW).
 *                     example: 0.95
 *       500:
 *         description: Internal server error.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: An error occurred
 * @function
 * @name fetchmtdpppslide1
 * @memberof module:Routes/MTDPPP
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue fetching MTD PPP data.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */

//MTD PPP slide
app.get('/fetchmtdpppslide1', authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    const date = new Date().toLocaleDateString('en-GB', { timeZone: 'Africa/Lagos' });
    const parts = date.split('/');
    const day = parts[0].padStart(2, '0');
    const month = parts[1].padStart(2, '0');
    const year = parts[2];
    const currentDate = `${day}-${month}-${year}`;
    const currentMonth = `${month}-${year}`;

    const monthK = '10-2023';

    const query1 = `
      SELECT w.*, f.item_description, f.tppp
      FROM geopos_operator w
      JOIN item_masterr f ON w.item = f.id
      WHERE w.month = ?
      GROUP BY w.item, w.month
    `;

    const result = await executeQuery(connection,query1, [currentMonth]);

    const responseData = [];

    for (const row of result) {
      const productName = row.item;

      const query2 = `
        SELECT *, SUM(fg_output) as tar
        FROM geopos_operator
        WHERE month = ? AND item = ?
      `;

      const result2 = await executeQuery(connection,query2, [currentMonth, productName]);
      const row2 = result2[0];
      const sumk = row2 ? row2.tar : 0;
      const tppp = row.tppp;

      const query3 = `
        SELECT COUNT(*) AS res
        FROM geopos_operator
        WHERE month = ? AND item = ?
      `;

      const result3 = await executeQuery(connection,query3, [currentMonth, productName]);
      const res1 = result3[0];
      const resCount = res1.res;

      let rew = sumk / resCount;
      if (rew === Infinity) {
        rew = 0;
      }

      const itemData = {
        itemDescription: row.item_description,
        tppp,
        sumk,
        rew: rew.toFixed(2),
      };

      responseData.push(itemData);
    }

    res.json(responseData);
  } catch (err) {
    console.error('Error executing SQL query:', err);
    res.status(500).json({ error: 'An error occurred' });
  } finally {
    if (connection) {
      connection.release();
    }
  }
});



/**
 * @swagger
 * /fetchWastageManagementslide1:
 *   get:
 *     summary: Fetch wastage management data.
 *     description: Retrieve wastage management data including item descriptions, BOM percentages, and conversion percentages (CP) for the current date.
 *     tags:
 *       - Wastage Management
 *     security:
 *       - BearerAuth: []
 *     responses:
 *       200:
 *         description: Successfully retrieved wastage management data.
 *         content:
 *           application/json:
 *             schema:
 *               type: array
 *               items:
 *                 type: object
 *                 properties:
 *                   itemDescription:
 *                     type: string
 *                     description: The description of the item.
 *                     example: Item A
 *                   bom:
 *                     type: string
 *                     description: The Bill of Materials (BOM) percentage.
 *                     example: "2.50"
 *                   cp:
 *                     type: string
 *                     description: The conversion percentage (CP).
 *                     example: "1.25 %"
 *       500:
 *         description: Internal server error.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: An error occurred
 * @function
 * @name fetchWastageManagementslide1
 * @memberof module:Routes/WastageManagement
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue fetching wastage management data.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */

//Waste Management slide
app.get('/fetchWastageManagementslide1', authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    const date = new Date().toLocaleDateString('en-GB', { timeZone: 'Africa/Lagos' });
    const parts = date.split('/');
    const day = parts[0].padStart(2, '0');
    const month = parts[1].padStart(2, '0');
    const year = parts[2];
    const currentDate = `${day}-${month}-${year}`;

    const query1 = `
      SELECT w.*, f.item_description,f.targeted_waste,f.net_weight
      FROM geopos_operator w
      JOIN item_masterr f ON w.item = f.id
      WHERE w.date = ?
      GROUP BY w.item,w.date
    `;

    const result = await executeQuery(connection,query1, [currentDate]);

    const responseData = [];

    for (const row of result) {
      const item_description = row.item_description;
      const waste = row.targeted_waste;
      const net = row.net_weight;
      const bom = ((waste / net) * 100).toFixed(2);
      const item = row.item;

      let fiberTotal = 0;
      let wasteWeightTotal = 0;

      const query2 = `
        SELECT * FROM geopos_operator
        WHERE date = ? AND item = ?
      `;

      const result2 = await executeQuery(connection, query2, [currentDate, item]);

      result2.forEach((res2) => {
        const fiber = res2.fiber;
        const waste_weight = res2.waste_weight;

        fiberTotal += fiber;
        wasteWeightTotal += waste_weight;
      });

      let cp = '-';
      if (fiberTotal !== 0) {
        cp = ((wasteWeightTotal / (fiberTotal * 1000)) * 100).toFixed(2) + ' %';
      }

      const itemData = {
        itemDescription: item_description,
        bom: bom,
        cp: cp,
      };

      responseData.push(itemData);
    }

    res.json(responseData);
  } catch (err) {
    console.error('Error executing SQL query:', err);
    res.status(500).json({ error: 'An error occurred' });
  } finally {
    if (connection) {
      connection.release();
    }
  }
});

/**
 * @swagger
 * /fetchWastageManagementslide1:
 *   get:
 *     summary: Fetch wastage management data.
 *     description: Retrieve wastage management data including item descriptions, BOM percentages, and conversion percentages (CP) for the current date.
 *     tags:
 *       - Wastage Management
 *     security:
 *       - BearerAuth: []
 *     responses:
 *       200:
 *         description: Successfully retrieved wastage management data.
 *         content:
 *           application/json:
 *             schema:
 *               type: array
 *               items:
 *                 type: object
 *                 properties:
 *                   itemDescription:
 *                     type: string
 *                     description: The description of the item.
 *                     example: Item A
 *                   bom:
 *                     type: string
 *                     description: The Bill of Materials (BOM) percentage.
 *                     example: "2.50"
 *                   cp:
 *                     type: string
 *                     description: The conversion percentage (CP).
 *                     example: "1.25 %"
 *       500:
 *         description: Internal server error.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: An error occurred
 * @function
 * @name fetchWastageManagementslide1
 * @memberof module:Routes/WastageManagement
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue fetching wastage management data.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
//Waste Management MTD slide
app.get('/fetchWastageManagementmtdslide1', authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    const date = new Date().toLocaleDateString('en-GB', { timeZone: 'Africa/Lagos' });
    const parts = date.split('/');
    const day = parts[0].padStart(2, '0');
    const month = parts[1].padStart(2, '0');
    const year = parts[2];
    const currentDate = `${day}-${month}-${year}`;
    const currentMonth = `${month}-${year}`;

    const query1 = `
      SELECT w.*, f.item_description,f.targeted_waste,f.net_weight
      FROM geopos_operator w
      JOIN item_masterr f ON w.item = f.id
      WHERE w.month = ?
      GROUP BY w.item,w.month
    `;

    const result = await executeQuery(connection,query1, [currentMonth]);

    const responseData = [];

    for (const row of result) {
      const item_description = row.item_description;
      const waste = row.targeted_waste;
      const net = row.net_weight;
      const bom = ((waste / net) * 100).toFixed(2);
      const item = row.item;

      let fiberTotal = 0;
      let wasteWeightTotal = 0;

      const query2 = `
        SELECT * FROM geopos_operator
        WHERE month = ? AND item = ?
      `;

      const result2 = await executeQuery(connection,  query2, [currentMonth, item]);

      result2.forEach((res2) => {
        const fiber = parseFloat(res2.fiber);
        const waste_weight = parseFloat(res2.waste_weight);

        fiberTotal += fiber;
        wasteWeightTotal += waste_weight;
      });

      let cp = '-';
      if (fiberTotal !== 0) {
        cp = ((wasteWeightTotal / (fiberTotal * 1000)) * 100).toFixed(2) + ' %';
      }

      const itemData = {
        itemDescription: item_description,
        bom: bom,
        cp: cp,
      };

      responseData.push(itemData);
    }

    res.json(responseData);
  } catch (err) {
    console.error('Error executing SQL query:', err);
    res.status(500).json({ error: 'An error occurred' });
  } finally {
    if (connection) {
      connection.release();
    }
  }
});

//-------------------------Tv Display BRAID-------------------------------//

//---------------------------Import Timesheet-------------------------------//
app.post('/getimporttimesheetfiltertimesheetdata',  authenticateJWT, (req, res) => {
  // Extract data from the request body
  const shift = req.body.shift;
  const hour = req.body.hour;
  const line = req.body.line_no;
  const section = req.body.section;
  const id = 9;
  const sites = req.body.site;

  console.log('Received data:');
  console.log('Line No:', line);
  console.log('Section:', section);
  console.log('Shift:', shift);
  console.log('Hour:', hour);
  console.log('Site:', sites);

  let date1 = '';
  let sectionName = ''; // Initialize sectionName

  // Check if the site is 'ota'
  if (sites === 'ota') {
    // Query to fetch data from 'employees_ota' table
    const query1 = 'SELECT * FROM employees_ota ORDER BY id ASC LIMIT 1';
    
    // Execute query1 to get the date value
    db.query(query1, (error1, results1, fields) => {
      if (error1) {
        console.error('Error executing query1:', error1);
        res.status(500).json({ error: 'Internal Server Error' });
      } else {
        // Set the date1 variable with the fetched date value
        date1 = results1[0].date;
        //console.log('date for ota:', date1);

        // Check if data already exists for the specified parameters
        const checkQuery = `
          SELECT *
          FROM timesheet
          WHERE line = '${line}' 
          AND section = '${section}' 
          AND shift = '${shift}' 
          AND date_time = '${date1}' 
          AND ${hour} > 0
          AND site = '${sites}';
        `;

        //console.log('Check Query:', checkQuery);
        //console.log('Values:', [line, section, shift, date1, sites]);

        // Execute checkQuery to see if data exists
        db.query(checkQuery,  (checkError, checkResults) => {
          if (checkError) {
            console.error('Error executing checkQuery:', checkError);
            res.status(500).json({ error: 'Internal Server Error' });
          } else {
           
            // Check if data exists
            const dataExists = checkResults.length > 0;
            //console.log('dataExists:', dataExists);
            //console.log('Check Results:', checkResults);
            
            if (dataExists) {
              // Fetch section name based on sectionId
              const querySectionName = `
                SELECT section_name
                FROM section
                WHERE id = ?;
              `;
            
              db.query(querySectionName, [section], (errorSection, resultsSection) => {
                if (errorSection) {
                  console.error('Error fetching section name:', errorSection);
                  res.status(500).json({ error: 'Internal Server Error' });
                } else {
                  // Extract sectionName from the query results
                  const sectionName = resultsSection.length > 0 ? resultsSection[0].section_name : '';
            
                  // Continue with constructing the response
                  //const message = `You have already inserted data for product, line ${line}, section ${sectionName}, and hour ${hour}. For editing, click on `;
                  const message = `You have already inserted data for, ${shift}, shift, ${line}, line, ${sectionName}, section and, ${hour}, hour. For editing, click on `;
                  const additionalData = {
                    sectionname: sectionName,
                    tdate: 0,
                    sites,
                    hour,
                    line,
                    section,
                    shiftt: shift,
                  };
            
                  res.status(200).json({ message, ...additionalData });
                }
              });
            } else {
              // Continue with the main logic

              // Query to fetch data from 'operator_assign' table
              const query2 = `
                SELECT operator_assign.*, geopos_users.name, operator_assign.name_id as opid
                FROM operator_assign
                LEFT JOIN geopos_users ON operator_assign.name_id = geopos_users.id
                WHERE operator_assign.line = ? 
                AND operator_assign.section = ? 
                AND operator_assign.shift = ? 
                AND operator_assign.category_type = 'NBRAID';
              `;
              db.query(query2, [line, section, shift], (error2, results2, fields) => {
                if (error2) {
                  console.error('Error executing query2:', error2);
                  res.status(500).json({ error: 'Internal Server Error' });
                } else {
                  // Execute query4 to fetch the section name
                  const sectionId = section; // Assuming 'section' holds the section_id
                  const query4 = `
                    SELECT section_name
                    FROM section
                    WHERE id = ?;
                  `;
                  db.query(query4, [sectionId], (error4, results4, fields) => {
                    if (error4) {
                      console.error('Error fetching section name:', error4);
                      res.status(500).json({ error: 'Internal Server Error' });
                    } else {
                      if (results4.length > 0) {
                        sectionName = results4[0].section_name;
                        //console.log('Section Name:', sectionName);
                      }
      
                      // Query to check if data exists in 'timesheet'
                      const query3 = `
                        SELECT *
                        FROM timesheet
                        WHERE line = ? 
                        AND section = ? 
                        AND shift = ? 
                        AND date_time = ? 
                        AND ? > 0 
                        AND site = ?;
                      `;

                      db.query(query3, [line, section, shift, date1, hour, sites], (error3, results3, fields) => {
                        if (error3) {
                          console.error('Error executing query3:', error3);
                          res.status(500).json({ error: 'Internal Server Error' });
                        } else {
                          // Log the results of query3 to the console
                          //console.log('Query3 Results:', results3);

                          // If no data exists in 'timesheet', execute additional query
                          if (results3.length === 0) {
                            // Query to fetch data from 'employees_ota' based on specific conditions
                            const query9 = `
                                SELECT *
                                FROM employees_ota
                                WHERE section_id = '${section}'
                                AND line = '${line}' 
                                AND roleid = '1' 
                                AND passive_type = 'ACT' 
                                AND workertype = 'DIRECT' 
                                AND shift = '${shift}' 
                                AND category_type = 'NBRAID'
                                ORDER BY name;
                              `;

                              console.log('Query9:', query9);

                              db.query(query9, (error9, results9) => {
                                if (error9) {
                                  console.error('Error executing query9:', error9);
                                  res.status(500).json({ error: 'Internal Server Error' });
                                } else {
                                  // Log the results of query9 to the console
                                  console.log('Query9 Results:', results9);

                                  // Initialize the data object outside the loop
                                  const data = {
                                    op: results2,
                                    filteredResults: [], // Initialize filteredResults as an empty array
                                    abs: [], // Initialize abs as an empty array for absent entryid values
                                    additionalResults: [], // Initialize additionalResults as an empty array for 'P' case
                                    sectionname: sectionName, // Set sectionName here
                                    tdate: 0,
                                    sites,
                                    hour,
                                    line,
                                    section,
                                    shiftt: shift,
                                  };

                                  // Function to execute the inner query and handle the result
                                  const executeInnerQuery = (row) => {
                                    return new Promise((resolve, reject) => {
                                      const queryInner = `
                                        SELECT * 
                                        FROM timesheet 
                                        WHERE entry_id = ? 
                                        AND ${hour} > 0 
                                        AND date_time = ?;
                                      `;
                                  
                                      console.log('Inner Query:', queryInner); // Log the SQL query
                                  
                                      db.query(queryInner, [row.entryid, date1], (errorInner, wrk) => {
                                        if (errorInner) {
                                          console.error('Error executing timesheet query:', errorInner);
                                          reject(errorInner);
                                        } else {
                                          const row1 = wrk.length; // Use the length property for the number of rows
                                          console.log('row1:', row1);
                                  
                                          if (row1 === 0) {
                                            // Include the entire 'row' object in filteredResults for 'P' case
                                            data.filteredResults.push(row);
                                          } else {
                                            // Handle the case when rows are found in the inner query
                                            // Add your logic here for the 'else' condition
                                  
                                            // Extract relevant information from the query 9 results for 'non-P' case
                                            const { name } = row;
                                  
                                            // Include the relevant information in additionalResults for 'non-P' case
                                            data.additionalResults.push({ name });
                                          }
                                  
                                          resolve();
                                        }
                                      });
                                    });
                                  };

                                  // Array to store promises for inner queries
                                  const innerQueryPromises = [];

                                  results9.forEach((row) => {
                                    const entryId = row.entryid;
                                    if (row.status === 'P') {
                                      // Execute the inner query and push the promise to the array
                                      innerQueryPromises.push(executeInnerQuery(row));
                                    } else {
                                      // Include the entryid in abs for 'non-P' case
                                      data.abs.push(entryId);
                                    }
                                  });

                                  // Wait for all inner queries to complete before sending the response
                                  Promise.all(innerQueryPromises)
                                    .then(() => {
                                      // Send the modified 'data' object as a response
                                      res.status(200).json(data);
                                    })
                                    .catch((error) => {
                                      console.error('Error in inner queries:', error);
                                      res.status(500).json({ error: 'Internal Server Error' });
                                    });
                                }
                              });
                          } else {
                            // Data already exists in 'timesheet'
                            const data = {
                              op: results2,
                              filteredResults: results3, // Include results from query3
                              sectionname: sectionName, // Set sectionName here
                              tdate: 0,
                              sites,
                              hour,
                              line,
                              section,
                              shiftt: shift,
                            };

                            // Send the 'data' object as a response with the results of query3
                            res.status(200).json(data);
                          }
                        }
                      });
                    }
                  });
                }
              });
            }
          }
        });
      }
    });
  }
  else if (sites === 'ikeja') {
    // Query to fetch data from 'geopos_employees' table
    const query5 = 'SELECT * FROM geopos_employees ORDER BY id ASC LIMIT 1';
    
    // Execute query5 to get the date value
    db.query(query5, (error5, results5, fields) => {
      if (error5) {
        console.error('Error executing query5:', error5);
        res.status(500).json({ error: 'Internal Server Error' });
      } else {
        // Set the date1 variable with the fetched date value
        date1 = results5[0].date;
        console.log('date for ikeja:', date1);

       // Check if data already exists for the specified parameters
       const checkQuery = `
       SELECT *
       FROM timesheet
       WHERE line = '${line}' 
       AND section = '${section}' 
       AND shift = '${shift}' 
       AND date_time = '${date1}' 
       AND ${hour} > 0
       AND site = '${sites}';
     `;
     
             console.log('Check Query:', checkQuery);
             //console.log('Values:', [line, section, shift, date1, sites]);
     
             // Execute checkQuery to see if data exists
             db.query(checkQuery,  (checkError, checkResults) => {
               if (checkError) {
                 console.error('Error executing checkQuery:', checkError);
                 res.status(500).json({ error: 'Internal Server Error' });
               } else {
                
                 // Check if data exists
                 const dataExists = checkResults.length > 0;
                 console.log('dataExists:', dataExists);
                 console.log('Check Results:', checkResults);
                 if (dataExists) {
                  // Fetch section name based on sectionId
                  const querySectionName = `
                    SELECT section_name
                    FROM section
                    WHERE id = ?;
                  `;
                
                  db.query(querySectionName, [section], (errorSection, resultsSection) => {
                    if (errorSection) {
                      console.error('Error fetching section name:', errorSection);
                      res.status(500).json({ error: 'Internal Server Error' });
                    } else {
                      // Extract sectionName from the query results
                      const sectionName = resultsSection.length > 0 ? resultsSection[0].section_name : '';
                
                      // Continue with constructing the response
                      //const message = `You have already inserted data for product, line ${line}, section ${sectionName}, and hour ${hour}. For editing, click on `;
                      const message = `You have already inserted data for, ${shift}, shift, ${line}, line, ${sectionName}, section and, ${hour}, hour. For editing, click on `;
                      const additionalData = {
                        sectionname: sectionName,
                        tdate: 0,
                        sites,
                        hour,
                        line,
                        section,
                        shiftt: shift,
                      };
                
                      res.status(200).json({ message, ...additionalData });
                    }
                  });
                }  else {
              // Continue with the main logic

              // Query to fetch data from 'operator_assign_ikeja' table
              const query6 = `
                SELECT operator_assign_ikeja.*, geopos_users.name, operator_assign_ikeja.operator_id as opid
                FROM operator_assign_ikeja
                LEFT JOIN geopos_users ON operator_assign_ikeja.operator_id = geopos_users.id
                WHERE operator_assign_ikeja.line = ? 
                AND operator_assign_ikeja.section = ? 
                AND operator_assign_ikeja.shift = ? 
                AND operator_assign_ikeja.category_type = 'NBRAID';
              `;
              db.query(query6, [line, section, shift], (error6, results6, fields) => {
                if (error6) {
                  console.error('Error executing query6:', error6);
                  res.status(500).json({ error: 'Internal Server Error' });
                } else {
                  // Execute query4 to fetch the section name
                  const sectionId = section; // Assuming 'section' holds the section_id
                  const query7 = `
                    SELECT section_name
                    FROM section
                    WHERE id = ?;
                  `;
                  db.query(query7, [sectionId], (error7, results7, fields) => {
                    if (error7) {
                      console.error('Error fetching section name:', error7);
                      res.status(500).json({ error: 'Internal Server Error' });
                    } else {
                      if (results7.length > 0) {
                        sectionName = results7[0].section_name;
                        console.log('Section Name:', sectionName);
                      }
      
                      // Query to check if data exists in 'timesheet'
                      const query3 = `
                        SELECT *
                        FROM timesheet
                        WHERE line = ? 
                        AND section = ? 
                        AND shift = ? 
                        AND date_time = ? 
                        AND ? > 0 
                        AND site = ?;
                      `;

                      db.query(query3, [line, section, shift, date1, hour, sites], (error3, results3, fields) => {
                        if (error3) {
                          console.error('Error executing query3:', error3);
                          res.status(500).json({ error: 'Internal Server Error' });
                        } else {
                          // Log the results of query3 to the console
                          console.log('Query3 Results:', results3);

                          // If no data exists in 'timesheet', execute additional query
                          if (results3.length === 0) {
                            // Query to fetch data from 'geopos_employees' based on specific conditions
                           
                            const query10 = `
                            SELECT *
                            FROM geopos_employees
                            WHERE section_id = '${section}'
                            AND line = '${line}' 
                            AND roleid = '1' 
                            AND passive_type = 'ACT' 
                            AND workertype = 'DIRECT' 
                            AND shift = '${shift}' 
                            AND category_type = 'NBRAID'
                            ORDER BY name;
                          `;
                          
                          console.log('query10:', query10);
                          
                          db.query(query10, (error10, results10) => {
                              if (error10) {
                                console.error('Error executing query10:', error10);
                                res.status(500).json({ error: 'Internal Server Error' });
                              } else {
                                // Log the results of query10 to the console
                                console.log('Query10 Results:', results10);

                                  // Initialize the data object outside the loop
                                  const data = {
                                    op: results6,
                                    filteredResults: [], // Initialize filteredResults as an empty array
                                    abs: [], // Initialize abs as an empty array for absent entryid values
                                    additionalResults: [], // Initialize additionalResults as an empty array for 'P' case
                                    sectionname: sectionName, // Set sectionName here
                                    tdate: 0,
                                    sites,
                                    hour,
                                    line,
                                    section,
                                    shiftt: shift,
                                  };

                                  // Function to execute the inner query and handle the result
                                  const executeInnerQuery = (row) => {
                                    return new Promise((resolve, reject) => {
                                      const queryInner = `
                                        SELECT * 
                                        FROM timesheet 
                                        WHERE entry_id = ? 
                                        AND ${hour} > 0 
                                        AND date_time = ?;
                                      `;

                                      console.log('Inner Query:', queryInner); // Log the SQL query

                                      db.query(queryInner, [row.entryid, date1], (errorInner, wrk) => {
                                        if (errorInner) {
                                          console.error('Error executing timesheet query:', errorInner);
                                          reject(errorInner);
                                        } else {
                                          const row1 = wrk.length; // Use the length property for the number of rows
                                          console.log('row1:', row1);

                                          if (row1 === 0) {
                                            // Include the entire 'row' object in filteredResults for 'P' case
                                            data.filteredResults.push(row);
                                          } else {
                                            // Handle the case when rows are found in the inner query
                                            // Add your logic here for the 'else' condition
                                  
                                            // Extract relevant information from the query 9 results for 'non-P' case
                                            const { name } = row;
                                  
                                            // Include the relevant information in additionalResults for 'non-P' case
                                            data.additionalResults.push({ name });
                                          }
                                          resolve();
                                        }
                                      });
                                    });
                                  };

                                  // Array to store promises for inner queries
                                  const innerQueryPromises = [];

                                  results10.forEach((row) => {
                                    const entryId = row.entryid;
                                    if (row.status === 'P') {
                                      // Execute the inner query and push the promise to the array
                                      innerQueryPromises.push(executeInnerQuery(row));
                                    } else {
                                      // Include the entryid in abs for 'non-P' case
                                      data.abs.push(entryId);
                                    }
                                  });

                                  // Wait for all inner queries to complete before sending the response
                                  Promise.all(innerQueryPromises)
                                    .then(() => {
                                      // Send the modified 'data' object as a response
                                      res.status(200).json(data);
                                    })
                                    .catch((error) => {
                                      console.error('Error in inner queries:', error);
                                      res.status(500).json({ error: 'Internal Server Error' });
                                    });
                                }
                              });


                          } else {
                            // Data already exists in 'timesheet'
                            const data = {
                              op: results6,
                              filteredResults: results3, // Include results from query3
                              sectionname: sectionName, // Set sectionName here
                              tdate: 0,
                              sites,
                              hour,
                              line,
                              section,
                              shiftt: shift,
                            };

                            // Send the 'data' object as a response with the results of query3
                            res.status(200).json(data);
                          }
                        }
                      });
                    }
                  });
                }
              });
            }
          }
        });
      }
    });
  }
});


/**
 * @swagger
 * /getproductname/{selectedProduct}:
 *   get:
 *     summary: Retrieve product name by product ID
 *     description: Fetches the product name from the item_masterr table using the provided product ID.
 *     tags:
 *       - Product
 *     security:
 *       - BearerAuth: []
 *     parameters:
 *       - in: path
 *         name: selectedProduct
 *         schema:
 *           type: string
 *         required: true
 *         description: The ID of the product to retrieve.
 *         example: "12345"
 *     responses:
 *       200:
 *         description: Successfully retrieved product name.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 productDescription:
 *                   type: string
 *                   description: The description of the product.
 *                   example: "Product A Description"
 *       404:
 *         description: Product not found.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: "Product not found."
 *       500:
 *         description: Internal server error.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: "An error occurred while fetching product details."
 * @function
 * @name getProductName
 * @memberof module:Routes/Product
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue fetching product details.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
// fetch product name
app.get('/getproductname/:selectedProduct', authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    const { selectedProduct } = req.params;
    const query = `SELECT * FROM item_masterr WHERE id = ?`;

    const [results] = await executeQuery(connection,query, [selectedProduct]);

    if (results.length === 0) {
      res.status(404).json({ error: 'Product not found.' });
    } else {
      const productDescription = results[0].item_description;
      res.json({ productDescription });
    }
  } catch (error) {
    console.error('Error executing MySQL query:', error);
    res.status(500).json({ error: 'An error occurred while fetching product details.' });
  } finally {
    if (connection) {
      connection.release();
    }
  }
});



//import timesheet 
/**
 * @swagger
 * /uploadtimesheet:
 *   post:
 *     summary: Upload timesheet data.
 *     description: Uploads timesheet data from a CSV file.
 *     tags:
 *       - Timesheet
 *     security:
 *       - BearerAuth: []
 *     consumes:
 *       - multipart/form-data
 *     parameters:
 *       - in: formData
 *         name: userfile
 *         type: file
 *         required: true
 *         description: The CSV file to upload.
 *     responses:
 *       200:
 *         description: Successful upload.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 status:
 *                   type: string
 *                   example: "Success"
 *                 message:
 *                   type: string
 *                   example: "Data Imported Successfully!"
 *       400:
 *         description: No file uploaded.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 message:
 *                   type: string
 *                   example: "No file uploaded"
 *       500:
 *         description: Internal Server Error.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 status:
 *                   type: string
 *                   example: "Error"
 *                 message:
 *                   type: string
 *                   example: "Database Import Error! Please check your file and its content."
 *
 * @function
 * @name uploadTimesheet
 * @memberof module:Routes/Timesheet
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with the database query.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
app.post('/uploadtimesheet', upload.single('userfile'), authenticateJWT,async (req, res) => {
  let connection;
  try {
    // Get a connection from the pool
    connection = await getPoolConnection();

    if (!req.file) {
      return res.status(400).json({ message: 'No file uploaded' });
    }

    const file = req.file;
    const filePath = file.path;
    const parser = csv({ delimiter: ',' });
    const itemNames = [];
    let headerColumns;
    let recordCount = 0;
    const recordPromises = []; // Define recordPromises array

    parser.on('headers', (headers) => {
      headerColumns = headers;
    });

    parser.on('readable', () => {
      let record;
      

      while ((record = parser.read())) {
        console.log('Record Count (Inside while loop):', recordCount);
        const recordCountIncremented = ++recordCount;
        console.log('Record Count (Incremented):', recordCountIncremented);

        const name = record.Name;
        const entryid = record.Entryid;
        const shift = record.Shift;
        const product = record.Product;
        const color = record.Color;
        const line = record.Line;
        const section = record.Section;
        const target = record.Target;
        const hour = record.HOUR1;
        const site = record.Site;
        const operator = record.Operator;
        const date = record.Date;
        const parts = date.split('-');
        const monthYear = parts[1] + '-' + parts[2];
        const formattedDate = parts[2] + '-' + parts[1] + '-' + parts[0]; // Reformat to 'YYYY-MM-DD'
        const timestamp = Date.parse(formattedDate);
        const timestampInSeconds = timestamp / 1000;

        console.log('date:', date);
        console.log('timestamp:', timestamp);
        console.log('timestampInSeconds:', timestampInSeconds);

        const hourColumnIndex = 8;
        const hourColumnName = headerColumns[hourColumnIndex];

        const itemQuery = `SELECT * FROM item_masterr WHERE item_description='${product}'`;
        const colorQuery = `SELECT * FROM item_code WHERE product_des='${color}'`;
        const query1 = `SELECT * FROM section WHERE section_name='${section}'`;
        const query2 = `SELECT * FROM geopos_users WHERE name='${operator}'`;

        // Push promises to the array
        recordPromises.push(
          (async () => {
            try {
              const [itemResults, colorResults, sectionResults, operatorResults] = await Promise.all([
                dbQueryPromise(itemQuery),
                dbQueryPromise(colorQuery),
                dbQueryPromise(query1),
                dbQueryPromise(query2),
              ]);

              const item = itemResults[0].id;
              const colorcode = colorResults[0].id;
              const sectioncode = sectionResults[0].id;
              const operatorcode = operatorResults[0].id;

              let op = operatorcode || '9';

              // Calculate join date based on the site
              let joindate;
              if (site === 'ota') {
                const joindateQuery = `SELECT joindate FROM employees_ota WHERE entryid='${entryid}'`;
                const joindateResults = await dbQueryPromise(joindateQuery);
                joindate = joindateResults[0].joindate;
              } else if (site === 'ikeja') {
                const joindateQuery = `SELECT joindate FROM geopos_employees WHERE entryid='${entryid}'`;
                const joindateResults = await dbQueryPromise(joindateQuery);
                joindate = joindateResults[0].joindate;
              }

              const recordObject = {
                product_name: item,
                line: line,
                section: sectioncode,
                worker: name,
                entry_id: entryid,
                shift: shift,
                hour: hour,
                target: target,
                actual_target: target,
                date_time: date,
                site: site,
                color_id: colorcode,
                time_stamp: timestampInSeconds,
                mon: monthYear,
                operator_id: op,
                joindate: joindate,
              };

              itemNames.push(recordObject);
            } catch (error) {
              console.error('Error processing record:', error);
              console.error('Record Data:', record);
            }
          })()
        );
      }

      // Wait for all promises to resolve before moving on
      Promise.all(recordPromises).then(() => {
        // Do anything else you need to do after processing all records
      });
    });

    parser.on('end', async () => {
      try {
        await Promise.all(recordPromises); // Wait for all promises to resolve
        fs.unlinkSync(filePath);
       console.log('Total records processed (After try catch block):', recordCount);
        console.log('itemNames:', itemNames);
       processItemNames(headerColumns, itemNames); // Pass headerColumns and itemNames to the function
      } catch (error) {
        console.error('Error processing records:', error);
        res.status(500).json({ status: 'Error', message: 'Database Import Error! Please check your file and its content.' });
      }
    });

    fs.createReadStream(filePath).pipe(parser);

    function processItemNames(headerColumns, itemNames) {
      if (itemNames.length === 0) {
        console.log('No items to process.');
        return;
      }
    
      // Access hourColumnName in this function
      const hourColumnIndex = 8;
      const hourColumnName = headerColumns[hourColumnIndex];
      console.log('Hour Column Name:', hourColumnName);

      const values = itemNames.map(Object.values);
      //console.log('Values:', values);

      const entryIds = values.map(subArray => subArray[4]);
      const products = values.map(subArray => subArray[0]);
      const sections = values.map(subArray => subArray[2]);
      const shifts = values.map(subArray => subArray[5]);
      const sites = values.map(subArray => subArray[10]);
      const lines = values.map(subArray => subArray[1]);
      const dates = values.map(subArray => subArray[9]);
      const targets = values.map(subArray => subArray[7]);
      const hours = values.map(subArray => subArray[6]);
      /*  console.log('entryIds:', entryIds);
      console.log('products:', products);
      console.log('sections:', sections);
      console.log('shifts:', shifts);
      console.log('sites:', sites);
      console.log('lines:', lines);
      console.log('dates:', dates);
      console.log('targets:', targets); */ 

      // Generate placeholders for each row
      const placeholders = values.map(() => '(?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)').join(', ');

      // Flatten the values array to pass as parameters to the query
      const flattenedValues = values.flat();

      //console.log('flattenedValues:', flattenedValues);

      // Specify the indices of the fields you want to extract
      const desiredIndices = [0, 1, 2, 4, 5, 9, 10];

      // Extract desired fields from each subArray
      const uflattenedValues = values.map(subArray => desiredIndices.map(index => subArray[index])).flat();
      

      //console.log('uflattenedValues:', uflattenedValues);

     

      const duplicateCheckQuery = `SELECT id
      FROM timesheet
    WHERE
    entry_id IN (${entryIds.join(',')}) AND
    product_name IN (${products.join(',')}) AND
    section IN (${sections.join(',')}) AND
    shift IN ('${shifts.join("','")}') AND
    site IN ('${sites.join("','")}') AND
    line IN (${lines.join(',')}) AND
    date_time IN ('${dates.join("','")}')`;


      console.log('duplicateCheckQuery:', duplicateCheckQuery);  

      db.query(duplicateCheckQuery, uflattenedValues, (error, results) => {
        if (error) {
          console.error(error);
          res.status(500).json({ status: 'Error', message: 'Database Import Error! Please check your file and its content.' });
          return;
        }

        console.log('results:', results);  

        

       // Check if there are duplicates based on the query results
if (results.length > 0) {
  let target = [];
  let tar;
  let tarValue;

  const tarQueries = entryIds.map((id, index) => {
    return `
      SELECT * FROM timesheet
      WHERE
      entry_id = '${id}' AND
      product_name = ${products[index]} AND
      section = ${sections[index]} AND
      shift = '${shifts[index]}' AND
      site = '${sites[index]}' AND
      line = '${lines[index]}' AND
      date_time = '${dates[index]}'
    `;
  });

  // Log or use the generated tarQueries as needed
  tarQueries.forEach(tarQuery => {
    console.log('tarQuery:');
    console.log(tarQuery);

    const executeQuery = async (connection,tarQuery, index) => {
      return new Promise((resolve, reject) => {
        db.query(tarQuery, (err, result) => {
          if (err) reject(err);

          let totalTarget = 0;

          if (result.length > 0) {
            result.forEach(row => {
              tarValue = row.target;
              target.push(Number(tarValue) + Number(targets[index]));
            });

            console.log('target:', target);
          } else {
            console.log('tar:', tarValue);
          }

          const updateQuery = `UPDATE timesheet
            SET ${hourColumnName}='${hours[index]}', target='${target[index]}'
            WHERE
            entry_id = '${entryIds[index]}' AND
            product_name = ${products[index]} AND
            section = ${sections[index]} AND
            shift = '${shifts[index]}' AND
            site = '${sites[index]}' AND
            line = '${lines[index]}' AND
            date_time = '${dates[index]}'`;

          console.log(`updateQuery ${index + 1}:`);
          console.log(updateQuery);

          db.query(updateQuery, (err, result) => {
            if (err) reject(err);
            resolve();
          });
        });
      });
    };

    // Execute queries sequentially using async/await
    const executeQueries = async () => {
      for (let i = 0; i < tarQueries.length; i++) {
        const tarQuery = tarQueries[i];
        await executeQuery(connection,tarQuery, i);
      }
    };

    executeQueries()
      .then(() => {
        // All queries and updates are completed
        res.json({ status: 'Success', message: 'Data Updated Successfully!' });
      })
      .catch(err => {
        console.error(err);
        res.status(500).json({ status: 'Error', message: 'Error updating existing record.' });
      });
  });
} else {
          // No duplicates found, proceed with inserting the new record
          const insertQuery = `INSERT INTO timesheet (product_name, line, section, worker, entry_id, shift, ${hourColumnName}, target, actual_target, date_time, site, color_id, time_stamp, mon, operator_id, joindate) VALUES ${placeholders}`;

          //console.log('insertQuery:', insertQuery);

          db.query(insertQuery, flattenedValues, (insertError, insertResult) => {
            if (insertError) {
              console.error(insertError);
              res.status(500).json({ status: 'Error', message: 'Database Import Error! Please check your file and its content.' });
            } else {
              res.json({ status: 'Success', message: 'Data Imported Successfully!' });
            }
          });
        }
      });
    }

    function processRecord(record) {
      // ... (your existing code for processing individual records)
    }

    function dbQueryPromise(query) {
      return new Promise((resolve, reject) => {
        db.query(query, (error, results) => {
          if (error) {
            reject(error);
          } else {
            resolve(results);
          }
        });
      });
    }
  } catch (error) {
    console.error('Upload Timesheet Error:', error);
    res.status(500).json({ status: 'Error', message: 'Database Import Error! Please check your file and its content.' });
  } finally {
    // Release the connection back to the pool in case of success or error
    if (connection) {
      connection.release();
      //console.log("Connection released");
    }
  }
});



/**
 * @swagger
 * /viewtimesheet:
 *   get:
 *     summary: Retrieve timesheet data for the current date
 *     description: Fetches the timesheet data for the current date, including section and item descriptions.
 *     tags:
 *       - Timesheet
 *     security:
 *       - BearerAuth: []
 *     responses:
 *       200:
 *         description: Successfully retrieved timesheet data.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 timesheet:
 *                   type: array
 *                   items:
 *                     type: object
 *                     properties:
 *                       entry_id:
 *                         type: string
 *                       worker:
 *                         type: string
 *                       product_name:
 *                         type: string
 *                       section:
 *                         type: string
 *                       shift:
 *                         type: string
 *                       date_time:
 *                         type: string
 *                       section_name:
 *                         type: string
 *                       item_description:
 *                         type: string
 *                       value_sum:
 *                         type: number
 *       500:
 *         description: Internal server error.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: "An error occurred while fetching timesheet data."
 * @function
 * @name viewTimesheet
 * @memberof module:Routes/Timesheet
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue fetching timesheet data.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */

//view timesheet
app.get('/viewtimesheet', authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    const date = new Date().toLocaleDateString('en-GB', { timeZone: 'Africa/Lagos' });
    const parts = date.split('/');
    const formattedDay = parts[0].padStart(2, '0');
    const formattedMonth = parts[1].padStart(2, '0');
    const year = parts[2];
    const date1 = `${formattedDay}-${formattedMonth}-${year}`;

    console.log('Date:', date1);

    // Define the SQL query based on the user's role
    const sqlQuery = `
      SELECT
        timesheet.*, section.section_name, item_masterr.item_description,
        SUM(
          timesheet.HOUR1 + timesheet.HOUR2 + timesheet.HOUR3 +
          timesheet.HOUR4 + timesheet.HOUR5 + timesheet.HOUR6 +
          timesheet.HOUR7 + timesheet.HOUR8 + timesheet.HOUR9 +
          timesheet.HOUR10 + timesheet.HOUR11
        ) AS value_sum
      FROM timesheet
      LEFT JOIN item_masterr ON timesheet.product_name = item_masterr.id
      LEFT JOIN section ON timesheet.section = section.id
      WHERE timesheet.date_time = ?
      GROUP BY
        timesheet.entry_id,
        timesheet.product_name,
        timesheet.section,
        timesheet.shift,
        timesheet.date_time
      ORDER BY timesheet.worker ASC
    `;

    // Execute the SQL query
    const [results] = await executeQuery(connection,sqlQuery, [date1]);

    console.log('Query results ota:', results);

    const data = {
      timesheet: results,
    };
    res.json(data); // Send response back to client
  } catch (error) {
    console.error('Error fetching timesheet data:', error);
    res.status(500).json({ error: 'An error occurred while fetching timesheet data.' });
  } finally {
    if (connection) {
      connection.release();
      //console.log("Connection released");
    }
  }
});



//---------------------------Import Timesheet-------------------------------//

/**
 * @swagger
 * /report/nbraid/getEmployeesikeja:
 *   get:
 *     summary: Retrieve employees working in Ikeja site
 *     description: Fetches a list of employees from the worker_timesheet table where the site is "ikeja", grouped by entry_id and ordered by worker name.
 *     tags:
 *       - Employees
 *     security:
 *       - BearerAuth: []
 *     responses:
 *       200:
 *         description: Successfully retrieved employees list.
 *         content:
 *           application/json:
 *             schema:
 *               type: array
 *               items:
 *                 type: object
 *                 properties:
 *                   entry_id:
 *                     type: string
 *                   worker:
 *                     type: string
 *                   site:
 *                     type: string
 *                   date_time:
 *                     type: string
 *                   section:
 *                     type: string
 *                   HOUR1:
 *                     type: number
 *                   HOUR2:
 *                     type: number
 *                   HOUR3:
 *                     type: number
 *                   HOUR4:
 *                     type: number
 *                   HOUR5:
 *                     type: number
 *                   HOUR6:
 *                     type: number
 *                   HOUR7:
 *                     type: number
 *                   HOUR8:
 *                     type: number
 *                   HOUR9:
 *                     type: number
 *                   HOUR10:
 *                     type: number
 *                   HOUR11:
 *                     type: number
 *                   target:
 *                     type: number
 *                   actual_target:
 *                     type: number
 *       500:
 *         description: Internal server error.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: "Internal Server Error"
 * @function
 * @name getEmployeesIkeja
 * @memberof module:Routes/Employees
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue fetching employees data.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */

//Performance eff individual Report 
app.get('/report/nbraid/getEmployeesikeja', authenticateJWT,async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection()
    executeQuery(connection,'SELECT * FROM worker_timesheet WHERE site="ikeja" GROUP BY entry_id ORDER BY worker ASC', [], (err, result) => {
      if (err) {
        console.error('Error executing MySQL query:', err);
        res.status(500).send('Internal Server Error');
        return;
      }
      res.send(result);
    });
  } catch (error) {
    console.error('An error occurred:', error);
    res.status(500).send('Internal Server Error');
  } finally {
    if (connection) {
      connection.release();
      //console.log("Connection released");
    }
  }
});


//--------------------Attendance And Attrition Dashboard--------------------//


/**
 * @swagger
 * /fetchtotalotabraid:
 *   get:
 *     summary: Fetch total number of workers for a specific date in OTA Braid category
 *     description: Retrieves the total number of workers for a specific date in the OTA Braid category.
 *     tags:
 *       - OTA Employee Management
 *     security:
 *       - BearerAuth: []
 *     responses:
 *       200:
 *         description: Total number of workers fetched successfully.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 totalWorkerCount:
 *                   type: integer
 *                   example: 20
 *       500:
 *         description: Error occurred while fetching total number of workers.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 message:
 *                   type: string
 *                   example: An error occurred
 * @function
 * @name fetchTotalOTABraid
 * @memberof module:Routes/OTAEmployeeManagement
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with executing the MySQL query.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
//Get ota(braid) total worker 
app.get("/fetchtotalotabraid", authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    const query = `
      SELECT * FROM employees_ota
      ORDER BY id ASC
      LIMIT 1;
    `;

    const results = await executeQuery(connection,query);

    if (results.length === 0) {
      //console.log('No records found');
      return;
    }

    const dt = results[0].date;

    const whereClause = `passive_type = 'ACT' AND workertype = 'DIRECT' AND category_type = 'BRAID' AND date = '${dt}' `;
    const countQuery = `
      SELECT COUNT(*) AS totalWorkerCount
      FROM employees_ota
      WHERE ${whereClause};
    `;

    const countResults = await executeQuery(connection,countQuery);

    const totalCount = countResults[0].totalWorkerCount;
    console.log('Total Worker Count:', totalCount);
    res.send(countResults);
  } catch (error) {
    console.error('An error occurred:', error);
    res.status(500).json({ message: 'An error occurred' });
  } finally {
    if (connection) {
      connection.release();
      //console.log("Connection released");
    }
  }
});


/**
 * @swagger
 * /fetchpresentotabraid:
 *   get:
 *     summary: Fetch total number of present workers for a specific date in OTA Braid category
 *     description: Retrieves the total number of present workers for a specific date in the OTA Braid category.
 *     tags:
 *       - OTA Employee Management
 *     security:
 *       - BearerAuth: []
 *     responses:
 *       200:
 *         description: Total number of present workers fetched successfully.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 totalPresentCount:
 *                   type: integer
 *                   example: 15
 *       500:
 *         description: Error occurred while fetching total number of present workers.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 message:
 *                   type: string
 *                   example: An error occurred
 * @function
 * @name fetchPresentOTABraid
 * @memberof module:Routes/OTAEmployeeManagement
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with executing the MySQL query.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
//Get ota(braid) present worker 
app.get("/fetchpresentotabraid", authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    const query = `
      SELECT * FROM employees_ota
      ORDER BY id ASC
      LIMIT 1;
    `;

    const results = await executeQuery(connection,query);

    if (results.length === 0) {
      //console.log('No records found');
      return;
    }

    const dt = results[0].date;

    const whereClause = `passive_type = 'ACT' AND workertype = 'DIRECT' AND category_type = 'BRAID' AND date = '${dt}' AND status = 'P'`;
    const countQuery = `
      SELECT COUNT(*) AS totalPresentCount
      FROM employees_ota
      WHERE ${whereClause};
    `;

    const countResults = await executeQuery(connection,countQuery);

    const totalCount = countResults[0].totalPresentCount;
    console.log('Total Present Worker Count:', totalCount);
    res.send(countResults);
  } catch (error) {
    console.error('An error occurred:', error);
    res.status(500).json({ message: 'An error occurred' });
  } finally {
    if (connection) {
      connection.release();
      //console.log("Connection released");
    }
  }
});


/**
 * @swagger
 * /fetchabsentotabraid:
 *   get:
 *     summary: Fetch total number of absent workers for a specific date in OTA Braid category
 *     description: Retrieves the total number of absent workers for a specific date in the OTA Braid category.
 *     tags:
 *       - OTA Employee Management
 *     security:
 *       - BearerAuth: []
 *     responses:
 *       200:
 *         description: Total number of absent workers fetched successfully.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 totalAbsentCount:
 *                   type: integer
 *                   example: 5
 *       500:
 *         description: Error occurred while fetching total number of absent workers.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 message:
 *                   type: string
 *                   example: An error occurred
 * @function
 * @name fetchAbsentOTABraid
 * @memberof module:Routes/OTAEmployeeManagement
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with executing the MySQL query.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
//Get ota(braid) absent worker 
app.get("/fetchabsentotabraid",  authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    const query = `
      SELECT * FROM employees_ota
      ORDER BY id ASC
      LIMIT 1;
    `;

    const results = await executeQuery(connection,query);

    if (results.length === 0) {
      //console.log('No records found');
      return;
    }

    const dt = results[0].date;

    const whereClause = `passive_type = 'ACT' AND workertype = 'DIRECT' AND category_type = 'BRAID' AND date = '${dt}' AND status = 'A'`;
    const countQuery = `
      SELECT COUNT(*) AS totalAbsentCount
      FROM employees_ota
      WHERE ${whereClause};
    `;

    const countResults = await executeQuery(connection,countQuery);

    const totalCount = countResults[0].totalAbsentCount;
    console.log('Total Absent Worker Count:', totalCount);
    res.send(countResults);
  } catch (error) {
    console.error('An error occurred:', error);
    res.status(500).json({ message: 'An error occurred' });
  } finally {
    if (connection) {
      connection.release();
      //console.log("Connection released");
    }
  }
});



/**
 * @swagger
 * /fetchtotalotanbraid:
 *   get:
 *     summary: Fetch total number of active workers for a specific date in OTA NBraid category
 *     description: Retrieves the total number of active workers for a specific date in the OTA NBraid category.
 *     tags:
 *       - OTA Employee Management
 *     security:
 *       - BearerAuth: []
 *     responses:
 *       200:
 *         description: Total number of active workers fetched successfully.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 totalWorkerCount:
 *                   type: integer
 *                   example: 10
 *       500:
 *         description: Error occurred while fetching total number of active workers.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 message:
 *                   type: string
 *                   example: An error occurred
 * @function
 * @name fetchTotalOTANBraid
 * @memberof module:Routes/OTAEmployeeManagement
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with executing the MySQL query.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
app.get("/fetchtotalotanbraid",  authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    const query = `
      SELECT * FROM employees_ota
      ORDER BY id ASC
      LIMIT 1;
    `;

    const results = await executeQuery(connection, query);

    if (results.length === 0) {
      //console.log('No records found');
      return;
    }

    const dt = results[0].date;

    const whereClause = `passive_type = 'ACT' AND workertype = 'DIRECT' AND category_type = 'NBRAID' AND date = '${dt}' `;
    const countQuery = `
      SELECT COUNT(*) AS totalWorkerCount
      FROM employees_ota
      WHERE ${whereClause};
    `;

    const countResults = await executeQuery(connection, countQuery);

    const totalCount = countResults[0].totalWorkerCount;
    //console.log('Total Worker Count:', totalCount);
    res.json({ totalWorkerCount: totalCount });
  } catch (error) {
    console.error('An error occurred:', error);
    res.status(500).json({ message: 'An error occurred' });
  } finally {
    if (connection) {
      connection.release();
      //console.log("Connection released");
    }
  }
});


/**
 * @swagger
 * /fetchtotalotanbraid:
 *   get:
 *     summary: Fetch total number of active workers for a specific date in OTA NBraid category
 *     description: Retrieves the total number of active workers for a specific date in the OTA NBraid category.
 *     tags:
 *       - OTA Employee Management
 *     security:
 *       - BearerAuth: []
 *     responses:
 *       200:
 *         description: Total number of active workers fetched successfully.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 totalWorkerCount:
 *                   type: integer
 *                   example: 10
 *       500:
 *         description: Error occurred while fetching total number of active workers.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 message:
 *                   type: string
 *                   example: An error occurred
 * @function
 * @name fetchTotalOTANBraid
 * @memberof module:Routes/OTAEmployeeManagement
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with executing the MySQL query.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
//Get ota(nbraid) total worker 
app.get("/fetchtotalotanbraid",  authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    const query = `
      SELECT * FROM employees_ota
      ORDER BY id ASC
      LIMIT 1;
    `;

    const results = await executeQuery(connection,query);

    if (results.length === 0) {
      //console.log('No records found');
      return;
    }

    const dt = results[0].date;

    const whereClause = `passive_type = 'ACT' AND workertype = 'DIRECT' AND category_type = 'NBRAID' AND date = '${dt}' `;
    const countQuery = `
      SELECT COUNT(*) AS totalWorkerCount
      FROM employees_ota
      WHERE ${whereClause};
    `;

    const countResults = await executeQuery(connection,countQuery);

    const totalCount = countResults[0].totalWorkerCount;
    //console.log('Total Worker Count:', totalCount);
    res.send(countResults);
  } catch (error) {
    console.error('An error occurred:', error);
    res.status(500).json({ message: 'An error occurred' });
  } finally {
    if (connection) {
      connection.release();
      //console.log("Connection released");
    }
  }
});


/**
 * @swagger
 * /fetchpresentotanbraid:
 *   get:
 *     summary: Fetch total number of present workers for a specific date in OTA NBraid category
 *     description: Retrieves the total number of present workers for a specific date in the OTA NBraid category.
 *     tags:
 *       - OTA Employee Management
 *     security:
 *       - BearerAuth: []
 *     responses:
 *       200:
 *         description: Total number of present workers fetched successfully.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 totalPresentCount:
 *                   type: integer
 *                   example: 10
 *       404:
 *         description: No records found.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 message:
 *                   type: string
 *                   example: No records found
 *       500:
 *         description: Error occurred while fetching total number of present workers.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 message:
 *                   type: string
 *                   example: An error occurred
 * @function
 * @name fetchPresentOTANBraid
 * @memberof module:Routes/OTAEmployeeManagement
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with executing the MySQL query.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
//Get ota(nbraid) present worker 
app.get("/fetchpresentotanbraid",  authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    const query = `
      SELECT * FROM employees_ota
      ORDER BY id ASC
      LIMIT 1;
    `;

    const results = await executeQuery(connection,query);

    if (results.length === 0) {
      //console.log('No records found');
      return;
    }

    const dt = results[0].date;

    const whereClause = `passive_type = 'ACT' AND workertype = 'DIRECT' AND category_type = 'NBRAID' AND date = '${dt}' AND status = 'P'`;
    const countQuery = `
      SELECT COUNT(*) AS totalPresentCount
      FROM employees_ota
      WHERE ${whereClause};
    `;

    const countResults = await executeQuery(connection,countQuery);

    const totalCount = countResults[0].totalPresentCount;
    console.log('Total Present Worker Count:', totalCount);
    res.send(countResults);
  } catch (error) {
    console.error('An error occurred:', error);
    res.status(500).json({ message: 'An error occurred' });
  } finally {
    if (connection) {
      connection.release();
      //console.log("Connection released");
    }
  }
});



/**
 * @swagger
 * /fetchabsentotanbraid:
 *   get:
 *     summary: Fetch total number of absent workers for a specific date in OTA NBraid category
 *     description: Retrieves the total number of absent workers for a specific date in the OTA NBraid category.
 *     tags:
 *       - OTA Employee Management
 *     security:
 *       - BearerAuth: []
 *     responses:
 *       200:
 *         description: Total number of absent workers fetched successfully.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 totalAbsentCount:
 *                   type: integer
 *                   example: 5
 *       404:
 *         description: No records found.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 message:
 *                   type: string
 *                   example: No records found
 *       500:
 *         description: Error occurred while fetching total number of absent workers.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 message:
 *                   type: string
 *                   example: An error occurred
 * @function
 * @name fetchAbsentOTANBraid
 * @memberof module:Routes/OTAEmployeeManagement
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with executing the MySQL query.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
//Get ota(nbraid) absent worker 
app.get("/fetchabsentotanbraid", authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    const query = `
      SELECT * FROM employees_ota
      ORDER BY id ASC
      LIMIT 1;
    `;

    const results = await executeQuery(connection,query);

    if (results.length === 0) {
      //console.log('No records found');
      return;
    }

    const dt = results[0].date;

    const whereClause = `passive_type = 'ACT' AND workertype = 'DIRECT' AND category_type = 'NBRAID' AND date = '${dt}' AND status = 'A'`;
    const countQuery = `
      SELECT COUNT(*) AS totalAbsentCount
      FROM employees_ota
      WHERE ${whereClause};
    `;

    const countResults = await executeQuery(connection,countQuery);

    const totalCount = countResults[0].totalAbsentCount;
    console.log('Total Absent Worker Count:', totalCount);
    res.send(countResults);
  } catch (error) {
    console.error('An error occurred:', error);
    res.status(500).json({ message: 'An error occurred' });
  } finally {
    if (connection) {
      connection.release();
      //console.log("Connection released");
    }
    
  }
});


/**
 * @swagger
 * /fetchtotalikejabraid:
 *   get:
 *     summary: Fetch total number of workers in the IKEJA Braid category
 *     description: Retrieves the total number of workers in the IKEJA Braid category who are active, direct workers.
 *     tags:
 *       - IKEJA Employee Management
 *     security:
 *       - BearerAuth: []
 *     responses:
 *       200:
 *         description: Total number of workers fetched successfully.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 totalWorkerCount:
 *                   type: integer
 *                   example: 50
 *       404:
 *         description: No records found.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 message:
 *                   type: string
 *                   example: No records found
 *       500:
 *         description: Error occurred while fetching total number of workers.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 message:
 *                   type: string
 *                   example: An error occurred
 * @function
 * @name fetchTotalIKEJABraid
 * @memberof module:Routes/IKEJAEmployeeManagement
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with executing the MySQL query.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
//Get ikeja(braid) total worker 
app.get("/fetchtotalikejabraid", authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    const query = `
      SELECT * FROM geopos_employees
      ORDER BY id ASC
      LIMIT 1;
    `;

    const results = await executeQuery(connection,query);

    if (results.length === 0) {
      //console.log('No records found');
      return;
    }

    const dt = results[0].date;

    const whereClause = `passive_type = 'ACT' AND workertype = 'DIRECT' AND category_type = 'BRAID' AND date = '${dt}' `;
    const countQuery = `
      SELECT COUNT(*) AS totalWorkerCount
      FROM geopos_employees
      WHERE ${whereClause};
    `;

    const countResults = await executeQuery(connection,countQuery);

    const totalCount = countResults[0].totalWorkerCount;
    //console.log('Total Worker Count:', totalCount);
    res.send(countResults);
  } catch (error) {
    console.error('An error occurred:', error);
    res.status(500).json({ message: 'An error occurred' });
  } finally {
    if(connection){
      connection.release();
      //console.log("Connection released");
    }
  }
});


/**
 * @swagger
 * /fetchpresentikejabraid:
 *   get:
 *     summary: Fetch total number of present workers in the IKEJA Braid category
 *     description: Retrieves the total number of present workers in the IKEJA Braid category who are active, direct workers.
 *     tags:
 *       - IKEJA Employee Management
 *     security:
 *       - BearerAuth: []
 *     responses:
 *       200:
 *         description: Total number of present workers fetched successfully.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 totalPresentCount:
 *                   type: integer
 *                   example: 45
 *       404:
 *         description: No records found.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 message:
 *                   type: string
 *                   example: No records found
 *       500:
 *         description: Error occurred while fetching total number of present workers.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 message:
 *                   type: string
 *                   example: An error occurred
 * @function
 * @name fetchPresentIKEJABraid
 * @memberof module:Routes/IKEJAEmployeeManagement
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with executing the MySQL query.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
//Get ikeja(braid) present worker 
app.get("/fetchpresentikejabraid", authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    const query = `
      SELECT * FROM geopos_employees
      ORDER BY id ASC
      LIMIT 1;
    `;

    const results = await executeQuery(connection,query);

    if (results.length === 0) {
      //console.log('No records found');
      return;
    }

    const dt = results[0].date;

    const whereClause = `passive_type = 'ACT' AND workertype = 'DIRECT' AND category_type = 'BRAID' AND date = '${dt}' AND status = 'P'`;
    const countQuery = `
      SELECT COUNT(*) AS totalPresentCount
      FROM geopos_employees
      WHERE ${whereClause};
    `;

    const countResults = await executeQuery(connection,countQuery);

    const totalCount = countResults[0].totalPresentCount;
    console.log('Total Present Worker Count:', totalCount);
    res.send(countResults);
  } catch (error) {
    console.error('An error occurred:', error);
    res.status(500).json({ message: 'An error occurred' });
  } finally {
    if (connection) {
      connection.release();
      //console.log("Connection released");
    }
  }
});


/**
 * @swagger
 * /fetchabsentikejabraid:
 *   get:
 *     summary: Fetch total number of absent workers in the IKEJA Braid category
 *     description: Retrieves the total number of absent workers in the IKEJA Braid category who are active, direct workers.
 *     tags:
 *       - IKEJA Employee Management
 *     security:
 *       - BearerAuth: []
 *     responses:
 *       200:
 *         description: Total number of absent workers fetched successfully.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 totalAbsentCount:
 *                   type: integer
 *                   example: 10
 *       404:
 *         description: No records found.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 message:
 *                   type: string
 *                   example: No records found
 *       500:
 *         description: Error occurred while fetching total number of absent workers.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 message:
 *                   type: string
 *                   example: An error occurred
 * @function
 * @name fetchAbsentIKEJABraid
 * @memberof module:Routes/IKEJAEmployeeManagement
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with executing the MySQL query.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
//Get ikeja(braid) absent worker 
app.get("/fetchabsentikejabraid", authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    const query = `
      SELECT * FROM geopos_employees
      ORDER BY id ASC
      LIMIT 1;
    `;

    const results = await executeQuery(connection,query);

    if (results.length === 0) {
      //console.log('No records found');
      return;
    }

    const dt = results[0].date;

    const whereClause = `passive_type = 'ACT' AND workertype = 'DIRECT' AND category_type = 'BRAID' AND date = '${dt}' AND status = 'A'`;
    const countQuery = `
      SELECT COUNT(*) AS totalAbsentCount
      FROM geopos_employees
      WHERE ${whereClause};
    `;

    const countResults = await executeQuery(connection,countQuery);

    const totalCount = countResults[0].totalAbsentCount;
    console.log('Total Absent Worker Count:', totalCount);
    res.send(countResults);
  } catch (error) {
    console.error('An error occurred:', error);
    res.status(500).json({ message: 'An error occurred' });
  } finally {
    if (connection) {
      connection.release();
      //console.log("Connection released");
    }
  }
});


/**
 * @swagger
 * /fetchtotalikejanbraid:
 *   get:
 *     summary: Fetch total number of workers in the IKEJA NBRAID category
 *     description: Retrieves the total number of workers in the IKEJA NBRAID category who are active, direct workers.
 *     tags:
 *       - IKEJA Employee Management
 *     security:
 *       - BearerAuth: []
 *     responses:
 *       200:
 *         description: Total number of workers fetched successfully.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 totalWorkerCount:
 *                   type: integer
 *                   example: 50
 *       404:
 *         description: No records found.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 message:
 *                   type: string
 *                   example: No records found
 *       500:
 *         description: Error occurred while fetching total number of workers.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 message:
 *                   type: string
 *                   example: An error occurred
 * @function
 * @name fetchTotalIKEJANBraid
 * @memberof module:Routes/IKEJAEmployeeManagement
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with executing the MySQL query.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
//Get ikeja(nbraid) total worker 
app.get("/fetchtotalikejanbraid", authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    const query = `
      SELECT * FROM geopos_employees
      ORDER BY id ASC
      LIMIT 1;
    `;

    const results = await executeQuery(connection,query);

    if (results.length === 0) {
      //console.log('No records found');
      return;
    }

    const dt = results[0].date;

    const whereClause = `passive_type = 'ACT' AND workertype = 'DIRECT' AND category_type = 'NBRAID' AND date = '${dt}' `;
    const countQuery = `
      SELECT COUNT(*) AS totalWorkerCount
      FROM geopos_employees
      WHERE ${whereClause};
    `;

    const countResults = await executeQuery(connection,countQuery);

    const totalCount = countResults[0].totalWorkerCount;
    //console.log('Total Worker Count:', totalCount);
    res.send(countResults);
  } catch (error) {
    console.error('An error occurred:', error);
    res.status(500).json({ message: 'An error occurred' });
  } finally {
    if(connection){
      connection.release();
      //console.log("Connection released");
    }
  }
});


/**
 * @swagger
 * /fetchpresentikejanbraid:
 *   get:
 *     summary: Fetch total number of present workers in the IKEJA NBRAID category
 *     description: Retrieves the total number of workers present in the IKEJA NBRAID category who are active, direct workers.
 *     tags:
 *       - IKEJA Employee Management
 *     security:
 *       - BearerAuth: []
 *     responses:
 *       200:
 *         description: Total number of present workers fetched successfully.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 totalPresentCount:
 *                   type: integer
 *                   example: 30
 *       404:
 *         description: No records found.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 message:
 *                   type: string
 *                   example: No records found
 *       500:
 *         description: Error occurred while fetching total number of present workers.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 message:
 *                   type: string
 *                   example: An error occurred
 * @function
 * @name fetchPresentIKEJANBraid
 * @memberof module:Routes/IKEJAEmployeeManagement
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with executing the MySQL query.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
//Get ikeja(nbraid) present worker 
app.get("/fetchpresentikejanbraid", authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    const query = `
      SELECT * FROM geopos_employees
      ORDER BY id ASC
      LIMIT 1;
    `;

    const results = await executeQuery(connection,query);

    if (results.length === 0) {
      //console.log('No records found');
      return;
    }

    const dt = results[0].date;

    const whereClause = `passive_type = 'ACT' AND workertype = 'DIRECT' AND category_type = 'NBRAID' AND date = '${dt}' AND status = 'P'`;
    const countQuery = `
      SELECT COUNT(*) AS totalPresentCount
      FROM geopos_employees
      WHERE ${whereClause};
    `;

    const countResults = await executeQuery(connection,countQuery);

    const totalCount = countResults[0].totalPresentCount;
    console.log('Total Present Worker Count:', totalCount);
    res.send(countResults);
  } catch (error) {
    console.error('An error occurred:', error);
    res.status(500).json({ message: 'An error occurred' });
  } finally {
    if(connection){
      connection.release();
      //console.log("Connection released");
    }
  }
});

/**
 * @swagger
 * /fetchabsentikejanbraid:
 *   get:
 *     summary: Fetch total number of absent workers in the IKEJA NBRAID category
 *     description: Retrieves the total number of workers absent in the IKEJA NBRAID category who are active, direct workers.
 *     tags:
 *       - IKEJA Employee Management
 *     security:
 *       - BearerAuth: []
 *     responses:
 *       200:
 *         description: Total number of absent workers fetched successfully.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 totalAbsentCount:
 *                   type: integer
 *                   example: 10
 *       404:
 *         description: No records found.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 message:
 *                   type: string
 *                   example: No records found
 *       500:
 *         description: Error occurred while fetching total number of absent workers.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 message:
 *                   type: string
 *                   example: An error occurred
 * @function
 * @name fetchAbsentIKEJANBraid
 * @memberof module:Routes/IKEJAEmployeeManagement
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with executing the MySQL query.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
//Get ikeja(nbraid) absent worker 
app.get("/fetchabsentikejanbraid", authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    const query = `
      SELECT * FROM geopos_employees
      ORDER BY id ASC
      LIMIT 1;
    `;

    const results = await executeQuery(connection,query);

    if (results.length === 0) {
      //console.log('No records found');
      return;
    }

    const dt = results[0].date;

    const whereClause = `passive_type = 'ACT' AND workertype = 'DIRECT' AND category_type = 'NBRAID' AND date = '${dt}' AND status = 'A'`;
    const countQuery = `
      SELECT COUNT(*) AS totalAbsentCount
      FROM geopos_employees
      WHERE ${whereClause};
    `;

    const countResults = await executeQuery(connection,countQuery);

    const totalCount = countResults[0].totalAbsentCount;
    console.log('Total Absent Worker Count:', totalCount);
    res.send(countResults);
  } catch (error) {
    console.error('An error occurred:', error);
    res.status(500).json({ message: 'An error occurred' });
  } finally {
    if(connection){
      connection.release();
      //console.log("Connection released");
    }
  }
});



/**
 * @swagger
 * /ota_braid_total_day:
 *   get:
 *     summary: Fetch total number of active, direct workers in the BRAID category assigned to the DAY shift
 *     description: Retrieves the total number of active, direct workers in the BRAID category who are assigned to the DAY shift.
 *     tags:
 *       - OTA Employee Management
 *     security:
 *       - BearerAuth: []
 *     responses:
 *       200:
 *         description: Total number of active, direct workers in the BRAID category assigned to the DAY shift fetched successfully.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 totalEmployees:
 *                   type: integer
 *                   example: 10
 *       500:
 *         description: Error occurred while fetching total number of active, direct workers in the BRAID category assigned to the DAY shift.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: Internal Server Error
 * @function
 * @name fetchOTABraidTotalDay
 * @memberof module:Routes/OTAEmployeeManagement
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with executing the MySQL query.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
// API endpoint for ota_braid_total_day
app.get('/ota_braid_total_day', authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    // Get the latest date from the employees_ota table
    const latestDateQuery = 'SELECT * FROM employees_ota ORDER BY id ASC LIMIT 1';
    const latestDateResults = await executeQuery(connection,latestDateQuery);
    const latestDate = latestDateResults[0].date;

    // Query to count the total employees for the specified date and conditions
    const employeeCountQuery = `
      SELECT COUNT(*) AS totalEmployees
      FROM employees_ota
      WHERE passive_type = 'ACT'
        AND workertype = 'DIRECT'
        AND shift = 'DAY'
        AND category_type = 'BRAID'
        AND date = ?
    `;

    // Execute the query with the latest date
    const employeeCountResults = await executeQuery(connection,employeeCountQuery, [latestDate]);
    const totalEmployees = employeeCountResults[0].totalEmployees;

    // Send the total employee count as the API response
    res.json({ totalEmployees });
  } catch (error) {
    console.error('An error occurred:', error);
    res.status(500).json({ error: 'Internal Server Error' });
  } finally {
    if(connection){
      connection.release();
      //console.log("Connection released");
    }
  }
});


/**
 * @swagger
 * /ota_braid_total_present_day:
 *   get:
 *     summary: Fetch total number of present active, direct workers in the BRAID category assigned to the DAY shift
 *     description: Retrieves the total number of present active, direct workers in the BRAID category who are assigned to the DAY shift.
 *     tags:
 *       - OTA Employee Management
 *     security:
 *       - BearerAuth: []
 *     responses:
 *       200:
 *         description: Total number of present active, direct workers in the BRAID category assigned to the DAY shift fetched successfully.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 presentEmployees:
 *                   type: integer
 *                   example: 5
 *       500:
 *         description: Error occurred while fetching total number of present active, direct workers in the BRAID category assigned to the DAY shift.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: Internal Server Error
 * @function
 * @name fetchOTABraidTotalPresentDay
 * @memberof module:Routes/OTAEmployeeManagement
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with executing the MySQL query.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
// API endpoint for ota_braid_total_present_day
app.get('/ota_braid_total_present_day', authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    // Get the latest date from the employees_ota table
    const latestDateQuery = 'SELECT * FROM employees_ota ORDER BY id ASC LIMIT 1';
    const latestDateResults = await executeQuery(connection,latestDateQuery);
    const latestDate = latestDateResults[0].date;

    // Query to count the total present employees for the specified date and conditions
    const presentEmployeeCountQuery = `
      SELECT COUNT(*) AS presentEmployees
      FROM employees_ota
      WHERE passive_type = 'ACT'
        AND workertype = 'DIRECT'
        AND category_type = 'BRAID'
        AND status = 'P'
        AND shift = 'DAY'
        AND date = ?
    `;

    // Execute the query with the latest date
    const presentEmployeeCountResults = await executeQuery(connection,presentEmployeeCountQuery, [latestDate]);
    const presentEmployees = presentEmployeeCountResults[0].presentEmployees;

    // Send the total present employee count as the API response
    res.json({ presentEmployees });
  } catch (error) {
    console.error('An error occurred:', error);
    res.status(500).json({ error: 'Internal Server Error' });
  } finally {
    if(connection){
      connection.release();
      //console.log("Connection released");
    }
  }
});


// API endpoint for ota_braid_total_absent_day

/**
 * @swagger
 * /ota_braid_total_absent_day:
 *   get:
 *     summary: Fetch total number of absent active, direct workers in the BRAID category assigned to the DAY shift
 *     description: Retrieves the total number of absent active, direct workers in the BRAID category who are assigned to the DAY shift.
 *     tags:
 *       - OTA Employee Management
 *     security:
 *       - BearerAuth: []
 *     responses:
 *       200:
 *         description: Total number of absent active, direct workers in the BRAID category assigned to the DAY shift fetched successfully.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 absentEmployees:
 *                   type: integer
 *                   example: 5
 *       404:
 *         description: No records found in the employees_ota table.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: No records found
 *       500:
 *         description: Error occurred while fetching total number of absent active, direct workers in the BRAID category assigned to the DAY shift.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: Internal Server Error
 * @function
 * @name fetchOTABraidTotalAbsentDay
 * @memberof module:Routes/OTAEmployeeManagement
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with executing the MySQL query.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
app.get('/ota_braid_total_absent_day', authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    // Get the latest date from the employees_ota table
    const latestDateQuery = 'SELECT * FROM employees_ota ORDER BY id ASC LIMIT 1';
    const latestDateResults = await executeQuery(connection,latestDateQuery);
    const latestDate = latestDateResults[0].date;

    // Query to count the total absent employees for the specified date and conditions
    const absentEmployeeCountQuery = `
      SELECT COUNT(*) AS absentEmployees
      FROM employees_ota
      WHERE passive_type = 'ACT'
        AND workertype = 'DIRECT'
        AND category_type = 'BRAID'
        AND status = 'A'
        AND shift = 'DAY'
        AND date = ?
    `;

    // Execute the query with the latest date
    const absentEmployeeCountResults = await executeQuery(connection,absentEmployeeCountQuery, [latestDate]);
    const absentEmployees = absentEmployeeCountResults[0].absentEmployees;

    // Send the total absent employee count as the API response
    res.json({ absentEmployees });
  } catch (error) {
    console.error('An error occurred:', error);
    res.status(500).json({ error: 'Internal Server Error' });
  } finally {
    if(connection){
      connection.release();
      //console.log("Connection released");
    }
  }
});


// API endpoint for ota_braid_total_night

/**
 * @swagger
 * /ota_braid_total_night:
 *   get:
 *     summary: Fetch total number of active, direct workers in the BRAID category assigned to the NIGHT shift
 *     description: Retrieves the total number of active, direct workers in the BRAID category who are assigned to the NIGHT shift.
 *     tags:
 *       - OTA Employee Management
 *     security:
 *       - BearerAuth: []
 *     responses:
 *       200:
 *         description: Total number of active, direct workers in the BRAID category assigned to the NIGHT shift fetched successfully.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 totalEmployees:
 *                   type: integer
 *                   example: 10
 *       404:
 *         description: No records found in the employees_ota table.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: No records found
 *       500:
 *         description: Error occurred while fetching total number of active, direct workers in the BRAID category assigned to the NIGHT shift.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: Internal Server Error
 * @function
 * @name fetchOTABraidTotalNight
 * @memberof module:Routes/OTAEmployeeManagement
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with executing the MySQL query.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
app.get('/ota_braid_total_night', authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    // Get the latest date from the employees_ota table
    const latestDateQuery = 'SELECT * FROM employees_ota ORDER BY id ASC LIMIT 1';
    const latestDateResults = await executeQuery(connection,latestDateQuery);
    const latestDate = latestDateResults[0].date;

    // Query to count the total employees for the specified date and conditions (night shift)
    const employeeCountQuery = `
      SELECT COUNT(*) AS totalEmployees
      FROM employees_ota
      WHERE passive_type = 'ACT'
        AND workertype = 'DIRECT'
        AND shift = 'NIGHT'
        AND category_type = 'BRAID'
        AND date = ?
    `;

    // Execute the query with the latest date
    const employeeCountResults = await executeQuery(connection,employeeCountQuery, [latestDate]);
    const totalEmployees = employeeCountResults[0].totalEmployees;

    // Send the total employee count as the API response
    res.json({ totalEmployees });
  } catch (error) {
    console.error('An error occurred:', error);
    res.status(500).json({ error: 'Internal Server Error' });
  } finally {
    if(connection){
      connection.release();
      //console.log("Connection released");
    }
  }
});


// API endpoint for ota_braid_total_present_night
/**
 * @swagger
 * /ota_braid_total_present_night:
 *   get:
 *     summary: Fetch total number of present active, direct workers in the BRAID category assigned to the NIGHT shift
 *     description: Retrieves the total number of present active, direct workers in the BRAID category who are assigned to the NIGHT shift.
 *     tags:
 *       - OTA Employee Management
 *     security:
 *       - BearerAuth: []
 *     responses:
 *       200:
 *         description: Total number of present active, direct workers in the BRAID category assigned to the NIGHT shift fetched successfully.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 presentEmployees:
 *                   type: integer
 *                   example: 8
 *       404:
 *         description: No records found in the employees_ota table.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: No records found
 *       500:
 *         description: Error occurred while fetching total number of present active, direct workers in the BRAID category assigned to the NIGHT shift.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: Internal Server Error
 * @function
 * @name fetchOTABraidTotalPresentNight
 * @memberof module:Routes/OTAEmployeeManagement
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with executing the MySQL query.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
app.get('/ota_braid_total_present_night', authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    // Get the latest date from the employees_ota table
    const latestDateQuery = 'SELECT * FROM employees_ota ORDER BY id ASC LIMIT 1';
    const latestDateResults = await executeQuery(connection,latestDateQuery);
    const latestDate = latestDateResults[0].date;

    // Query to count the total present employees for the specified date and conditions (night shift, BRAID category, status: P)
    const presentEmployeeCountQuery = `
      SELECT COUNT(*) AS presentEmployees
      FROM employees_ota
      WHERE passive_type = 'ACT'
        AND workertype = 'DIRECT'
        AND category_type = 'BRAID'
        AND status = 'P'
        AND shift = 'NIGHT'
        AND date = ?
    `;

    // Execute the query with the latest date
    const presentEmployeeCountResults = await executeQuery(connection,presentEmployeeCountQuery, [latestDate]);
    const presentEmployees = presentEmployeeCountResults[0].presentEmployees;

    // Send the total present employee count as the API response
    res.json({ presentEmployees });
  } catch (error) {
    console.error('An error occurred:', error);
    res.status(500).json({ error: 'Internal Server Error' });
  } finally {
    if(connection){
      connection.release();
      //console.log("Connection released");
    }
  }
});


// API endpoint for ota_braid_total_absent_night
/**
 * @swagger
 * /ota_braid_total_absent_night:
 *   get:
 *     summary: Fetch total number of absent active, direct workers in the BRAID category assigned to the NIGHT shift
 *     description: Retrieves the total number of absent active, direct workers in the BRAID category who are assigned to the NIGHT shift.
 *     tags:
 *       - OTA Employee Management
 *     security:
 *       - BearerAuth: []
 *     responses:
 *       200:
 *         description: Total number of absent active, direct workers in the BRAID category assigned to the NIGHT shift fetched successfully.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 absentEmployees:
 *                   type: integer
 *                   example: 5
 *       404:
 *         description: No records found in the employees_ota table.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: No records found
 *       500:
 *         description: Error occurred while fetching total number of absent active, direct workers in the BRAID category assigned to the NIGHT shift.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: Internal Server Error
 * @function
 * @name fetchOTABraidTotalAbsentNight
 * @memberof module:Routes/OTAEmployeeManagement
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with executing the MySQL query.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
app.get('/ota_braid_total_absent_night', authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    // Get the latest date from the employees_ota table
    const latestDateQuery = 'SELECT * FROM employees_ota ORDER BY id ASC LIMIT 1';
    const latestDateResults = await executeQuery(connection,latestDateQuery);
    const latestDate = latestDateResults[0].date;

    // Query to count the total absent employees for the specified date and conditions (night shift, BRAID category, status: A)
    const absentEmployeeCountQuery = `
      SELECT COUNT(*) AS absentEmployees
      FROM employees_ota
      WHERE passive_type = 'ACT'
        AND workertype = 'DIRECT'
        AND category_type = 'BRAID'
        AND status = 'A'
        AND shift = 'NIGHT'
        AND date = ?
    `;

    // Execute the query with the latest date
    const absentEmployeeCountResults = await executeQuery(connection,absentEmployeeCountQuery, [latestDate]);
    const absentEmployees = absentEmployeeCountResults[0].absentEmployees;

    // Send the total absent employee count as the API response
    res.json({ absentEmployees });
  } catch (error) {
    console.error('An error occurred:', error);
    res.status(500).json({ error: 'Internal Server Error' });
  } finally {
    if(connection){
      connection.release();
      //console.log("Connection released");
    }
  }
});

/**
 * @swagger
 * /ota_nbraid_total_day:
 *   get:
 *     summary: Fetch total number of active, direct workers in the NBRAID category assigned to the DAY shift
 *     description: Retrieves the total number of active, direct workers in the NBRAID category who are assigned to the DAY shift.
 *     tags:
 *       - OTA Employee Management
 *     security:
 *       - BearerAuth: []
 *     responses:
 *       200:
 *         description: Total number of active, direct workers in the NBRAID category assigned to the DAY shift fetched successfully.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 totalEmployees:
 *                   type: integer
 *                   example: 42
 *       404:
 *         description: No records found in the employees_ota table.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: No records found
 *       500:
 *         description: Error occurred while fetching total number of active, direct workers in the NBRAID category assigned to the DAY shift.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: Internal Server Error
 * @function
 * @name fetchOTANbraidTotalDay
 * @memberof module:Routes/OTAEmployeeManagement
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with executing the MySQL query.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
// API endpoint for ota_nbraid_total_day
app.get('/ota_nbraid_total_day', authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    // Get the latest date from the employees_ota table
    const latestDateQuery = 'SELECT * FROM employees_ota ORDER BY id ASC LIMIT 1';
    const latestDateResults = await executeQuery(connection,latestDateQuery);
    const latestDate = latestDateResults[0].date;

    // Query to count the total employees for the specified date and conditions (day shift, NBRAID category)
    const employeeCountQuery = `
      SELECT COUNT(*) AS totalEmployees
      FROM employees_ota
      WHERE passive_type = 'ACT'
        AND workertype = 'DIRECT'
        AND shift = 'DAY'
        AND category_type = 'NBRAID'
        AND date = ?
    `;

    // Execute the query with the latest date
    const employeeCountResults = await executeQuery(connection,employeeCountQuery, [latestDate]);
    const totalEmployees = employeeCountResults[0].totalEmployees;

    // Send the total employee count as the API response
    res.json({ totalEmployees });
  } catch (error) {
    console.error('An error occurred:', error);
    res.status(500).json({ error: 'Internal Server Error' });
  } finally {
    if(connection){
      connection.release();
      //console.log("Connection released");
    }
  }
});


/**
 * @swagger
 * /ota_nbraid_total_present_day:
 *   get:
 *     summary: Fetch total number of present active, direct workers in the NBRAID category assigned to the DAY shift
 *     description: Retrieves the total number of present active, direct workers in the NBRAID category who are assigned to the DAY shift.
 *     tags:
 *       - OTA Employee Management
 *     security:
 *       - BearerAuth: []
 *     responses:
 *       200:
 *         description: Total number of present active, direct workers in the NBRAID category assigned to the DAY shift fetched successfully.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 presentEmployees:
 *                   type: integer
 *                   example: 25
 *       404:
 *         description: No records found in the employees_ota table.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: No records found
 *       500:
 *         description: Error occurred while fetching total number of present active, direct workers in the NBRAID category assigned to the DAY shift.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: Internal Server Error
 * @function
 * @name fetchOTANbraidTotalPresentDay
 * @memberof module:Routes/OTAEmployeeManagement
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with executing the MySQL query.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
// API endpoint for ota_nbraid_total_present_day
app.get('/ota_nbraid_total_present_day', authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    // Get the latest date from the employees_ota table
    const latestDateQuery = 'SELECT * FROM employees_ota ORDER BY id ASC LIMIT 1';
    const latestDateResults = await executeQuery(connection,latestDateQuery);
    const latestDate = latestDateResults[0].date;

    // Query to count the total present employees for the specified date and conditions (day shift, NBRAID category, status: P)
    const presentEmployeeCountQuery = `
      SELECT COUNT(*) AS presentEmployees
      FROM employees_ota
      WHERE passive_type = 'ACT'
        AND workertype = 'DIRECT'
        AND category_type = 'NBRAID'
        AND status = 'P'
        AND shift = 'DAY'
        AND date = ?
    `;

    // Execute the query with the latest date
    const presentEmployeeCountResults = await executeQuery(connection,presentEmployeeCountQuery, [latestDate]);
    const presentEmployees = presentEmployeeCountResults[0].presentEmployees;

    // Send the total present employee count as the API response
    res.json({ presentEmployees });
  } catch (error) {
    console.error('An error occurred:', error);
    res.status(500).json({ error: 'Internal Server Error' });
  } finally {
    if(connection){
      connection.release();
      //console.log("Connection released");
    }
  }
});

/**
 * @swagger
 * /ota_nbraid_total_absent_day:
 *   get:
 *     summary: Fetch total number of absent active, direct workers in the NBRAID category assigned to the DAY shift
 *     description: Retrieves the total number of absent active, direct workers in the NBRAID category who are assigned to the DAY shift.
 *     tags:
 *       - OTA Employee Management
 *     security:
 *       - BearerAuth: []
 *     responses:
 *       200:
 *         description: Total number of absent active, direct workers in the NBRAID category assigned to the DAY shift fetched successfully.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 absentEmployees:
 *                   type: integer
 *                   example: 10
 *       404:
 *         description: No records found in the employees_ota table.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: No records found
 *       500:
 *         description: Error occurred while fetching total number of absent active, direct workers in the NBRAID category assigned to the DAY shift.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: Internal Server Error
 * @function
 * @name fetchOTANbraidTotalAbsentDay
 * @memberof module:Routes/OTAEmployeeManagement
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with executing the MySQL query.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
// API endpoint for ota_nbraid_total_absent_day
app.get('/ota_nbraid_total_absent_day', authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    // Get the latest date from the employees_ota table
    const latestDateQuery = 'SELECT * FROM employees_ota ORDER BY id ASC LIMIT 1';
    const latestDateResults = await executeQuery(connection,latestDateQuery);
    const latestDate = latestDateResults[0].date;

    // Query to count the total absent employees for the specified date and conditions (day shift, NBRAID category, status: A)
    const absentEmployeeCountQuery = `
      SELECT COUNT(*) AS absentEmployees
      FROM employees_ota
      WHERE passive_type = 'ACT'
        AND workertype = 'DIRECT'
        AND category_type = 'NBRAID'
        AND status = 'A'
        AND shift = 'DAY'
        AND date = ?
    `;

    // Execute the query with the latest date
    const absentEmployeeCountResults = await executeQuery(connection,absentEmployeeCountQuery, [latestDate]);
    const absentEmployees = absentEmployeeCountResults[0].absentEmployees;

    // Send the total absent employee count as the API response
    res.json({ absentEmployees });
  } catch (error) {
    console.error('An error occurred:', error);
    res.status(500).json({ error: 'Internal Server Error' });
  } finally {
    if(connection){
      connection.release();
      //console.log("Connection released");
    }
  }
});


// API endpoint for ota_nbraid_total_night

/**
 * @swagger
 * /ota_nbraid_total_night:
 *   get:
 *     summary: Fetch total number of active, direct workers in the NBRAID category assigned to the NIGHT shift
 *     description: Retrieves the total number of active, direct workers in the NBRAID category who are assigned to the NIGHT shift.
 *     tags:
 *       - OTA Employee Management
 *     security:
 *       - BearerAuth: []
 *     responses:
 *       200:
 *         description: Total number of active, direct workers in the NBRAID category assigned to the NIGHT shift fetched successfully.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 totalEmployees:
 *                   type: integer
 *                   example: 15
 *       404:
 *         description: No records found in the employees_ota table.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: No records found
 *       500:
 *         description: Error occurred while fetching total number of active, direct workers in the NBRAID category assigned to the NIGHT shift.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: Internal Server Error
 * @function
 * @name fetchOTANbraidTotalNight
 * @memberof module:Routes/OTAEmployeeManagement
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with executing the MySQL query.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
app.get('/ota_nbraid_total_night', authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    // Get the latest date from the employees_ota table
    const latestDateQuery = 'SELECT * FROM employees_ota ORDER BY id ASC LIMIT 1';
    const latestDateResults = await executeQuery(connection,latestDateQuery);
    const latestDate = latestDateResults[0].date;

    // Query to count the total employees for the specified date and conditions (night shift, NBRAID category)
    const employeeCountQuery = `
      SELECT COUNT(*) AS totalEmployees
      FROM employees_ota
      WHERE passive_type = 'ACT'
        AND workertype = 'DIRECT'
        AND shift = 'NIGHT'
        AND category_type = 'NBRAID'
        AND date = ?
    `;

    // Execute the query with the latest date
    const employeeCountResults = await executeQuery(connection,employeeCountQuery, [latestDate]);
    const totalEmployees = employeeCountResults[0].totalEmployees;

    // Send the total employee count as the API response
    res.json({ totalEmployees });
  } catch (error) {
    console.error('An error occurred:', error);
    res.status(500).json({ error: 'Internal Server Error' });
  } finally {
    if(connection){
      connection.release();
      //console.log("Connection released");
    }
  }
});


/**
 * @swagger
 * /ota_nbraid_total_present_night:
 *   get:
 *     summary: Fetch total number of active, direct workers in the NBRAID category assigned to the NIGHT shift and marked present
 *     description: Retrieves the total number of active, direct workers in the NBRAID category who are assigned to the NIGHT shift and marked present.
 *     tags:
 *       - OTA Employee Management
 *     security:
 *       - BearerAuth: []
 *     responses:
 *       200:
 *         description: Total number of active, direct workers in the NBRAID category assigned to the NIGHT shift and marked present fetched successfully.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 presentEmployees:
 *                   type: integer
 *                   example: 10
 *       404:
 *         description: No records found in the employees_ota table.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: No records found
 *       500:
 *         description: Error occurred while fetching total number of active, direct workers in the NBRAID category assigned to the NIGHT shift and marked present.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: Internal Server Error
 * @function
 * @name fetchOTANbraidPresentNight
 * @memberof module:Routes/OTAEmployeeManagement
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with executing the MySQL query.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
// API endpoint for ota_nbraid_total_present_night
app.get('/ota_nbraid_total_present_night', authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    // Get the latest date from the employees_ota table
    const latestDateQuery = 'SELECT * FROM employees_ota ORDER BY id ASC LIMIT 1';
    const latestDateResults = await executeQuery(connection,latestDateQuery);
    const latestDate = latestDateResults[0].date;

    // Query to count the total present employees for the specified date and conditions (night shift, NBRAID category, status: P)
    const presentEmployeeCountQuery = `
      SELECT COUNT(*) AS presentEmployees
      FROM employees_ota
      WHERE passive_type = 'ACT'
        AND workertype = 'DIRECT'
        AND category_type = 'NBRAID'
        AND status = 'P'
        AND shift = 'NIGHT'
        AND date = ?
    `;

    // Execute the query with the latest date
    const presentEmployeeCountResults = await executeQuery(connection,presentEmployeeCountQuery, [latestDate]);
    const presentEmployees = presentEmployeeCountResults[0].presentEmployees;

    // Send the total present employee count as the API response
    res.json({ presentEmployees });
  } catch (error) {
    console.error('An error occurred:', error);
    res.status(500).json({ error: 'Internal Server Error' });
  } finally {
    if(connection){
      connection.release();
      //console.log("Connection released");
    }
  }
});


// API endpoint for ota_nbraid_total_absent_night
/**
 * @swagger
 * /ota_nbraid_total_absent_night:
 *   get:
 *     summary: Fetch total number of active, direct workers in the NBRAID category assigned to the NIGHT shift and marked absent
 *     description: Retrieves the total number of active, direct workers in the NBRAID category who are assigned to the NIGHT shift and marked absent.
 *     tags:
 *       - OTA Employee Management
 *     security:
 *       - BearerAuth: []
 *     responses:
 *       200:
 *         description: Total number of active, direct workers in the NBRAID category assigned to the NIGHT shift and marked absent fetched successfully.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 absentEmployees:
 *                   type: integer
 *                   example: 5
 *       404:
 *         description: No records found in the employees_ota table.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: No records found
 *       500:
 *         description: Error occurred while fetching total number of active, direct workers in the NBRAID category assigned to the NIGHT shift and marked absent.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: Internal Server Error
 * @function
 * @name fetchOTANbraidAbsentNight
 * @memberof module:Routes/OTAEmployeeManagement
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with executing the MySQL query.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
app.get('/ota_nbraid_total_absent_night', authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    // Get the latest date from the employees_ota table
    const latestDateQuery = 'SELECT * FROM employees_ota ORDER BY id ASC LIMIT 1';
    const latestDateResults = await executeQuery(connection,latestDateQuery);
    const latestDate = latestDateResults[0].date;

    // Query to count the total absent employees for the specified date and conditions (night shift, NBRAID category, status: A)
    const absentEmployeeCountQuery = `
      SELECT COUNT(*) AS absentEmployees
      FROM employees_ota
      WHERE passive_type = 'ACT'
        AND workertype = 'DIRECT'
        AND category_type = 'NBRAID'
        AND status = 'A'
        AND shift = 'NIGHT'
        AND date = ?
    `;

    // Execute the query with the latest date
    const absentEmployeeCountResults = await executeQuery(connection,absentEmployeeCountQuery, [latestDate]);
    const absentEmployees = absentEmployeeCountResults[0].absentEmployees;

    // Send the total absent employee count as the API response
    res.json({ absentEmployees });
  } catch (error) {
    console.error('An error occurred:', error);
    res.status(500).json({ error: 'Internal Server Error' });
  } finally {
    if(connection){
      connection.release();
      //console.log("Connection released");
    }
  }
});


  // API endpoint for ikeja_braid_total_day
  /**
 * @swagger
 * /ikeja_braid_total_day:
 *   get:
 *     summary: Fetch total number of active, direct workers in the BRAID category assigned to the DAY shift in Ikeja
 *     description: Retrieves the total number of active, direct workers in the BRAID category who are assigned to the DAY shift in Ikeja.
 *     tags:
 *       - Ikeja Employee Management
 *     security:
 *       - BearerAuth: []
 *     responses:
 *       200:
 *         description: Total number of active, direct workers in the BRAID category assigned to the DAY shift in Ikeja fetched successfully.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 totalEmployees:
 *                   type: integer
 *                   example: 10
 *       404:
 *         description: No records found in the geopos_employees table.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: No records found
 *       500:
 *         description: Error occurred while fetching total number of active, direct workers in the BRAID category assigned to the DAY shift in Ikeja.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: Internal Server Error
 * @function
 * @name fetchIkejaBraidTotalDay
 * @memberof module:Routes/IkejaEmployeeManagement
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with executing the MySQL query.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
  app.get('/ikeja_braid_total_day', authenticateJWT, async (req, res) => {
    let connection;
    try {
      connection = await getPoolConnection();
      // Get the latest date from the geopos_employees table
      const latestDateQuery = 'SELECT * FROM geopos_employees ORDER BY id ASC LIMIT 1';
      const latestDateResults = await executeQuery(connection,latestDateQuery);
      const latestDate = latestDateResults[0].date;
  
      // Query to count the total employees for the specified date and conditions
      const employeeCountQuery = `
        SELECT COUNT(*) AS totalEmployees
        FROM geopos_employees
        WHERE passive_type = 'ACT'
          AND workertype = 'DIRECT'
          AND shift = 'DAY'
          AND category_type = 'BRAID'
          AND date = ?
      `;
  
      // Execute the query with the latest date
      const employeeCountResults = await executeQuery(connection,employeeCountQuery, [latestDate]);
      const totalEmployees = employeeCountResults[0].totalEmployees;
  
      // Send the total employee count as the API response
      res.json({ totalEmployees });
    } catch (error) {
      console.error('An error occurred:', error);
      res.status(500).json({ error: 'Internal Server Error' });
    } finally {
      if(connection){
        connection.release();
        //console.log("Connection released");
      }
    }
  });
  
  
  // API endpoint for ikeja_braid_total_present_day
  /**
 * @swagger
 * /ikeja_braid_total_present_day:
 *   get:
 *     summary: Fetch total number of active, direct workers in the BRAID category assigned to the DAY shift in Ikeja who are present
 *     description: Retrieves the total number of active, direct workers in the BRAID category who are assigned to the DAY shift in Ikeja and are present.
 *     tags:
 *       - Ikeja Employee Management
 *     security:
 *       - BearerAuth: []
 *     responses:
 *       200:
 *         description: Total number of active, direct workers in the BRAID category assigned to the DAY shift in Ikeja who are present fetched successfully.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 presentEmployees:
 *                   type: integer
 *                   example: 8
 *       404:
 *         description: No records found in the geopos_employees table.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: No records found
 *       500:
 *         description: Error occurred while fetching total number of active, direct workers in the BRAID category assigned to the DAY shift in Ikeja who are present.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: Internal Server Error
 * @function
 * @name fetchIkejaBraidTotalPresentDay
 * @memberof module:Routes/IkejaEmployeeManagement
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with executing the MySQL query.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
  app.get('/ikeja_braid_total_present_day', authenticateJWT, async (req, res) => {
    let connection;
    try {
      connection = await getPoolConnection();
      // Get the latest date from the geopos_employees table
      const latestDateQuery = 'SELECT * FROM geopos_employees ORDER BY id ASC LIMIT 1';
      const latestDateResults = await executeQuery(connection,latestDateQuery);
      const latestDate = latestDateResults[0].date;
  
      // Query to count the total present employees for the specified date and conditions
      const presentEmployeeCountQuery = `
        SELECT COUNT(*) AS presentEmployees
        FROM geopos_employees
        WHERE passive_type = 'ACT'
          AND workertype = 'DIRECT'
          AND category_type = 'BRAID'
          AND status = 'P'
          AND shift = 'DAY'
          AND date = ?
      `;
  
      // Execute the query with the latest date
      const presentEmployeeCountResults = await executeQuery(connection,presentEmployeeCountQuery, [latestDate]);
      const presentEmployees = presentEmployeeCountResults[0].presentEmployees;
  
      // Send the total present employee count as the API response
      res.json({ presentEmployees });
    } catch (error) {
      console.error('An error occurred:', error);
      res.status(500).json({ error: 'Internal Server Error' });
    } finally {
      if(connection){
        connection.release();
        //console.log("Connection released");
      }
    }
  });
  
/**
 * @swagger
 * /ikeja_braid_total_absent_day:
 *   get:
 *     summary: Fetch total number of active, direct workers in the BRAID category assigned to the DAY shift in Ikeja who are absent
 *     description: Retrieves the total number of active, direct workers in the BRAID category who are assigned to the DAY shift in Ikeja and are absent.
 *     tags:
 *       - Ikeja Employee Management
 *     security:
 *       - BearerAuth: []
 *     responses:
 *       200:
 *         description: Total number of active, direct workers in the BRAID category assigned to the DAY shift in Ikeja who are absent fetched successfully.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 absentEmployees:
 *                   type: integer
 *                   example: 2
 *       404:
 *         description: No records found in the geopos_employees table.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: No records found
 *       500:
 *         description: Error occurred while fetching total number of active, direct workers in the BRAID category assigned to the DAY shift in Ikeja who are absent.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: Internal Server Error
 * @function
 * @name fetchIkejaBraidTotalAbsentDay
 * @memberof module:Routes/IkejaEmployeeManagement
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with executing the MySQL query.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
  // API endpoint for ikeja_braid_total_absent_day
  app.get('/ikeja_braid_total_absent_day', authenticateJWT, async (req, res) => {
    let connection;
    try {
      connection = await getPoolConnection();
      // Get the latest date from the geopos_employees table
      const latestDateQuery = 'SELECT * FROM geopos_employees ORDER BY id ASC LIMIT 1';
      const latestDateResults = await executeQuery(connection,latestDateQuery);
      const latestDate = latestDateResults[0].date;
  
      // Query to count the total absent employees for the specified date and conditions
      const absentEmployeeCountQuery = `
        SELECT COUNT(*) AS absentEmployees
        FROM geopos_employees
        WHERE passive_type = 'ACT'
          AND workertype = 'DIRECT'
          AND category_type = 'BRAID'
          AND status = 'A'
          AND shift = 'DAY'
          AND date = ?
      `;
  
      // Execute the query with the latest date
      const absentEmployeeCountResults = await executeQuery(connection,absentEmployeeCountQuery, [latestDate]);
      const absentEmployees = absentEmployeeCountResults[0].absentEmployees;
  
      // Send the total absent employee count as the API response
      res.json({ absentEmployees });
    } catch (error) {
      console.error('An error occurred:', error);
      res.status(500).json({ error: 'Internal Server Error' });
    } finally {
      if(connection){
        connection.release();
        //console.log("Connection released");
      }
    }
  });
  
  /**
 * @swagger
 * /ikeja_braid_total_night:
 *   get:
 *     summary: Fetch total number of active, direct workers in the BRAID category assigned to the NIGHT shift in Ikeja
 *     description: Retrieves the total number of active, direct workers in the BRAID category who are assigned to the NIGHT shift in Ikeja.
 *     tags:
 *       - Ikeja Employee Management
 *     security:
 *       - BearerAuth: []
 *     responses:
 *       200:
 *         description: Total number of active, direct workers in the BRAID category assigned to the NIGHT shift in Ikeja fetched successfully.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 totalEmployees:
 *                   type: integer
 *                   example: 5
 *       404:
 *         description: No records found in the geopos_employees table.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: No records found
 *       500:
 *         description: Error occurred while fetching total number of active, direct workers in the BRAID category assigned to the NIGHT shift in Ikeja.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: Internal Server Error
 * @function
 * @name fetchIkejaBraidTotalNight
 * @memberof module:Routes/IkejaEmployeeManagement
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with executing the MySQL query.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
  // API endpoint for ikeja_braid_total_night
  app.get('/ikeja_braid_total_night', authenticateJWT, async (req, res) => {
    let connection;
    try {
      connection = await getPoolConnection();
      // Get the latest date from the geopos_employees table
      const latestDateQuery = 'SELECT * FROM geopos_employees ORDER BY id ASC LIMIT 1';
      const latestDateResults = await executeQuery(connection,latestDateQuery);
      const latestDate = latestDateResults[0].date;
  
      // Query to count the total employees for the specified date and conditions (night shift)
      const employeeCountQuery = `
        SELECT COUNT(*) AS totalEmployees
        FROM geopos_employees
        WHERE passive_type = 'ACT'
          AND workertype = 'DIRECT'
          AND shift = 'NIGHT'
          AND category_type = 'BRAID'
          AND date = ?
      `;
  
      // Execute the query with the latest date
      const employeeCountResults = await executeQuery(connection,employeeCountQuery, [latestDate]);
      const totalEmployees = employeeCountResults[0].totalEmployees;
  
      // Send the total employee count as the API response
      res.json({ totalEmployees });
    } catch (error) {
      console.error('An error occurred:', error);
      res.status(500).json({ error: 'Internal Server Error' });
    } finally {
      if(connection){
        connection.release();
        //console.log("Connection released");
      }
    }
  });
  
  /**
 * @swagger
 * /ikeja_braid_total_present_night:
 *   get:
 *     summary: Fetch total number of active, direct workers in the BRAID category assigned to the NIGHT shift in Ikeja
 *     description: Retrieves the total number of active, direct workers in the BRAID category who are assigned to the NIGHT shift in Ikeja and are marked as present.
 *     tags:
 *       - Ikeja Employee Management
 *     security:
 *       - BearerAuth: []
 *     responses:
 *       200:
 *         description: Total number of active, direct workers in the BRAID category assigned to the NIGHT shift in Ikeja and marked as present fetched successfully.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 presentEmployees:
 *                   type: integer
 *                   example: 5
 *       404:
 *         description: No records found in the geopos_employees table.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: No records found
 *       500:
 *         description: Error occurred while fetching total number of active, direct workers in the BRAID category assigned to the NIGHT shift in Ikeja and marked as present.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: Internal Server Error
 * @function
 * @name fetchIkejaBraidTotalPresentNight
 * @memberof module:Routes/IkejaEmployeeManagement
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with executing the MySQL query.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
  // API endpoint for ikeja_braid_total_present_night
  app.get('/ikeja_braid_total_present_night', authenticateJWT, async (req, res) => {
    let connection;
    try {
      connection = await getPoolConnection();
      // Get the latest date from the geopos_employees table
      const latestDateQuery = 'SELECT * FROM geopos_employees ORDER BY id ASC LIMIT 1';
      const latestDateResults = await executeQuery(connection,latestDateQuery);
      const latestDate = latestDateResults[0].date;
  
      // Query to count the total present employees for the specified date and conditions (night shift, BRAID category, status: P)
      const presentEmployeeCountQuery = `
        SELECT COUNT(*) AS presentEmployees
        FROM geopos_employees
        WHERE passive_type = 'ACT'
          AND workertype = 'DIRECT'
          AND category_type = 'BRAID'
          AND status = 'P'
          AND shift = 'NIGHT'
          AND date = ?
      `;
  
      // Execute the query with the latest date
      const presentEmployeeCountResults = await executeQuery(connection,presentEmployeeCountQuery, [latestDate]);
      const presentEmployees = presentEmployeeCountResults[0].presentEmployees;
  
      // Send the total present employee count as the API response
      res.json({ presentEmployees });
    } catch (error) {
      console.error('An error occurred:', error);
      res.status(500).json({ error: 'Internal Server Error' });
    } finally {
      if(connection){
        connection.release();
        //console.log("Connection released");
      }
    }
  });
  
  
  /**
 * @swagger
 * /ikeja_braid_total_absent_night:
 *   get:
 *     summary: Fetch total number of active, direct workers in the BRAID category assigned to the NIGHT shift in Ikeja and marked as absent
 *     description: Retrieves the total number of active, direct workers in the BRAID category who are assigned to the NIGHT shift in Ikeja and are marked as absent.
 *     tags:
 *       - Ikeja Employee Management
 *     security:
 *       - BearerAuth: []
 *     responses:
 *       200:
 *         description: Total number of active, direct workers in the BRAID category assigned to the NIGHT shift in Ikeja and marked as absent fetched successfully.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 absentEmployees:
 *                   type: integer
 *                   example: 3
 *       404:
 *         description: No records found in the geopos_employees table.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: No records found
 *       500:
 *         description: Error occurred while fetching total number of active, direct workers in the BRAID category assigned to the NIGHT shift in Ikeja and marked as absent.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: Internal Server Error
 * @function
 * @name fetchIkejaBraidTotalAbsentNight
 * @memberof module:Routes/IkejaEmployeeManagement
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with executing the MySQL query.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
  // API endpoint for ikeja_braid_total_absent_night
  app.get('/ikeja_braid_total_absent_night', authenticateJWT, async (req, res) => {
    let connection;
    try {
      connection = await getPoolConnection();
      // Get the latest date from the geopos_employees table
      const latestDateQuery = 'SELECT * FROM geopos_employees ORDER BY id ASC LIMIT 1';
      const latestDateResults = await executeQuery(connection,latestDateQuery);
      const latestDate = latestDateResults[0].date;
  
      // Query to count the total absent employees for the specified date and conditions (night shift, BRAID category, status: A)
      const absentEmployeeCountQuery = `
        SELECT COUNT(*) AS absentEmployees
        FROM geopos_employees
        WHERE passive_type = 'ACT'
          AND workertype = 'DIRECT'
          AND category_type = 'BRAID'
          AND status = 'A'
          AND shift = 'NIGHT'
          AND date = ?
      `;
  
      // Execute the query with the latest date
      const absentEmployeeCountResults = await executeQuery(connection,absentEmployeeCountQuery, [latestDate]);
      const absentEmployees = absentEmployeeCountResults[0].absentEmployees;
  
      // Send the total absent employee count as the API response
      res.json({ absentEmployees });
    } catch (error) {
      console.error('An error occurred:', error);
      res.status(500).json({ error: 'Internal Server Error' });
    } finally {
      if(connection){
        connection.release();
        //console.log("Connection released");
      }
    }
  });
  
  /**
 * @swagger
 * /ikeja_nbraid_total_day:
 *   get:
 *     summary: Fetch total number of active, direct workers in the NBRAID category assigned to the DAY shift in Ikeja
 *     description: Retrieves the total number of active, direct workers in the NBRAID category who are assigned to the DAY shift in Ikeja.
 *     tags:
 *       - Ikeja Employee Management
 *     security:
 *       - BearerAuth: []
 *     responses:
 *       200:
 *         description: Total number of active, direct workers in the NBRAID category assigned to the DAY shift in Ikeja fetched successfully.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 totalEmployees:
 *                   type: integer
 *                   example: 10
 *       404:
 *         description: No records found in the geopos_employees table.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: No records found
 *       500:
 *         description: Error occurred while fetching total number of active, direct workers in the NBRAID category assigned to the DAY shift in Ikeja.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: Internal Server Error
 * @function
 * @name fetchIkejaNbraidTotalDay
 * @memberof module:Routes/IkejaEmployeeManagement
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with executing the MySQL query.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
  // API endpoint for ikeja_nbraid_total_day
  app.get('/ikeja_nbraid_total_day', authenticateJWT, async (req, res) => {
    let connection;
    try {
      connection = await getPoolConnection();
      // Get the latest date from the geopos_employees table
      const latestDateQuery = 'SELECT * FROM geopos_employees ORDER BY id ASC LIMIT 1';
      const latestDateResults = await executeQuery(connection,latestDateQuery);
      const latestDate = latestDateResults[0].date;
  
      // Query to count the total employees for the specified date and conditions (day shift, NBRAID category)
      const employeeCountQuery = `
        SELECT COUNT(*) AS totalEmployees
        FROM geopos_employees
        WHERE passive_type = 'ACT'
          AND workertype = 'DIRECT'
          AND shift = 'DAY'
          AND category_type = 'NBRAID'
          AND date = ?
      `;
  
      // Execute the query with the latest date
      const employeeCountResults = await executeQuery(connection,employeeCountQuery, [latestDate]);
      const totalEmployees = employeeCountResults[0].totalEmployees;
  
      // Send the total employee count as the API response
      res.json({ totalEmployees });
    } catch (error) {
      console.error('An error occurred:', error);
      res.status(500).json({ error: 'Internal Server Error' });
    } finally {
      if(connection){
        connection.release();
        //console.log("Connection released");
      }
    }
  });
  
  /**
 * @swagger
 * /ikeja_nbraid_total_present_day:
 *   get:
 *     summary: Fetch total number of active, direct workers in the NBRAID category assigned to the DAY shift in Ikeja
 *     description: Retrieves the total number of active, direct workers in the NBRAID category who are assigned to the DAY shift in Ikeja and are present.
 *     tags:
 *       - Ikeja Employee Management
 *     security:
 *       - BearerAuth: []
 *     responses:
 *       200:
 *         description: Total number of active, direct workers in the NBRAID category assigned to the DAY shift in Ikeja and present fetched successfully.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 presentEmployees:
 *                   type: integer
 *                   example: 8
 *       404:
 *         description: No records found in the geopos_employees table.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: No records found
 *       500:
 *         description: Error occurred while fetching total number of active, direct workers in the NBRAID category assigned to the DAY shift in Ikeja and present.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: Internal Server Error
 * @function
 * @name fetchIkejaNbraidTotalPresentDay
 * @memberof module:Routes/IkejaEmployeeManagement
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with executing the MySQL query.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
  // API endpoint for ikeja_nbraid_total_present_day
  app.get('/ikeja_nbraid_total_present_day', authenticateJWT, async (req, res) => {
    let connection;
    try {
      connection = await getPoolConnection();
      // Get the latest date from the geopos_employees table
      const latestDateQuery = 'SELECT * FROM geopos_employees ORDER BY id ASC LIMIT 1';
      const latestDateResults = await executeQuery(connection,latestDateQuery);
  
      const latestDate = latestDateResults[0].date;
  
      // Query to count the total present employees for the specified date and conditions (day shift, NBRAID category, status: P)
      const presentEmployeeCountQuery = `
        SELECT COUNT(*) AS presentEmployees
        FROM geopos_employees
        WHERE passive_type = 'ACT'
          AND workertype = 'DIRECT'
          AND category_type = 'NBRAID'
          AND status = 'P'
          AND shift = 'DAY'
          AND date = ?
      `;
  
      // Execute the query with the latest date
      const presentEmployeeCountResults = await executeQuery(connection,presentEmployeeCountQuery, [latestDate]);
  
      const presentEmployees = presentEmployeeCountResults[0].presentEmployees;
  
      // Send the total present employee count as the API response
      res.json({ presentEmployees });
    } catch (error) {
      console.error(error);
      res.status(500).json({ error: 'Internal Server Error' });
    } finally {
      if(connection){
        connection.release();
        //console.log("Connection released");
      }
    }
  });
  
  /**
 * @swagger
 * /ikeja_nbraid_total_absent_day:
 *   get:
 *     summary: Fetch total number of active, direct workers in the NBRAID category assigned to the DAY shift in Ikeja who are absent
 *     description: Retrieves the total number of active, direct workers in the NBRAID category who are assigned to the DAY shift in Ikeja and are absent.
 *     tags:
 *       - Ikeja Employee Management
 *     security:
 *       - BearerAuth: []
 *     responses:
 *       200:
 *         description: Total number of active, direct workers in the NBRAID category assigned to the DAY shift in Ikeja and absent fetched successfully.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 absentEmployees:
 *                   type: integer
 *                   example: 2
 *       404:
 *         description: No records found in the geopos_employees table.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: No records found
 *       500:
 *         description: Error occurred while fetching total number of active, direct workers in the NBRAID category assigned to the DAY shift in Ikeja and absent.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: Internal Server Error
 * @function
 * @name fetchIkejaNbraidTotalAbsentDay
 * @memberof module:Routes/IkejaEmployeeManagement
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with executing the MySQL query.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
  // API endpoint for ikeja_nbraid_total_absent_day
  app.get('/ikeja_nbraid_total_absent_day', authenticateJWT, async (req, res) => {
    let connection;
    try {
      connection = await getPoolConnection();
      // Get the latest date from the geopos_employees table
      const latestDateQuery = 'SELECT * FROM geopos_employees ORDER BY id ASC LIMIT 1';
      const latestDateResults = await executeQuery(connection,latestDateQuery);
  
      const latestDate = latestDateResults[0].date;
  
      // Query to count the total absent employees for the specified date and conditions (day shift, NBRAID category, status: A)
      const absentEmployeeCountQuery = `
        SELECT COUNT(*) AS absentEmployees
        FROM geopos_employees
        WHERE passive_type = 'ACT'
          AND workertype = 'DIRECT'
          AND category_type = 'NBRAID'
          AND status = 'A'
          AND shift = 'DAY'
          AND date = ?
      `;
  
      // Execute the query with the latest date
      const absentEmployeeCountResults = await executeQuery(connection,absentEmployeeCountQuery, [latestDate]);
  
      const absentEmployees = absentEmployeeCountResults[0].absentEmployees;
  
      // Send the total absent employee count as the API response
      res.json({ absentEmployees });
    } catch (error) {
      console.error(error);
      res.status(500).json({ error: 'Internal Server Error' });
    } finally {
      if(connection){
        connection.release();
        //console.log("Connection released");
      }
    }
  });
  

  /**
 * @swagger
 * /ikeja_nbraid_total_night:
 *   get:
 *     summary: Fetch total number of active, direct workers in the NBRAID category assigned to the NIGHT shift in Ikeja
 *     description: Retrieves the total number of active, direct workers in the NBRAID category who are assigned to the NIGHT shift in Ikeja.
 *     tags:
 *       - Ikeja Employee Management
 *     security:
 *       - BearerAuth: []
 *     responses:
 *       200:
 *         description: Total number of active, direct workers in the NBRAID category assigned to the NIGHT shift in Ikeja fetched successfully.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 totalEmployees:
 *                   type: integer
 *                   example: 50
 *       404:
 *         description: No records found in the geopos_employees table.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: No records found
 *       500:
 *         description: Error occurred while fetching total number of active, direct workers in the NBRAID category assigned to the NIGHT shift in Ikeja.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: Internal Server Error
 * @function
 * @name fetchIkejaNbraidTotalNight
 * @memberof module:Routes/IkejaEmployeeManagement
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with executing the MySQL query.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
  // API endpoint for ikeja_nbraid_total_night
  app.get('/ikeja_nbraid_total_night', authenticateJWT, async (req, res) => {
    let connection;
    try {
      connection = await getPoolConnection();
      // Get the latest date from the geopos_employees table
      const latestDateQuery = 'SELECT * FROM geopos_employees ORDER BY id ASC LIMIT 1';
      const latestDateResults = await executeQuery(connection,latestDateQuery);
  
      const latestDate = latestDateResults[0].date;
  
      // Query to count the total employees for the specified date and conditions (night shift, NBRAID category)
      const employeeCountQuery = `
        SELECT COUNT(*) AS totalEmployees
        FROM geopos_employees
        WHERE passive_type = 'ACT'
          AND workertype = 'DIRECT'
          AND shift = 'NIGHT'
          AND category_type = 'NBRAID'
          AND date = ?
      `;
  
      // Execute the query with the latest date
      const employeeCountResults = await executeQuery(connection,employeeCountQuery, [latestDate]);
  
      const totalEmployees = employeeCountResults[0].totalEmployees;
  
      // Send the total employee count as the API response
      res.json({ totalEmployees });
    } catch (error) {
      console.error(error);
      res.status(500).json({ error: 'Internal Server Error' });
    } finally {
      if(connection){
        connection.release();
        //console.log("Connection released");
      }
    }
  });
  

  /**
 * @swagger
 * /ikeja_nbraid_total_present_night:
 *   get:
 *     summary: Fetch total number of present active, direct workers in the NBRAID category assigned to the NIGHT shift in Ikeja
 *     description: Retrieves the total number of present active, direct workers in the NBRAID category who are assigned to the NIGHT shift in Ikeja.
 *     tags:
 *       - Ikeja Employee Management
 *     security:
 *       - BearerAuth: []
 *     responses:
 *       200:
 *         description: Total number of present active, direct workers in the NBRAID category assigned to the NIGHT shift in Ikeja fetched successfully.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 presentEmployees:
 *                   type: integer
 *                   example: 50
 *       404:
 *         description: No records found in the geopos_employees table.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: No records found
 *       500:
 *         description: Error occurred while fetching total number of present active, direct workers in the NBRAID category assigned to the NIGHT shift in Ikeja.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: Internal Server Error
 * @function
 * @name fetchIkejaNbraidTotalPresentNight
 * @memberof module:Routes/IkejaEmployeeManagement
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with executing the MySQL query.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
  // API endpoint for ikeja_nbraid_total_present_night
  app.get('/ikeja_nbraid_total_present_night', authenticateJWT, async (req, res) => {
    let connection;
    try {
      connection = await getPoolConnection();
      // Get the latest date from the geopos_employees table
      const latestDateQuery = 'SELECT * FROM geopos_employees ORDER BY id ASC LIMIT 1';
      const latestDateResults = await executeQuery(connection,latestDateQuery);
  
      const latestDate = latestDateResults[0].date;
  
      // Query to count the total present employees for the specified date and conditions (night shift, NBRAID category, status: P)
      const presentEmployeeCountQuery = `
        SELECT COUNT(*) AS presentEmployees
        FROM geopos_employees
        WHERE passive_type = 'ACT'
          AND workertype = 'DIRECT'
          AND category_type = 'NBRAID'
          AND status = 'P'
          AND shift = 'NIGHT'
          AND date = ?
      `;
  
      // Execute the query with the latest date
      const presentEmployeeCountResults = await executeQuery(connection,presentEmployeeCountQuery, [latestDate]);
  
      const presentEmployees = presentEmployeeCountResults[0].presentEmployees;
  
      // Send the total present employee count as the API response
      res.json({ presentEmployees });
    } catch (error) {
      console.error(error);
      res.status(500).json({ error: 'Internal Server Error' });
    } finally {
      if(connection){
        connection.release();
        //console.log("Connection released");
      }
    }
  });
  


  /**
 * @swagger
 * /ikeja_nbraid_total_absent_night:
 *   get:
 *     summary: Fetch total number of absent active, direct workers in the NBRAID category assigned to the NIGHT shift in Ikeja
 *     description: Retrieves the total number of absent active, direct workers in the NBRAID category who are assigned to the NIGHT shift in Ikeja.
 *     tags:
 *       - Ikeja Employee Management
 *     security:
 *       - BearerAuth: []
 *     responses:
 *       200:
 *         description: Total number of absent active, direct workers in the NBRAID category assigned to the NIGHT shift in Ikeja fetched successfully.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 absentEmployees:
 *                   type: integer
 *                   example: 10
 *       404:
 *         description: No records found in the geopos_employees table.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: No records found
 *       500:
 *         description: Error occurred while fetching total number of absent active, direct workers in the NBRAID category assigned to the NIGHT shift in Ikeja.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: Internal Server Error
 * @function
 * @name fetchIkejaNbraidTotalAbsentNight
 * @memberof module:Routes/IkejaEmployeeManagement
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with executing the MySQL query.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
  // API endpoint for ikeja_nbraid_total_absent_night
  app.get('/ikeja_nbraid_total_absent_night', authenticateJWT, async (req, res) => {
    let connection;
    try {
      connection = await getPoolConnection();
      // Get the latest date from the geopos_employees table
      const latestDateQuery = 'SELECT * FROM geopos_employees ORDER BY id ASC LIMIT 1';
      const latestDateResults = await executeQuery(connection,latestDateQuery);
  
      const latestDate = latestDateResults[0].date;
  
      // Query to count the total absent employees for the specified date and conditions (night shift, NBRAID category, status: A)
      const absentEmployeeCountQuery = `
        SELECT COUNT(*) AS absentEmployees
        FROM geopos_employees
        WHERE passive_type = 'ACT'
          AND workertype = 'DIRECT'
          AND category_type = 'NBRAID'
          AND status = 'A'
          AND shift = 'NIGHT'
          AND date = ?
      `;
  
      // Execute the query with the latest date
      const absentEmployeeCountResults = await executeQuery(connection,absentEmployeeCountQuery, [latestDate]);
  
      const absentEmployees = absentEmployeeCountResults[0].absentEmployees;
  
      // Send the total absent employee count as the API response
      res.json({ absentEmployees });
    } catch (error) {
      console.error(error);
      res.status(500).json({ error: 'Internal Server Error' });
    } finally {
      if(connection){
        connection.release();
        //console.log("Connection released");
      }
    }
  });
  

/**
 * @swagger
 * /braid_daywise_active_employees_staff:
 *   get:
 *     summary: Fetch total count of active, direct, staff employees in the BRAID category from two tables.
 *     description: Retrieves the total count of active, direct, staff employees in the BRAID category from the geopos_employees and employees_ota tables.
 *     tags:
 *       - Employee Management
 *     security:
 *       - BearerAuth: []
 *     responses:
 *       200:
 *         description: Total count of active, direct, staff employees in the BRAID category fetched successfully.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 totalEmployeeCount:
 *                   type: integer
 *                   example: 100
 *       500:
 *         description: Error occurred while fetching the total count of active, direct, staff employees in the BRAID category.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: Internal Server Error
 * @function
 * @name fetchBraidDaywiseActiveEmployeesStaff
 * @memberof module:Routes/EmployeeManagement
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with executing the MySQL query.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
// API endpoint for braid_daywise_active_employees_staff
app.get('/braid_daywise_active_employees_staff', authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    // Use a parameterized query to avoid SQL injection
    const query1 = `
      SELECT COUNT(*) AS employee_count
      FROM geopos_employees
      WHERE passive_type = 'ACT'
        AND workertype = 'DIRECT'
        AND employee_type = 'Staff'
        AND category_type = 'BRAID'
    `;

    const query2 = `
      SELECT COUNT(*) AS employee_count
      FROM employees_ota
      WHERE passive_type = 'ACT'
        AND workertype = 'DIRECT'
        AND employee_type = 'Staff'
        AND category_type = 'BRAID'
    `;

    // Execute the queries using the connection pool
    const results1 = await executeQuery(connection,query1);
    const results2 = await executeQuery(connection,query2);

    // Extract the counts from the results
    const employeeCount1 = results1[0].employee_count;
    const employeeCount2 = results2[0].employee_count;

    // Calculate the total employee count and send it as the API response
    const totalEmployeeCount = employeeCount1 + employeeCount2;
    res.json({ totalEmployeeCount });
  } catch (error) {
    console.error(error);
    res.status(500).json({ error: 'Internal Server Error' });
  } finally {
    if(connection){
      connection.release();
      //console.log("Connection released");
    }
  }
});

/**
 * @swagger
 * /braid_daywise_active_employees_staff_present:
 *   get:
 *     summary: Fetch total count of active, direct, present staff employees in the BRAID category from two tables.
 *     description: Retrieves the total count of active, direct, present staff employees in the BRAID category from the geopos_employees and employees_ota tables.
 *     tags:
 *       - Employee Management
 *     security:
 *       - BearerAuth: []
 *     responses:
 *       200:
 *         description: Total count of active, direct, present staff employees in the BRAID category fetched successfully.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 totalEmployeeCount:
 *                   type: integer
 *                   example: 100
 *       500:
 *         description: Error occurred while fetching the total count of active, direct, present staff employees in the BRAID category.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: Internal Server Error
 * @function
 * @name fetchBraidDaywiseActiveEmployeesStaffPresent
 * @memberof module:Routes/EmployeeManagement
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with executing the MySQL query.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
// API endpoint for braid_daywise_active_employees_staff_present
app.get('/braid_daywise_active_employees_staff_present', authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    // Use a parameterized query to avoid SQL injection
    const query1 = `
      SELECT COUNT(*) AS employee_count
      FROM geopos_employees
      WHERE passive_type = 'ACT'
        AND workertype = 'DIRECT'
        AND status = 'P'
        AND employee_type = 'Staff'
        AND category_type = 'BRAID'
    `;

    const query2 = `
      SELECT COUNT(*) AS employee_count
      FROM employees_ota
      WHERE passive_type = 'ACT'
        AND workertype = 'DIRECT'
        AND status = 'P'
        AND employee_type = 'Staff'
        AND category_type = 'BRAID'
    `;

    // Execute the queries using the connection pool
    const results1 = await executeQuery(connection,query1);
    const results2 = await executeQuery(connection,query2);

    // Extract the counts from the results
    const employeeCount1 = results1[0].employee_count;
    const employeeCount2 = results2[0].employee_count;

    // Calculate the total employee count and send it as the API response
    const totalEmployeeCount = employeeCount1 + employeeCount2;
    res.json({ totalEmployeeCount });
  } catch (error) {
    console.error(error);
    res.status(500).json({ error: 'Internal Server Error' });
  } finally {
    if(connection){
      connection.release();
      //console.log("Connection released");
    }
  }
});



// API endpoint for braid_daywise_active_employees_staff_absent
/**
 * @swagger
 * /braid_daywise_active_employees_staff_absent:
 *   get:
 *     summary: Fetch total count of active, direct, absent staff employees in the BRAID category from two tables.
 *     description: Retrieves the total count of active, direct, absent staff employees in the BRAID category from the geopos_employees and employees_ota tables.
 *     tags:
 *       - Employee Management
 *     security:
 *       - BearerAuth: []
 *     responses:
 *       200:
 *         description: Total count of active, direct, absent staff employees in the BRAID category fetched successfully.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 totalEmployeeCount:
 *                   type: integer
 *                   example: 50
 *       500:
 *         description: Error occurred while fetching the total count of active, direct, absent staff employees in the BRAID category.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: Internal Server Error
 * @function
 * @name fetchBraidDaywiseActiveEmployeesStaffAbsent
 * @memberof module:Routes/EmployeeManagement
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with executing the MySQL query.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
app.get('/braid_daywise_active_employees_staff_absent', authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    // Use a parameterized query to avoid SQL injection
    const query1 = `
      SELECT COUNT(*) AS employee_count
      FROM geopos_employees
      WHERE passive_type = 'ACT'
        AND workertype = 'DIRECT'
        AND status = 'A'
        AND employee_type = 'Staff'
        AND category_type = 'BRAID'
    `;

    const query2 = `
      SELECT COUNT(*) AS employee_count
      FROM employees_ota
      WHERE passive_type = 'ACT'
        AND workertype = 'DIRECT'
        AND status = 'A'
        AND employee_type = 'Staff'
        AND category_type = 'BRAID'
    `;

    // Execute the queries using the connection pool
    const results1 = await executeQuery(connection,query1);
    const results2 = await executeQuery(connection,query2);

    // Extract the counts from the results
    const employeeCount1 = results1[0].employee_count;
    const employeeCount2 = results2[0].employee_count;

    // Calculate the total employee count and send it as the API response
    const totalEmployeeCount = employeeCount1 + employeeCount2;
    res.json({ totalEmployeeCount });
  } catch (error) {
    console.error(error);
    res.status(500).json({ error: 'Internal Server Error' });
  } finally {
    if(connection){
      connection.release();
      //console.log("Connection released");
    }
  }
});


// API endpoint for braid_daywise_active_employees_contract
/**
 * @swagger
 * /braid_daywise_active_employees_contract:
 *   get:
 *     summary: Fetch total count of active, direct, contract employees in the BRAID category from two tables.
 *     description: Retrieves the total count of active, direct, contract employees in the BRAID category from the geopos_employees and employees_ota tables.
 *     tags:
 *       - Employee Management
 *     security:
 *       - BearerAuth: []
 *     responses:
 *       200:
 *         description: Total count of active, direct, contract employees in the BRAID category fetched successfully.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 totalEmployeeCount:
 *                   type: integer
 *                   example: 50
 *       500:
 *         description: Error occurred while fetching the total count of active, direct, contract employees in the BRAID category.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: Internal Server Error
 * @function
 * @name fetchBraidDaywiseActiveEmployeesContract
 * @memberof module:Routes/EmployeeManagement
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with executing the MySQL query.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
app.get('/braid_daywise_active_employees_contract', authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    const query1 = `
      SELECT COUNT(*) AS employee_count
      FROM geopos_employees
      WHERE passive_type = 'ACT'
        AND workertype = 'DIRECT'
        AND employee_type = 'Contract'
        AND category_type = 'BRAID'
    `;

    const query2 = `
      SELECT COUNT(*) AS employee_count
      FROM employees_ota
      WHERE passive_type = 'ACT'
        AND workertype = 'DIRECT'
        AND employee_type = 'Contract'
        AND category_type = 'BRAID'
    `;

    const results1 = await executeQuery(connection,query1);
    const results2 = await executeQuery(connection,query2);

    const employeeCount1 = results1[0].employee_count;
    const employeeCount2 = results2[0].employee_count;
    const totalEmployeeCount = employeeCount1 + employeeCount2;

    res.json({ totalEmployeeCount });
  } catch (error) {
    console.error(error);
    res.status(500).json({ error: 'Internal Server Error' });
  } finally {
    if(connection){
      connection.release();
      //console.log("Connection released");
    }
  }
});


// API endpoint for braid_daywise_active_employees_contract_present
/**
 * @swagger
 * /braid_daywise_active_employees_contract_present:
 *   get:
 *     summary: Fetch total count of active, direct, present contract employees in the BRAID category from two tables.
 *     description: Retrieves the total count of active, direct, present contract employees in the BRAID category from the geopos_employees and employees_ota tables.
 *     tags:
 *       - Employee Management
 *     security:
 *       - BearerAuth: []
 *     responses:
 *       200:
 *         description: Total count of active, direct, present contract employees in the BRAID category fetched successfully.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 totalEmployeeCount:
 *                   type: integer
 *                   example: 50
 *       500:
 *         description: Error occurred while fetching the total count of active, direct, present contract employees in the BRAID category.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: Internal Server Error
 * @function
 * @name fetchBraidDaywiseActiveEmployeesContractPresent
 * @memberof module:Routes/EmployeeManagement
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with executing the MySQL query.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
app.get('/braid_daywise_active_employees_contract_present', authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    const query1 = `
      SELECT COUNT(*) AS employee_count
      FROM geopos_employees
      WHERE passive_type = 'ACT'
        AND workertype = 'DIRECT'
        AND status = 'P'
        AND employee_type = 'Contract'
        AND category_type = 'BRAID'
    `;

    const query2 = `
      SELECT COUNT(*) AS employee_count
      FROM employees_ota
      WHERE passive_type = 'ACT'
        AND workertype = 'DIRECT'
        AND status = 'P'
        AND employee_type = 'Contract'
        AND category_type = 'BRAID'
    `;

    const results1 = await executeQuery(connection,query1);
    const results2 = await executeQuery(connection,query2);

    const employeeCount1 = results1[0].employee_count;
    const employeeCount2 = results2[0].employee_count;
    const totalEmployeeCount = employeeCount1 + employeeCount2;

    res.json({ totalEmployeeCount });
  } catch (error) {
    console.error(error);
    res.status(500).json({ error: 'Internal Server Error' });
  } finally {
    if(connection){
      connection.release();
      //console.log("Connection released");
    }
  }
});


// API endpoint for braid_daywise_active_employees_contract_absent
/**
 * @swagger
 * /braid_daywise_active_employees_contract_absent:
 *   get:
 *     summary: Fetch total count of active, direct, absent contract employees in the BRAID category from two tables.
 *     description: Retrieves the total count of active, direct, absent contract employees in the BRAID category from the geopos_employees and employees_ota tables.
 *     tags:
 *       - Employee Management
 *     security:
 *       - BearerAuth: []
 *     responses:
 *       200:
 *         description: Total count of active, direct, absent contract employees in the BRAID category fetched successfully.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 totalEmployeeCount:
 *                   type: integer
 *                   example: 30
 *       500:
 *         description: Error occurred while fetching the total count of active, direct, absent contract employees in the BRAID category.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: Internal Server Error
 * @function
 * @name fetchBraidDaywiseActiveEmployeesContractAbsent
 * @memberof module:Routes/EmployeeManagement
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with executing the MySQL query.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
app.get('/braid_daywise_active_employees_contract_absent', authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    const query1 = `
      SELECT COUNT(*) AS employee_count
      FROM geopos_employees
      WHERE passive_type = 'ACT'
        AND workertype = 'DIRECT'
        AND status = 'A'
        AND employee_type = 'Contract'
        AND category_type = 'BRAID'
    `;

    const query2 = `
      SELECT COUNT(*) AS employee_count
      FROM employees_ota
      WHERE passive_type = 'ACT'
        AND workertype = 'DIRECT'
        AND status = 'A'
        AND employee_type = 'Contract'
        AND category_type = 'BRAID'
    `;

    const results1 = await executeQuery(connection,query1);
    const results2 = await executeQuery(connection,query2);

    const employeeCount1 = results1[0].employee_count;
    const employeeCount2 = results2[0].employee_count;
    const totalEmployeeCount = employeeCount1 + employeeCount2;

    res.json({ totalEmployeeCount });
  } catch (error) {
    console.error(error);
    res.status(500).json({ error: 'Internal Server Error' });
  } finally {
    if(connection){
      connection.release();
      //console.log("Connection released");
    }
  }
});


// API endpoint for braid_daywise_active_employees_casual
/**
 * @swagger
 * /braid_daywise_active_employees_casual:
 *   get:
 *     summary: Fetch total count of active, direct, casual employees in the BRAID category from two tables.
 *     description: Retrieves the total count of active, direct, casual employees in the BRAID category from the geopos_employees and employees_ota tables.
 *     tags:
 *       - Employee Management
 *     security:
 *       - BearerAuth: []
 *     responses:
 *       200:
 *         description: Total count of active, direct, casual employees in the BRAID category fetched successfully.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 totalEmployeeCount:
 *                   type: integer
 *                   example: 50
 *       500:
 *         description: Error occurred while fetching the total count of active, direct, casual employees in the BRAID category.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: Internal Server Error
 * @function
 * @name fetchBraidDaywiseActiveEmployeesCasual
 * @memberof module:Routes/EmployeeManagement
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with executing the MySQL query.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
app.get('/braid_daywise_active_employees_casual', authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    const query1 = `
      SELECT COUNT(*) AS employee_count
      FROM geopos_employees
      WHERE passive_type = 'ACT'
        AND workertype = 'DIRECT'
        AND employee_type = 'Casual'
        AND category_type = 'BRAID'
    `;

    const query2 = `
      SELECT COUNT(*) AS employee_count
      FROM employees_ota
      WHERE passive_type = 'ACT'
        AND workertype = 'DIRECT'
        AND employee_type = 'Casual'
        AND category_type = 'BRAID'
    `;

    const results1 = await executeQuery(connection,query1);
    const results2 = await executeQuery(connection,query2);

    const employeeCount1 = results1[0].employee_count;
    const employeeCount2 = results2[0].employee_count;
    const totalEmployeeCount = employeeCount1 + employeeCount2;

    res.json({ totalEmployeeCount });
  } catch (error) {
    console.error(error);
    res.status(500).json({ error: 'Internal Server Error' });
  } finally {
    if(connection){
      connection.release();
      //console.log("Connection released");
    }
  }
});


// API endpoint for braid_daywise_active_employees_casual_present
/**
 * @swagger
 * /braid_daywise_active_employees_casual_present:
 *   get:
 *     summary: Fetch total count of active, direct, casual, present employees in the BRAID category from two tables.
 *     description: Retrieves the total count of active, direct, casual, present employees in the BRAID category from the geopos_employees and employees_ota tables.
 *     tags:
 *       - Employee Management
 *     security:
 *       - BearerAuth: []
 *     responses:
 *       200:
 *         description: Total count of active, direct, casual, present employees in the BRAID category fetched successfully.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 totalEmployeeCount:
 *                   type: integer
 *                   example: 50
 *       500:
 *         description: Error occurred while fetching the total count of active, direct, casual, present employees in the BRAID category.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: Internal Server Error
 * @function
 * @name fetchBraidDaywiseActiveEmployeesCasualPresent
 * @memberof module:Routes/EmployeeManagement
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with executing the MySQL query.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
app.get('/braid_daywise_active_employees_casual_present', authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    const query1 = `
      SELECT COUNT(*) AS employee_count
      FROM geopos_employees
      WHERE passive_type = 'ACT'
        AND workertype = 'DIRECT'
        AND status = 'P'
        AND employee_type = 'Casual'
        AND category_type = 'BRAID'
    `;

    const query2 = `
      SELECT COUNT(*) AS employee_count
      FROM employees_ota
      WHERE passive_type = 'ACT'
        AND workertype = 'DIRECT'
        AND status = 'P'
        AND employee_type = 'Casual'
        AND category_type = 'BRAID'
    `;

    const results1 = await executeQuery(connection,query1);
    const results2 = await executeQuery(connection,query2);

    const employeeCount1 = results1[0].employee_count;
    const employeeCount2 = results2[0].employee_count;
    const totalEmployeeCount = employeeCount1 + employeeCount2;

    res.json({ totalEmployeeCount });
  } catch (error) {
    console.error(error);
    res.status(500).json({ error: 'Internal Server Error' });
  } finally {
    if(connection){
      connection.release();
      //console.log("Connection released");
    }
  }
});



// API endpoint for braid_daywise_active_employees_casual_absent
/**
 * @swagger
 * /braid_daywise_active_employees_casual_absent:
 *   get:
 *     summary: Fetch total count of active, direct, casual, absent employees in the BRAID category from two tables.
 *     description: Retrieves the total count of active, direct, casual, absent employees in the BRAID category from the geopos_employees and employees_ota tables.
 *     tags:
 *       - Employee Management
 *     security:
 *       - BearerAuth: []
 *     responses:
 *       200:
 *         description: Total count of active, direct, casual, absent employees in the BRAID category fetched successfully.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 totalEmployeeCount:
 *                   type: integer
 *                   example: 30
 *       500:
 *         description: Error occurred while fetching the total count of active, direct, casual, absent employees in the BRAID category.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: Internal Server Error
 * @function
 * @name fetchBraidDaywiseActiveEmployeesCasualAbsent
 * @memberof module:Routes/EmployeeManagement
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with executing the MySQL query.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
app.get('/braid_daywise_active_employees_casual_absent', authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    // Use a parameterized query to avoid SQL injection
    const query1 = `
      SELECT COUNT(*) AS employee_count
      FROM geopos_employees
      WHERE passive_type = 'ACT'
        AND workertype = 'DIRECT'
        AND status = 'A'
        AND employee_type = 'Casual'
        AND category_type = 'BRAID'
    `;

    const query2 = `
      SELECT COUNT(*) AS employee_count
      FROM employees_ota
      WHERE passive_type = 'ACT'
        AND workertype = 'DIRECT'
        AND status = 'A'
        AND employee_type = 'Casual'
        AND category_type = 'BRAID'
    `;

    // Execute the queries using the connection pool
    const results1 = await executeQuery(connection,query1);
    const results2 = await executeQuery(connection,query2);

    // Extract the counts from the results
    const employeeCount1 = results1[0].employee_count;
    const employeeCount2 = results2[0].employee_count;

    // Calculate the total employee count and send it as the API response
    const totalEmployeeCount = employeeCount1 + employeeCount2;
    res.json({ totalEmployeeCount });
  } catch (error) {
    console.error(error);
    res.status(500).json({ error: 'Internal Server Error' });
  } finally {
    if(connection){
      connection.release();
      //console.log("Connection released");
    }
  }
});


//API endpoint for braid_daywise_active_employees_outsourcing
/**
 * @swagger
 * /braid_daywise_active_employees_outsourcing:
 *   get:
 *     summary: Fetch total count of active, direct, outsourcing employees in the BRAID category from two tables.
 *     description: Retrieves the total count of active, direct, outsourcing employees in the BRAID category from the geopos_employees and employees_ota tables.
 *     tags:
 *       - Employee Management
 *     security:
 *       - BearerAuth: []
 *     responses:
 *       200:
 *         description: Total count of active, direct, outsourcing employees in the BRAID category fetched successfully.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 totalEmployeeCount:
 *                   type: integer
 *                   example: 45
 *       500:
 *         description: Error occurred while fetching the total count of active, direct, outsourcing employees in the BRAID category.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: Internal Server Error
 * @function
 * @name fetchBraidDaywiseActiveEmployeesOutsourcing
 * @memberof module:Routes/EmployeeManagement
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with executing the MySQL query.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
app.get('/braid_daywise_active_employees_outsourcing', authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    // Use a parameterized query to avoid SQL injection
    const query1 = `
      SELECT COUNT(*) AS employee_count
      FROM geopos_employees
      WHERE passive_type = 'ACT'
        AND workertype = 'DIRECT'
        AND employee_type = 'Outsourcing'
        AND category_type = 'BRAID'
    `;

    const query2 = `
      SELECT COUNT(*) AS employee_count
      FROM employees_ota
      WHERE passive_type = 'ACT'
        AND workertype = 'DIRECT'
        AND employee_type = 'Outsourcing'
        AND category_type = 'BRAID'
    `;

    // Execute the queries using the connection pool
    const results1 = await executeQuery(connection,query1);
    const results2 = await executeQuery(connection,query2);

    // Extract the counts from the results
    const employeeCount1 = results1[0].employee_count;
    const employeeCount2 = results2[0].employee_count;

    // Calculate the total employee count and send it as the API response
    const totalEmployeeCount = employeeCount1 + employeeCount2;
    res.json({ totalEmployeeCount });
  } catch (error) {
    console.error(error);
    res.status(500).json({ error: 'Internal Server Error' });
  } finally {
    if(connection){
      connection.release();
      //console.log("Connection released");
    }
  }
});


// API endpoint for braid_daywise_active_employees_outsourcing_present
/**
 * @swagger
 * /braid_daywise_active_employees_outsourcing_present:
 *   get:
 *     summary: Fetch total count of present, active, direct, outsourcing employees in the BRAID category from two tables.
 *     description: Retrieves the total count of present, active, direct, outsourcing employees in the BRAID category from the geopos_employees and employees_ota tables.
 *     tags:
 *       - Employee Management
 *     security:
 *       - BearerAuth: []
 *     responses:
 *       200:
 *         description: Total count of present, active, direct, outsourcing employees in the BRAID category fetched successfully.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 totalEmployeeCount:
 *                   type: integer
 *                   example: 25
 *       500:
 *         description: Error occurred while fetching the total count of present, active, direct, outsourcing employees in the BRAID category.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: Internal Server Error
 * @function
 * @name fetchBraidDaywiseActiveEmployeesOutsourcingPresent
 * @memberof module:Routes/EmployeeManagement
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with executing the MySQL query.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
app.get('/braid_daywise_active_employees_outsourcing_present', authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    // Use a parameterized query to avoid SQL injection
    const query1 = `
      SELECT COUNT(*) AS employee_count
      FROM geopos_employees
      WHERE passive_type = 'ACT'
        AND workertype = 'DIRECT'
        AND status = 'P'
        AND employee_type = 'Outsourcing'
        AND category_type = 'BRAID'
    `;

    const query2 = `
      SELECT COUNT(*) AS employee_count
      FROM employees_ota
      WHERE passive_type = 'ACT'
        AND workertype = 'DIRECT'
        AND status = 'P'
        AND employee_type = 'Outsourcing'
        AND category_type = 'BRAID'
    `;

    // Execute the queries using the connection pool
    const results1 = await executeQuery(connection,query1);
    const results2 = await executeQuery(connection,query2);

    // Extract the counts from the results
    const employeeCount1 = results1[0].employee_count;
    const employeeCount2 = results2[0].employee_count;

    // Calculate the total employee count and send it as the API response
    const totalEmployeeCount = employeeCount1 + employeeCount2;
    res.json({ totalEmployeeCount });
  } catch (error) {
    console.error(error);
    res.status(500).json({ error: 'Internal Server Error' });
  } finally {
    if(connection){
      connection.release();
      //console.log("Connection released");
    }
  }
});

/**
 * @swagger
 * /braid_daywise_active_employees_outsourcing_absent:
 *   get:
 *     summary: Fetch total count of absent, active, direct, outsourcing employees in the BRAID category from two tables.
 *     description: Retrieves the total count of absent, active, direct, outsourcing employees in the BRAID category from the geopos_employees and employees_ota tables.
 *     tags:
 *       - Employee Management
 *     security:
 *       - BearerAuth: []
 *     responses:
 *       200:
 *         description: Total count of absent, active, direct, outsourcing employees in the BRAID category fetched successfully.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 totalEmployeeCount:
 *                   type: integer
 *                   example: 25
 *       500:
 *         description: Error occurred while fetching the total count of absent, active, direct, outsourcing employees in the BRAID category.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: Internal Server Error
 * @function
 * @name fetchBraidDaywiseActiveEmployeesOutsourcingAbsent
 * @memberof module:Routes/EmployeeManagement
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with executing the MySQL query.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
//API endpoint for braid_daywise_active_employees_outsourcing_absent
app.get('/braid_daywise_active_employees_outsourcing_absent', authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    // Use a parameterized query to avoid SQL injection
    const query1 = `
      SELECT COUNT(*) AS employee_count
      FROM geopos_employees
      WHERE passive_type = 'ACT'
        AND workertype = 'DIRECT'
        AND status = 'A'
        AND employee_type = 'Outsourcing'
        AND category_type = 'BRAID'
    `;

    const query2 = `
      SELECT COUNT(*) AS employee_count
      FROM employees_ota
      WHERE passive_type = 'ACT'
        AND workertype = 'DIRECT'
        AND status = 'A'
        AND employee_type = 'Outsourcing'
        AND category_type = 'BRAID'
    `;

    // Execute the queries using the connection pool
    const results1 = await executeQuery(connection,query1);
    const results2 = await executeQuery(connection,query2);

    // Extract the counts from the results
    const employeeCount1 = results1[0].employee_count;
    const employeeCount2 = results2[0].employee_count;

    // Calculate the total employee count and send it as the API response
    const totalEmployeeCount = employeeCount1 + employeeCount2;
    res.json({ totalEmployeeCount });
  } catch (error) {
    console.error(error);
    res.status(500).json({ error: 'Internal Server Error' });
  } finally {
    if(connection){
      connection.release();
      //console.log("Connection released");
    }
  }
});


// API endpoint for nbraid_daywise_active_employess_staff
/**
 * @swagger
 * /nbraid_daywise_active_employees_staff:
 *   get:
 *     summary: Fetch total count of active, direct, staff employees in the NBRAID category from two tables.
 *     description: Retrieves the total count of active, direct, staff employees in the NBRAID category from the geopos_employees and employees_ota tables.
 *     tags:
 *       - Employee Management
 *     security:
 *       - BearerAuth: []
 *     responses:
 *       200:
 *         description: Total count of active, direct, staff employees in the NBRAID category fetched successfully.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 totalEmployeeCount:
 *                   type: integer
 *                   example: 50
 *       500:
 *         description: Error occurred while fetching the total count of active, direct, staff employees in the NBRAID category.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: Internal Server Error
 * @function
 * @name fetchNBraidDaywiseActiveEmployeesStaff
 * @memberof module:Routes/EmployeeManagement
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with executing the MySQL query.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
app.get('/nbraid_daywise_active_employees_staff', authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    // Use a parameterized query to avoid SQL injection
    const query1 = `
      SELECT COUNT(*) AS employee_count
      FROM geopos_employees
      WHERE passive_type = 'ACT'
        AND workertype = 'DIRECT'
        AND employee_type = 'Staff'
        AND category_type = 'NBRAID'
    `;

    const query2 = `
      SELECT COUNT(*) AS employee_count
      FROM employees_ota
      WHERE passive_type = 'ACT'
        AND workertype = 'DIRECT'
        AND employee_type = 'Staff'
        AND category_type = 'NBRAID'
    `;

    // Execute the queries using the connection pool
    const results1 = await executeQuery(connection,query1);
    const results2 = await executeQuery(connection,query2);

    // Extract the counts from the results
    const employeeCount1 = results1[0].employee_count;
    const employeeCount2 = results2[0].employee_count;

    // Calculate the total employee count and send it as the API response
    const totalEmployeeCount = employeeCount1 + employeeCount2;
    res.json({ totalEmployeeCount });
  } catch (error) {
    console.error(error);
    res.status(500).json({ error: 'Internal Server Error' });
  } finally {
    if(connection){
      connection.release();
      //console.log("Connection released");
    }
  }
});


// API endpoint for nbraid_daywise_active_employess_staff_present
/**
 * @swagger
 * /nbraid_daywise_active_employees_staff_present:
 *   get:
 *     summary: Fetch total count of active, direct, present staff employees in the NBRAID category from two tables.
 *     description: Retrieves the total count of active, direct, present staff employees in the NBRAID category from the geopos_employees and employees_ota tables.
 *     tags:
 *       - Employee Management
 *     security:
 *       - BearerAuth: []
 *     responses:
 *       200:
 *         description: Total count of active, direct, present staff employees in the NBRAID category fetched successfully.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 totalEmployeeCount:
 *                   type: integer
 *                   example: 50
 *       500:
 *         description: Error occurred while fetching the total count of active, direct, present staff employees in the NBRAID category.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: Internal Server Error
 * @function
 * @name fetchNBraidDaywiseActiveEmployeesStaffPresent
 * @memberof module:Routes/EmployeeManagement
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with executing the MySQL query.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
app.get('/nbraid_daywise_active_employees_staff_present', authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    // Use a parameterized query to avoid SQL injection
    const query1 = `
      SELECT COUNT(*) AS employee_count
      FROM geopos_employees
      WHERE passive_type = 'ACT'
        AND workertype = 'DIRECT'
        AND status = 'P'
        AND employee_type = 'Staff'
        AND category_type = 'NBRAID'
    `;

    const query2 = `
      SELECT COUNT(*) AS employee_count
      FROM employees_ota
      WHERE passive_type = 'ACT'
        AND workertype = 'DIRECT'
        AND status = 'P'
        AND employee_type = 'Staff'
        AND category_type = 'NBRAID'
    `;

    // Execute the queries using the connection pool
    const results1 = await executeQuery(connection,query1);
    const results2 = await executeQuery(connection,query2);

    // Extract the counts from the results
    const employeeCount1 = results1[0].employee_count;
    const employeeCount2 = results2[0].employee_count;

    // Calculate the total employee count and send it as the API response
    const totalEmployeeCount = employeeCount1 + employeeCount2;
    res.json({ totalEmployeeCount });
  } catch (error) {
    console.error(error);
    res.status(500).json({ error: 'Internal Server Error' });
  } finally {
    if(connection){
      connection.release();
      //console.log("Connection released");
    }
  }
});


//API endpoint for nbraid_daywise_active_employess_staff_absent
/**
 * @swagger
 * /nbraid_daywise_active_employees_staff_absent:
 *   get:
 *     summary: Fetch total count of active, direct, absent staff employees in the NBRAID category from two tables.
 *     description: Retrieves the total count of active, direct, absent staff employees in the NBRAID category from the geopos_employees and employees_ota tables.
 *     tags:
 *       - Employee Management
 *     security:
 *       - BearerAuth: []
 *     responses:
 *       200:
 *         description: Total count of active, direct, absent staff employees in the NBRAID category fetched successfully.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 totalEmployeeCount:
 *                   type: integer
 *                   example: 25
 *       500:
 *         description: Error occurred while fetching the total count of active, direct, absent staff employees in the NBRAID category.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: Internal Server Error
 * @function
 * @name fetchNBraidDaywiseActiveEmployeesStaffAbsent
 * @memberof module:Routes/EmployeeManagement
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with executing the MySQL query.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
app.get('/nbraid_daywise_active_employees_staff_absent', authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    // Use a parameterized query to avoid SQL injection
    const query1 = `
      SELECT COUNT(*) AS employee_count
      FROM geopos_employees
      WHERE passive_type = 'ACT'
        AND workertype = 'DIRECT'
        AND status = 'A'
        AND employee_type = 'Staff'
        AND category_type = 'NBRAID'
    `;

    // Execute the first query using your custom executeQuery function
    const results1 = await executeQuery(connection,query1);

    // Extract the counts from the results
    const employeeCount1 = results1[0].employee_count;

    // Execute the second query
    const query2 = `
      SELECT COUNT(*) AS employee_count
      FROM employees_ota
      WHERE passive_type = 'ACT'
        AND workertype = 'DIRECT'
        AND status = 'A'
        AND employee_type = 'Staff'
        AND category_type = 'NBRAID'
    `;

    const results2 = await executeQuery(connection,query2);

    // Extract the counts from the results
    const employeeCount2 = results2[0].employee_count;

    // Calculate the total employee count and send it as the API response
    const totalEmployeeCount = employeeCount1 + employeeCount2;
    res.json({ totalEmployeeCount });
  } catch (error) {
    console.error(error);
    res.status(500).json({ error: 'Internal Server Error' });
  } finally {
    if(connection){
      connection.release();
      //console.log("Connection released");
    }
  }   
});


//  API endpoint for nbraid_daywise_active_employess_contract
/**
 * @swagger
 * /nbraid_daywise_active_employees_contract:
 *   get:
 *     summary: Fetch total count of active, direct contract employees in the NBRAID category from two tables.
 *     description: Retrieves the total count of active, direct contract employees in the NBRAID category from the geopos_employees and employees_ota tables.
 *     tags:
 *       - Employee Management
 *     security:
 *       - BearerAuth: []
 *     responses:
 *       200:
 *         description: Total count of active, direct contract employees in the NBRAID category fetched successfully.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 totalEmployeeCount:
 *                   type: integer
 *                   example: 25
 *       500:
 *         description: Error occurred while fetching the total count of active, direct contract employees in the NBRAID category.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: Internal Server Error
 * @function
 * @name fetchNBraidDaywiseActiveEmployeesContract
 * @memberof module:Routes/EmployeeManagement
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with executing the MySQL query.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
app.get('/nbraid_daywise_active_employees_contract', authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    // Use a parameterized query to avoid SQL injection
    const query1 = `
      SELECT COUNT(*) AS employee_count
      FROM geopos_employees
      WHERE passive_type = 'ACT'
        AND workertype = 'DIRECT'
        AND employee_type = 'Contract'
        AND category_type = 'NBRAID'
    `;

    // Execute the first query using your custom executeQuery function
    const results1 = await executeQuery(connection,query1);

    // Extract the counts from the results
    const employeeCount1 = results1[0].employee_count;

    // Execute the second query
    const query2 = `
      SELECT COUNT(*) AS employee_count
      FROM employees_ota
      WHERE passive_type = 'ACT'
        AND workertype = 'DIRECT'
        AND employee_type = 'Contract'
        AND category_type = 'NBRAID'
    `;

    const results2 = await executeQuery(connection,query2);

    // Extract the counts from the results
    const employeeCount2 = results2[0].employee_count;

    // Calculate the total employee count and send it as the API response
    const totalEmployeeCount = employeeCount1 + employeeCount2;
    res.json({ totalEmployeeCount });
  } catch (error) {
    console.error(error);
    res.status(500).json({ error: 'Internal Server Error' });
  } finally {
    if(connection){
      connection.release();
      //console.log("Connection released");
    }
  }
});


// API endpoint for nbraid_daywise_active_employees_contract_present
/**
 * @swagger
 * /nbraid_daywise_active_employees_contract_present:
 *   get:
 *     summary: Fetch total count of active, present direct contract employees in the NBRAID category from two tables.
 *     description: Retrieves the total count of active, present direct contract employees in the NBRAID category from the geopos_employees and employees_ota tables.
 *     tags:
 *       - Employee Management
 *     security:
 *       - BearerAuth: []
 *     responses:
 *       200:
 *         description: Total count of active, present direct contract employees in the NBRAID category fetched successfully.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 totalEmployeeCount:
 *                   type: integer
 *                   example: 15
 *       500:
 *         description: Error occurred while fetching the total count of active, present direct contract employees in the NBRAID category.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: Internal Server Error
 * @function
 * @name fetchNBraidDaywiseActiveEmployeesContractPresent
 * @memberof module:Routes/EmployeeManagement
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with executing the MySQL query.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
app.get('/nbraid_daywise_active_employees_contract_present', authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    // Use a parameterized query to avoid SQL injection
    const query1 = `
      SELECT COUNT(*) AS employee_count
      FROM geopos_employees
      WHERE passive_type = 'ACT'
        AND workertype = 'DIRECT'
        AND status = 'P'
        AND employee_type = 'Contract'
        AND category_type = 'NBRAID'
    `;

    // Execute the first query using your custom executeQuery function
    const results1 = await executeQuery(connection,query1);

    // Extract the counts from the results
    const employeeCount1 = results1[0].employee_count;

    // Execute the second query
    const query2 = `
      SELECT COUNT(*) AS employee_count
      FROM employees_ota
      WHERE passive_type = 'ACT'
        AND workertype = 'DIRECT'
        AND status = 'P'
        AND employee_type = 'Contract'
        AND category_type = 'NBRAID'
    `;

    const results2 = await executeQuery(connection,query2);

    // Extract the counts from the results
    const employeeCount2 = results2[0].employee_count;

    // Calculate the total employee count and send it as the API response
    const totalEmployeeCount = employeeCount1 + employeeCount2;
    res.json({ totalEmployeeCount });
  } catch (error) {
    console.error(error);
    res.status(500).json({ error: 'Internal Server Error' });
  } finally {
    if(connection){
      connection.release();
      //console.log("Connection released");
    }
  }
});


// API endpoint for nbraid_daywise_active_employess_contract_absent
/**
 * @swagger
 * /nbraid_daywise_active_employees_contract_absent:
 *   get:
 *     summary: Fetch total count of active, absent direct contract employees in the NBRAID category from two tables.
 *     description: Retrieves the total count of active, absent direct contract employees in the NBRAID category from the geopos_employees and employees_ota tables.
 *     tags:
 *       - Employee Management
 *     security:
 *       - BearerAuth: []
 *     responses:
 *       200:
 *         description: Total count of active, absent direct contract employees in the NBRAID category fetched successfully.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 totalEmployeeCount:
 *                   type: integer
 *                   example: 15
 *       500:
 *         description: Error occurred while fetching the total count of active, absent direct contract employees in the NBRAID category.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: Internal Server Error
 * @function
 * @name fetchNBraidDaywiseActiveEmployeesContractAbsent
 * @memberof module:Routes/EmployeeManagement
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with executing the MySQL query.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
app.get('/nbraid_daywise_active_employees_contract_absent', authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    // Use a parameterized query to avoid SQL injection
    const query1 = `
      SELECT COUNT(*) AS employee_count
      FROM geopos_employees
      WHERE passive_type = 'ACT'
        AND workertype = 'DIRECT'
        AND status = 'A'
        AND employee_type = 'Contract'
        AND category_type = 'NBRAID'
    `;

    // Execute the first query using your custom executeQuery function
    const results1 = await executeQuery(connection,query1);

    // Extract the counts from the results
    const employeeCount1 = results1[0].employee_count;

    // Execute the second query
    const query2 = `
      SELECT COUNT(*) AS employee_count
      FROM employees_ota
      WHERE passive_type = 'ACT'
        AND workertype = 'DIRECT'
        AND status = 'A'
        AND employee_type = 'Contract'
        AND category_type = 'NBRAID'
    `;

    const results2 = await executeQuery(connection,query2);

    // Extract the counts from the results
    const employeeCount2 = results2[0].employee_count;

    // Calculate the total employee count and send it as the API response
    const totalEmployeeCount = employeeCount1 + employeeCount2;
    res.json({ totalEmployeeCount });
  } catch (error) {
    console.error(error);
    res.status(500).json({ error: 'Internal Server Error' });
  } finally {
    if(connection){
      connection.release();
      //console.log("Connection released");
    }
  }
});




//  API endpoint for nbraid_daywise_active_employess_casual
/**
 * @swagger
 * /nbraid_daywise_active_employees_casual:
 *   get:
 *     summary: Fetch total count of active, direct casual employees in the NBRAID category from two tables.
 *     description: Retrieves the total count of active, direct casual employees in the NBRAID category from the geopos_employees and employees_ota tables.
 *     tags:
 *       - Employee Management
 *     security:
 *       - BearerAuth: []
 *     responses:
 *       200:
 *         description: Total count of active, direct casual employees in the NBRAID category fetched successfully.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 totalEmployeeCount:
 *                   type: integer
 *                   example: 20
 *       500:
 *         description: Error occurred while fetching the total count of active, direct casual employees in the NBRAID category.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: Internal Server Error
 * @function
 * @name fetchNBraidDaywiseActiveEmployeesCasual
 * @memberof module:Routes/EmployeeManagement
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with executing the MySQL query.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
app.get('/nbraid_daywise_active_employees_casual', authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    // Use a parameterized query to avoid SQL injection
    const query1 = `
      SELECT COUNT(*) AS employee_count
      FROM geopos_employees
      WHERE passive_type = 'ACT'
        AND workertype = 'DIRECT'
        AND employee_type = 'Casual'
        AND category_type = 'NBRAID'
    `;

    // Execute the first query using your custom executeQuery function
    const results1 = await executeQuery(connection,query1);

    // Extract the counts from the results
    const employeeCount1 = results1[0].employee_count;

    // Execute the second query
    const query2 = `
      SELECT COUNT(*) AS employee_count
      FROM employees_ota
      WHERE passive_type = 'ACT'
        AND workertype = 'DIRECT'
        AND employee_type = 'Casual'
        AND category_type = 'NBRAID'
    `;

    const results2 = await executeQuery(connection,query2);

    // Extract the counts from the results
    const employeeCount2 = results2[0].employee_count;

    // Calculate the total employee count and send it as the API response
    const totalEmployeeCount = employeeCount1 + employeeCount2;
    res.json({ totalEmployeeCount });
  } catch (error) {
    console.error(error);
    res.status(500).json({ error: 'Internal Server Error' });
  } finally {
    if(connection){
      connection.release();
      //console.log("Connection released");
    }
  }
});



// Define your API endpoint for nbraid_daywise_active_employees_casual_present
/**
 * @swagger
 * /nbraid_daywise_active_employees_casual_present:
 *   get:
 *     summary: Fetch total count of active, present casual employees in the NBRAID category from two tables.
 *     description: Retrieves the total count of active, present casual employees in the NBRAID category from the geopos_employees and employees_ota tables.
 *     tags:
 *       - Employee Management
 *     security:
 *       - BearerAuth: []
 *     responses:
 *       200:
 *         description: Total count of active, present casual employees in the NBRAID category fetched successfully.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 totalEmployeeCount:
 *                   type: integer
 *                   example: 20
 *       500:
 *         description: Error occurred while fetching the total count of active, present casual employees in the NBRAID category.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: Internal Server Error
 * @function
 * @name fetchNBraidDaywiseActiveEmployeesCasualPresent
 * @memberof module:Routes/EmployeeManagement
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with executing the MySQL query.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
app.get('/nbraid_daywise_active_employees_casual_present', authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    // Use a parameterized query to avoid SQL injection
    const query1 = `
      SELECT COUNT(*) AS employee_count
      FROM geopos_employees
      WHERE passive_type = 'ACT'
        AND workertype = 'DIRECT'
        AND status = 'P'
        AND employee_type = 'Casual'
        AND category_type = 'NBRAID'
    `;

    // Execute the first query using your custom executeQuery function
    const results1 = await executeQuery(connection,query1);

    // Extract the counts from the results
    const employeeCount1 = results1[0].employee_count;

    // Execute the second query
    const query2 = `
      SELECT COUNT(*) AS employee_count
      FROM employees_ota
      WHERE passive_type = 'ACT'
        AND workertype = 'DIRECT'
        AND status = 'P'
        AND employee_type = 'Casual'
        AND category_type = 'NBRAID'
    `;

    const results2 = await executeQuery(connection,query2);

    // Extract the counts from the results
    const employeeCount2 = results2[0].employee_count;

    // Calculate the total employee count and send it as the API response
    const totalEmployeeCount = employeeCount1 + employeeCount2;
    res.json({ totalEmployeeCount });
  } catch (error) {
    console.error(error);
    res.status(500).json({ error: 'Internal Server Error' });
  } finally {
    if(connection){
      connection.release();
      //console.log("Connection released");
    }
  }
});


// Define your API endpoint for nbraid_daywise_active_employees_casual_absent
/**
 * @swagger
 * /nbraid_daywise_active_employees_casual_absent:
 *   get:
 *     summary: Fetch total count of active, absent casual employees in the NBRAID category from two tables.
 *     description: Retrieves the total count of active, absent casual employees in the NBRAID category from the geopos_employees and employees_ota tables.
 *     tags:
 *       - Employee Management
 *     security:
 *       - BearerAuth: []
 *     responses:
 *       200:
 *         description: Total count of active, absent casual employees in the NBRAID category fetched successfully.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 totalEmployeeCount:
 *                   type: integer
 *                   example: 20
 *       500:
 *         description: Error occurred while fetching the total count of active, absent casual employees in the NBRAID category.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: Internal Server Error
 * @function
 * @name fetchNBraidDaywiseActiveEmployeesCasualAbsent
 * @memberof module:Routes/EmployeeManagement
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with executing the MySQL query.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
app.get('/nbraid_daywise_active_employees_casual_absent', authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    // Use a parameterized query to avoid SQL injection
    const query1 = `
      SELECT COUNT(*) AS employee_count
      FROM geopos_employees
      WHERE passive_type = 'ACT'
        AND workertype = 'DIRECT'
        AND status = 'A'
        AND employee_type = 'Casual'
        AND category_type = 'NBRAID'
    `;

    // Execute the first query using your custom executeQuery function
    const results1 = await executeQuery(connection,query1);

    // Extract the counts from the results
    const employeeCount1 = results1[0].employee_count;

    // Execute the second query
    const query2 = `
      SELECT COUNT(*) AS employee_count
      FROM employees_ota
      WHERE passive_type = 'ACT'
        AND workertype = 'DIRECT'
        AND status = 'A'
        AND employee_type = 'Casual'
        AND category_type = 'NBRAID'
    `;

    const results2 = await executeQuery(connection,query2);

    // Extract the counts from the results
    const employeeCount2 = results2[0].employee_count;

    // Calculate the total employee count and send it as the API response
    const totalEmployeeCount = employeeCount1 + employeeCount2;
    res.json({ totalEmployeeCount });
  } catch (error) {
    console.error(error);
    res.status(500).json({ error: 'Internal Server Error' });
  }
});



// API endpoint for nbraid_daywise_active_employess_outsourcing
/**
 * @swagger
 * /nbraid_daywise_active_employees_outsourcing:
 *   get:
 *     summary: Fetch total count of active employees in the Outsourcing category from two tables.
 *     description: Retrieves the total count of active employees in the Outsourcing category from the geopos_employees and employees_ota tables.
 *     tags:
 *       - Employee Management
 *     security:
 *       - BearerAuth: []
 *     responses:
 *       200:
 *         description: Total count of active employees in the Outsourcing category fetched successfully.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 totalEmployeeCount:
 *                   type: integer
 *                   example: 20
 *       500:
 *         description: Error occurred while fetching the total count of active employees in the Outsourcing category.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: Internal Server Error
 * @function
 * @name fetchNBraidDaywiseActiveEmployeesOutsourcing
 * @memberof module:Routes/EmployeeManagement
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with executing the MySQL query.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
app.get('/nbraid_daywise_active_employees_outsourcing', authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    // Use a parameterized query to avoid SQL injection
    const query1 = `
      SELECT COUNT(*) AS employee_count
      FROM geopos_employees
      WHERE passive_type = 'ACT'
        AND workertype = 'DIRECT'
        AND employee_type = 'Outsourcing'
        AND category_type = 'NBRAID'
    `;

    // Execute the first query using your custom executeQuery function
    const results1 = await executeQuery(connection,query1);

    // Extract the counts from the results
    const employeeCount1 = results1[0].employee_count;

    // Execute the second query
    const query2 = `
      SELECT COUNT(*) AS employee_count
      FROM employees_ota
      WHERE passive_type = 'ACT'
        AND workertype = 'DIRECT'
        AND employee_type = 'Outsourcing'
        AND category_type = 'NBRAID'
    `;

    const results2 = await executeQuery(connection,query2);

    // Extract the counts from the results
    const employeeCount2 = results2[0].employee_count;

    // Calculate the total employee count and send it as the API response
    const totalEmployeeCount = employeeCount1 + employeeCount2;
    res.json({ totalEmployeeCount });
  } catch (error) {
    console.error(error);
    res.status(500).json({ error: 'Internal Server Error' });
  } finally {
    if(connection){
      connection.release();
      //console.log("Connection released");
    }
  }
});


// Define your API endpoint for nbraid_daywise_active_employees_outsourcing_present
/**
 * @swagger
 * /nbraid_daywise_active_employees_outsourcing_present:
 *   get:
 *     summary: Fetch total count of active employees in the Outsourcing category who are present from two tables.
 *     description: Retrieves the total count of active employees in the Outsourcing category who are present (status = 'P') from the geopos_employees and employees_ota tables.
 *     tags:
 *       - Employee Management
 *     security:
 *       - BearerAuth: []
 *     responses:
 *       200:
 *         description: Total count of active employees in the Outsourcing category who are present fetched successfully.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 totalEmployeeCount:
 *                   type: integer
 *                   example: 20
 *       500:
 *         description: Error occurred while fetching the total count of active employees in the Outsourcing category who are present.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: Internal Server Error
 * @function
 * @name fetchNBraidDaywiseActiveEmployeesOutsourcingPresent
 * @memberof module:Routes/EmployeeManagement
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with executing the MySQL query.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
app.get('/nbraid_daywise_active_employees_outsourcing_present', authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    // Use a parameterized query to avoid SQL injection
    const query1 = `
      SELECT COUNT(*) AS employee_count
      FROM geopos_employees
      WHERE passive_type = 'ACT'
        AND workertype = 'DIRECT'
        AND status = 'P'
        AND employee_type = 'Outsourcing'
        AND category_type = 'NBRAID'
    `;

    // Execute the first query using your custom executeQuery function
    const results1 = await executeQuery(connection,query1);

    // Extract the counts from the results
    const employeeCount1 = results1[0].employee_count;

    // Execute the second query
    const query2 = `
      SELECT COUNT(*) AS employee_count
      FROM employees_ota
      WHERE passive_type = 'ACT'
        AND workertype = 'DIRECT'
        AND status = 'P'
        AND employee_type = 'Outsourcing'
        AND category_type = 'NBRAID'
    `;

    const results2 = await executeQuery(connection,query2);

    // Extract the counts from the results
    const employeeCount2 = results2[0].employee_count;

    // Calculate the total employee count and send it as the API response
    const totalEmployeeCount = employeeCount1 + employeeCount2;
    res.json({ totalEmployeeCount });
  } catch (error) {
    console.error(error);
    res.status(500).json({ error: 'Internal Server Error' });
  } finally {
    if(connection){
      connection.release();
      //console.log("Connection released");
    }
  }
});


// Define your API endpoint for nbraid_daywise_active_employees_outsourcing_absent
/**
 * @swagger
 * /nbraid_daywise_active_employees_outsourcing_absent:
 *   get:
 *     summary: Fetch total count of active employees in the Outsourcing category who are absent from two tables.
 *     description: Retrieves the total count of active employees in the Outsourcing category who are absent (status = 'A') from the geopos_employees and employees_ota tables.
 *     tags:
 *       - Employee Management
 *     security:
 *       - BearerAuth: []
 *     responses:
 *       200:
 *         description: Total count of active employees in the Outsourcing category who are absent fetched successfully.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 totalEmployeeCount:
 *                   type: integer
 *                   example: 10
 *       500:
 *         description: Error occurred while fetching the total count of active employees in the Outsourcing category who are absent.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: Internal Server Error
 * @function
 * @name fetchNBraidDaywiseActiveEmployeesOutsourcingAbsent
 * @memberof module:Routes/EmployeeManagement
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with executing the MySQL query.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
app.get('/nbraid_daywise_active_employees_outsourcing_absent', authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    // Use a parameterized query to avoid SQL injection
    const query1 = `
      SELECT COUNT(*) AS employee_count
      FROM geopos_employees
      WHERE passive_type = 'ACT'
        AND workertype = 'DIRECT'
        AND status = 'A'
        AND employee_type = 'Outsourcing'
        AND category_type = 'NBRAID'
    `;

    // Execute the first query using your custom executeQuery function
    const results1 = await executeQuery(connection,query1);

    // Extract the counts from the results
    const employeeCount1 = results1[0].employee_count;

    // Execute the second query
    const query2 = `
      SELECT COUNT(*) AS employee_count
      FROM employees_ota
      WHERE passive_type = 'ACT'
        AND workertype = 'DIRECT'
        AND status = 'A'
        AND employee_type = 'Outsourcing'
        AND category_type = 'NBRAID'
    `;

    const results2 = await executeQuery(connection,query2);

    // Extract the counts from the results
    const employeeCount2 = results2[0].employee_count;

    // Calculate the total employee count and send it as the API response
    const totalEmployeeCount = employeeCount1 + employeeCount2;
    res.json({ totalEmployeeCount });
  } catch (error) {
    console.error(error);
    res.status(500).json({ error: 'Internal Server Error' });
  } finally {
    if(connection){
      connection.release();
      //console.log("Connection released");
    }
  }
});


// API endpoint for indirect_ikeja
/**
 * @swagger
 * /fetchindirectikeja:
 *   get:
 *     summary: Fetch total count of active indirect employees present on the latest date recorded in the geopos_employees table.
 *     description: Retrieves the total count of active indirect employees (workertype = 'INDIRECT' and status = 'P') present on the latest date recorded in the geopos_employees table.
 *     tags:
 *       - Employee Management
 *     security:
 *       - BearerAuth: []
 *     responses:
 *       200:
 *         description: Total count of active indirect employees present on the latest date fetched successfully.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 count:
 *                   type: integer
 *                   example: 10
 *       500:
 *         description: Error occurred while fetching the total count of active indirect employees present on the latest date.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: Internal Server Error
 * @function
 * @name fetchIndirectEmployeesIkeja
 * @memberof module:Routes/EmployeeManagement
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with executing the MySQL queries.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
app.get('/fetchindirectikeja', authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    // Query to get the latest date from geopos_employees
    const latestDateQuery = 'SELECT date FROM geopos_employees ORDER BY id ASC LIMIT 1';

    // Execute the query to get the latest date using your custom executeQuery function
    const latestDateResults = await executeQuery(connection,latestDateQuery);

    // Extract the date from the results
    const dt = latestDateResults[0].date;

    // Use a parameterized query to avoid SQL injection
    const query = `
      SELECT COUNT(*) AS count
      FROM geopos_employees
      WHERE passive_type = 'ACT'
        AND workertype = 'INDIRECT'
        AND status = 'P'
        AND date = ?
    `;

    // Execute the main query using the connection pool
    const results = await executeQuery(connection,query, [dt]);

    const totalCount = results[0].count;
    console.log('Total Count:', totalCount);
    res.send(results);
  } catch (error) {
    console.error(error);
    res.status(500).json({ error: 'Internal Server Error' });
  } finally {
    if(connection){
      connection.release();
      //console.log("Connection released");
    }
  }
});

/**
 * @swagger
 * /fetchindirectota:
 *   get:
 *     summary: Fetch total count of active indirect employees present on the latest date recorded in the employees_ota table.
 *     description: Retrieves the total count of active indirect employees (workertype = 'INDIRECT' and status = 'P') present on the latest date recorded in the employees_ota table.
 *     tags:
 *       - Employee Management
 *     security:
 *       - BearerAuth: []
 *     responses:
 *       200:
 *         description: Total count of active indirect employees present on the latest date fetched successfully.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 count:
 *                   type: integer
 *                   example: 10
 *       500:
 *         description: Error occurred while fetching the total count of active indirect employees present on the latest date.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: Internal Server Error
 * @function
 * @name fetchIndirectEmployeesOTA
 * @memberof module:Routes/EmployeeManagement
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with executing the MySQL queries.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
// API endpoint for indirect_ota
app.get('/fetchindirectota', authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    // Query to get the latest date from employees_ota
    const latestDateQuery = 'SELECT date FROM employees_ota ORDER BY id ASC LIMIT 1';

    // Execute the query to get the latest date using your custom executeQuery function
    const latestDateResults = await executeQuery(connection,latestDateQuery);

    // Extract the date from the results
    const dt = latestDateResults[0].date;

    // Use a parameterized query to avoid SQL injection
    const query = `
      SELECT COUNT(*) AS count
      FROM employees_ota
      WHERE passive_type = 'ACT'
        AND workertype = 'INDIRECT'
        AND status = 'P'
        AND date = ?
    `;

    // Execute the main query using the connection pool
    const results = await executeQuery(connection,query, [dt]);

    const totalCount = results[0].count;
    console.log('Total Count:', totalCount);
    res.send(results);
  } catch (error) {
    console.error(error);
    res.status(500).json({ error: 'Internal Server Error' });
  } finally {
    if(connection){
      connection.release();
      //console.log("Connection released");
    }
  } 
});


// API endpoint for attrition_braid
/**
 * @swagger
 * /fetchattritionbraid:
 *   get:
 *     summary: Fetch total count of attrition for the current month from the geopos_employees_attrition table.
 *     description: Retrieves the total count of attrition for the current month from the geopos_employees_attrition table.
 *     tags:
 *       - Employee Management
 *     security:
 *       - BearerAuth: []
 *     responses:
 *       200:
 *         description: Total count of attrition for the current month fetched successfully.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 count:
 *                   type: integer
 *                   example: 10
 *       500:
 *         description: Error occurred while fetching the total count of attrition for the current month.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: Internal Server Error
 * @function
 * @name fetchAttritionBraid
 * @memberof module:Routes/EmployeeManagement
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with executing the MySQL query.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
app.get('/fetchattritionbraid', authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    // Get the current month and year
    const date = new Date().toLocaleDateString('en-GB', { timeZone: 'Africa/Lagos' });
    const parts = date.split('/');
    const formattedDay = parts[0].padStart(2, '0');
    const formattedMonth = parts[1].padStart(2, '0');
    const year = parts[2];
    const date1 = `${formattedDay}-${formattedMonth}-${year}`;
    const mon = `${formattedMonth}-${year}`;

    // Use a parameterized query to avoid SQL injection
    const query = `SELECT COUNT(*) AS count FROM geopos_employees_attrition WHERE SUBSTRING(exitdate, 4) = ?`;

    // Execute the query using the custom executeQuery function
    const results = await executeQuery(connection,query, [mon]);

    const totalCount = results[0].count;
    console.log('Total Count:', totalCount);
    res.send(results);
  } catch (error) {
    console.error(error);
    res.status(500).json({ error: 'Internal Server Error' });
  } finally {
    if(connection){
      connection.release();
      //console.log("Connection released");
    }
  }
});

/**
 * @swagger
 * /fetchattritionNbraid:
 *   get:
 *     summary: Fetch total count of attrition for the current month from the employees_ota_attrition table.
 *     description: Retrieves the total count of attrition for the current month from the employees_ota_attrition table.
 *     tags:
 *       - Employee Management
 *     security:
 *       - BearerAuth: []
 *     responses:
 *       200:
 *         description: Total count of attrition for the current month fetched successfully.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 count:
 *                   type: integer
 *                   example: 10
 *       500:
 *         description: Error occurred while fetching the total count of attrition for the current month.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: Internal Server Error
 * @function
 * @name fetchAttritionNbraid
 * @memberof module:Routes/EmployeeManagement
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with executing the MySQL query.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
// API endpoint to get attrition_nbraid
app.get('/fetchattritionNbraid', authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    // Get the current month and year
    const date = new Date().toLocaleDateString('en-GB', { timeZone: 'Africa/Lagos' });
    const parts = date.split('/');
    const formattedDay = parts[0].padStart(2, '0');
    const formattedMonth = parts[1].padStart(2, '0');
    const year = parts[2];
    const date1 = `${formattedDay}-${formattedMonth}-${year}`;
    const mon = `${formattedMonth}-${year}`;

    // Use a parameterized query to avoid SQL injection
    const query = `SELECT COUNT(*) AS count FROM employees_ota_attrition WHERE SUBSTRING(exitdate, 4) = ?`;

    // Execute the query using the custom executeQuery function
    const results = await executeQuery(connection,query, [mon]);

    const totalCount = results[0].count;
    console.log('Total Count:', totalCount);
    res.send(results);
  } catch (error) {
    console.error(error);
    res.status(500).json({ error: 'Internal Server Error' });
  } finally {
    if(connection){
      connection.release();
      //console.log("Connection released");
    }
  }
});

app.post('/getattritiondate', (req, res) => {
const fromdate = req.body.fromdate;
const fdParts = fromdate.split('-');
const fd = `${fdParts[2]}-${fdParts[1]}-${fdParts[0]}`;

const dateObj = new Date(fromdate);
const day = dateObj.getDate().toString().padStart(2, '0');
const month = (dateObj.getMonth() + 1).toString().padStart(2, '0');
const year = dateObj.getFullYear();

const sdate = `${day}-${month}-${year}`;
console.log('Converted:', sdate);

 const date = new Date().toLocaleDateString('en-GB', { timeZone: 'Africa/Lagos' });
  const parts = date.split('/');
  const formattedDay = parts[0].padStart(2, '0');
  const formattedMonth = parts[1].padStart(2, '0');
  const year1 = parts[2];
  const today = `${formattedDay}-${formattedMonth}-${year1}`;

  console.log('Today:', today);


  // Query to fetch default_date from employees_ota table
  const query1 = 'SELECT * FROM employees_ota ORDER BY id ASC LIMIT 1';
  db.query(query1, (err, result1) => {
    if (err) {
      res.status(500).send('Error retrieving data from employees_ota');
      throw err;
    }
    const defaultDate = result1[0].date;

    // Query to fetch default_date from geopos_employees table
    const query2 = 'SELECT * FROM geopos_employees ORDER BY id ASC LIMIT 1';
    db.query(query2, (err, result2) => {
      if (err) {
        res.status(500).send('Error retrieving data from geopos_employees');
        throw err;
      }
      const defaultDate2 = result2[0].date;

      // Assigning values similar to PHP logic
      const ota = sdate || defaultDate;
      const ikeja = sdate || defaultDate2;

      // Prepare response data
      const data = {
        sdate: sdate,
        today: today,
        tdate: ota,
        tdate2: ikeja
      };

      // Sending the response
      res.json(data);
    });
  });
});


//--------------------------Attendance And Attrition Dashboard----------------------------------/

//----------------------------------Operator Login--------------------------------------------------//
//braid employeetimesheet
/**
 * @swagger
 * /employee_detailso/{id}:
 *   get:
 *     summary: Fetch details of an employee with the specified ID from the operator_assign_ikeja table.
 *     description: Retrieves details of an employee with the specified ID from the operator_assign_ikeja table.
 *     tags:
 *       - Employee Management
 *     security:
 *       - BearerAuth: []
 *     parameters:
 *       - in: path
 *         name: id
 *         description: ID of the employee to fetch details for.
 *         required: true
 *         schema:
 *           type: integer
 *     responses:
 *       200:
 *         description: Details of the employee fetched successfully.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *       500:
 *         description: Error occurred while fetching details of the employee.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: Internal Server Error
 * @function
 * @name fetchEmployeeDetailsO
 * @memberof module:Routes/EmployeeManagement
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with executing the MySQL query.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
//add
app.get('/employee_detailso/:id', authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    const id = req.params.id;

    // Perform the database query
    const query = `
      SELECT *
      FROM operator_assign_ikeja
      WHERE operator_id = ? AND category_type = 'BRAID';
    `;

    const results = await executeQuery(connection,query, [id]);
    res.json(results);
  } catch (err) {
    console.error('Error executing MySQL query:', err);
    res.status(500).json({ error: 'Internal Server Error' });
  } finally {
    if (connection) {
      connection.release();
    }
  }
});


// Define the API endpoint
/**
 * @swagger
 * /employee_detailso_nb/{id}:
 *   get:
 *     summary: Fetch details of an employee with the specified ID from the operator_assign table.
 *     description: Retrieves details of an employee with the specified ID from the operator_assign table where the category_type is 'BRAID'.
 *     tags:
 *       - Employee Management
 *     security:
 *       - BearerAuth: []
 *     parameters:
 *       - in: path
 *         name: id
 *         description: ID of the employee to fetch details for.
 *         required: true
 *         schema:
 *           type: integer
 *     responses:
 *       200:
 *         description: Details of the employee fetched successfully.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *       500:
 *         description: Error occurred while fetching details of the employee.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: Internal Server Error
 * @function
 * @name fetchEmployeeDetailsONb
 * @memberof module:Routes/EmployeeManagement
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with executing the MySQL query.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
app.get('/employee_detailso_nb/:id', authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    const id = req.params.id;

    // Perform the database query
    const query = `
      SELECT *
      FROM operator_assign
      WHERE operator_id = ? AND category_type = 'BRAID';
    `;
     
    const results = await executeQuery(connection,query, [id]);
    res.json(results);
  } catch (err) {
    console.error('Error executing MySQL query:', err);
    res.status(500).json({ error: 'Internal Server Error' });
  } finally {
    if (connection) {
      connection.release();
    }
  }
});


// Define the API endpoint
/**
 * @swagger
 * /employee_details_nbraid/{id}:
 *   get:
 *     summary: Fetch details of an employee with the specified ID from the employees_ota table.
 *     description: Retrieves details of an employee with the specified ID from the employees_ota table, along with additional information from the geopos_users table.
 *     tags:
 *       - Employee Management
 *     security:
 *       - BearerAuth: []
 *     parameters:
 *       - in: path
 *         name: id
 *         description: ID of the employee to fetch details for.
 *         required: true
 *         schema:
 *           type: integer
 *     responses:
 *       200:
 *         description: Details of the employee fetched successfully.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *       404:
 *         description: Employee not found.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: Employee not found
 *       500:
 *         description: Error occurred while fetching details of the employee.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: Internal Server Error
 * @function
 * @name fetchEmployeeDetailsNBraid
 * @memberof module:Routes/EmployeeManagement
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with executing the MySQL query.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
app.get('/employee_details_nbraid/:id', authenticateJWT, async (req, res) => {
  let connection;
  try {  
    connection = await getPoolConnection();
    const id = req.params.id;
    // Perform the database query
    const query = `
      SELECT employees_ota.*, geopos_users.email, geopos_users.loc, geopos_users.roleid
      FROM employees_ota
      LEFT JOIN geopos_users ON employees_ota.entryid = geopos_users.entryid
      WHERE geopos_users.id = ? AND geopos_users.production_type = 'ota' AND geopos_users.banned = '0';
    `;

    const result = await executeQuery(connection, query, [id]);

    if (result.length > 0) {
      res.json(result[0]); // Assuming you want to return the first row if there are multiple matches
    } else {
      res.status(404).json({ error: 'Employee not found' });
    }
  } catch (err) {
    console.error('Error executing MySQL query:', err);
    res.status(500).json({ error: 'Internal Server Error' });
  } finally {
    if (connection) {
      connection.release();
    }
  }
});


// Define the API endpoint
/**
 * @swagger
 * /employee_details/{id}:
 *   get:
 *     summary: Fetch details of an employee with the specified ID from the geopos_employees table.
 *     description: Retrieves details of an employee with the specified ID from the geopos_employees table, along with additional information from the geopos_users table.
 *     tags:
 *       - Employee Management
 *     security:
 *       - BearerAuth: []
 *     parameters:
 *       - in: path
 *         name: id
 *         description: ID of the employee to fetch details for.
 *         required: true
 *         schema:
 *           type: integer
 *     responses:
 *       200:
 *         description: Details of the employee fetched successfully.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 timesheet:
 *                   type: object
 *       404:
 *         description: Employee not found.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: Employee not found
 *       500:
 *         description: Error occurred while fetching details of the employee.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: Internal Server Error
 * @function
 * @name fetchEmployeeDetails
 * @memberof module:Routes/EmployeeManagement
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with executing the MySQL query.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
app.get('/employee_details/:id', authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    const id = req.params.id;

    // Perform the database query
    const query = `
      SELECT geopos_employees.*, geopos_users.email, geopos_users.loc, geopos_users.roleid
      FROM geopos_employees
      LEFT JOIN geopos_users ON geopos_employees.entryid = geopos_users.entryid
      WHERE geopos_users.id = ? AND geopos_users.production_type = 'ikeja' AND geopos_users.banned = '0';
    `;

    const result = await executeQuery(connection, query, [id]);

    if (result.length > 0) {
      const employeeData = result[0];
      const response = {
        timesheet: employeeData,
      };
      res.json(response);
    } else {
      res.status(404).json({ error: 'Employee not found' });
    }
  } catch (err) {
    console.error('Error executing MySQL query:', err);
    res.status(500).json({ error: 'Internal Server Error' });
  } finally {
    if (connection) {
      connection.release();
      //console.log("Connection released");
    }
  }
});


//get sections for operator login
/**
 * @swagger
 * /getsectionsforaddemployeeoplogin:
 *   post:
 *     summary: Get sections for adding employees for operator login.
 *     description: Retrieves sections for adding employees for operator login based on the provided parameters.
 *     tags:
 *       - Employee
 *     security:
 *       - BearerAuth: []
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             properties:
 *               product_name:
 *                 type: string
 *                 description: The product name.
 *               color_description:
 *                 type: string
 *                 description: The color description.
 *               zone:
 *                 type: string
 *                 description: The zone.
 *               shift:
 *                 type: string
 *                 description: The shift.
 *               machine:
 *                 type: string
 *                 description: The machine.
 *     responses:
 *       200:
 *         description: Successful response containing the sections for adding employees.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 pr:
 *                   type: string
 *                   description: The sections for adding employees.
 *                 ab:
 *                   type: string
 *                   description: The absent employees.
 *       500:
 *         description: Internal Server Error.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: "Internal Server Error"
 *
 * @function
 * @name getSectionsForAddEmployeeOpLogin
 * @memberof module:Routes/Employee
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with the database query.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
app.post('/getsectionsforaddemployeeoplogin',  authenticateJWT, (req, res) => {  
  let zone, shift, machine, cat, color;
  if (req.body) {
    cat = req.body.product_name;
    color = req.body.color_description;
    
    zone = req.body.zone;
    shift = req.body.shift;
    machine = req.body.machine + ',';
  }
  
  console.log('cat:', cat);
  console.log('Zone:', zone);
  console.log('Shift:', shift);
  console.log('Machine:', machine); 

  const date = new Date().toLocaleDateString('en-GB', { timeZone: 'Africa/Lagos' });
  const parts = date.split('/');
  const formattedDay = parts[0].padStart(2, '0');
  const formattedMonth = parts[1].padStart(2, '0');
  const year = parts[2];
  const date1 = `${formattedDay}-${formattedMonth}-${year}`;

  const query = 'SELECT * FROM item_section_ota WHERE item_id = ?';

  site = 'ikeja';
  ctype = 'BRAID';

  db.query(query, [cat], (error, results) => {
    if (error) {
      console.error('Error in initial query:', error);
      return res.status(500).json({ error: 'Internal Server Error' });
    }

    let output = '';
    let absent = '';
    let resolvedPromises = [];

    

    const processResults = (row, querya, querye) => {
      return new Promise((resolve, reject) => {
        db.query(querya, (errora, resultsa) => {
          if (errora) return reject(errora);

          resultsa.forEach(rowa => {
            absent += rowa.entryid + ',';
          });

          db.query(querye, (errore, resultse) => {
            if (errore) return reject(errore);

            //console.log('Result of querye:', resultse);

            const sectionQuery = `SELECT * FROM section WHERE id = ${row.section_id}`;
            db.query(sectionQuery, (errorSection, resultSection) => {
              if (errorSection) return reject(errorSection);

              const section = resultSection[0].section_name;
              const target = row.target;

              resultse.forEach(roww => {
              // Add section_name and target to the current row
              roww.section_name = resultSection[0].section_name;
              roww.target = row.target;

              // Add the modified row to the output array
              output += JSON.stringify(roww, null, 2);
              });

              resolve();
            });
          });
        });
      });
    };

    const sendResponseIfDone = () => {
      if (resolvedPromises.length === results.length) {
        const dataArray = {
          pr: output.replace(/\n/g, ''),
          ab: absent
        };
        //console.log('Sending response:', dataArray);
        res.json(dataArray);
      }
    };

    const promises = results.map(row => {
      let wherea, where, querya, querye;

      if (site === 'ota' && ctype =='BRAID') {
        wherea = `roleid != 3 AND zone='${zone}' AND shift='${shift}' AND machine LIKE '%${machine}%' AND status='A' AND workertype='DIRECT'`;
        where = `roleid != 3 AND zone='${zone}' AND shift='${shift}' AND machine LIKE '%${machine}%' AND status='P' AND workertype='DIRECT'`;
        querya = `SELECT * FROM employees_ota WHERE ${wherea} AND section_id = ${row.section_id}`;
        querye = `SELECT * FROM employees_ota WHERE ${where} AND section_id = ${row.section_id}`;
      } else if (site === 'ikeja' && ctype =='BRAID') {
        wherea = `roleid != 3 AND zone='${zone}' AND shift='${shift}' AND machine LIKE '%${machine}%' AND status='A' AND workertype='DIRECT'`;
        where = `roleid != 3 AND zone='${zone}' AND shift='${shift}' AND machine LIKE '%${machine}%' AND status='P' AND workertype='DIRECT'`;
        querya = `SELECT * FROM geopos_employees WHERE ${wherea} AND section_id = ${row.section_id}`;
        querye = `SELECT * FROM geopos_employees WHERE ${where} AND section_id = ${row.section_id}`;
      }

      return processResults(row, querya, querye)
        .then(() => {
          resolvedPromises.push(row); // Assuming each promise represents a row
        })
        .catch(error => {
          //console.error('Error processing results:', error);
          res.status(500).json({ error: 'Internal Server Error' });
        });
    });

    Promise.all(promises)
      .then(() => sendResponseIfDone())
      .catch(error => {
        //console.error('Error in Promise.all:', error);
        res.status(500).json({ error: 'Internal Server Error' });
      });
  });
});

//insert employee timesheet data for operator login
/**
 * @swagger
 * /insertemployeetimesheetfilterdataoplogin:
 *   post:
 *     summary: Insert employee timesheet filter data for operator login.
 *     description: Inserts employee timesheet filter data for operator login into the database.
 *     tags:
 *       - Timesheet
 *     security:
 *       - BearerAuth: []
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             properties:
 *               zone:
 *                 type: string
 *                 description: The zone.
 *               machinec:
 *                 type: string
 *                 description: The machine.
 *               shift:
 *                 type: string
 *                 description: The shift.
 *               fdate:
 *                 type: string
 *                 format: date
 *                 description: The formatted date.
 *               additionalProperties:
 *                 type: object
 *                 description: Additional properties.
 *     responses:
 *       200:
 *         description: Successful response indicating successful insertion.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 success:
 *                   type: string
 *                   example: "MySQL operation successful."
 *                 successMessage:
 *                   type: string
 *                   description: The success message.
 *       500:
 *         description: Internal Server Error.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: "MySQL operation failed."
 *                 errorMessage:
 *                   type: string
 *                   description: The error message.
 * @function
 * @name insertEmployeeTimesheetFilterDataOpLogin
 * @memberof module:Routes/Timesheet
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with the MySQL operation.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */

app.post('/insertemployeetimesheetfilterdataoplogin',  authenticateJWT, (req, res) => {
  const receivedData = req.body;
  console.log('Received Form Data:', receivedData);

  const formDataToSend = receivedData[0];
  const { zone, machinec, shift, fdate } = formDataToSend;
  
  const date1 = fdate;
  const fdParts = date1.split('-');
  const fd = `${fdParts[2]}-${fdParts[1]}-${fdParts[0]}`;

  const dateObj = new Date(date1);
  const day = dateObj.getDate().toString().padStart(2, '0');
  const month = (dateObj.getMonth() + 1).toString().padStart(2, '0');
  const year = dateObj.getFullYear();

  const date = `${day}-${month}-${year}`;
  const date2 = `${month}-${year}`;

  const fd2 = Math.floor(new Date(date1).getTime() / 1000);


var dayy1 = fd2;

const originalDate = new Date(fdate);

const year1 = originalDate.getFullYear();
const month1 = String(originalDate.getMonth() + 1).padStart(2, '0');
const day1 = String(originalDate.getDate()).padStart(2, '0');
const hour = '12';
const minute = '00';
const second = '00';

const date3 = `${year1}-${month1}-${day1} ${hour}:${minute}:${second}`;


console.log('Date:', date);
console.log('date2:', date2);
console.log('dayy1:', dayy1);
console.log('date3:', date3);

 /* const dayy1 = '1700524800';
  const date2 = '11-2023';
  const date3 = '2023-11-21 12:00:00';*/

  const tableRowsData = receivedData.slice(1);

  const machineCondition = `machine LIKE '%${machinec}%'`;
  const whereConditionIndirect = `zone='${zone}' AND shift='${shift}' AND ${machineCondition} AND workertype='INDIRECT' AND status='P'`;
  const whereConditionDirect = `zone='${zone}' AND shift='${shift}' AND ${machineCondition} AND workertype='DIRECT' AND status='P'`;

  const queryIndirect = `SELECT * FROM geopos_employees WHERE ${whereConditionIndirect}`;
  const queryDirect = `SELECT * FROM geopos_employees WHERE ${whereConditionDirect}`;

  db.query(queryIndirect, (err, resultIndirect) => {
    if (err) throw err;

    let ire = 0;
    resultIndirect.forEach((ws) => {
      ire += parseInt(ws.emp_count, 10);
    });

    db.query(queryDirect, (err, resultDirect) => {
      if (err) throw err;

      let dre = 0;
      resultDirect.forEach((ws1) => {
        dre += parseInt(ws1.emp_count, 10);
      });

      const combinedData = {
        dataArray: [
          {
            ...formDataToSend,
            indirectCount: ire,
            directCount: dre,
            date,
            dayy1,
            date2,
            date3,
          },
          ...tableRowsData,
        ],
        dataArray1: tableRowsData,
      };

      // Call the function to perform MySQL operations
      performMySQLOperationsoplogin(combinedData, (mysqlErr, mysqlResult) => {
        if (mysqlErr) {
          console.error('MySQL operation failed:', mysqlErr);
      
          res.status(500).json({
            error: 'MySQL operation failed.',
            errorMessage: mysqlErr.message // Include the error message from mysqlErr
          });
        } else {
          res.json({ success: 'MySQL operation successful.', successMessage: mysqlResult });
        }
      });
    });
  });
});


function performMySQLOperationsoplogin(combinedData, callback) {
  // Log dataArray to the console
 // console.log('Received combinedData:', combinedData);

  const { emp_id, shift, item, color_id, zone, machine, machinec, hr_start, hr_end, fiber, fg_output, waste1, waste2, waste3, waste_weight, date, temp0, temp1, temp2, temp3, temp4, temp5, site, indirectCount, directCount, dayy1, date2, date3 } = combinedData.dataArray[0];

  const data = {
    emp_id: emp_id,
    shift: shift,
    item: item,
    color_id: color_id,
    zone: zone,
    machine: machine,
    hr_start: hr_start,
    hr_end: hr_end,
    fiber: fiber,
    fg_output: fg_output,
    waste1: waste1,
    waste2: waste2,
    waste3: waste3,
    waste_weight: waste_weight,
    date: date,
    timestamp: dayy1,
    datetime: date3,
    month: date2,
    iemp_count: indirectCount,
    demp_count: directCount,
    upper: temp0,
    lower: temp1,
    perheating: temp2,
    machine_speed: temp3,
    tension: temp4,
    spreading: temp5,
    site: site,
  };


  
  /* const { emp_ids, worker_names, section, target, section_id, completes } = combinedData.dataArray1;
  const empIdsArray = emp_ids.split(',').map(id => id.trim()); */

  const selectQuery = `SELECT * FROM geopos_operator WHERE hr_start = '${hr_start}' AND zone = '${zone}' AND machine = '${machine}' AND date = '${date}'`;

  console.log('selectQuery:', selectQuery);

  db.query(selectQuery, (selectError, selectResults) => {
    if (selectError) {
      res.json({ status: 'Error', message: 'Database error' });
    } else {
      const numRows = selectResults.length;
      console.log('selectResults:', selectResults);
      console.log('numRows:', numRows);

      if (numRows > 0) {
        const errorMessage = `Sorry, you have already entered ${hr_start} start hour for ${zone} and ${machine} on ${date}`;
        console.log('Error Message:', errorMessage);
        const errorResponse = {
          status: 'Error',
          message: errorMessage,
        };
       // Sending the error response to the client
         return callback(errorResponse);
      } else {
        const insertQuery = 'INSERT INTO geopos_operator SET ?';

        db.query(insertQuery, data, (insertError, insertResults) => {
          if (insertError) {
            res.json({ status: 'Error', message: 'Failed to insert data' });
          }
          else {
            const opid = insertResults.insertId;
            console.log('opid:', opid);
            const dataArray = combinedData.dataArray1;

              for (let i = 0; i < dataArray.length; i++) {
                const { emp_ids, worker_names, section, target, section_id, completes } = dataArray[i];
                const empIdsArray = emp_ids.split(',').map(id => id.trim());
                
                console.log('Emp IDs:', emp_ids);
                console.log('Worker Names:', worker_names);
                console.log('Section:', section);
                console.log('Target:', target);
                console.log('Section ID:', section_id);
                console.log('Completes:', completes);
              

                
            
              if (section) {
                const selectSectionQuery = 'SELECT * FROM geopos_operator ORDER BY id DESC LIMIT 1';

                db.query(selectSectionQuery, (selectSectionError, selectSectionResults) => {
                  const lastOperatorId = selectSectionResults[0].id;
                  console.log('lastOperatorId:', lastOperatorId);

                  //console.log('empIdsArray:', empIdsArray);

                  empIdsArray.forEach((emid, index) => {
                    const comp = completes;
                    console.log(`Before data1 construction (Index ${index}):`, worker_names, section_id, target);


                    const data1 = {
                      empid: emid,
                      opmanual_id: `${lastOperatorId},`,
                      section_id: section_id,
                      emp: worker_names,
                      target: target,
                      complete: `${comp},`,
                      date,
                      timestamp: dayy1,
                    };

                    console.log(`data1 (Index ${index}):`, data1);

                    const selectOperatorSectionQuery = 'SELECT * FROM operator_section WHERE empid = ? AND date = ?';
                    const selectOperatorSectionValues = [emid, date];

                    db.query(
                      selectOperatorSectionQuery,
                      selectOperatorSectionValues,
                      (selectOSQueryError, selectOSQueryResults) => {
                        const numOSRows = selectOSQueryResults.length;

                        if (numOSRows > 0) {
                          const cid = selectOSQueryResults[0].id;
                          const op = `${selectOSQueryResults[0].opmanual_id}${opid},`;
                          const cm = `${selectOSQueryResults[0].complete}${comp},`;

                          const updateOperatorSectionQuery =
                            'UPDATE operator_section SET opmanual_id = ?, complete = ? WHERE id = ?';
                          const updateOperatorSectionValues = [op, cm, cid];

                          db.query(
                            updateOperatorSectionQuery,
                            updateOperatorSectionValues,
                            (updateOSError) => {
                              if (updateOSError) {
                                console.error(updateOSError);
                              }
                            }
                          );
                        } else {
                          const insertOperatorSectionQuery = 'INSERT INTO operator_section SET ?';

                          db.query(
                            insertOperatorSectionQuery,
                            data1,
                            (insertOSQueryError) => {
                              if (insertOSQueryError) {
                                console.error(insertOSQueryError);
                              }
                            }
                          );
                        }
                      }
                    );
                  });
                });
              }
            } 
            // Send success message to the client
            const successMessage = 'Details added successfully!';
            return callback(null, successMessage);
          }
        });
      }
    }
  });
}

// Get the default employee data for current date
/**
 * @swagger
 * /getdefaultemployeetimesheetdatabraidoplogin/{userid}:
 *   get:
 *     summary: Get default employee timesheet data for BRAID operator login.
 *     description: Retrieves default employee timesheet data for a BRAID operator login based on the user ID.
 *     tags:
 *       - Timesheet
 *     security:
 *       - BearerAuth: []
 *     parameters:
 *       - in: path
 *         name: userid
 *         required: true
 *         description: The ID of the user.
 *         schema:
 *           type: integer
 *     responses:
 *       200:
 *         description: Successful response containing the default employee timesheet data.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 timesheet:
 *                   type: array
 *                   description: An array of timesheet data for the user.
 *                   items:
 *                     type: object
 *                     properties:
 *                       id:
 *                         type: integer
 *                         description: The ID of the timesheet entry.
 *                       name:
 *                         type: string
 *                         description: The name of the employee.
 *                       entryid:
 *                         type: integer
 *                         description: The entry ID of the employee.
 *                       workertype:
 *                         type: string
 *                         description: The type of worker.
 *                       item_description:
 *                         type: string
 *                         description: The description of the item.
 *                       color_name:
 *                         type: string
 *                         description: The name of the color.
 *       500:
 *         description: Internal Server Error.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: "An error occurred while processing your request."
 *
 * @function
 * @name getDefaultEmployeeTimesheetDataBraidOpLogin
 * @memberof module:Routes/Timesheet
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with the database query.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
app.get('/getdefaultemployeetimesheetdatabraidoplogin/:userid',  authenticateJWT, (req, res) => {
  const roleid = 3;
  const { userid } = req.params;

  const date = new Date().toLocaleDateString('en-GB', { timeZone: 'Africa/Lagos' });
  const parts = date.split('/');
  const formattedDay = parts[0].padStart(2, '0');
  const formattedMonth = parts[1].padStart(2, '0');
  const year = parts[2];
  const date1 = `${formattedDay}-${formattedMonth}-${year}`;

  console.log('Received data:');
  console.log('Date:', date1);
  console.log('userid:', userid);

  let query;

  if (roleid === 5) {
    const query1 = `
      SELECT geopos_operator.*, geopos_employees.name, geopos_employees.entryid, geopos_employees.workertype, item_masterr.item_description, color_master.color_name
      FROM geopos_operator
      LEFT JOIN geopos_employees ON geopos_employees.id = geopos_operator.emp_id
      LEFT JOIN item_masterr ON geopos_operator.item = item_masterr.id
      LEFT JOIN color_master ON geopos_operator.color_id = color_master.id
      WHERE geopos_operator.date = ? AND geopos_operator.site = 'ikeja'
    `;

    const query2 = `
      SELECT geopos_operator.*, employees_ota.name, employees_ota.entryid, employees_ota.workertype, item_masterr.item_description, color_master.color_name
      FROM geopos_operator
      LEFT JOIN employees_ota ON employees_ota.id = geopos_operator.emp_id
      LEFT JOIN item_masterr ON geopos_operator.item = item_masterr.id
      LEFT JOIN color_master ON geopos_operator.color_id = color_master.id
      WHERE geopos_operator.date = ? AND geopos_operator.site = 'ota'
    `;

    query = `${query1} UNION ${query2}`;
  } else {
    const id2 = userid;

    db.query('SELECT * FROM geopos_users WHERE id = ?', [id2], (err, userData) => {
      if (err) {
        console.error('Error querying the database:', err);
        res.status(500).json({ error: 'Internal Server Error' });
        return;
      }

      const site = userData[0].production_type;
      const ctype = userData[0].category_type;

      console.log('site:', site);
      console.log('ctype:', ctype);

      if (site === 'ikeja' && ctype === 'BRAID') {
        const userQuery = `
          SELECT geopos_employees.*
          FROM geopos_employees
          LEFT JOIN geopos_users ON geopos_employees.entryid = geopos_users.entryid
          WHERE geopos_users.id = ?;
        `;

        db.query(userQuery, [id2], (err, rows) => {
          if (err) {
            console.error('Error querying the database:', err);
            res.status(500).json({ error: 'Internal Server Error' });
            return;
          }

          const id = rows[0].id;
          const query = `
            SELECT geopos_operator.*, geopos_employees.name, geopos_employees.entryid, geopos_employees.workertype, item_masterr.item_description, color_master.color_name
            FROM geopos_operator
            LEFT JOIN geopos_employees ON geopos_employees.id = geopos_operator.emp_id
            LEFT JOIN item_masterr ON item_masterr.id = geopos_operator.item
            LEFT JOIN color_master ON color_master.id = geopos_operator.color_id
            WHERE geopos_operator.date = ? AND geopos_operator.emp_id = ?
            ORDER BY id DESC
            LIMIT 1
          `;

          db.query(query, [date1, id], (err, results) => {
            if (err) {
              console.error('Error executing SQL query:', err);
              res.status(500).json({ error: 'Internal server error' });
            } else {
              const data = {
                timesheet: results,
              };
              res.json(data);
            }
          });
        });
      }

      if (site === 'ota' && ctype === 'BRAID') {
        db.query(
          'SELECT employees_ota.* FROM employees_ota ' +
            'LEFT JOIN geopos_users ON employees_ota.entryid = geopos_users.entryid ' +
            'WHERE geopos_users.id = ?',
          [id2],
          (err, result) => {
            if (err) {
              console.error('Error querying the database:', err);
              res.status(500).json({ error: 'Internal Server Error' });
              return;
            }

            const id = result[0].id;
            const query = `
              SELECT geopos_operator.*, employees_ota.name, employees_ota.entryid, employees_ota.workertype, item_masterr.item_description, color_master.color_name
              FROM geopos_operator
              LEFT JOIN employees_ota ON employees_ota.id = geopos_operator.emp_id
              LEFT JOIN item_masterr ON item_masterr.id = geopos_operator.item
              LEFT JOIN color_master ON color_master.id = geopos_operator.color_id
              WHERE geopos_operator.date = ? AND geopos_operator.emp_id = ?
              ORDER BY id DESC
              LIMIT 1
            `;

            db.query(query, [date1, id], (err, results) => {
              if (err) {
                console.error('Error executing SQL query:', err);
                res.status(500).json({ error: 'Internal server error' });
              } else {
                const data = {
                  timesheet: results,
                };
                res.json(data);
              }
            });
          }
        );
      }
    });
  }

});


//----------------------------------Operator Login--------------------------------------------------//


/**
 * @swagger
 * /updatetimesheet:
 *   post:
 *     summary: Update timesheet data.
 *     description: Updates a specific field in the timesheet data for a given entry ID.
 *     tags:
 *       - Timesheet
 *     security:
 *       - BearerAuth: []
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             properties:
 *               id:
 *                 type: integer
 *                 description: The ID of the timesheet entry to be updated.
 *                 example: 123
 *               field:
 *                 type: string
 *                 description: The field to be updated in the timesheet entry.
 *                 example: "HOUR1"
 *               value:
 *                 type: number
 *                 description: The new value for the specified field.
 *                 example: 8
 *     responses:
 *       200:
 *         description: Successful response indicating the timesheet entry was updated.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 message:
 *                   type: string
 *                   example: "updated successfully."
 *       500:
 *         description: Internal Server Error.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: "An error occurred while processing your request."
 *
 * @function
 * @name updateTimesheet
 * @memberof module:Routes/Timesheet
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with the database query.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
app.post('/updatetimesheet', authenticateJWT, async (req, res) => {
  // The JSON data sent from the client will be available in req.body
  const dataReceived = req.body;
  // Access the 'id' from the received data
  const id = dataReceived.id;
  const field = dataReceived.field;
  let value = dataReceived.value;
 let connection;
  try {
    connection = await getPoolConnection();
    if (value === '' || value === null || value === undefined) {
      value = 0;
      console.log('Value is empty, null, or undefined');
    }

    console.log('id:', id);
    console.log('field:', field);
    console.log('value:', value);

    const query = `UPDATE worker_timesheet SET ${field}=${value} WHERE id=${id}`;
    console.log(query);

    // Execute the query with await
    const result = await executeQuery(connection,query);

    console.log(result);
    res.json({ message: 'updated successfully.' });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: 'An error occurred while processing your request.' });
  } finally {
    if (connection) {
      connection.release();
    }
  }
});


//Performance eff individual Report 
/**
 * @swagger
 * /report/nbraid/getEmployeesikeja:
 *   get:
 *     summary: Get a list of employees from the Ikeja site.
 *     description: Retrieves a list of employees who have records in the worker_timesheet table for the Ikeja site, grouped by entry_id and ordered by worker name in ascending order.
 *     tags:
 *       - Employees
 *     security:
 *       - BearerAuth: []
 *     responses:
 *       200:
 *         description: Successful response with a list of employees.
 *         content:
 *           application/json:
 *             schema:
 *               type: array
 *               items:
 *                 type: object
 *                 properties:
 *                   entry_id:
 *                     type: string
 *                     description: The entry ID of the employee.
 *                     example: "12345"
 *                   worker:
 *                     type: string
 *                     description: The name of the worker.
 *                     example: "John Doe"
 *                   site:
 *                     type: string
 *                     description: The site of the worker.
 *                     example: "ikeja"
 *                   date_time:
 *                     type: string
 *                     format: date-time
 *                     description: The date and time of the timesheet entry.
 *                     example: "2023-05-31T12:34:56Z"
 *                   shift:
 *                     type: string
 *                     description: The shift of the worker.
 *                     example: "Morning"
 *                   product_name:
 *                     type: string
 *                     description: The product name associated with the entry.
 *                     example: "Product 1"
 *                   line:
 *                     type: string
 *                     description: The line associated with the entry.
 *                     example: "Line A"
 *                   section:
 *                     type: string
 *                     description: The section associated with the entry.
 *                     example: "Section B"
 *       500:
 *         description: Internal Server Error.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: "Internal Server Error"
 *
 * @function
 * @name getEmployeesIkeja
 * @memberof module:Routes/Employees
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with the database query.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
app.get('/report/nbraid/getEmployeesikeja', authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    const result = await executeQuery('SELECT * FROM worker_timesheet WHERE site="ikeja" GROUP BY entry_id ORDER BY worker ASC');
    res.send(result);
  } catch (err) {
    console.error('Error executing MySQL query:', err);
    res.status(500).send('Internal Server Error');
  } finally {
    if (connection) {
      connection.release();
    }
  }
});

/**
 * @swagger
 * /report/nbraid/getEmployeesota:
 *   get:
 *     summary: Get a list of employees from the OTA site.
 *     description: Retrieves a list of employees who have records in the worker_timesheet table for the OTA site, grouped by entry_id and ordered by worker name in ascending order.
 *     tags:
 *       - Employees
 *     security:
 *       - BearerAuth: []
 *     responses:
 *       200:
 *         description: Successful response with a list of employees.
 *         content:
 *           application/json:
 *             schema:
 *               type: array
 *               items:
 *                 type: object
 *                 properties:
 *                   entry_id:
 *                     type: string
 *                     description: The entry ID of the employee.
 *                     example: "12345"
 *                   worker:
 *                     type: string
 *                     description: The name of the worker.
 *                     example: "John Doe"
 *                   site:
 *                     type: string
 *                     description: The site of the worker.
 *                     example: "ota"
 *                   date_time:
 *                     type: string
 *                     format: date-time
 *                     description: The date and time of the timesheet entry.
 *                     example: "2023-05-31T12:34:56Z"
 *                   shift:
 *                     type: string
 *                     description: The shift of the worker.
 *                     example: "Morning"
 *                   product_name:
 *                     type: string
 *                     description: The product name associated with the entry.
 *                     example: "Product 1"
 *                   line:
 *                     type: string
 *                     description: The line associated with the entry.
 *                     example: "Line A"
 *                   section:
 *                     type: string
 *                     description: The section associated with the entry.
 *                     example: "Section B"
 *       500:
 *         description: Internal Server Error.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: "Internal Server Error"
 *
 * @function
 * @name getEmployeesOta
 * @memberof module:Routes/Employees
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with the database query.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
app.get('/report/nbraid/getEmployeesota', authenticateJWT, async (req, res) => {
  let connection;
  try {
   connection = await getPoolConnection();
    const result = await executeQuery(connection,'SELECT * FROM worker_timesheet WHERE site="ota" GROUP BY entry_id ORDER BY worker ASC');
    res.send(result);
  } catch (err) {
    console.error('Error executing MySQL query:', err);
    res.status(500).send('Internal Server Error');
  } finally {
    if (connection) {
      connection.release();
    }
  }
});



//Get assign operator worker list
/**
 * @swagger
 * /get_assigned_zone_machine/{userid}:
 *   get:
 *     summary: Get assigned zone and machine details for a specific user.
 *     description: Retrieves assigned zone and machine details for a specified user based on the provided parameters.
 *     tags:
 *       - Assignments
 *     parameters:
 *       - in: path
 *         name: userid
 *         schema:
 *           type: string
 *         required: true
 *         description: The ID of the user.
 *       - in: query
 *         name: ptype
 *         schema:
 *           type: string
 *         required: true
 *         description: The type of plant (e.g., 'ikeja', 'ota').
 *       - in: query
 *         name: ctype
 *         schema:
 *           type: string
 *         required: true
 *         description: The category type (e.g., 'BRAID', 'NBRAID').
 *     responses:
 *       200:
 *         description: Successful response with assigned zone and machine details.
 *         content:
 *           application/json:
 *             schema:
 *               type: array
 *               items:
 *                 type: object
 *                 properties:
 *                   shift:
 *                     type: string
 *                     description: The shift of the assignment.
 *                     example: "Morning"
 *                   line:
 *                     type: string
 *                     description: The line of the assignment.
 *                     example: "Line 1"
 *                   section_name:
 *                     type: string
 *                     description: The name of the section.
 *                     example: "Section A"
 *                   operator_id:
 *                     type: string
 *                     description: The ID of the operator (for ikeja queries).
 *                     example: "123"
 *                   category_type:
 *                     type: string
 *                     description: The category type of the assignment (for ikeja queries).
 *                     example: "BRAID"
 *       500:
 *         description: Internal Server Error.
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 error:
 *                   type: string
 *                   example: "Internal Server Error"
 *
 * @function
 * @name getAssignedZoneMachine
 * @memberof module:Routes/Assignments
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with the database query.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
app.get('/get_assigned_zone_machine/:userid', authenticateJWT, async (req, res) => {
  const { userid } = req.params;
  const { ptype, ctype } = req.query;

  //console.log('Received request with the following parameters:');
 // console.log('userid:', userid);
  //console.log('ptype:', ptype);
  //console.log('ctype:', ctype); 

  let query;
  let connection;
  if (ptype === 'ikeja' && ctype === 'BRAID') {
    query = `
      SELECT *
      FROM operator_assign_ikeja
      WHERE operator_id = ? AND category_type = 'BRAID';
    `;
  } else if (ptype === 'ikeja' && ctype === 'NBRAID') {
    // Define query for ikeja and NBRAID
    query = `
      SELECT *
      FROM operator_assign_ikeja
      WHERE operator_id = ? AND category_type = 'NBRAID';
    `;
  } else if (ptype === 'ota' && ctype === 'BRAID') {
    // Define query for otherType and otherCategory
    query = `
      SELECT operator_assign.shift, operator_assign.line, section.section_name 
      FROM operator_assign 
      LEFT JOIN section ON operator_assign.section = section.id 
      WHERE name_id=? AND category_type = 'BRAID';
    `;
  } else {
    // Default query if no specific conditions match
    query = `
      SELECT operator_assign.shift, operator_assign.line, section.section_name 
      FROM operator_assign  
      LEFT JOIN section ON operator_assign.section = section.id 
      WHERE name_id=? AND category_type = 'NBRAID';
    `;
  }

  try {
    connection = await getPoolConnection();
    // Execute the constructed query
    const results = await executeQuery(connection,query, [userid]);
    console.log('results:', results);
    res.json(results);
  } catch (err) {
    console.error('Error executing query:', err);
    res.status(500).json({ error: 'Internal Server Error' });
  } finally {
    if (connection) {
      connection.release();
    }
  }
});

/*TV Display*/

//SOP & Safety

// Define the endpoint to fetch SOP data
app.get('/sop', authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    const query = "SELECT * FROM sop_safety";
    const result = await executeQuery(connection,query);
    res.send(result);
    console.log(result);
    console.log('Connected!');
  } catch (error) {
    console.error('Error:', error);
    res.status(500).json({ message: "An error occurred" });
  } finally {
    if (connection) {
      connection.release();
    }
  }
});


// delete sop by ID
app.delete('/sopdelete/:id', authenticateJWT, async (req, res) => {
  let connection;
  try {
    connection = await getPoolConnection();
    const id = req.params.id;
    const query = 'DELETE FROM sop_safety WHERE id = ?';
    const result = await executeQuery(connection, query, [id]);

    console.log(result);
    res.json({ message: 'SOP deleted successfully.' });
  } catch (error) {
    console.error(error);
    res.status(500).json({ error: 'An error occurred while deleting the SOP.' });
  } finally {
    if (connection) {
      connection.release();
    }
  }
});

// Add new SOP endpoint
app.post('/addsop', (req, res) => {
  const { file_type, title, embed_code } = req.body;

  // Debugging console logs
  console.log('file_type:', file_type);
  console.log('embed_code:', embed_code); // Corrected variable name
  console.log('title:', title);

  const date = new Date().toLocaleDateString('en-GB', { timeZone: 'Africa/Lagos' });
  const parts = date.split('/');
  const formattedDay = parts[0].padStart(2, '0');
  const formattedMonth = parts[1].padStart(2, '0');
  const year = parts[2];
  const date1 = `${formattedDay}-${formattedMonth}-${year}`;

  const data = {
    file_type: file_type,
    title: title,
    embedded_code: embed_code,
    date: date1,
  };

  // Insert data into MySQL
  db.query('INSERT INTO sop_safety SET ?', data, (err, results) => {
    if (err) {
      console.error('Error inserting data into MySQL: ' + err.stack);
      res.status(500).json({ error: 'Internal server error' });
      return;
    }
    
    // Data inserted successfully
    res.status(200).json({ message: 'Document Uploaded Successfully' });
  });
});

app.get('/viewsop', (req, res) => {
  const catid = req.query.id; // Use req.query.id to get the query parameter

  if (!catid) {
    return res.status(400).json({ error: 'Missing id parameter' });
  }

  const query = 'SELECT * FROM sop_safety WHERE id = ?';

  db.query(query, [catid], (err, results) => {
    if (err) {
      console.error('Error executing query: ', err.stack);
      return res.status(500).json({ error: 'Internal server error' });
    }

    if (results.length === 0) {
      return res.status(404).json({ error: 'SOP not found' });
    }

    res.json(results); // Respond with the results
  });
});


// Configure Multer for file upload
const storage2 = multer.diskStorage({
  destination: function (req, file, cb) {
    cb(null, 'sopuploads/');
  },
  filename: function (req, file, cb) {
    const uniqueSuffix = Date.now() + '-' + Math.round(Math.random() * 1E9);
    cb(null, uniqueSuffix + path.extname(file.originalname));
  }
});

const upload2 = multer({ storage: storage2 });

 // Log __dirname to ensure it points to the correct directory
console.log(__dirname); // Should log the path up to F:\NIGERIA\server

// Serve static files from the 'uploads' directory
app.use('/uploads', express.static(path.join(__dirname, 'sopuploads')));



// Express route for file upload
app.post('/adddocument', upload2.fields([{ name: 'image_file', maxCount: 1 }, { name: 'pdf_file', maxCount: 1 }]), (req, res) => {
  const file_type = req.body.file_type;
  const title = req.body.title;
  let imageFilename = null;
  let pdfFilename = null;

  // Check if an image file is uploaded
  if (req.files['image_file'] && req.files['image_file'][0]) {
    imageFilename = req.files['image_file'][0].filename;
  }

  // Check if a PDF file is uploaded
  if (req.files['pdf_file'] && req.files['pdf_file'][0]) {
    pdfFilename = req.files['pdf_file'][0].filename;
  }

  const date = new Date().toLocaleDateString('en-GB', { timeZone: 'Africa/Lagos' });
  const parts = date.split('/');
  const formattedDay = parts[0].padStart(2, '0');
  const formattedMonth = parts[1].padStart(2, '0');
  const year = parts[2];
  const date1 = `${formattedDay}-${formattedMonth}-${year}`;

  const query = "INSERT INTO sop_safety (file_type, title, file_name, date) VALUES (?, ?, ?, ?)";
  db.query(query, [file_type, title, imageFilename || pdfFilename, date1], (err, results) => {
    if (err) {
      console.error('Error storing files in database: ' + err.message);
      res.status(500).send('Error storing files in database');
    } else {
      res.json({
        response: 1,
        responsetext: 'Documents Uploaded Successfully.',
        image_file: imageFilename,
        pdf_file: pdfFilename
      });
    }
  });
});







//---------------------------------Get Attendance----------------------------------------//
const conConfig1 = {
  connectionLimit: 10,
  host: '197.255.216.211',
  user: 'lorna',
  password: 'lorna123',
  database: 'access'
};
const con1 = mysql.createConnection(conConfig1);
con1.connect(err => {
  if (err) {
    //console.error('Could not connect to first database:', err);
    process.exit(1);
  }
  //console.log('Connected to the first database');
});

const conConfig2 = {
  connectionLimit: 10,
  host: '197.255.216.212',
  user: 'lorna', // Provide the correct username for the second database
  password: 'lorna123', // Provide the correct password for the second database
  database: 'access',
};

const con2 = mysql.createConnection(conConfig2);
con2.connect(err => {
  if (err) {
    //console.error('Could not connect to second database:', err);
    process.exit(1);
  }
  //console.log('Connected to the second database');
});

//get attendance for lorna and ril
app.get('/getattendance', async (req, res) => {
  try {
    const timezone = 'Africa/Lagos';
    const currentDate = new Date();
    const formatter = new Intl.DateTimeFormat('en-GB', { timeZone: timezone });
    const formattedDate0 = formatter.formatToParts(currentDate).reduce((acc, part) => {
      if (part.type === 'year' || part.type === 'month' || part.type === 'day') {
        acc += part.value;
      }
      return acc;
    }, '');
    const formattedDate1 = `${formattedDate0.substring(4, 8)}${formattedDate0.substring(2, 4)}${formattedDate0.substring(0, 2)}`;
    const formatDateDMY = (date) => {
      const day = date.getDate().toString().padStart(2, '0');
      const month = (date.getMonth() + 1).toString().padStart(2, '0');
      const year = date.getFullYear();
      return `${day}-${month}-${year}`;
    };


    const formattedDate = formatDateDMY(currentDate);

    // Extract month and year in MM-YYYY format
    const extractMonthYear = (date) => {
      const month = (date.getMonth() + 1).toString().padStart(2, '0');
      const year = date.getFullYear();
      return `${month}-${year}`;
    };

    // Get month and year
    const monthYear = extractMonthYear(currentDate);

    const unixTimestamp = currentDate.getTime();

    console.log(formattedDate1);
    console.log(formattedDate);
    console.log(unixTimestamp);
    console.log(`Month: ${monthYear}`); // MM-YYYY

    const [rows] = await queryDatabase(db, `SELECT * FROM employees_ota ORDER BY id ASC LIMIT 1`);
    const erow = rows;
    console.log("erow:", erow);

    if (erow && erow.date !== formattedDate) {
      const updateQuery = `UPDATE employees_ota SET passive_type='RS', status='A', date='${formattedDate}'`;
      await queryDatabase(db, updateQuery);
    }

    // Perform operations on the second database (tuser table)
    const tuserQuery = "SELECT * FROM tuser WHERE PassiveType='ACT' AND dept LIKE 'Ota_%'";
    const tuserResult = await queryDatabase(con1, tuserQuery);

    for (const row of tuserResult) {
      let emp_type = '';

      if (row.idno === 'A - LNL STAFF' || row.idno === 'E - GNL STAFF') {
        emp_type = 'Staff';
      } else if (row.idno === 'M - GNL/LNL CON' || row.idno === 'C - LNL CONTRACT' || row.idno === 'I - GNL CONTRACT') {
        emp_type = 'Contract';
      } else if (row.idno === 'P - FACTORY CASUAL') {
        emp_type = 'Casual';
      } else if (row.idno === 'OUTSOURCING') {
        emp_type = 'Outsourcing';
      }

      const regDate = new Date(row.reg_date.replace(/(\d{4})(\d{2})(\d{2})(\d{2})(\d{2})/, '$1-$2-$3T$4:$5:00'));
      const day = regDate.getDate().toString().padStart(2, '0');
      const month = (regDate.getMonth() + 1).toString().padStart(2, '0');
      const year = regDate.getFullYear();
      const rdate = `${day}-${month}-${year}`;
      //console.log('rdate:', rdate);

      const geoposQuery = `SELECT * FROM employees_ota WHERE entryid='${row.id}'`;
      const geoposResult = await queryDatabase(db, geoposQuery);

      if (geoposResult.length > 0) {
        const updateQuery = `UPDATE employees_ota SET employee_type='${emp_type}', passive_type='${row.PassiveType}', joindate='${rdate}', dept='${row.dept}', name='${row.name}', new_staff='LORNA', staff='LORNA' WHERE entryid='${row.id}'`;
        await queryDatabase(db, updateQuery);
      } else {
        const insertQuery = `INSERT INTO employees_ota (entryid, name, passive_type, workertype, joindate, dept, roleid, staff, category_type, employee_type) VALUES('${row.id}', '${row.name}', '${row.PassiveType}', 'DIRECT', '${rdate}' , '${row.dept}', '1','LORNA','NBRAID', '${emp_type}')`;
        await queryDatabase(db, insertQuery);
      }
    }

     // Perform operations  for ril
     const tuserQuery1 = "SELECT * FROM tuser WHERE PassiveType='ACT' ";
     const tuserResult1 = await queryDatabase(con2, tuserQuery1);
 
     for (const rowr of tuserResult1) {
      const regDate = new Date(rowr.reg_date.replace(/(\d{4})(\d{2})(\d{2})(\d{2})(\d{2})/, '$1-$2-$3T$4:$5:00'));
      const day = regDate.getDate().toString().padStart(2, '0');
      const month = (regDate.getMonth() + 1).toString().padStart(2, '0');
      const year = regDate.getFullYear();
      const rdate = `${day}-${month}-${year}`;
    
      const geoposQuery1 = `SELECT * FROM employees_ota WHERE entryid='${rowr.id}'`;
      const geoposResult1 = await queryDatabase(db, geoposQuery1);
    
      if (geoposResult1.length > 0) {
        const updateQuery3 = `UPDATE employees_ota SET employee_type='Outsourcing', passive_type='${rowr.PassiveType}', joindate='${rdate}', dept='${rowr.dept}', name='${rowr.name}', new_staff='RIL', staff='RIL' WHERE entryid='${rowr.id}'`;
        await queryDatabase(db, updateQuery3);
      } else {
        const insertQuery3 = `INSERT INTO employees_ota (entryid, name, passive_type, workertype, joindate, dept, roleid, staff, category_type, employee_type) VALUES('${rowr.id}', '${rowr.name}', '${rowr.PassiveType}', 'DIRECT', '${rdate}' , '${rowr.dept}', '1','RIL','NBRAID', 'Outsourcing')`;
        await queryDatabase(db, insertQuery3);
      }
    }
    
         

    const attendanceQuery = `SELECT * FROM attendancemigrate WHERE dept LIKE '%OTA%'`;
    const attendanceResult = await queryDatabase(con1, attendanceQuery);

    for (const rowx of attendanceResult) {
      const updateQuery = `UPDATE employees_ota SET status='P', date='${formattedDate}' WHERE entryid='${rowx.id}'`;
      await queryDatabase(db, updateQuery);
    }

    const attendanceQuery1 = `SELECT * FROM attendancemigrate WHERE company LIKE '%OTA%'`;
    const attendanceResult1 = await queryDatabase(con2, attendanceQuery1);

    for (const rowxr of attendanceResult1) {
      const updateQuery1 = `UPDATE employees_ota SET status='P', date='${formattedDate}' WHERE entryid='${rowxr.id}'`;
      await queryDatabase(db, updateQuery1);
    }

    

    const date = new Date().toLocaleDateString('en-GB', { timeZone: 'Africa/Lagos' });
    const parts = date.split('/');
    const formattedDay = parts[0].padStart(2, '0');
    const formattedMonth = parts[1].padStart(2, '0');
    const year = parts[2];
    const date1 = `${formattedDay}-${formattedMonth}-${year}`;
    const mon = `${formattedMonth}-${year}`;

    // Parse the date string into a JavaScript Date object
    const dateObject = new Date(date1.split('-').reverse().join('-'));

    // Calculate the Unix timestamp (Epoch time) in seconds
    const dayy1 = Math.floor(dateObject.getTime() / 1000);

    console.log('dayy1:', dayy1);

    const queries = [
      `SELECT COUNT(*) as li FROM employees_ota WHERE date='${date1}' AND passive_type='ACT' AND roleid='1'`,
      `SELECT COUNT(*) as li FROM employees_ota WHERE date='${date1}' AND status='P' AND passive_type='ACT' AND roleid='1'`,
      `SELECT COUNT(*) as li FROM employees_ota WHERE date='${date1}' AND status='A' AND passive_type='ACT' AND roleid='1'`,
      `SELECT COUNT(*) as li FROM employees_ota WHERE date='${date1}' AND passive_type='ACT' AND roleid='3'`,
      `SELECT COUNT(*) as li FROM employees_ota WHERE date='${date1}' AND status='P' AND passive_type='ACT' AND roleid='3'`,
      `SELECT COUNT(*) as li FROM employees_ota WHERE date='${date1}' AND status='A' AND passive_type='ACT' AND roleid='3'`,
      `SELECT * FROM nigeria_attendance WHERE date='${date1}' AND site='ota'`
    ];

    const [row, row1, row2, rowop, row1op, row2op, resAttendance] = await Promise.all(queries.map(query => queryDatabase(db, query)));

    const totalEmployee = row[0].li;
    const presentEmployee = row1[0].li;
    const absentEmployee = row2[0].li;
    const totalOperator = rowop[0].li;
    const presentOperator = row1op[0].li;
    const absentOperator = row2op[0].li;

    if (resAttendance.length > 0) {
      const updateQuery2 = `
        UPDATE nigeria_attendance
        SET total_employee='${totalEmployee}', present_employee='${presentEmployee}', absent_employee='${absentEmployee}', total_operator='${totalOperator}', abs_operator='${absentOperator}', pr_operator='${presentOperator}'
        WHERE id='${resAttendance[0].id}'
      `;
      await queryDatabase(db, updateQuery2);
      res.json("Yes");
    } else {
      const insertQuery = `
        INSERT INTO nigeria_attendance (total_employee, present_employee, absent_employee, total_operator, abs_operator, pr_operator, site, date, mon, time_stamp)
        VALUES ('${totalEmployee}', '${presentEmployee}', '${absentEmployee}', '${totalOperator}', '${absentOperator}', '${presentOperator}', 'ota', '${date1}', '${mon}', '${dayy1}')
      `;
      await queryDatabase(db, insertQuery);
      res.json("Yes");
    }

    
    //res.json("Yes");
  } catch (error) {
    console.error('Error:', error.message);
    res.json("No");
  } finally {
    con1.end();
    con2.end();
  }
});
function queryDatabase(connection, sql) {
  return new Promise((resolve, reject) => {
    connection.query(sql, (err, result) => {
      if (err) {
        reject(err);
      } else {
        resolve(result);
      }
    });
  });
}

// API endpoint for processing tables
app.get('/process-tables', (req, res) => {
  processTable('employees_ota', 'ota');
  processTable('geopos_employees', 'ikeja');
  res.send('Processing tables...');
});

// Function to process table
function processTable(tableName, site) {
  const date = new Date().toLocaleDateString('en-GB', { timeZone: 'Africa/Lagos' });
  const parts = date.split('/');
  const formattedDay = parts[0].padStart(2, '0');
  const formattedMonth = parts[1].padStart(2, '0');
  const year = parts[2];
  const date1 = `${formattedDay}-${formattedMonth}-${year}`;
  const mon = `${formattedMonth}-${year}`;

  // Parse the date string into a JavaScript Date object
  const dateObject = new Date(date1.split('-').reverse().join('-'));

  // Calculate the Unix timestamp (Epoch time) in seconds
  const dayy1 = Math.floor(dateObject.getTime() / 1000);

  let employeeTypes = ['Contract', 'Casual', 'Outsourcing', 'staff'];
  let categoryTypes = ['NBRAID', 'BRAID'];
  let shifts = ['DAY', 'NIGHT'];

  let values = [];

  shifts.forEach(shift => {
    employeeTypes.forEach(employeeType => {
      categoryTypes.forEach(categoryType => {
        let query1 = `
          SELECT COUNT(*) as Present 
          FROM ${tableName} 
          WHERE date='${date1}' AND status='P' AND workertype='DIRECT' 
          AND employee_type='${employeeType}' AND passive_type='ACT' 
          AND category_type='${categoryType}' AND shift='${shift}'
        `;
        console.log('Executing Present query:', query1);
        db.query(query1, (error, results1, fields) => {
          if (error) {
            console.error('Error executing Present query:', error);
            return;
          }
          console.log('Present query result:', results1);
          let presentCount = results1[0].Present;

          let query2 = `
            SELECT COUNT(*) as Absent 
            FROM ${tableName} 
            WHERE date='${date1}' AND status='A' AND workertype='DIRECT' 
            AND employee_type='${employeeType}' AND passive_type='ACT' 
            AND category_type='${categoryType}' AND shift='${shift}'
          `;
          console.log('Executing Absent query:', query2);
          db.query(query2, (error, results2, fields) => {
            if (error) {
              console.error('Error executing Absent query:', error);
              return;
            }
            console.log('Absent query result:', results2);
            let absentCount = results2[0].Absent;

            let query3 = `
              SELECT COUNT(*) as Active 
              FROM ${tableName} 
              WHERE date='${date1}' AND workertype='DIRECT' 
              AND employee_type='${employeeType}' AND passive_type='ACT' 
              AND category_type='${categoryType}' AND shift='${shift}'
            `;
            console.log('Executing Active query:', query3);
            db.query(query3, (error, results3, fields) => {
              if (error) {
                console.error('Error executing Active query:', error);
                return;
              }
              console.log('Active query result:', results3);
              let activeCount = results3[0].Active;

              values.push([employeeType, activeCount, presentCount, absentCount, site, shift, categoryType, date1, mon, dayy1]);

              if (values.length === shifts.length * employeeTypes.length * categoryTypes.length) {
                console.log('All values:', values);
                insertOrUpdate(values);
              }
            });
          });
        });
      });
    });
  });
}


// Function to insert or update data
function insertOrUpdate(values) {
  let sql = `
    INSERT INTO ng_attendance (employee_status, active, present, absent, site, shift, category_type, date, mon, time_stamp)
    VALUES ?
    ON DUPLICATE KEY UPDATE
      active = VALUES(active),
      present = VALUES(present),
      absent = VALUES(absent)
  `;

  db.query(sql, [values], (error, results, fields) => {
    if (error) {
      console.error('Error inserting data:', error);
      return;
    }
    console.log('Data inserted or updated successfully');
  });
}



//get attendance for ikeja
 app.get('/getattendanceikeja', async (req, res) => {
  try {
    const timezone = 'Africa/Lagos';
    const currentDate = new Date();
    const formatter = new Intl.DateTimeFormat('en-GB', { timeZone: timezone });
    const formattedDate0 = formatter.formatToParts(currentDate).reduce((acc, part) => {
      if (part.type === 'year' || part.type === 'month' || part.type === 'day') {
        acc += part.value;
      }
      return acc;
    }, '');
    const formattedDate1 = `${formattedDate0.substring(4, 8)}${formattedDate0.substring(2, 4)}${formattedDate0.substring(0, 2)}`;
    const formatDateDMY = (date) => {
      const day = date.getDate().toString().padStart(2, '0');
      const month = (date.getMonth() + 1).toString().padStart(2, '0');
      const year = date.getFullYear();
      return `${day}-${month}-${year}`;
    };
    const formattedDate = formatDateDMY(currentDate);

    // Extract month and year in MM-YYYY format
    const extractMonthYear = (date) => {
      const month = (date.getMonth() + 1).toString().padStart(2, '0');
      const year = date.getFullYear();
      return `${month}-${year}`;
    };

    // Get month and year
    const monthYear = extractMonthYear(currentDate);

    const unixTimestamp = currentDate.getTime();

    console.log(formattedDate1);
    console.log(formattedDate);
    console.log(unixTimestamp);
    console.log(`Month: ${monthYear}`); // MM-YYYY

    const [rows] = await queryDatabase(db, `SELECT * FROM geopos_employees ORDER BY id ASC LIMIT 1`);
    const erow = rows;
    console.log("erow:", erow);

    if (erow && erow.date !== formattedDate) {
      const updateQuery = `UPDATE geopos_employees SET passive_type='RS', status='A', date='${formattedDate}'`;
      await queryDatabase(db, updateQuery);
    }

    // Perform operations on the second database (tuser table)
    const tuserQuery = "SELECT * FROM tuser WHERE PassiveType='ACT' AND dept LIKE 'Braid_%'";
    const tuserResult = await queryDatabase(con1, tuserQuery);

    for (const row of tuserResult) {
      let emp_type = '';

      if (row.idno === 'A - LNL STAFF' || row.idno === 'E - GNL STAFF') {
        emp_type = 'Staff';
      } else if (row.idno === 'M - GNL/LNL CON' || row.idno === 'C - LNL CONTRACT' || row.idno === 'I - GNL CONTRACT') {
        emp_type = 'Contract';
      } else if (row.idno === 'P - FACTORY CASUAL') {
        emp_type = 'Casual';
      } else if (row.idno === 'OUTSOURCING') {
        emp_type = 'Outsourcing';
      }

      const geoposQuery = `SELECT * FROM geopos_employees WHERE entryid='${row.id}'`;
      const geoposResult = await queryDatabase(db, geoposQuery);

      if (geoposResult.length > 0) {
        const updateQuery = `UPDATE geopos_employees SET employee_type='${emp_type}', passive_type='${row.PassiveType}', dept='${row.dept}' WHERE entryid='${row.id}'`;
        await queryDatabase(db, updateQuery);
      } else {
        const insertQuery = `INSERT INTO geopos_employees (entryid, name, passive_type, dept, roleid, category_type, employee_type) VALUES('${row.id}', '${row.name}', '${row.PassiveType}', '${row.dept}', '1', 'BRAID', '${emp_type}')`;
        await queryDatabase(db, insertQuery);
      }
    }

    const attendanceQuery = `SELECT * FROM attendancemigrate WHERE dept LIKE '%braid%'`;
    const attendanceResult = await queryDatabase(con1, attendanceQuery);

    for (const rowx of attendanceResult) {
      const updateQuery = `UPDATE geopos_employees SET status='P', date='${formattedDate}' WHERE entryid='${rowx.id}'`;
      await queryDatabase(db, updateQuery);
    }

    
    const date = new Date().toLocaleDateString('en-GB', { timeZone: 'Africa/Lagos' });
    const parts = date.split('/');
    const formattedDay = parts[0].padStart(2, '0');
    const formattedMonth = parts[1].padStart(2, '0');
    const year = parts[2];
    const date1 = `${formattedDay}-${formattedMonth}-${year}`;
    const mon = `${formattedMonth}-${year}`;

    // Parse the date string into a JavaScript Date object
    const dateObject = new Date(date1.split('-').reverse().join('-'));

    // Calculate the Unix timestamp (Epoch time) in seconds
    const dayy1 = Math.floor(dateObject.getTime() / 1000);

    console.log('dayy1:', dayy1);

    const queries = [
      `SELECT COUNT(*) as li FROM geopos_employees WHERE date='${date1}' AND passive_type='ACT' AND roleid='1'`,
      `SELECT COUNT(*) as li FROM geopos_employees WHERE date='${date1}' AND status='P' AND passive_type='ACT' AND roleid='1'`,
      `SELECT COUNT(*) as li FROM geopos_employees WHERE date='${date1}' AND status='A' AND passive_type='ACT' AND roleid='1'`,
      `SELECT COUNT(*) as li FROM geopos_employees WHERE date='${date1}' AND passive_type='ACT' AND roleid='3'`,
      `SELECT COUNT(*) as li FROM geopos_employees WHERE date='${date1}' AND status='P' AND passive_type='ACT' AND roleid='3'`,
      `SELECT COUNT(*) as li FROM geopos_employees WHERE date='${date1}' AND status='A' AND passive_type='ACT' AND roleid='3'`,
      `SELECT * FROM nigeria_attendance WHERE date='${date1}' AND site='ikeja'`
    ];

    const [row, row1, row2, rowop, row1op, row2op, resAttendance] = await Promise.all(queries.map(query => queryDatabase(db, query)));

    const totalEmployee = row[0].li;
    const presentEmployee = row1[0].li;
    const absentEmployee = row2[0].li;
    const totalOperator = rowop[0].li;
    const presentOperator = row1op[0].li;
    const absentOperator = row2op[0].li;

    if (resAttendance.length > 0) {
      const updateQuery2 = `
        UPDATE nigeria_attendance
        SET total_employee='${totalEmployee}', present_employee='${presentEmployee}', absent_employee='${absentEmployee}', total_operator='${totalOperator}', abs_operator='${absentOperator}', pr_operator='${presentOperator}'
        WHERE id='${resAttendance[0].id}'
      `;
      await queryDatabase(db, updateQuery2);
      res.json("Yes");
    } else {
      const insertQuery = `
        INSERT INTO nigeria_attendance (total_employee, present_employee, absent_employee, total_operator, abs_operator, pr_operator, site, date, mon, time_stamp)
        VALUES ('${totalEmployee}', '${presentEmployee}', '${absentEmployee}', '${totalOperator}', '${absentOperator}', '${presentOperator}', 'ikeja', '${date1}', '${mon}', '${dayy1}')
      `;
      await queryDatabase(db, insertQuery);
      res.json("Yes");
    }

    
    //res.json("Yes");
  } catch (error) {
    console.error('Error:', error.message);
    res.json("No");
  } finally {
    con1.end();
  }
});

/**********************************Get Attendance*********************************************/

 app.listen(4000);
console.log("Server Started : http://192.168.29.60:4000"); 

