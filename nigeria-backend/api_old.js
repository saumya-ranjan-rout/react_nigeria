// ETA Nigeria
const mysql = require('mysql');
const db = mysql.createConnection({
    host: 'localhost', 
    user: 'root',
    password: '',
    port: '3306',
    database: 'nigeria2024'
});

module.exports = db;


//const db = require(./db);
const express = require("express");
const cors = require('cors');
const app = express();
//const PORT = 3002;

const bcrypt = require('bcrypt');
const crypto = require('crypto');
const sqlString = require('sqlstring');


const multer = require('multer');
const csv = require('csv-parser');
const upload = multer({ dest: 'uploads/' });
const fs = require('fs');
const path = require('path');

app.use(cors());

app.use(express.urlencoded({
    extended:true
}));
app.use(express.json());


// Increase the payload size limit to 10MB (adjust the limit as per your requirement)
app.use(express.json({ limit: '10mb' }));
app.use(express.urlencoded({ limit: '10mb', extended: true }));

db.connect(); // you missed this line



const jwt = require('jsonwebtoken');
// Secret key for JWT (keep this secret in a real application)
const secretKey = 'nigeria@1234';
/* require('dotenv').config();
const secretKey = process.env.YOUR_SECRET_KEY; */
//console.log('Secret Key:', secretKey);

// Middleware for authentication using JWT
const authenticateJWT = (req, res, next) => {
  const token = req.header('Authorization');

  if (!token) {
    return res.status(401).json({ message: 'Unauthorized' });
  }

  jwt.verify(token, secretKey, (err, user) => {
    if (err) {
      return res.status(403).json({ message: 'Forbidden' });
    }

    req.user = user;
    next();
  });
};


const swaggerJsDoc = require('swagger-jsdoc');
const swaggerUI = require('swagger-ui-express');

const swaggerOptions = {
  swaggerDefinition: {
    info: {
      title: "Godrej ETA Nigeria",
      version: '1.0.0',
    },
  },
  apis: ["api.js"],
  
  
};

const swaggerDocs = swaggerJsDoc(swaggerOptions);
app.use('/api-docs', swaggerUI.serve, swaggerUI.setup(swaggerDocs));


// API endpoint for login validation
app.post('/signin', (req, res) => {
  const { email, password } = req.body;
  //const hashedPassword = await bcrypt.hash(newpassword, saltRounds);
  // Perform validation by querying the MySQL table
  db.query(
    'SELECT id,roleid,username,entryid,email,pass,production_type,category_type FROM geopos_users WHERE email = ? OR username = ?',
    [email, email],
    (error, user) => {
      if (error) {
        console.error(error);
        res.status(500).json({ success: false, message: 'An error occurred during login' });
      } else if (user.length > 0) {
        const userId = `${user[0].id}`; // Converts the integer to a string using template literals
        const hashedPassword = hashPassword(password, userId);
       // console.log("hashedPassword", hashedPassword);
        if (hashedPassword === user[0].pass) {
          // Credentials are valid
          const user_details = {
            id: user[0].id,
            roleid: user[0].roleid,
            username: user[0].username,
            entryid: user[0].entryid,
            email: user[0].email,
          };
          const token = jwt.sign(user_details, secretKey);
          console.log("token:", token);
          console.log("user:", user);
          //res.json({ token });

          res.json({ success: true, result: user, token: token });
        }
        else {
          // Credentials are invalid
          res.json({ success: false, message: 'Invalid password' });
        }

      } else {
        // Credentials are invalid
        res.json({ success: false, message: 'Invalid username' });
      }
    }
  );
});

const configVars = {
  usePasswordHash: false,
  passwordHashOptions: {
    saltRounds: 10, // Adjust the number of salt rounds as needed
    // Other bcrypt options can be added here
  },
  hash: 'sha256', // Set your desired hash algorithm (e.g., 'sha256')
};

// Function to hash a password
function hashPassword(pass, userId) {
  if (configVars.usePasswordHash) {
    const saltRounds = configVars.passwordHashOptions.saltRounds || 10; // Set your desired salt rounds
    return bcrypt.hash(pass, saltRounds);
  } else {
    const salt = crypto.createHash('md5').update(userId).digest('hex'); // Calculate MD5 hash
    const hashAlgorithm = configVars.hash || 'sha256'; // Set your desired hash algorithm
    return crypto.createHash(hashAlgorithm).update(salt + pass).digest('hex');
  }
}

app.get('/getuserbyid/:id', (req, res) => {
  const id = req.params.id
  db.query('SELECT * FROM geopos_users WHERE id=?', [id], (err, result) => {
    if (err) {
      console.log(err)
    }
    res.send(result[0]); // Send only the name value from the result

  })
});

//Database Connection
app.get("/db", (req, res) => {
    db.query("SELECT * FROM geopos_users", (err, result) => {
      
        if(err) {
            console.log(err);
        } else {
            res.send(result);
            console.log(result);
            //console.log('Connected!');
        }
    });
});

//-------------------------QC Notification BELL-------------------------------------------//
//get notifications bell count
app.get('/getnotificationbellcount', async (req, res) => {
  try {
    const query = "SELECT * FROM qc_master";

    const results = await new Promise((resolve, reject) => {
      db.query(query, (error, results) => {
        if (error) {
          console.error('Error executing MySQL query: ', error);
          reject(error);
        } else {
          resolve(results);
        }
      });
    });

    let output = '';
    let count = 0;

    for (const data1 of results) {
      let col = '';

      if (data1.id === 1) {
        col = 'upper';
      } else if (data1.id === 2) {
        col = 'lower';
      } else if (data1.id === 3) {
        col = 'perheating';
      } else if (data1.id === 4) {
        col = 'machine_speed';
      } else if (data1.id === 5) {
        col = 'tension';
      } else if (data1.id === 6) {
        col = 'spreading';
      } else {
        continue; // Skip to the next iteration
      }

      
       const date = new Date().toLocaleDateString('en-GB', { timeZone: 'Africa/Lagos' });
      const parts = date.split('/');
      const formattedDay = parts[0].padStart(2, '0');
      const formattedMonth = parts[1].padStart(2, '0');
      const year = parts[2];
      const date1 = `${formattedDay}-${formattedMonth}-${year}`; 


      //const date1 = `03-10-2023`;
      const val = data1.value;

      const query1 = `SELECT * FROM geopos_operator WHERE date='${date1}' AND ${col} > ${val} ORDER BY id DESC LIMIT 2`;

      const res1 = await new Promise((resolve, reject) => {
        db.query(query1, (error1, res1) => {
          if (error1) {
            console.error('Error executing MySQL query: ', error1);
            reject(error1);
          } else {
            resolve(res1);
          }
        });
      });

      const num = res1.length;
      let str = '';

      if (num > 0) {
        str += `${data1.name} `;
        count++;
      }

      for (const row of res1) {
        str += `${row.zone}[ ${row.machine} ] -> ${row[col]} [ ${row.hr_start}-${row.hr_end} ], `;
      }

      if (str !== '') {
        output += str; // Add <br> after each comma
      }
    }

    // Include the count in the response
    const response = {
      count: count,
      output: output,
    };

    res.header('Content-Type', 'text/plain');
    res.send(JSON.stringify(response));
  } catch (error) {
    console.error('Error:', error);
    res.status(500).send('Internal Server Error');
  }
});
//-------------------------QC Notification BELL-------------------------------------------//

//-------------------------Data accuracy-------------------------------------------//
//get data accuracy 
app.post('/getdataaccuracy', (req, res) => {
  const roleid = req.body.roleid;
  const userid = req.body.userid;
  //console.log('roleid:', roleid);
  //console.log('userid:', userid);
  const date = new Date().toLocaleDateString('en-GB', { timeZone: 'Africa/Lagos' });
  const parts = date.split('/');
  const day = parts[0].padStart(2, '0');
  const month = parts[1].padStart(2, '0');
  const year = parts[2];
  const currentMonth = `${month}-${year}`;
  const currentDate = `${day}-${month}-${year}`;
  //console.log('Current Date:', currentDate);
  let whereConditions = [];
  whereConditions.push(`worker_timesheet.date_time = '${currentDate}'`);
  if (roleid == 3) {
    //whereConditions.push(`worker_timesheet.operator_id = '${userid}'`);
  }
  const whereClause = whereConditions.join(' AND ');
  
  
  const query = `
    SELECT worker_timesheet.*, item_masterr.item_description, section.section_name,
           ((HOUR1 + HOUR2 + HOUR3 + HOUR4 + HOUR5 + HOUR6 + HOUR7 + HOUR8 + HOUR9 + HOUR10 + HOUR11) / target) AS value_sum
    FROM worker_timesheet
    LEFT JOIN item_masterr ON item_masterr.id = worker_timesheet.product_name
    LEFT JOIN section ON section.id = worker_timesheet.section
    WHERE ${whereClause}
    GROUP BY worker_timesheet.date_time, worker_timesheet.entry_id, worker_timesheet.product_name,
             worker_timesheet.section, worker_timesheet.shift, worker_timesheet.line
    HAVING value_sum * 100 > 150;
  `;
  //console.log(query);
  db.query(query, (error, results) => {
    if (error) {
      console.error('Error executing MySQL query: ', error);
      return res.status(500).json({ error: 'Internal Server Error' });
    }
    const data = {
      timesheet: results,
      date: currentDate
    };
    console.log(data);
    res.json(data);
  });
});

//get data accuracy search
app.post('/getdataaccuracysearch', (req, res) => {
  const roleid = req.body.roleid;
  const userid = req.body.userid;
  var product_name = req.body.product_id;
  var section = req.body.section_id;
  var shift = req.body.shift;
  var line_no = req.body.line_no;
  var day_night = req.body.day_night;
 
const fromdate = req.body.fromdate;
const fdParts = fromdate.split('-');
const fd = `${fdParts[2]}-${fdParts[1]}-${fdParts[0]}`;

const todate = req.body.todate;
const tdParts = todate.split('-');
const td = `${tdParts[2]}-${tdParts[1]}-${tdParts[0]}`;


const dateObj = new Date(fromdate);

const day = dateObj.getDate().toString().padStart(2, '0');
const month = (dateObj.getMonth() + 1).toString().padStart(2, '0');
const year = dateObj.getFullYear();

const convertedDate = `${day}-${month}-${year}`;

const dateObj1 = new Date(todate);
const day1 = dateObj1.getDate().toString().padStart(2, '0');
const month1 = (dateObj1.getMonth() + 1).toString().padStart(2, '0');
const year1 = dateObj1.getFullYear();

const convertedDate1 = `${day1}-${month1}-${year1}`;

console.log('fromdate:', fromdate);
console.log('todate:', todate);
console.log('Converted:', convertedDate);
console.log('Converted2:', convertedDate1);


const fd2 = Math.floor(new Date(fromdate).getTime() / 1000);
const td1 = Math.floor(new Date(todate).getTime() / 1000);
const fd1 = Math.floor(new Date(fd2 * 1000).setDate(new Date(fd2 * 1000).getDate() - 1) / 1000);

var newfd = fd1;
var newtd = td1;

  let whereConditions = [];

  if (fromdate !== '' && todate !== '' && fromdate !== undefined && todate !== undefined && fromdate != null && todate != null) {
    whereConditions.push(`worker_timesheet.time_stamp BETWEEN '${newfd}' AND '${newtd}'`);
  }
  else {
    res.status(400).json({ error: 'Invalid date range provided' });
    return;
  }

  if (product_name !== '' && product_name !== undefined && product_name != null) {
    whereConditions.push(`worker_timesheet.product_name = '${product_name}'`);
  }
  if (section !== '' && section !== undefined && section != null) {
    whereConditions.push(`worker_timesheet.section = '${section}'`);
  }
  if (shift !== '' && shift !== undefined && shift != null) {
    whereConditions.push(`worker_timesheet.shift = '${shift}'`);
  }
  if (line_no !== '' && line_no !== undefined && line_no != null) {
    whereConditions.push(`worker_timesheet.line = '${line_no}'`);
  }
  if (day_night !== '' && day_night !== undefined && day_night != null) {
    whereConditions.push(`worker_timesheet.day_night = '${day_night}'`);
  }

  if (roleid == 3) {
    //whereConditions.push(`worker_timesheet.operator_id = '${userid}'`);
  }



  const whereClause = whereConditions.join(' AND ');


  const query = `
   SELECT worker_timesheet.*, item_masterr.item_description, section.section_name,((HOUR1+HOUR2+HOUR3+HOUR4+HOUR5+HOUR6+HOUR7+HOUR8+HOUR9+HOUR10+HOUR11) / target) AS value_sum
                   FROM worker_timesheet
                   LEFT JOIN item_masterr ON item_masterr.id = worker_timesheet.product_name
                   LEFT JOIN section ON section.id = worker_timesheet.section
                   WHERE ${whereClause}
                   GROUP BY worker_timesheet.date_time,worker_timesheet.entry_id,worker_timesheet.product_name,worker_timesheet.section,worker_timesheet.shift,worker_timesheet.line HAVING (value_sum * 100) > 150`;

  console.log(query);

  db.query(query, (error, results) => {
    if (error) {
      console.error('Error executing MySQL query: ', error);
      return res.status(500).json({ error: 'Internal Server Error' });
    }

    const data = {
      timesheet: results,
      product: product_name,
      line: line_no,
      fdate: convertedDate,
      tdate: convertedDate1,
      shift: shift,
      section: section
    };

    res.json(data);
  });
});

//-------------------------Data accuracy-------------------------------------------//

//--------------------------DASHBOARD PAGE DATA ---------------------------//

//Get ota date
app.get("/otadate", (req, res) => {
  db.query("SELECT * FROM employees_ota order by id asc limit 1", (err, result) => {
    
      if(err) {
          console.log(err);
      } else {
          res.send(result);
          //console.log(result);
          
      }
  });
}); 

//Get ikeja date
app.get("/ikejadate", (req, res) => {
  db.query("SELECT * FROM geopos_employees order by id asc limit 1", (err, result) => {
    
      if(err) {
          console.log(err);
      } else {
          res.send(result);
          //console.log(result);
          
      }
  });
}); 


//Get ril total worker 
app.get("/totalworkerril", (req, res) => {

  const query = `
  SELECT * FROM employees_ota
  ORDER BY id ASC
  LIMIT 1;
`;

db.query(query, (error, results) => {
  if (error) {
    console.error('Error executing the query:', error);
   
    return;
  }

  if (results.length === 0) {
    //console.log('No records found');
   
    return;
  }

  const dt = results[0].date;

  const whereClause = `roleid = '1' AND passive_type = 'ACT' AND date = '${dt}' AND staff = 'RIL'`;
  const countQuery = `
    SELECT COUNT(*) AS totalWorkerCount
    FROM employees_ota
    WHERE ${whereClause};
  `;
  

  db.query(countQuery, (error, countResults) => {
    if (error) {
      console.error('Error executing the count query:', error);
      return;
    }

    const totalCount = countResults[0].totalWorkerCount;
    //console.log('Total Worker Count:', totalCount);
    res.send(countResults);
   
  });
});
}); 

//Get ril present worker 
app.get("/presentworkerril", (req, res) => {
  const query = `
  SELECT * FROM employees_ota
  ORDER BY id ASC
  LIMIT 1;
`;

db.query(query, (error, results) => {
  if (error) {
    console.error('Error executing the query:', error);
   
    return;
  }

  if (results.length === 0) {
    //console.log('No records found');
   
    return;
  }

  const dt = results[0].date;

  const whereClause = `roleid = '1' AND passive_type = 'ACT' AND date = '${dt}' AND staff = 'RIL' AND status = 'P'`;
  const countQuery = `
    SELECT COUNT(*) AS totalPresentCount
    FROM employees_ota
    WHERE ${whereClause};
  `;

  db.query(countQuery, (error, countResults) => {
    if (error) {
      console.error('Error executing the count query:', error);
     
      return;
    }

    const totalCount = countResults[0].totalPresentCount;
    //console.log('Total Present  Worker Count:', totalCount);
    res.send(countResults);
   
  });
});
}); 

//Get ril absent worker 
app.get("/absentworkerril", (req, res) => {
  const query = `
  SELECT * FROM employees_ota
  ORDER BY id ASC
  LIMIT 1;
`;

db.query(query, (error, results) => {
  if (error) {
    console.error('Error executing the query:', error);
   
    return;
  }

  if (results.length === 0) {
    //console.log('No records found');
   
    return;
  }

  const dt = results[0].date;

  const whereClause = `roleid = '1' AND passive_type = 'ACT' AND date = '${dt}' AND staff = 'RIL' AND status = 'A'`;
  const countQuery = `
    SELECT COUNT(*) AS totalAbsentCount
    FROM employees_ota
    WHERE ${whereClause};
  `;

  db.query(countQuery, (error, countResults) => {
    if (error) {
      console.error('Error executing the count query:', error);
     
      return;
    }

    const totalCount = countResults[0].totalAbsentCount;
    //console.log('Total Absent Worker Count:', totalCount);
    res.send(countResults);
   
  });
});
}); 

//Get lorna total worker 
app.get("/totalworkerlorna", (req, res) => {
  const query = `
  SELECT * FROM employees_ota
  ORDER BY id ASC
  LIMIT 1;
`;

db.query(query, (error, results) => {
  if (error) {
    console.error('Error executing the query:', error);
   
    return;
  }

  if (results.length === 0) {
    //console.log('No records found');
   
    return;
  }

  const dt = results[0].date;

  const whereClause = `roleid = '1' AND passive_type = 'ACT' AND date = '${dt}' AND staff = 'LORNA'`;
  const countQuery = `
    SELECT COUNT(*) AS totalWorkerCount
    FROM employees_ota
    WHERE ${whereClause};
  `;

  db.query(countQuery, (error, countResults) => {
    if (error) {
      console.error('Error executing the count query:', error);
     
      return;
    }

    const totalCount = countResults[0].totalWorkerCount;
    //console.log('Total Worker Count:', totalCount);
    res.send(countResults);
   
  });
});
}); 

//Get lorna present worker 
app.get("/presentworkerlorna", (req, res) => {
  const query = `
  SELECT * FROM employees_ota
  ORDER BY id ASC
  LIMIT 1;
`;

db.query(query, (error, results) => {
  if (error) {
    console.error('Error executing the query:', error);
   
    return;
  }

  if (results.length === 0) {
    //console.log('No records found');
   
    return;
  }

  const dt = results[0].date;

  const whereClause = `roleid = '1' AND passive_type = 'ACT' AND date = '${dt}' AND staff = 'LORNA' AND status = 'P'`;
  const countQuery = `
    SELECT COUNT(*) AS totalPresentCount
    FROM employees_ota
    WHERE ${whereClause};
  `;

  db.query(countQuery, (error, countResults) => {
    if (error) {
      console.error('Error executing the count query:', error);
     
      return;
    }

    const totalCount = countResults[0].totalPresentCount;
    //console.log('Total Present Worker Count:', totalCount);
    res.send(countResults);
   
  });
});
}); 

//Get lorna absent worker 
app.get("/absentworkerlorna", (req, res) => {
  const query = `
  SELECT * FROM employees_ota
  ORDER BY id ASC
  LIMIT 1;
`;

db.query(query, (error, results) => {
  if (error) {
    console.error('Error executing the query:', error);
   
    return;
  }

  if (results.length === 0) {
    //console.log('No records found');
   
    return;
  }

  const dt = results[0].date;

  const whereClause = `roleid = '1' AND passive_type = 'ACT' AND date = '${dt}' AND staff = 'LORNA' AND status = 'A'`;
  const countQuery = `
    SELECT COUNT(*) AS totalAbsentCount
    FROM employees_ota
    WHERE ${whereClause};
  `;

  db.query(countQuery, (error, countResults) => {
    if (error) {
      console.error('Error executing the count query:', error);
     
      return;
    }

    const totalCount = countResults[0].totalAbsentCount;
    //console.log('Total Absent Worker Count:', totalCount);
    res.send(countResults);
   
  });
});
}); 


//Get ikeja total worker 
app.get("/totalworkerikeja", (req, res) => {
  const query = `
  SELECT * FROM geopos_employees
  ORDER BY id ASC
  LIMIT 1;
`;

db.query(query, (error, results) => {
  if (error) {
    console.error('Error executing the query:', error);
   
    return;
  }

  if (results.length === 0) {
    //console.log('No records found');
   
    return;
  }

  const dt = results[0].date;

  const whereClause = `roleid = '1' AND passive_type = 'ACT' AND date = '${dt}'`;
  const countQuery = `
    SELECT COUNT(*) AS totalWorkerCount
    FROM geopos_employees
    WHERE ${whereClause};
  `;

  db.query(countQuery, (error, countResults) => {
    if (error) {
      console.error('Error executing the count query:', error);
     
      return;
    }

    const totalCount = countResults[0].totalWorkerCount;
    //console.log('Total Worker Count:', totalCount);
    res.send(countResults);
   
  });
});
}); 

//Get ikeja present worker 
app.get("/presentworkerikeja", (req, res) => {
  const query = `
  SELECT * FROM geopos_employees
  ORDER BY id ASC
  LIMIT 1;
`;

db.query(query, (error, results) => {
  if (error) {
    console.error('Error executing the query:', error);
   
    return;
  }

  if (results.length === 0) {
    //console.log('No records found');
   
    return;
  }

  const dt = results[0].date;

  const whereClause = `roleid = '1' AND passive_type = 'ACT' AND date = '${dt}' AND status = 'P'`;
  const countQuery = `
    SELECT COUNT(*) AS totalPresentCount
    FROM geopos_employees
    WHERE ${whereClause};
  `;

  db.query(countQuery, (error, countResults) => {
    if (error) {
      console.error('Error executing the count query:', error);
     
      return;
    }

    const totalCount = countResults[0].totalPresentCount;
   // console.log('Total Present Worker Count:', totalCount);
    res.send(countResults);
   
  });
});
}); 

//Get ikeja absent worker 
app.get("/absentworkerikeja", (req, res) => {
  const query = `
  SELECT * FROM geopos_employees
  ORDER BY id ASC
  LIMIT 1;
`;

db.query(query, (error, results) => {
  if (error) {
    console.error('Error executing the query:', error);
   
    return;
  }

  if (results.length === 0) {
    //console.log('No records found');
   
    return;
  }

  const dt = results[0].date;

  const whereClause = `roleid = '1' AND passive_type = 'ACT' AND date = '${dt}' AND status = 'A'`;
  const countQuery = `
    SELECT COUNT(*) AS totalAbsentCount
    FROM geopos_employees
    WHERE ${whereClause};
  `;

  db.query(countQuery, (error, countResults) => {
    if (error) {
      console.error('Error executing the count query:', error);
     
      return;
    }

    const totalCount = countResults[0].totalAbsentCount;
    //console.log('Total Absent Worker Count:', totalCount);
    res.send(countResults);
   
  });
});
}); 

//Get ril total operator
app.get("/totaloperatorril", (req, res) => {

  const query = `
    SELECT COUNT(*) AS rilOpCount
    FROM employees_ota
    WHERE roleid = '3' AND banned = '0' AND passive_type = 'ACT' AND staff = 'RIL';
  `;

  db.query(query, (err, results) => {
    
    if(err) {
        console.log(err);
    }
    const rilOpCount = results[0].rilOpCount;
    //console.log('RIL Operation Count:', rilOpCount);
    res.send(results);

});
}); 

//Get lorna total operator
app.get("/totaloperatorlorna", (req, res) => {

  const query = `
  SELECT COUNT(*) AS lornaOpCount
  FROM employees_ota
  WHERE roleid = 3
  AND passive_type = 'ACT'
  AND banned = 0
  AND staff = 'LORNA';
`;

  db.query(query, (err, results) => {
    
      if(err) {
          console.log(err);
      }
       const lornaOpCount = results[0].lornaOpCount;
     // console.log('LORNA Operation Count:', lornaOpCount);
      res.send(results);

  });
}); 

//Get ikeja total operator
app.get("/totaloperatorikeja", (req, res) => {

  const query = `
  SELECT COUNT(*) AS ikejaOpCount
  FROM geopos_employees
  WHERE roleid = '3' AND passive_type = 'ACT';
`;
db.query(query, (err, results) => {
    
  if(err) {
      console.log(err);
  }
  const ikejaOpCount = results[0].ikejaOpCount;
 // console.log('Ikeja Operation Count:', ikejaOpCount);
  res.send(results);

});
}); 

//get ota direct expected day
app.get("/otadirectexpectedday", (req, res) => {
  const query = `
  SELECT * FROM employees_ota WHERE shift = "DAY" ORDER BY id ASC LIMIT 1;
`;

db.query(query, (error, results) => {
  if (error) {
    console.error('Error executing the query:', error);
   
    return;
  }

  if (results.length === 0) {
    //console.log('No records found');
   
    return;
  }

  const dt = results[0].date;

  const whereClause = `roleid = '1' AND passive_type = 'ACT' AND shift = 'DAY' AND workertype = 'DIRECT' AND date = '${dt}'`;
  const countQuery = `
  SELECT COUNT(*) AS otaDEDCount
  FROM employees_ota
    WHERE ${whereClause};
  `;

 

  db.query(countQuery, (error, countResults) => {
    if (error) {
      console.error('Error executing the count query:', error);
     
      return;
    }

    const totalCount = countResults[0].otaDEDCount;
   // console.log('OTA Direct Expected Day Count:', totalCount);
    res.send(countResults);
   
  });
});
}); 

//get ota direct present day
app.get("/otadirectpresentday", (req, res) => {
   const query = `
  SELECT * FROM employees_ota WHERE shift = "DAY" ORDER BY id ASC LIMIT 1;
`;

db.query(query, (error, results) => {
  if (error) {
    console.error('Error executing the query:', error);
   
    return;
  }

  if (results.length === 0) {
    //console.log('No records found');
   
    return;
  }

  const dt = results[0].date;
 
  const whereClause = `roleid = '1' AND passive_type = 'ACT' AND status = 'P' AND shift = 'DAY' AND workertype = 'DIRECT' AND date = '${dt}'`;
  const countQuery = `
  SELECT COUNT(*) AS otaDPDCount
  FROM employees_ota
    WHERE ${whereClause};
  `;

 

  db.query(countQuery, (error, countResults) => {
    if (error) {
      console.error('Error executing the count query:', error);
     
      return;
    }

    const totalCount = countResults[0].otaDPDCount;
    //console.log('OTA Direct Present Day Count:', totalCount);
    res.send(countResults);
   
  });
});
}); 

//get ota direct absent day
app.get("/otadirectabsentday", (req, res) => {
  const query = `
  SELECT * FROM employees_ota WHERE shift = "DAY" ORDER BY id ASC LIMIT 1;
`;

db.query(query, (error, results) => {
  if (error) {
    console.error('Error executing the query:', error);
   
    return;
  }

  if (results.length === 0) {
    //console.log('No records found');
   
    return;
  }

  const dt = results[0].date;
 
  const whereClause = `roleid = '1' AND passive_type = 'ACT' AND status = 'A' AND shift = 'DAY' AND workertype = 'DIRECT' AND date = '${dt}'`;
  const countQuery = `
  SELECT COUNT(*) AS otaDADCount
  FROM employees_ota
    WHERE ${whereClause};
  `;

 

  db.query(countQuery, (error, countResults) => {
    if (error) {
      console.error('Error executing the count query:', error);
     
      return;
    }

    const totalCount = countResults[0].otaDADCount;
    //console.log('OTA Direct Absent Day Count:', totalCount);
    res.send(countResults);
   
  });
});
}); 

//get ota indirect expected day
app.get('/otaindirectexpectedday', (req, res) => {
  const date = new Date().toLocaleDateString('en-GB', { timeZone: 'Africa/Lagos' });
  const parts = date.split('/');
  const formattedDay = parts[0].padStart(2, '0');
  const formattedMonth = parts[1].padStart(2, '0');
  const year = parts[2];
  const date1 = `${formattedDay}-${formattedMonth}-${year}`; 

  // Your SQL query
  const query = `
    SELECT COUNT(*) AS otaIEDCount
    FROM employees_ota
    WHERE roleid = '1'
      AND passive_type = 'ACT'
      AND shift = 'DAY'
      AND workertype = 'INDIRECT'
      AND date = ?;
  `;

  // Execute the query
  db.query(query, [date1], (err, results) => {
    if (err) {
      console.error('Error executing MySQL query: ', err);
      res.status(500).json({ error: 'Internal Server Error' });
      return;
    }

    // Send the count as JSON response
    //res.json({ count: results[0].count });

    const totalCount = results[0].otaIEDCount;
   // console.log('OTA Indirect Expected Day Count:', totalCount);
    res.send(results);
  });
});

//get ota indirect present day
app.get('/otaindirectpresentday', (req, res) => {
  const date = new Date().toLocaleDateString('en-GB', { timeZone: 'Africa/Lagos' });
  const parts = date.split('/');
  const formattedDay = parts[0].padStart(2, '0');
  const formattedMonth = parts[1].padStart(2, '0');
  const year = parts[2];
  const date1 = `${formattedDay}-${formattedMonth}-${year}`; 

  // Your SQL query
  const query = `
    SELECT COUNT(*) as otaIPDCount
    FROM employees_ota
    WHERE roleid = '1'
      AND passive_type = 'ACT'
      AND status = 'P'
      AND shift = 'DAY'
      AND workertype = 'INDIRECT'
      AND date = ?;
  `;

  // Execute the query
  db.query(query, [date1], (err, results) => {
    if (err) {
      console.error('Error executing MySQL query: ', err);
      res.status(500).json({ error: 'Internal Server Error' });
      return;
    }

    const totalCount = results[0].otaIPDCount;
    // console.log('OTA Indirect Present Day Count:', totalCount);
     res.send(results);
  });
});

 //get ota indirect absent day
app.get('/otaindirectabsentday', (req, res) => {
  const date = new Date().toLocaleDateString('en-GB', { timeZone: 'Africa/Lagos' });
  const parts = date.split('/');
  const formattedDay = parts[0].padStart(2, '0');
  const formattedMonth = parts[1].padStart(2, '0');
  const year = parts[2];
  const date1 = `${formattedDay}-${formattedMonth}-${year}`; 

  // Your SQL query
  const query = `
    SELECT COUNT(*) as otaIADCount
    FROM employees_ota
    WHERE roleid = '1'
      AND passive_type = 'ACT'
      AND status = 'A'
      AND shift = 'DAY'
      AND workertype = 'INDIRECT'
      AND date = ?;
  `;

  // Execute the query
  db.query(query, [date1], (err, results) => {
    if (err) {
      console.error('Error executing MySQL query: ', err);
      res.status(500).json({ error: 'Internal Server Error' });
      return;
    }

    const totalCount = results[0].otaIADCount;
    // console.log('OTA Indirect Present Day Count:', totalCount);
     res.send(results);
  });
});

//get ota direct expected night
app.get("/otadirectexpectednight", (req, res) => {
  const query = `
  SELECT * FROM employees_ota WHERE shift = "NIGHT" ORDER BY id ASC LIMIT 1;
`;

db.query(query, (error, results) => {
  if (error) {
    console.error('Error executing the query:', error);
   
    return;
  }

  if (results.length === 0) {
    //console.log('No records found');
   
    return;
  }

  const dt = results[0].date;

  const whereClause = `roleid = '1' AND passive_type = 'ACT' AND shift = 'NIGHT' AND workertype = 'DIRECT' AND date = '${dt}'`;
  const countQuery = `
  SELECT COUNT(*) AS otaDENCount
  FROM employees_ota
    WHERE ${whereClause};
  `;
 //console.log('countQuery:',countQuery);
 

  db.query(countQuery, (error, countResults) => {
    if (error) {
      console.error('Error executing the count query:', error);
     
      return;
    }

    const totalCount = countResults[0].otaDENCount;
    //console.log('OTA Direct Expected Night Count:', totalCount);
    res.send(countResults);
   
  });
});
}); 

//get ota direct present night
app.get("/otadirectpresentnight", (req, res) => {
   const query = `
  SELECT * FROM employees_ota WHERE shift = "NIGHT" ORDER BY id ASC LIMIT 1;
`;

db.query(query, (error, results) => {
  if (error) {
    console.error('Error executing the query:', error);
   
    return;
  }

  if (results.length === 0) {
    //console.log('No records found');
   
    return;
  }

  const dt = results[0].date;
 
  const whereClause = `roleid = '1' AND passive_type = 'ACT' AND status = 'P' AND shift = 'NIGHT' AND workertype = 'DIRECT' AND date = '${dt}'`;
  const countQuery = `
  SELECT COUNT(*) AS otaDPNCount
  FROM employees_ota
    WHERE ${whereClause};
  `;

 

  db.query(countQuery, (error, countResults) => {
    if (error) {
      console.error('Error executing the count query:', error);
     
      return;
    }

    const totalCount = countResults[0].otaDPNCount;
    //console.log('OTA Direct Present Night Count:', totalCount);
    res.send(countResults);
   
  });
});
}); 

//get ota direct absent night
app.get("/otadirectabsentnight", (req, res) => {
  const query = `
  SELECT * FROM employees_ota WHERE shift = "NIGHT" ORDER BY id ASC LIMIT 1;
`;

db.query(query, (error, results) => {
  if (error) {
    console.error('Error executing the query:', error);
   
    return;
  }

  if (results.length === 0) {
    //console.log('No records found');
   
    return;
  }

  const dt = results[0].date;
 
  const whereClause = `roleid = '1' AND passive_type = 'ACT' AND status = 'A' AND shift = 'NIGHT' AND workertype = 'DIRECT' AND date = '${dt}'`;
  const countQuery = `
  SELECT COUNT(*) AS otaDANCount
  FROM employees_ota
    WHERE ${whereClause};
  `;

 

  db.query(countQuery, (error, countResults) => {
    if (error) {
      console.error('Error executing the count query:', error);
     
      return;
    }

    const totalCount = countResults[0].otaDANCount;
   // console.log('OTA Direct Absent Night Count:', totalCount);
    res.send(countResults);
   
  });
});
}); 

//get ota indirect expected night
app.get('/otaindirectexpectednight', (req, res) => {
  const date = new Date().toLocaleDateString('en-GB', { timeZone: 'Africa/Lagos' });
  const parts = date.split('/');
  const formattedDay = parts[0].padStart(2, '0');
  const formattedMonth = parts[1].padStart(2, '0');
  const year = parts[2];
  const date1 = `${formattedDay}-${formattedMonth}-${year}`; 

  // Your SQL query
  const query = `
    SELECT COUNT(*) AS otaIENCount
    FROM employees_ota
    WHERE roleid = '1'
      AND passive_type = 'ACT'
      AND shift = 'NIGHT'
      AND workertype = 'INDIRECT'
      AND date = ?;
  `;

  // Execute the query
  db.query(query, [date1], (err, results) => {
    if (err) {
      console.error('Error executing MySQL query: ', err);
      res.status(500).json({ error: 'Internal Server Error' });
      return;
    }

    // Send the count as JSON response
    //res.json({ count: results[0].count });

    const totalCount = results[0].otaIENCount;
   // console.log('OTA Indirect Expected night Count:', totalCount);
    res.send(results);
  });
});

//get ota indirect present night
app.get('/otaindirectpresentnight', (req, res) => {
  const date = new Date().toLocaleDateString('en-GB', { timeZone: 'Africa/Lagos' });
  const parts = date.split('/');
  const formattedDay = parts[0].padStart(2, '0');
  const formattedMonth = parts[1].padStart(2, '0');
  const year = parts[2];
  const date1 = `${formattedDay}-${formattedMonth}-${year}`; 

  // Your SQL query
  const query = `
    SELECT COUNT(*) as otaIPNCount
    FROM employees_ota
    WHERE roleid = '1'
      AND passive_type = 'ACT'
      AND status = 'P'
      AND shift = 'NIGHT'
      AND workertype = 'INDIRECT'
      AND date = ?;
  `;

  // Execute the query
  db.query(query, [date1], (err, results) => {
    if (err) {
      console.error('Error executing MySQL query: ', err);
      res.status(500).json({ error: 'Internal Server Error' });
      return;
    }

    const totalCount = results[0].otaIPNCount;
    // console.log('OTA Indirect Present night Count:', totalCount);
     res.send(results);
  });
});

 //get ota indirect absent night
app.get('/otaindirectabsentnight', (req, res) => {
  const date = new Date().toLocaleDateString('en-GB', { timeZone: 'Africa/Lagos' });
  const parts = date.split('/');
  const formattedDay = parts[0].padStart(2, '0');
  const formattedMonth = parts[1].padStart(2, '0');
  const year = parts[2];
  const date1 = `${formattedDay}-${formattedMonth}-${year}`; 

  // Your SQL query
  const query = `
    SELECT COUNT(*) as otaIANCount
    FROM employees_ota
    WHERE roleid = '1'
      AND passive_type = 'ACT'
      AND status = 'A'
      AND shift = 'NIGHT'
      AND workertype = 'INDIRECT'
      AND date = ?;
  `;

  // Execute the query
  db.query(query, [date1], (err, results) => {
    if (err) {
      console.error('Error executing MySQL query: ', err);
      res.status(500).json({ error: 'Internal Server Error' });
      return;
    }

    const totalCount = results[0].otaIANCount;
    // console.log('OTA Indirect Present night Count:', totalCount);
     res.send(results);
  });
});


//get ikeja direct expected day
app.get("/ikejadirectexpectedday", (req, res) => {
  const query = `
  SELECT * FROM geopos_employees WHERE shift='DAY' ORDER BY id ASC LIMIT 1;
`;

db.query(query, (error, results) => {
  if (error) {
    console.error('Error executing the query:', error);
   
    return;
  }

  if (results.length === 0) {
    //console.log('No records found');
   
    return;
  }

  const dt = results[0].date;
 
  const whereClause = `roleid = '1' AND passive_type = 'ACT' AND shift = 'DAY' AND workertype = 'DIRECT' AND date = '${dt}'`;
  const countQuery = `
  SELECT COUNT(*) AS ikejaDEDCount
  FROM geopos_employees
    WHERE ${whereClause};
  `;

 

  db.query(countQuery, (error, countResults) => {
    if (error) {
      console.error('Error executing the count query:', error);
     
      return;
    }

    const totalCount = countResults[0].ikejaDEDCount;
   // console.log('IKEJA Direct Expected Day Count:', totalCount);
    res.send(countResults);
   
  });
});
}); 

//get ikeja direct present day
app.get("/ikejadirectpresentday", (req, res) => {
   const query = `
  SELECT * FROM geopos_employees WHERE shift = "DAY" ORDER BY id ASC LIMIT 1;
`;

db.query(query, (error, results) => {
  if (error) {
    console.error('Error executing the query:', error);
   
    return;
  }

  if (results.length === 0) {
    //console.log('No records found');
   
    return;
  }

  const dt = results[0].date;
 
  const whereClause = `roleid = '1' AND passive_type = 'ACT' AND status = 'P' AND shift = 'DAY' AND workertype = 'DIRECT' AND date = '${dt}'`;
  const countQuery = `
  SELECT COUNT(*) AS ikejaDPDCount
  FROM geopos_employees
    WHERE ${whereClause};
  `;

 

  db.query(countQuery, (error, countResults) => {
    if (error) {
      console.error('Error executing the count query:', error);
     
      return;
    }

    const totalCount = countResults[0].ikejaDPDCount;
   // console.log('IKEJA Direct Present Day Count:', totalCount);
    res.send(countResults);
   
  });
});
}); 

//get ikeja direct absent day
app.get("/ikejadirectabsentday", (req, res) => {
  const query = `
  SELECT * FROM geopos_employees WHERE shift = "DAY" ORDER BY id ASC LIMIT 1;
`;

db.query(query, (error, results) => {
  if (error) {
    console.error('Error executing the query:', error);
   
    return;
  }

  if (results.length === 0) {
    //console.log('No records found');
   
    return;
  }

  const dt = results[0].date;
 
  const whereClause = `roleid = '1' AND passive_type = 'ACT' AND status = 'A' AND shift = 'DAY' AND workertype = 'DIRECT' AND date = '${dt}'`;
  const countQuery = `
  SELECT COUNT(*) AS ikejaDADCount
  FROM geopos_employees
    WHERE ${whereClause};
  `;

 

  db.query(countQuery, (error, countResults) => {
    if (error) {
      console.error('Error executing the count query:', error);
     
      return;
    }

    const totalCount = countResults[0].ikejaDADCount;
   // console.log('IKEJA Direct Absent Day Count:', totalCount);
    res.send(countResults);
   
  });
});
}); 

//get ikeja indirect expected day
app.get('/ikejaindirectexpectedday', (req, res) => {
  const date = new Date().toLocaleDateString('en-GB', { timeZone: 'Africa/Lagos' });
  const parts = date.split('/');
  const formattedDay = parts[0].padStart(2, '0');
  const formattedMonth = parts[1].padStart(2, '0');
  const year = parts[2];
  const date1 = `${formattedDay}-${formattedMonth}-${year}`; 

  // Your SQL query
  const query = `
    SELECT COUNT(*) AS ikejaIEDCount
    FROM geopos_employees
    WHERE roleid = '1'
      AND passive_type = 'ACT'
      AND shift = 'DAY'
      AND workertype = 'INDIRECT'
      AND date = ?;
  `;

  // Execute the query
  db.query(query, [date1], (err, results) => {
    if (err) {
      console.error('Error executing MySQL query: ', err);
      res.status(500).json({ error: 'Internal Server Error' });
      return;
    }

    // Send the count as JSON response
    //res.json({ count: results[0].count });

    const totalCount = results[0].ikejaIEDCount;
  // console.log('IKEJA Indirect Expected Day Count:', totalCount);
    res.send(results);
  });
});

//get ikeja indirect present day
app.get('/ikejaindirectpresentday', (req, res) => {
  const date = new Date().toLocaleDateString('en-GB', { timeZone: 'Africa/Lagos' });
  const parts = date.split('/');
  const formattedDay = parts[0].padStart(2, '0');
  const formattedMonth = parts[1].padStart(2, '0');
  const year = parts[2];
  const date1 = `${formattedDay}-${formattedMonth}-${year}`; 

  // Your SQL query
  const query = `
    SELECT COUNT(*) as ikejaIPDCount
    FROM geopos_employees
    WHERE roleid = '1'
      AND passive_type = 'ACT'
      AND status = 'P'
      AND shift = 'DAY'
      AND workertype = 'INDIRECT'
      AND date = ?;
  `;

  // Execute the query
  db.query(query, [date1], (err, results) => {
    if (err) {
      console.error('Error executing MySQL query: ', err);
      res.status(500).json({ error: 'Internal Server Error' });
      return;
    }

    const totalCount = results[0].ikejaIPDCount;
   //console.log('IKEJA Indirect Present Day Count:', totalCount);
     res.send(results);
  });
});

 //get ikeja indirect absent day
app.get('/ikejaindirectabsentday', (req, res) => {
  const date = new Date().toLocaleDateString('en-GB', { timeZone: 'Africa/Lagos' });
  const parts = date.split('/');
  const formattedDay = parts[0].padStart(2, '0');
  const formattedMonth = parts[1].padStart(2, '0');
  const year = parts[2];
  const date1 = `${formattedDay}-${formattedMonth}-${year}`; 

  // Your SQL query
  const query = `
    SELECT COUNT(*) as ikejaIADCount
    FROM geopos_employees
    WHERE roleid = '1'
      AND passive_type = 'ACT'
      AND status = 'A'
      AND shift = 'DAY'
      AND workertype = 'INDIRECT'
      AND date = ?;
  `;

  // Execute the query
  db.query(query, [date1], (err, results) => {
    if (err) {
      console.error('Error executing MySQL query: ', err);
      res.status(500).json({ error: 'Internal Server Error' });
      return;
    }

    const totalCount = results[0].ikejaIADCount;
    // console.log('IKEJA Indirect Absent Day Count:', totalCount);
     res.send(results);
  });
});

//get ikeja direct expected night
app.get("/ikejadirectexpectednight", (req, res) => {
  const query = `
  SELECT * FROM geopos_employees WHERE shift = "NIGHT" ORDER BY id ASC LIMIT 1;
`;

db.query(query, (error, results) => {
  if (error) {
    console.error('Error executing the query:', error);
   
    return;
  }

  if (results.length === 0) {
    //console.log('No records found');
   
    return res.status(404).send('No records found');
  }

  const dt = results[0].date;

  const whereClause = `roleid = '1' AND passive_type = 'ACT' AND shift = 'NIGHT' AND workertype = 'DIRECT' AND date = '${dt}'`;
  const countQuery = `
  SELECT COUNT(*) AS ikejaDENCount
  FROM geopos_employees
    WHERE ${whereClause};
  `;

 

  db.query(countQuery, (error, countResults) => {
    if (error) {
      console.error('Error executing the count query:', error);
     
      return;
    }

    const totalCount = countResults[0].ikejaDENCount;
    //console.log('IKEJA Direct Expected Night Count:', totalCount);
    res.send(countResults);
   
  });
});
}); 

//get ikeja direct present night
app.get("/ikejadirectpresentnight", (req, res) => {
   const query = `
  SELECT * FROM geopos_employees WHERE shift = "NIGHT" ORDER BY id ASC LIMIT 1;
`;

db.query(query, (error, results) => {
  if (error) {
    console.error('Error executing the query:', error);
   
    return;
  }

  if (results.length === 0) {
    //console.log('No records found');
   
    return res.status(404).send('No records found');
  }

  const dt = results[0].date;
 
  const whereClause = `roleid = '1' AND passive_type = 'ACT' AND status = 'P' AND shift = 'NIGHT' AND workertype = 'DIRECT' AND date = '${dt}'`;
  const countQuery = `
  SELECT COUNT(*) AS ikejaDPNCount
  FROM geopos_employees
    WHERE ${whereClause};
  `;

 

  db.query(countQuery, (error, countResults) => {
    if (error) {
      console.error('Error executing the count query:', error);
     
      return;
    }

    const totalCount = countResults[0].ikejaDPNCount;
    //console.log('IKEJA Direct Present Night Count:', totalCount);
    res.send(countResults);
   
  });
});
}); 

//get ikeja direct absent night
app.get("/ikejadirectabsentnight", (req, res) => {
  const query = `
  SELECT * FROM geopos_employees WHERE shift = "NIGHT" ORDER BY id ASC LIMIT 1;
`;

db.query(query, (error, results) => {
  if (error) {
    console.error('Error executing the query:', error);
   
    return;
  }

  if (results.length === 0) {
    //console.log('No records found');
   
    return res.status(404).send('No records found');
  }

  const dt = results[0].date;
 
  const whereClause = `roleid = '1' AND passive_type = 'ACT' AND status = 'A' AND shift = 'NIGHT' AND workertype = 'DIRECT' AND date = '${dt}'`;
  const countQuery = `
  SELECT COUNT(*) AS ikejaDANCount
  FROM geopos_employees
    WHERE ${whereClause};
  `;

 

  db.query(countQuery, (error, countResults) => {
    if (error) {
      console.error('Error executing the count query:', error);
     
      return;
    }

    const totalCount = countResults[0].ikejaDANCount;
   // console.log('IKEJA Direct Absent Night Count:', totalCount);
    res.send(countResults);
   
  });
});
}); 

//get ikeja indirect expected night
app.get('/ikejaindirectexpectednight', (req, res) => {
  const date = new Date().toLocaleDateString('en-GB', { timeZone: 'Africa/Lagos' });
  const parts = date.split('/');
  const formattedDay = parts[0].padStart(2, '0');
  const formattedMonth = parts[1].padStart(2, '0');
  const year = parts[2];
  const date1 = `${formattedDay}-${formattedMonth}-${year}`; 

  // Your SQL query
  const query = `
    SELECT COUNT(*) AS ikejaIENCount
    FROM geopos_employees
    WHERE roleid = '1'
      AND passive_type = 'ACT'
      AND shift = 'NIGHT'
      AND workertype = 'INDIRECT'
      AND date = ?;
  `;

  // Execute the query
  db.query(query, [date1], (err, results) => {
    if (err) {
      console.error('Error executing MySQL query: ', err);
      res.status(500).json({ error: 'Internal Server Error' });
      return;
    }

    // Send the count as JSON response
    //res.json({ count: results[0].count });

    const totalCount = results[0].ikejaIENCount;
  // console.log('IKEJA Indirect Expected Day Count:', totalCount);
    res.send(results);
  });
});

//get ikeja indirect present night
app.get('/ikejaindirectpresentnight', (req, res) => {
  const date = new Date().toLocaleDateString('en-GB', { timeZone: 'Africa/Lagos' });
  const parts = date.split('/');
  const formattedDay = parts[0].padStart(2, '0');
  const formattedMonth = parts[1].padStart(2, '0');
  const year = parts[2];
  const date1 = `${formattedDay}-${formattedMonth}-${year}`; 

  // Your SQL query
  const query = `
    SELECT COUNT(*) as ikejaIPNCount
    FROM geopos_employees
    WHERE roleid = '1'
      AND passive_type = 'ACT'
      AND status = 'P'
      AND shift = 'NIGHT'
      AND workertype = 'INDIRECT'
      AND date = ?;
  `;

  // Execute the query
  db.query(query, [date1], (err, results) => {
    if (err) {
      console.error('Error executing MySQL query: ', err);
      res.status(500).json({ error: 'Internal Server Error' });
      return;
    }

    const totalCount = results[0].ikejaIPNCount;
   //console.log('IKEJA Indirect Present Day Count:', totalCount);
     res.send(results);
  });
});

 //get ikeja indirect absent night
app.get('/ikejaindirectabsentnight', (req, res) => {
  const date = new Date().toLocaleDateString('en-GB', { timeZone: 'Africa/Lagos' });
  const parts = date.split('/');
  const formattedDay = parts[0].padStart(2, '0');
  const formattedMonth = parts[1].padStart(2, '0');
  const year = parts[2];
  const date1 = `${formattedDay}-${formattedMonth}-${year}`; 

  // Your SQL query
  const query = `
    SELECT COUNT(*) as ikejaIANCount
    FROM geopos_employees
    WHERE roleid = '1'
      AND passive_type = 'ACT'
      AND status = 'A'
      AND shift = 'NIGHT'
      AND workertype = 'INDIRECT'
      AND date = ?;
  `;

  // Execute the query
  db.query(query, [date1], (err, results) => {
    if (err) {
      console.error('Error executing MySQL query: ', err);
      res.status(500).json({ error: 'Internal Server Error' });
      return;
    }

    const totalCount = results[0].ikejaIANCount;
    // console.log('IKEJA Indirect Absent Day Count:', totalCount);
     res.send(results);
  });
});
  

//items row
app.get('/dashbord_total_item', (req, res) => {
  db.query('SELECT COUNT(*) as rowCount FROM item_masterr', (err, result) => {
    if (err) {
      console.log(err);
      res.status(500).send('Error fetching total items');
    } else {
      const rowCount = result[0].rowCount;
      const response = {
        totalItem: rowCount, // Use "totalItem" as the key instead of "rowCount"
      };
      res.send(response);
      console.log('Connected!');
    }
  });
});

//--------------------------DASHBOARD PAGE DATA ---------------------------//

//---------------------------COMPANY SETTINGS----------------------------//

//get company setting details
app.get('/company', (req, res) => {
  db.query('SELECT * FROM geopos_system WHERE id=?', [1], (err, result) => {
    if (err) {
      console.log(err)
    }
    res.send(result[0]);
  })
})

//update company settings
app.post('/update_company', (req, res) => {
  const cname = req.body.cname;
  const phone = req.body.phone;
  const email = req.body.email;
  const address = req.body.address;
  const city = req.body.city;
  const region = req.body.region;
  const country = req.body.country;
  const postbox = req.body.postbox;
  const taxid = req.body.taxid;
  const foundation = req.body.foundation;

  // Convert the foundation date format from "25-11-2022" to "2022-11-25"
  const foundationParts = foundation.split('-');
  const convertedFoundation = `${foundationParts[2]}-${foundationParts[1]}-${foundationParts[0]}`;

  console.log('Received Data:');
  console.log('cname:', cname);
  console.log('phone:', phone);
  console.log('email:', email);
  console.log('address:', address);
  console.log('city:', city);
  console.log('region:', region);
  console.log('country:', country);
  console.log('postbox:', postbox);
  console.log('taxid:', taxid);
  console.log('foundation:', convertedFoundation);

  db.query(
    'UPDATE geopos_system SET cname=?,phone=?,email=?,address=?,city=?,region=?,country=?,postbox=?,taxid=?,foundation=?  WHERE id = ?',
    [cname, phone, email, address, city, region, country, postbox, taxid, convertedFoundation, 1],
    (err, result) => {
      if (err) {
        res.status(500).json({ message: 'Error update record' })
      } else if (result.affectedRows === 0) {
        res.status(404).json({ message: 'Record not Updated' })
      } else {
        res.status(200).json({ message: 'Record Updated successfully' })
      }
    },
  )
});



//Company profile upload
const storage1 = multer.diskStorage({
  destination: (req, file, cb) => {
    const uploadPath = path.resolve(__dirname, '../src/components/CompanyLogo')
    cb(null, uploadPath)
  },
  filename: (req, file, cb) => {
    const uniqueSuffix = Date.now() + '-' + Math.round(Math.random() * 1e9)
    const originalExtension = path.extname(file.originalname)
    cb(null, file.fieldname + '-' + uniqueSuffix + originalExtension)
  },
})

const upload_Path = multer({ storage: storage1 }) // Destination folder for file uploads

app.post('/company_profile', upload_Path.single('file'), (req, res) => {
  const file = req.file
  const { originalname, mimetype, size } = file

  // MySQL query to store file information
  const query = 'UPDATE geopos_system SET logo=? WHERE id = ?'
  db.query(query, [originalname, 1], (err, result) => {
    if (err) {
      console.error('Error executing MySQL query:', err)
      res.status(500).json({ error: 'Error uploading file' })
    } else {
      console.log('File uploaded successfully')
      res.json({ message: 'File uploaded successfully' })
    }
  })
})

//---------------------------COMPANY SETTINGS----------------------------//

//-------------------------MASTER--------------------------------//

//QC Master

//Get qc master data for datatables
app.get("/getqc", (req, res) => {
  db.query("SELECT * FROM qc_master", (err, result) => {

   if (err) {
     console.log(err);
     res.status(500).json({ error: 'An error occurred' });
   } else {
     res.send(result);
     console.log(result);
    
   }
 });
});


//edit qc master
app.get("/editqc/:id", (req, res) => {
  const id = req.params.id;
  // Construct the SQL query with a placeholder
  const query = `SELECT * FROM qc_master WHERE id = ?`;

  // Execute the query with the id as a parameter
  db.query(query, [id], (error, results) => {
    if (error) {
      console.error('Error executing query:', error);
      res.status(500).json({ message: 'Server error' });
    } else {
      if (results.length > 0) {
        const section = results[0];
        res.status(200).json(section);
      } else {
        res.status(404).json({ message: 'Qc not found' });
      }
    }
  });
});

//update qc master
app.post("/updateqc", (req, res) => {
  var id = req.body.id;
  var qcname = req.body.name;
  var qcvalue = req.body.value;
 
  console.log("Received ID:", id);
console.log("Received Name:", qcname);
console.log("Received Value:", qcvalue);

var sql = `UPDATE qc_master SET name='${qcname}', value='${qcvalue}'  WHERE id='${id}'`;
console.log("Generated SQL query:", sql);

  db.query(sql, function(err, result) {
    if (err) {
      console.log(err);
      res.status(500).json({ error: 'An error occurred while updating the QC.' });
    } else {
      console.log(result);
      res.json({ message: 'QC Name Updated Successfully.' });
    }
  });
});


//Add Item category
app.post("/additemcategory", (req, res) => {
    
  var name = req.body.category_name;
  var sql = `INSERT INTO item_category (category_name) VALUES ("${name}")`;
  db.query(sql, function (err, result) {
    if (err) {
      console.log(err);
      res.status(500).json({ message: "Error adding item category" });
    } else {
      console.log(result);
      console.log('Connected!');
      res.json({ message: "Item category added successfully" });
    }
  });
});

//Get Item categories for datatables
 app.get("/ic", (req, res) => {
  db.query("SELECT * FROM item_category", (err, result) => {
    
      if(err) {
          console.log(err);
      } else {
          res.send(result);
          console.log(result);
          
      }
  });
}); 


//Get Item categories for non braid
app.get("/icnb", (req, res) => {
  db.query("SELECT * FROM item_category where status='1' ", (err, result) => {
    
      if(err) {
          console.log(err);
      } else {
          res.send(result);
          console.log(result);
          
      }
  });
}); 

//categories + item count
app.get("/icf", (req, res) => {
  db.query("SELECT * FROM item_category", (err, categoryResult) => {
    if (err) {
      console.log(err);
      res.status(500).json({ error: "Internal server error" });
    } else {
      const categories = categoryResult;

      // Fetch item counts for each category
      const categoryItems = [];
      let totalItems = 0;

      categories.forEach((category, index) => {
        const query = `SELECT COUNT(*) AS item_count FROM item_masterr WHERE category_id = ${category.id}`;

        db.query(query, (err, itemResult) => {
          if (err) {
            console.log(err);
            res.status(500).json({ error: "Internal server error" });
          } else {
            const itemCount = itemResult[0].item_count;
            totalItems += itemCount;

            categoryItems.push({
              category_name: category.category_name,
              item_count: itemCount,
            });

            // Send response when all categories are processed
            if (index === categories.length - 1) {
              res.json({
                categories: categoryItems,
                totalItems: totalItems,
              });
            }
          }
        });
      });
    }
  });
});

//Get Item categories for category dropdown in itemsubcategory add new page
app.get("/itemcategories", (req, res) => {
  db.query("SELECT id, category_name FROM item_category", (err, result) => {
    if (err) {
      console.log(err);
    } else {
      res.send(result);
      console.log(result);
      console.log('Connected!');
    }
  });
});

//Add Item Subcategory
app.post("/additemsubcategory", (req, res) => {
    
  var cname = req.body.category_id;
  var scname = req.body.subcategory_name;
  
 
  var sql = `INSERT INTO item_subcategory (category_id, subcategory_name) VALUES ("${cname}", "${scname}")`;
  db.query(sql, function (err, result) {
    if (err) {
      console.log(err);
      res.status(500).json({ message: "Error adding item subcategory" });
    } else {
      console.log(result);
      console.log('Connected!');
      res.json({ message: "Item Subcategory added successfully" });
    }
  });
});

  //Get Item subcategories for datatables
app.get("/isc", (req, res) => {
  db.query("SELECT * FROM item_subcategory", (err, result) => {
    
      if(err) {
          console.log(err);
      } else {
          res.send(result);
          console.log(result);
          console.log('Connected!');
      }
  });
});

 // GET request to fetch item subcategory by ID
app.get("/itemsubcategory/:id", (req, res) => {
  const id = req.params.id;
  //const id = 11;
  // Construct the SQL query with a placeholder
  const query = 'SELECT * FROM item_subcategory WHERE id = ?';

  // Execute the query with the id as a parameter
  db.query(query, [id], (error, results) => {
    if (error) {
      console.error('Error executing query:', error);
      res.status(500).json({ message: 'Server error' });
    } else {
      if (results.length > 0) {
        const subcategory = results[0];
        res.status(200).json(subcategory);
      } else {
        res.status(404).json({ message: 'Subcategory not found' });
      }
    }
  });
});

// update item subcategory by ID
app.post("/updateitemsubcategory", (req, res) => {
  var id = req.body.id;
  var cid = req.body.category_id;
  var scname = req.body.subcategory_name;
  var sql = `UPDATE item_subcategory SET category_id='${cid}', subcategory_name='${scname}' WHERE id=${id}`;

  db.query(sql, function(err, result) {
    if (err) {
      console.log(err);
      res.status(500).json({ error: 'An error occurred while updating the user.' });
    } else {
      console.log(result);
      res.json({ message: 'User updated successfully.' });
    }
  });
});

// delete item subcategory by ID
app.delete("/iscdelete/:id", (req, res) => {
  const id = req.params.id;
  db.query("DELETE FROM item_subcategory WHERE id = ?", [id], (err, result) => {
    if (err) {
      console.log(err);
      res.status(500).json({ error: 'An error occurred while deleting the item.' });
    } else {
      console.log(result);
      res.json({ message: 'Item deleted successfully.' });
    }
  });
});





//Shift

//Add Shift
app.post("/addshift", (req, res) => {
    
  var shname = req.body.shift_name;
  var sql = `INSERT INTO geopos_shift (name) VALUES ("${shname}")`;
  db.query(sql, function(err, result)  {
        if(err) {
            console.log(err);
        } else {
            res.send(result);
            console.log(result);
            console.log('Connected!');
        }
    });
  });

//Get Shifts for datatables
app.get("/getshift", (req, res) => {
  db.query("SELECT * FROM geopos_shift", (err, result) => {
    
      if(err) {
          console.log(err);
      } else {
          res.send(result);
          console.log(result);
         
      }
  });
});


//Worker Type

//Add Worker Type
app.post("/addworkertype1", (req, res) => {
    
  var wtname = req.body.workertype_name;
  var sql = `INSERT INTO geopos_workertype (name) VALUES ("${wtname}")`;
  db.query(sql, function(err, result)  {
        if(err) {
            console.log(err);
        } else {
            res.send(result);
            console.log(result);
           
        }
    });
  });


 
app.post("/addworkertype", (req, res) => {
  var wtname = req.body.workertype_name;
  
  // Check if the worker type already exists
  var checkSql = `SELECT * FROM geopos_workertype WHERE name = "${wtname}"`;
  db.query(checkSql, function (err, result) {
    if (err) {
      console.log(err);
      res.status(500).send({ message: "An error occurred" });
    } else {
      if (result.length > 0) {
        // worker type already exists
        res.status(409).send({ message: "Error : Worker type  already exists" });
      } else {
        // Worker type does not exist, add it to the database
        var insertSql = `INSERT INTO geopos_workertype (name) VALUES ("${wtname}")`;
        db.query(insertSql, function (err, result) {
          if (err) {
            console.log(err);
            res.status(500).send({ message: "An error occurred" });
          } else {
            res.status(200).send({ message: "Worker Type added successfully" });
            console.log(result);
            console.log('Connected!');
          }
        });
      }
    }
  });
});

//Get Shifts for datatables
app.get("/getworkertype", (req, res) => {
  db.query("SELECT * FROM geopos_workertype", (err, result) => {
    
      if(err) {
          console.log(err);
      } else {
          res.send(result);
          console.log(result);
         
      }
  });
});

//Employee Role

//Get Employee Role for datatables
app.get("/getemployeerole", (req, res) => {
  db.query("SELECT * FROM geopos_emptype", (err, result) => {
    
      if(err) {
          console.log(err);
      } else {
          res.send(result);
          console.log(result);
         
      }
  });
});




//Color Master

/**
 * @swagger
 * 
 * /getcolor:
 *   get:
 *     summary: Get colors
 *     description: Retrieves colors from the database.
 *     tags:
 *       - Color
 *     security:
 *       - ApiKeyAuth: []
 *     responses:
 *       200:
 *         description: Successful response containing colors.
 *         content:
 *           application/json:
 *             schema:
 *               example:
 *               status: "Success"
 *               message: "Colors fetched successfully."
 *       500:
 *         description: Internal server error. Failed to retrieve colors.
 *
 * @function
 * @name getColors
 * @memberof module:Routes/Color
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with the database query.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
app.get("/getcolor", async (req, res) => {
  try {
    const result = await new Promise((resolve, reject) => {
      db.query("SELECT * FROM color_master WHERE status = '1'", (err, result) => {
        if (err) {
          reject(err);
        } else {
          resolve(result);
        }
      });
    });

    res.send(result);
    console.log(result);
    console.log('Connected!');
  } catch (error) {
    console.error(error);
    res.status(500).json({ error: 'An error occurred' });
  }
});


/**
 * @swagger
 * 
 * /addcolor:
 *   post:
 *     summary: Add a new color
 *     description: Adds a new color to the database.
 *     tags:
 *       - Color
 *     security:
 *       - ApiKeyAuth: []
 *     requestBody:
 *       description: JSON object containing the color_name to be added.
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             properties:
 *               color_name:
 *                 type: string
 *                 description: The name of the color to be added.
 *     responses:
 *       200:
 *         description: Successful response indicating the color has been added.
 *         content:
 *           application/json:
 *             example:
 *               message: "Color added successfully"
 *       409:
 *         description: Conflict response indicating that the color name already exists.
 *         content:
 *           application/json:
 *             example:
 *               message: "Error: Color name already exists"
 *       500:
 *         description: Internal server error. Failed to add color.
 *
 * @function
 * @name addColor
 * @memberof module:Routes/Color
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with the database query.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
app.post("/addcolor", async (req, res) => {
  try {
    const colname = req.body.color_name;
    
    // Check if the color already exists
    const checkSql = `SELECT * FROM color_master WHERE color_name = ? AND status = '1'`;
    const checkResult = await new Promise((resolve, reject) => {
      db.query(checkSql, [colname], (err, result) => {
        if (err) {
          reject(err);
        } else {
          resolve(result);
        }
      });
    });

    if (checkResult.length > 0) {
      // Color already exists
      res.status(409).send({ message: "Error: Color name already exists" });
    } else {
      // Color does not exist, add it to the database
      const insertSql = `INSERT INTO color_master (color_name) VALUES (?)`;
      const insertResult = await new Promise((resolve, reject) => {
        db.query(insertSql, [colname], (err, result) => {
          if (err) {
            reject(err);
          } else {
            resolve(result);
          }
        });
      });

      res.status(200).send({ message: "Color added successfully" });
      console.log(insertResult);
      console.log('Connected!');
    }
  } catch (error) {
    console.error(error);
    res.status(500).json({ message: "An error occurred" });
  }
});


/**
 * @swagger
 * 
 * /editcolor/{id}:
 *   get:
 *     summary: Get color by ID
 *     description: Retrieves color data from the database by its ID.
 *     tags:
 *       - Color
 *     security:
 *       - ApiKeyAuth: []
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         description: ID of the color to retrieve
 *         schema:
 *           type: integer
 *     responses:
 *       200:
 *         description: Successful response containing the color data.
 *         content:
 *           application/json:
 *              example:
 *               status: "Success"
 *               message: "Color fetched from id successfully."
 *       404:
 *         description: Color not found.
 *         content:
 *           application/json:
 *             example:
 *               message: "Color not found"
 *       500:
 *         description: Internal server error. Failed to retrieve color data.
 *
 * @function
 * @name getColorById
 * @memberof module:Routes/Color
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with the database query.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
app.get("/editcolor/:id", async (req, res) => {
  try {
    const id = req.params.id;
    // Construct the SQL query with a placeholder
    const query = 'SELECT * FROM color_master WHERE id = ?';

    // Execute the query with the id as a parameter
    const results = await new Promise((resolve, reject) => {
      db.query(query, [id], (error, results) => {
        if (error) {
          reject(error);
        } else {
          resolve(results);
        }
      });
    });

    if (results.length > 0) {
      const color = results[0];
      res.status(200).json(color);
    } else {
      res.status(404).json({ message: 'Color not found' });
    }
  } catch (error) {
    console.error('Error executing query:', error);
    res.status(500).json({ message: 'Server error' });
  }
});


/**
 * @swagger
 * 
 * /updatecolor:
 *   post:
 *     summary: Update color by ID
 *     description: Updates the color name in the database based on its ID.
 *     tags:
 *       - Color
 *     security:
 *       - ApiKeyAuth: []
 *     requestBody:
 *       description: JSON object containing the ID of the color to update and the new color name.
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             type: object
 *             properties:
 *               id:
 *                 type: integer
 *                 description: The ID of the color to update.
 *               color_name:
 *                 type: string
 *                 description: The new name of the color.
 *     responses:
 *       200:
 *         description: Successful response indicating the color has been updated.
 *         content:
 *           application/json:
 *             example:
 *               message: "Color updated successfully"
 *       400:
 *         description: Bad request. The new color name already exists in the database.
 *         content:
 *           application/json:
 *             example:
 *               message: "Color name already exists."
 *       500:
 *         description: Internal server error. Failed to update the color.
 *
 * @function
 * @name updateColorById
 * @memberof module:Routes/Color
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with the database query or update.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
app.post("/updatecolor", async (req, res) => {
  try {

    // Log the request headers to inspect if the token is present
    console.log('Request Headers:', req.headers);
    var id = req.body.id;
    var colorname = req.body.color_name;

    console.log('colorname:', colorname);

    // Check if the new color name already exists in the database
    const checkDuplicateSQL = `SELECT * FROM color_master WHERE color_name=? AND status = '1'`;
    const duplicateResult = await new Promise((resolve, reject) => {
      db.query(checkDuplicateSQL, [colorname], (err, duplicateResult) => {
        if (err) {
          reject(err);
        } else {
          resolve(duplicateResult);
        }
      });
    });

    if (duplicateResult.length > 0) {
      res.status(400).send({ message: "Color name already exists." });
    } else {
      const sql = `UPDATE color_master SET color_name=? WHERE id=?`;
      const result = await new Promise((resolve, reject) => {
        db.query(sql, [colorname, id], (err, result) => {
          if (err) {
            reject(err);
          } else {
            resolve(result);
          }
        });
      });

      //console.log(result);
      res.status(200).send({ message: "Color updated successfully" });
    }
  } catch (error) {
    console.error(error);
    res.status(500).send({ message: "An error occurred while updating the color." });
  }
});



/**
 * @swagger
 * 
 * /colordelete/{id}:
 *   delete:
 *     summary: Delete color by ID
 *     description: Deletes the color from the database based on its ID.
 *     tags:
 *       - Color
 *     security:
 *       - ApiKeyAuth: []
 *     parameters:
 *       - in: path
 *         name: id
 *         required: true
 *         description: ID of the color to delete
 *         schema:
 *           type: integer
 *     responses:
 *       200:
 *         description: Successful response indicating the color has been deleted.
 *         content:
 *           application/json:
 *             example:
 *               message: "Color deleted successfully."
 *       500:
 *         description: Internal server error. Failed to delete the color.
 *
 * @function
 * @name deleteColorById
 * @memberof module:Routes/Color
 * @param {Object} req - Express request object.
 * @param {Object} res - Express response object.
 * @throws {InternalServerError} Will throw an error if there's an issue with the database query or deletion.
 * @returns {Promise<void>} Promise representing the result of the operation.
 */
app.delete("/colordelete/:id", async (req, res) => {
  try {
    const id = req.params.id;
    const result = await new Promise((resolve, reject) => {
      db.query("UPDATE color_master SET status='0' WHERE id = ?", [id], (err, result) => {
        if (err) {
          reject(err);
        } else {
          resolve(result);
        }
      });
    });

    console.log(result);
    res.json({ message: 'Color deleted successfully.' });
  } catch (error) {
    console.error(error);
    res.status(500).json({ error: 'An error occurred while deleting the color.' });
  }
});


//Line Master

//Get Line from database
app.get("/getline", (req, res) => {
  db.query("SELECT * FROM line_master where status = '1' ", (err, result) => {
    
      if(err) {
          console.log(err);
      } else {
          res.send(result);
          console.log(result);
          console.log('Connected!');
      }
  });
});

// Add new line
app.post("/addline", (req, res) => {
  var linename = req.body.line_name;
  
  // Check if the line already exists
  var checkSql = `SELECT * FROM line_master WHERE line_name = "${linename}" and status = '1'`;
  db.query(checkSql, function (err, result) {
    if (err) {
      console.log(err);
      res.status(500).send({ message: "An error occurred" });
    } else {
      if (result.length > 0) {
        // Line already exists
        res.status(409).send({ message: "Error : Line Name already exists" });
      } else {
        // Line does not exist, add it to the database
        var insertSql = `INSERT INTO line_master (line_name) VALUES ("${linename}")`;
        db.query(insertSql, function (err, result) {
          if (err) {
            console.log(err);
            res.status(500).send({ message: "An error occurred" });
          } else {
            res.status(200).send({ message: "Line added successfully" });
            console.log(result);
            console.log('Connected!');
          }
        });
      }
    }
  });
});

// GET request to fetch color data by ID
app.get("/editline/:id", (req, res) => {
  const id = req.params.id;
  // Construct the SQL query with a placeholder
  const query = 'SELECT * FROM line_master WHERE id = ?';

  // Execute the query with the id as a parameter
  db.query(query, [id], (error, results) => {
    if (error) {
      console.error('Error executing query:', error);
      res.status(500).json({ message: 'Server error' });
    } else {
      if (results.length > 0) {
        const section = results[0];
        res.status(200).json(section);
      } else {
        res.status(404).json({ message: 'Line not found' });
      }
    }
  });
});

// update color by ID
app.post("/updateline", (req, res) => {
  var id = req.body.id;
  var linename = req.body.line_name;

  console.log('linename:', linename);

  // Check if the new color name already exists in the database
  var checkDuplicateSQL = `SELECT * FROM line_master WHERE line_name='${linename}' and status = '1'`;
  db.query(checkDuplicateSQL, function(err, duplicateResult) {
    if (err) {
      console.log(err);
      res.status(500).send({ message: "An error occurred while checking for duplicate entry." });
    } else if (duplicateResult.length > 0) {
      res.status(400).send({ message: "Line name already exists." });
    } else {
      var sql = `UPDATE line_master SET line_name='${linename}' WHERE id=${id}`;
      db.query(sql, function(err, result) {
        if (err) {
          console.log(err);
          res.status(500).send({ message: "An error occurred while updating the line." });
        } else {
          console.log(result);
          res.status(200).send({ message: "Line updated successfully" });
        }
      });
    }
  });
});

// delete line by ID
app.delete("/linedelete/:id", (req, res) => {
  const id = req.params.id;
  db.query("UPDATE line_master SET status='0' WHERE id = ?", [id], (err, result) => {
    if (err) {
      console.log(err);
      res.status(500).json({ error: 'An error occurred while deleting the line.' });
    } else {
      console.log(result);
      res.json({ message: 'Line deleted successfully.' });
    }
  });
});

//waste master
//Get waste from database
app.get("/getwaste", (req, res) => {
  db.query("SELECT * FROM geopos_wastemaster where status = '1' ", (err, result) => {
    
      if(err) {
          console.log(err);
      } else {
          res.send(result);
          console.log(result);
          
      }
  });
});



// Add new waste
app.post("/addwaste", (req, res) => {
  var wastename = req.body.waste_name;
  
  // Check if the line already exists
  var checkSql = `SELECT * FROM geopos_wastemaster WHERE name = "${wastename}"`;
  db.query(checkSql, function (err, result) {
    if (err) {
      console.log(err);
      res.status(500).send({ message: "An error occurred" });
    } else {
      if (result.length > 0) {
        // Line already exists
        res.status(409).send({ message: "Error : Waste Name already exists" });
      } else {
        // Line does not exist, add it to the database
        var insertSql = `INSERT INTO geopos_wastemaster (name) VALUES ("${wastename}")`;
        db.query(insertSql, function (err, result) {
          if (err) {
            console.log(err);
            res.status(500).send({ message: "An error occurred" });
          } else {
            res.status(200).send({ message: "Waste added successfully" });
            console.log(result);
            console.log('Connected!');
          }
        });
      }
    }
  });
});

// GET request to fetch waste data by ID
app.get("/editwaste/:id", (req, res) => {
  const id = req.params.id;
  // Construct the SQL query with a placeholder
  const query = 'SELECT * FROM geopos_wastemaster WHERE id = ?';

  // Execute the query with the id as a parameter
  db.query(query, [id], (error, results) => {
    if (error) {
      console.error('Error executing query:', error);
      res.status(500).json({ message: 'Server error' });
    } else {
      if (results.length > 0) {
        const section = results[0];
        res.status(200).json(section);
      } else {
        res.status(404).json({ message: 'Waste not found' });
      }
    }
  });
});

// update waste by ID
app.post("/updatewaste", (req, res) => {
  var id = req.body.id;
  var wastename = req.body.waste_name;

  console.log('wastename:', wastename);

  // Check if the new waste name already exists in the database
  var checkDuplicateSQL = `SELECT * FROM geopos_wastemaster WHERE name='${wastename}' AND status = '1'`;
  db.query(checkDuplicateSQL, function(err, duplicateResult) {
    if (err) {
      console.log(err);
      res.status(500).send({ message: "An error occurred while checking for duplicate entry." });
    } else if (duplicateResult.length > 0) {
      res.status(400).send({ message: "Waste name already exists." });
    } else {
      var sql = `UPDATE geopos_wastemaster SET name='${wastename}' WHERE id=${id}`;
      db.query(sql, function(err, result) {
        if (err) {
          console.log(err);
          res.status(500).send({ message: "An error occurred while updating the waste." });
        } else {
          console.log(result);
          res.status(200).send({ message: "Waste updated successfully" });
        }
      });
    }
  });
});


// delete waste by ID
app.delete("/wastedelete/:id", (req, res) => {
  const id = req.params.id;
  db.query("UPDATE geopos_wastemaster SET status='0' WHERE id = ?", [id], (err, result) => {
    if (err) {
      console.log(err);
      res.status(500).json({ error: 'An error occurred while deleting the waste.' });
    } else {
      console.log(result);
      res.json({ message: 'waste deleted successfully.' });
    }
  });
});


//machine master

//Get machine from database
app.get("/getmachine", (req, res) => {
  db.query("SELECT * FROM geopos_machine where status=1", (err, result) => {
    
      if(err) {
          console.log(err);
      } else {
          res.send(result);
          console.log(result);
          
      }
  });
});



// Add new machine
app.post("/addmachine", (req, res) => {
  var zone = req.body.zone;
  var machine = req.body.machine;

  // Log the values of zone and machine
  console.log("Zone:", zone);
  console.log("Machine:", machine);

  // Directly add the machine to the database without checking if it already exists
  var insertSql = `INSERT INTO geopos_machine (zone, machine) VALUES ("${zone}", "${machine}")`;
  db.query(insertSql, function (err, result) {
    if (err) {
      console.log(err);
      res.status(500).send({ message: "An error occurred" });
    } else {
      res.status(200).send({ message: "Machine added successfully" });
      console.log(result);
    }
  });
});


// GET request to fetch machine data by ID
app.get("/editmachine/:id", (req, res) => {
  const id = req.params.id;
  // Construct the SQL query with a placeholder
  const query = 'SELECT * FROM geopos_machine WHERE id = ?';

  // Execute the query with the id as a parameter
  db.query(query, [id], (error, results) => {
    if (error) {
      console.error('Error executing query:', error);
      res.status(500).json({ message: 'Server error' });
    } else {
      if (results.length > 0) {
        const section = results[0];
        res.status(200).json(section);
      } else {
        res.status(404).json({ message: 'Failed to fetch machine data' });
      }
    }
  });
});


// update machine by ID
app.post("/updatemachine", (req, res) => {
  var id = req.body.id;
  var zone = req.body.zone;
  var machine = req.body.machine;

  // Log the values of zone and machine
  console.log("Zone:", zone);
  console.log("Machine:", machine);

  var sql = `UPDATE geopos_machine SET zone = '${zone}', machine = '${machine}' WHERE id=${id}`;

  db.query(sql, function(err, result) {
    if (err) {
      console.log(err);
      res.status(500).send({ message: "An error occurred while updating the machine." });
    } else {
      console.log(result);
      res.status(200).send({ message: "Machine updated successfully" });
    }
  });
});

// delete machine by ID
app.delete("/machinedelete/:id", (req, res) => {
  const id = req.params.id;
  db.query("UPDATE geopos_machine SET status='0' WHERE id = ?", [id], (err, result) => {
    if (err) {
      console.log(err);
      res.status(500).json({ error: 'An error occurred while deleting the machine.' });
    } else {
      console.log(result);
      res.json({ message: 'Machine deleted successfully.' });
    }
  });
});

//Plan vs Target

//Get default plan vs target for current date
app.get("/get_default_planvstarget", (req, res) => {
  
  const date = new Date().toLocaleDateString('en-GB', { timeZone: 'Africa/Lagos' });
  const parts = date.split('/');
  const day = parts[0].padStart(2, '0');
  const month = parts[1].padStart(2, '0');
  const year = parts[2];
  const currentMonth = `${month}-${year}`;
  const currentDate = `${day}-${month}-${year}`;

  const query = `
  SELECT target_plan_ota.*, item_code.product_code, item_code.product_des
  FROM target_plan_ota
  LEFT JOIN item_code ON target_plan_ota.item_code_id = item_code.id
  WHERE target_plan_ota.date = ?`;

db.query(query, [currentDate], (err, results) => {
 

    if (err) {
      console.log(err);
    } else {
      res.send(results);
      // console.log(result);
      // console.log('Connected!');
    }
  });
});

//Get search plan vs target for date
app.post("/get_search_planvstarget", (req, res) => {

const fromdate = req.body.fromdate;
const fdParts = fromdate.split('-');
const fd = `${fdParts[2]}-${fdParts[1]}-${fdParts[0]}`;



const dateObj = new Date(fromdate);
const day = dateObj.getDate().toString().padStart(2, '0');
const month = (dateObj.getMonth() + 1).toString().padStart(2, '0');
const year = dateObj.getFullYear();

const convertedDate = `${day}-${month}-${year}`;
console.log('Converted:', convertedDate);



const query = `
  SELECT target_plan_ota.*, item_code.product_code, item_code.product_des
  FROM target_plan_ota
  LEFT JOIN item_code ON target_plan_ota.item_code_id = item_code.id
  WHERE target_plan_ota.date = ?`;

db.query(query, [convertedDate], (err, results) => {
 

    if (err) {
      console.log(err);
    }else {
      res.send(results);
      // console.log(result);
      // console.log('Connected!');
    }
   
     
  });
});


// Define the GET endpoint for fetching section targets
app.get('/gettargetplan', (req, res) => {
  // Execute the SQL query to fetch section targets from the database
  const query = `
            SELECT item_code.*, item_masterr.item_description
            FROM item_code
            LEFT JOIN item_masterr ON item_code.product_id = item_masterr.id`;

        db.query(query, (err, results) => {
 
    if (err) {
      console.error('Error fetching target plans:', err);
      res.status(500).json({ error: 'Internal Server Error' });
    } else {
      // Return the section targets as the API response
      res.json({ data: results });
    }
  });
});

//add target plan
app.post('/addtargetplan', (req, res) => {
  const itemSections = req.body;
   // Extract the product IDs and datetimes from itemSections array
   const item = itemSections.map((itemSection) => itemSection.item);
   const target = itemSections.map((itemSection) => itemSection.target);
   const date = itemSections.map((itemSection) => itemSection.date);
   const time = itemSections.map((itemSection) => itemSection.time);
    //console
   console.log('Received request body values:');
   console.log('item:', item);
   console.log('target:', target);
   console.log('date:', date);
   console.log('time:', time);

  let j = 0;
  let k = 0;
  let completedQueries = 0;

  const processQuery = (index) => {
    if (index >= itemSections.length) {
      if (j > 0 || k > 0) {
        res.status(200).json({ message: 'Target plans added/updated successfully' });
      } else {
        res.status(500).json({ 'status': 'Error', 'message': 'Database error' });
      }
      return;
    }

    const { item, target, date, time } = itemSections[index];

    const data = {
      'item_code_id': item,
      'target_plan': target,
      'date': date,
      'timestamp': time
    };

    const selectQuery = `SELECT * FROM target_plan_ota WHERE item_code_id='${item}' AND date='${date}'`;
    db.query(selectQuery, (error, results) => {
      if (error) {
        res.status(500).json({ 'status': 'Error', 'message': 'Database error' });
        return;
      }

      if (results.length > 0) {
        const cid = results[0].id;
        const updateQuery = `UPDATE target_plan_ota SET ? WHERE id='${cid}'`;
        db.query(updateQuery, data, (error) => {
          if (error) {
            res.status(500).json({ 'status': 'Error', 'message': 'Database error' });
            return;
          }
          j++;
          completedQueries++;
          processQuery(completedQueries);
        });
      } else {
        const insertQuery = 'INSERT INTO target_plan_ota SET ?';
        db.query(insertQuery, data, (error) => {
          if (error) {
            res.status(500).json({ 'status': 'Error', 'message': 'Database error' });
            return;
          }
          k++;
          completedQueries++;
          processQuery(completedQueries);
          
        });
      }
    });
  };

  processQuery(0);
});

// weekly plan view
app.get('/weeklyplanview', (req, res) => {
  const today = new Date();
  const dayOfWeek = today.getDay();
const startOfWeek = new Date(today);
startOfWeek.setDate(today.getDate() - dayOfWeek + 1);
const endOfWeek = new Date(today);
endOfWeek.setDate(today.getDate() - dayOfWeek + 7);

const fd2 = Math.floor(startOfWeek.getTime() / 1000);
const ws = fd2;

const td2 = Math.floor(endOfWeek.getTime() / 1000);
const we = td2;


  const mainQuery = `
    SELECT *
    FROM target_plan_ota
    WHERE (timestamp BETWEEN ${ws} AND ${we})
    AND item_code_id > 0
    GROUP BY item_code_id
  `;

  db.query(mainQuery, (err, rows) => {
    if (err) {
      console.error('Error executing query:', err);
      res.status(500).json({ error: 'Internal server error' });
      return;
    }

    const result = [];

    rows.forEach((row) => {
      const productId = row.item_code_id;
      //console.log('productId:', productId);
      const targets = [];
      const productQuery = `
        SELECT *
        FROM item_code
        WHERE id = ${productId}
      `;

       //console.log('productQuery:', productQuery);

      db.query(productQuery, (err, productRow) => {
        if (err) {
          console.error('Error executing subquery:', err);
          res.status(500).json({ error: 'Internal server error' });
          return;
        }

        const productDescription = productRow[0].product_des;
        //console.log('productDescription:', productDescription);
        
          // End the endpoint response after getting the product description
        result.push({ productDescription, productId });

        if (result.length === rows.length) {
          res.json(result);
        }
      });
    });
  });
});


// target plan 
app.get('/targetplan/batchh', async (req, res) => {
  try {
    const timezone = 'Africa/Lagos';

    const weekStart = new Date();
    weekStart.setDate(weekStart.getDate() - weekStart.getDay() + 1);
    const weekEnd = new Date(weekStart);
    weekEnd.setDate(weekStart.getDate() + 6);

    let from = '';
    let to = '';
    
    if (weekStart && weekEnd) {
      from = new Date(weekStart);
      to = new Date(weekEnd);
    }

    from.toLocaleString('en-US', { timeZone: timezone });
    to.toLocaleString('en-US', { timeZone: timezone });

    const period = [];
    const date = new Date(from);

    while (date <= to) {
      period.push(new Date(date));
      date.setDate(date.getDate() + 1);
    }
   
   

    // Function to format a date as "d-m-Y"
    
    const formatDate = (date) => {
      const day = String(date.getDate()).padStart(2, '0');
      const month = String(date.getMonth() + 1).padStart(2, '0');
      const year = date.getFullYear();
      return `${day}-${month}-${year}`;
    };
    
    //const fd2 = Math.floor(new Date(weekStart).getTime() / 1000);
    const fd2 = Math.floor((weekStart.getTime() - (24 * 60 * 60 * 1000)) / 1000);
    const td1 = Math.floor(new Date(weekEnd).getTime() / 1000);

    console.log('fd2:',fd2);
    console.log('td1:',td1);
    const formattedDates = period.map((date) => formatDate(date));
    // Fetch data for geopos_machine
    const zoneRows = await planVsTargetquery(`SELECT * FROM target_plan_ota
    WHERE timestamp BETWEEN ${fd2} AND ${td1}
      AND item_code_id > 0
    GROUP BY item_code_id`);

    if (zoneRows.length > 0) {
      const responseData = [];

      for (const zoneItem of zoneRows) {
        const pdata = zoneItem.item_code_id;
        const descPromise = planVsTargetquery('SELECT * FROM item_code WHERE id = ?', [pdata]);
        
        const valuesByDate = {};
        const operatorPromises = formattedDates.map(async (formattedDate) => {
          try {
            const operatorRows = await planVsTargetquery(`
              SELECT * FROM target_plan_ota WHERE item_code_id = ? AND date = ?
            `, [pdata, formattedDate]);

            if (operatorRows.length > 0) {
              const count = operatorRows[0].target_plan;
              valuesByDate[formattedDate] = count;
              //console.log(count);
            } else {
              valuesByDate[formattedDate] = '';
            }
          } catch (dbError) {
            console.error('Database Error:', dbError);
            valuesByDate[formattedDate] = 'Error fetching data';
          }
        });

      

        const descResult = await descPromise;
        const descValue = descResult[0].product_des;
   
        await Promise.all(operatorPromises); // Await all operator data fetching

        responseData.push({
          values: valuesByDate,
          dates: formattedDates,
          desc: descValue,
        });
      }

      res.json(responseData);
      //console.log(responseData);
    } else {
      res.status(404).json({ error: 'No data found' });
    }
  } catch (error) {
    console.error(error);
    res.status(500).json({ error: 'An error occurred' });
  }
});


function planVsTargetquery(query, values) {
  return new Promise((resolve, reject) => {
    db.query(query, values, (err, results) => {
      if (err) {
        reject(err);
      } else {
        resolve(results);
      }
    });
  });
}




// Define the API endpoint
app.post('/targetplan/:productId', (req, res) => {
  const productId = req.params.productId;

  // Process the productId and send a response
  const responseData = {
    productId,
    productInfo: 'Sample product info for productId ' + productId
  };

  // Calculate date range
  const week_start = new Date();
  week_start.setDate(week_start.getDate() - week_start.getDay());
  const week_endd = new Date(week_start);
  week_endd.setDate(week_start.getDate() + 7);

  const period = [];
  let current = new Date(week_start);
  while (current <= week_endd) {
    period.push(current);
    current = new Date(current);
    current.setDate(current.getDate() + 1);
  }

  const targetPlanData = [];

  // Execute queries for each day in the period
  period.forEach((dt) => {
    const dtt = formatDate(dt); // Assuming formatDate function formats date as "d-m-Y"
    const time = dt.getTime();
    
    const query = `SELECT * FROM target_plan_ota WHERE item_code_id='${product_code}' AND timestamp='${time}'`;

    db.query(query, (err, results) => {
      if (err) {
        console.error('Error querying database:', err);
      } else if (results.length > 0) {
        const target = results[0].target_plan;
        targetPlanData.push({ date: dtt, target: target });
      }
    });
  });

  // Send the target plan data as a response
  res.json(targetPlanData);
});

// Helper function to format date as "d-m-Y"
function formatDate(date) {
  const day = date.getDate();
  const month = date.getMonth() + 1;
  const year = date.getFullYear();
  return `${day}-${month}-${year}`;
}


app.get("/ptt", (req, res) => {
  const weekDatesArray = getAllWeekDates();
  console.log(weekDatesArray);
  db.query("SELECT target_plan.*, item_masterr.item_description, item_masterr.item_group FROM target_plan INNER JOIN item_masterr ON target_plan.product_id = item_masterr.id GROUP BY target_plan.product_id", (err, result) => {
    if (err) {
      console.log(err);
      res.status(500).send("Error fetching data from the database");
      return;
    }

    let processedResult = [];
    let index = 0;

    const processNextRow = () => {
      if (index >= result.length) {
        // All rows processed, send the response
        res.send(processedResult);
        return;
      }

      const rowData = result[index];
      const processedRow = { item_group: rowData.item_group, item_description: rowData.item_description };

      let index2 = 0;
      const processNextDate = () => {
        if (index2 >= weekDatesArray.length) {
          // All dates for this row processed, move to the next row
          processedResult.push(processedRow);
          index++;
          processNextRow();
          return;
        }

        const currentDate = weekDatesArray[index2];

        db.query(
          `SELECT plan FROM target_plan WHERE product_id = ${rowData.product_id} AND datetime = '${currentDate}'`,
          (err, result2) => {
            if (err) {
              console.log(err);
              res.status(500).send("Error fetching data from the database");
              return;
            }

            const plan = result2.length > 0 ? result2[0].plan : "-";
            const dayKey = "day" + index2;
            processedRow[dayKey] = plan;

            index2++;
            processNextDate();
          }
        );
      };

      processNextDate();
    };

    processNextRow();
  });
});

// Function to get all the dates of the current week (Monday to Sunday) in DD-MM-YYYY format
function getAllWeekDates() {
  const now = new Date();
  const currentDayOfWeek = now.getDay();
  const startOfWeek = new Date(now);
  const offsetToMonday = currentDayOfWeek === 0 ? -6 : 1 - currentDayOfWeek;
  startOfWeek.setDate(now.getDate() + offsetToMonday);
  const weekDates = [];

  const options = { day: '2-digit', month: '2-digit', year: 'numeric' };
  const hyphenSeparator = '-';

  for (let i = 0; i < 7; i++) {
    const currentDate = new Date(startOfWeek);
    currentDate.setDate(startOfWeek.getDate() + i);
    const formattedDate = currentDate.toLocaleDateString(undefined, options)
      .split('/').join(hyphenSeparator);
    weekDates.push(formattedDate);
  }

  return weekDates;
}



// delete plan vs target by ID
app.delete("/planvstargetdelete/:id", (req, res) => {
  const id = req.params.id;
  db.query("DELETE FROM target_plan_ota WHERE id = ?", [id], (err, result) => {
    if (err) {
      console.log(err);
      res.status(500).json({ error: 'An error occurred while deleting the plan vs target.' });
    } else {
      console.log(result);
      res.json({ message: 'plan vs target deleted successfully.' });
    }
  });
});


//Section

//Fetch Section data from section table to view in datatable
app.get("/section", (req, res) => {
 
  db.query("SELECT * FROM section where status = '1'", (err, result) => {
        if(err) {
            console.log(err);
        } else {
            res.send(result);
            console.log(result);
            console.log('Connected!');
        }
    });
  });

//get section type
app.get("/getsectiontype", (req, res) => {
  db.query("SELECT * FROM item_category", (err, result) => {
    
      if(err) {
          console.log(err);
      } else {
          res.send(result);
          console.log(result);
          
      }
  });
}); 


//Add Section
  app.post("/addsection", (req, res) => {
    var sectionname = req.body.section_name;
    var tunit = req.body.target_unit;
    var stype = req.body.section_type;
    
    // Check if the section already exists
    var checkSql = `SELECT * FROM section WHERE section_name = "${sectionname}" AND status = '1' `;
    db.query(checkSql, function (err, result) {
      if (err) {
        console.log(err);
        res.status(500).send({ message: "An error occurred" });
      } else {
        if (result.length > 0) {
          // Section already exists
          res.status(409).send({ message: "Error : Section already exists" });
        } else {
          // Section does not exist, add it to the database
          var insertSql = `INSERT INTO section (section_name, target_unit, section_type) VALUES ("${sectionname}", "${tunit}", "${stype}")`;
          db.query(insertSql, function (err, result) {
            if (err) {
              console.log(err);
              res.status(500).send({ message: "An error occurred" });
            } else {
              res.status(200).send({ message: "Section added successfully" });
              console.log(result);
              
            }
          });
        }
      }
    });
  });

  

   // GET request to fetch section data by ID
app.get("/getsection/:id", (req, res) => {
  const id = req.params.id;
  // Construct the SQL query with a placeholder
  const query = 'SELECT * FROM section WHERE id = ?';

  // Execute the query with the id as a parameter
  db.query(query, [id], (error, results) => {
    if (error) {
      console.error('Error executing query:', error);
      res.status(500).json({ message: 'Server error' });
    } else {
      if (results.length > 0) {
        const section = results[0];
        res.status(200).json(section);
      } else {
        res.status(404).json({ message: 'Section not found' });
      }
    }
  });
});

// update section by ID
app.post("/updatesection", (req, res) => {
  var id = req.body.id;
  var sname = req.body.section_name;
  var tunit = req.body.target_unit;
  var stype = req.body.section_type;

  // Check if the new section name already exists in the database
  var checkDuplicateSQL = `SELECT * FROM section WHERE section_name = "${sname}" AND status = '1' `;
  db.query(checkDuplicateSQL, function(err, duplicateResult) {
    if (err) {
      console.log(err);
      res.status(500).json({ error: 'An error occurred while checking for duplicate entry.' });
    } else if (duplicateResult.length > 0) {
      res.status(400).json({ error: 'Section name already exists.' });
    } else {
      var sql = `UPDATE section SET section_name='${sname}', target_unit='${tunit}', section_type='${stype}' WHERE id=${id}`;
      db.query(sql, function(err, result) {
        if (err) {
          console.log(err);
          res.status(500).json({ error: 'An error occurred while updating the section.' });
        } else {
          console.log(result);
          res.json({ message: 'Section updated successfully.' });
        }
      });
    }
  });
});

// delete section by ID
app.delete("/sectiondelete/:id", (req, res) => {
  const id = req.params.id;
  db.query("UPDATE section SET status='0' WHERE id = ?", [id], (err, result) => {
    if (err) {
      console.log(err);
      res.status(500).json({ error: 'An error occurred while deleting the section.' });
    } else {
      console.log(result);
      res.json({ message: 'Section deleted successfully.' });
    }
  });
});
 

//Item Master

//Get Item Master for datatables
app.get("/getitemmaster", (req, res) => {

  const query = `
  SELECT item_masterr.*, item_category.category_name
  FROM item_masterr
  LEFT JOIN item_category ON item_masterr.category_id = item_category.id`;

  db.query(query, (err, result) => {
    if (err) {
      console.log(err);
      res.status(500).json({ error: "An error occurred" });
    } else {
      res.send(result);
      console.log(result);
     
    }
  });
});

//Get Sections Targets for Add New Item Master 
app.get('/getsectiontarget', (req, res) => {
  // Execute the SQL query to fetch section targets from the database
  db.query(`SELECT * FROM section where status='1'`, (err, results) => {
    if (err) {
      console.error('Error fetching section targets:', err);
      res.status(500).json({ error: 'Internal Server Error' });
    } else {
      // Return the section targets as the API response
      res.json({ data: results });
    }
  });
});

//Fetch categories and subcategories in add item master
app.get('/getcategories', (req, res) => {
  // Fetch all categories
  db.query('SELECT * FROM item_category', (err, results) => {
    if (err) {
      console.error('Failed to fetch categories:', err);
      res.status(500).json({ error: 'Failed to fetch categories' });
    } else {
      const categories = results.map((category) => ({
        id: category.id,
        category_name: category.category_name,
        // Include other properties if necessary
      }));
      res.json({ data: categories });
    }
  });
});

//get subcategories based on category value
app.get('/getcatsubcat/:category_id', (req, res) => {
  const categoryId = req.params.category_id;

  // Fetch subcategories based on the provided category_id
  db.query('SELECT * FROM item_subcategory WHERE category_id = ?', [categoryId], (err, results) => {
    if (err) {
      console.error('Failed to fetch subcategories:', err);
      res.status(500).json({ error: 'Failed to fetch subcategories' });
    } else {
      const subcategories = results.map((subcategory) => ({
        id: subcategory.id,
        subcategory_name: subcategory.subcategory_name,
        // Include other properties if necessary
      }));
      res.json({ data: subcategories });
    }
  });
});

//get sections based on category value
app.get('/getcatsection/:category_id', (req, res) => {
  const categoryId = req.params.category_id;

  const getCategoryQuery = 'SELECT * FROM item_category WHERE id = ?';
  db.query(getCategoryQuery, [categoryId], (error, results, fields) => {
    if (error) {
      console.error('Error executing the first query:', error);
      res.status(500).json({ error: 'An error occurred while fetching category.' });
    } else {
      if (results.length > 0) {
        const category_name = results[0].category_name;
        console.log('Category Name:', category_name);

        const getItemsQuery = 'SELECT * FROM section WHERE section_type = ? OR section_type = ? AND status = ?';
        db.query(getItemsQuery, [category_name, 'ALL', '1'], (err, itemResults, fields) => {
          if (err) {
            console.error('Error executing the second query:', err);
            res.status(500).json({ error: 'An error occurred while fetching items.' });
          } else {
            console.log('Items in this category:', itemResults);
            res.json({ data: itemResults });
          }
        });
      } else {
        console.log('Category not found');
        res.status(404).json({ error: 'Category not found.' });
      }
    }
  });
});



//add item master
app.post('/additemmaster', (req, res) => {
  const {
    category_id,
    item_group,
    item_description,
    tppp,
    net_weight,
    targeted_waste,
    target,
    utarget,
  } = req.body;

  const sectionWiseTargets = req.body.sectionWiseTargets;

  if (sectionWiseTargets && Array.isArray(sectionWiseTargets)) {
    const sections = [];
    const targets = [];
    const sectionids = [];

    sectionWiseTargets.forEach((item) => {
      if (item && item.section) {
        sections.push(item.section);
        targets.push(item.target);
        sectionids.push(item.sectionid);
      }
    });

    console.log('Sections:', sections);
    console.log('Targets:', targets);
    console.log('sectionids:', sectionids);

    const date = new Date().toLocaleDateString('en-GB', { timeZone: 'Africa/Lagos' });
    const parts = date.split('/');
    const day = parts[0].padStart(2, '0');
    const month = parts[1].padStart(2, '0');
    const year = parts[2];
    const currentMonth = `${month}-${year}`;
    const currentDate = `${day}-${month}-${year}`;

    const data = {
      category_id: category_id,
      item_group: item_group,
      item_description: item_description,
      tppp: tppp,
      net_weight: net_weight,
      targeted_waste: targeted_waste,
    };

    db.query(
      `SELECT * FROM item_masterr WHERE item_description = '${item_description}'`,
      (err, result) => {
        if (err) {
          console.error('Database error:', err);
          return res.status(500).json({ status: 'Error', message: 'Database error' });
        }

        if (result.length > 0) {
          // Item already exists
          return res.status(409).json({ status: 'Error', message: 'Item already exists' });
        } else {
          db.query('INSERT INTO item_masterr SET ?', data, (err, result) => {
            if (err) {
              console.error('Database error:', err);
              return res.status(500).json({ status: 'Error', message: 'Database error' });
            }

            if (sections.length > 0) {
              db.query('SELECT * FROM item_masterr ORDER BY id DESC LIMIT 1', (err, result) => {
                if (err) {
                  console.error('Database error:', err);
                  return res.json({ status: 'Error', message: 'Database error' });
                }
                const opid = result[0].id;
                console.log('OPId:', opid);

                sections.forEach((section, index) => {
                  if (!section) {
                    console.log(`Invalid section at index ${index} in sectionWiseTargets array.`);
                    res.status(400).send({ message: "Invalid sectionWiseTargets array in the request." });
                    return;
                  }
                  const data1 = {
                    item_id: opid,
                    section_id: sectionids[index],
                    target: targets[index],
                  };

                  console.log('data1:', data1); // Add this line to log data1 to the console

                  db.query(
                    `SELECT * FROM item_section_ota WHERE item_id='${opid}' AND section_id='${section}'`,
                    (err, result) => {
                      if (err) {
                        console.error('Database error in SELECT:', err);
                      }

                      if (result.length > 0) {
                        const cid = result[0].id;
                        console.log('cid:', cid);
                        const datau = {
                          target: targets[index],
                          utarget: utarget[index],
                        };

                        db.query(
                          'UPDATE item_section_ota SET ? WHERE id = ?',
                          [datau, cid],
                          (err, result) => {
                            if (err) {
                              console.error('Database error in UPDATE:', err);
                            }
                          }
                        );
                      } else {
                        db.query(
                          'INSERT INTO item_section_ota SET ?',
                          data1,
                          (err, result) => {
                            if (err) {
                              console.error('Database error in INSERT:', err);
                            }
                          }
                        );
                      }
                    }
                  );
                });
                // res.status(200).send({ message: "Item added successfullyy" });
              });

              return res.status(200).json({ status: 'Success', message: 'Item added successfully' });
            }

            // Item added successfully without sectionWiseTargets...
            return res.status(200).json({ status: 'Success', message: 'Item added successfully' });
          });
        }
      }
    );
  } else {
    console.log('sectionWiseTargets not found or not in the expected format.');
    res.status(400).json({ status: 'Error', message: 'sectionWiseTargets not found or not in the expected format.' });
  }
});

//add item sections
app.post('/additemsections', (req, res) => {
  const itemSections = req.body;

  const sql = 'INSERT INTO item_section_moz (item_id, section_id, target, utarget) VALUES ?';

  // Extract the values from itemSections array
  const values = itemSections.map((itemSection) => [
    itemSection.item_id, // Use null if item_id is undefined
    itemSection.section_id,
    itemSection.target,
    itemSection.utarget,
  ]);

  // Execute the query with the values
  db.query(sql, [values], (error, result) => {
    if (error) {
      console.error('Error inserting item sections:', error);
      res.status(500).json({ error: 'Failed to insert item sections' });
    } else {
      console.log('Item sections inserted successfully');
      res.status(200).json({ message: 'Item sections added successfully' });
    }
  });
});

// API endpoint to fetch sections and targets
app.get('/getsections/:itemId', (req, res) => {
  const itemId = req.params.itemId;
  console.log('Recieved ID:', itemId);

  // Fetch sections data from the item_section_moz table
  const query = `
  SELECT item_section_ota.*, section.section_name, section.target_unit
      FROM item_section_ota
      LEFT JOIN section ON item_section_ota.section_id = section.id
      WHERE item_section_ota.item_id = "${itemId}"
`;

  db.query(query, (err, results) => {
    if (err) {
      console.error('Error fetching sections:', err);
      res.sendStatus(500);
    } else {
      const sections = results.map((row) => ({
        id: row.id,
        section_name: row.section_name,
        target_unit: row.target_unit,
        target: row.target,
      }));
      res.json(sections);
    }
  });
});


//add new section to item_master product
app.post('/addsectionitemmaster/:itemId', (req, res) => {
  const itemId = req.params.itemId;
 
  const section = req.body.section;
  const target = req.body.target;

  console.log('Recieved ID:', itemId);
  
  var checkSql = `SELECT * FROM item_section_ota WHERE item_id = "${itemId}" AND section_id = "${section}"`;
  db.query(checkSql, function (err, result) {
    if (err) {
      console.log(err);
      res.status(500).send({ message: "An error occurred" });
    } else {
      if (result.length > 0) {
        // Color already exists
        res.status(409).send({ message: "Error : Section already exists" });
      } else {
        // Color does not exist, add it to the database
        var insertSql = `INSERT INTO item_section_ota (item_id, section_id, target) VALUES ("${itemId}", "${section}", "${target}" )`;
        db.query(insertSql, function (err, result) {
          if (err) {
            console.log(err);
            res.status(500).send({ message: "An error occurred" });
          } else {
            res.status(200).send({ message: "Section added successfully" });
            console.log(result);
            
          }
        });
      }
    }
  });
});


//get section,unit and target to update 
app.get('/getsectionandtarget/:itemId', (req, res) => {
  const itemId = req.params.itemId;

  // Fetch section name, target unit, and target from the Section and item_section_moz tables
  const query = `
    SELECT s.section_name, s.target_unit, ism.target
    FROM item_section_ota ism
    INNER JOIN section s ON ism.section_id = s.id
    WHERE ism.id = ${itemId}
    LIMIT 1
  `;

  db.query(query, (err, results) => {
    if (err) {
      console.error('Error fetching section and target:', err);
      res.sendStatus(500);
    } else {
      if (results.length === 0) {
        // Handle the case where no section and target is found for the itemId
        res.status(404).json({ error: 'Section and target not found' });
        return;
      }

      const sectionName = results[0].section_name;
      const targetUnit = results[0].target_unit;
      const target = results[0].target;

      res.json({ sectionName, targetUnit, target });
    }
  });
});


// Update target value API endpoint
app.post('/updatesectiontarget', (req, res) => {
  const itemId = req.body.id;
  const updatedTarget = req.body.updatedtarget;

  const query = 'UPDATE item_section_ota SET target = ? WHERE id = ?';
  db.query(query, [updatedTarget, itemId], (error, results) => {
    if (error) {
      console.error('Error updating target value:', error);
      res.status(500).json({ error: 'An error occurred while updating the target value.' });
    } else {
      res.json({ message: 'Target value updated successfully.' });
    }
  });
});


//Get Color for dropdown
app.get("/getcolors", (req, res) => {
  db.query("SELECT * FROM color_master", (err, result) => {
    
      if(err) {
          console.log(err);
      } else {
          res.send(result);
          console.log(result);
          console.log('Connected!');
      }
  });
}); 


//get color and products code and product description
app.get("/getdata/:itemId", (req, res) => {

  const itemId = req.params.itemId;

  const sql = `
  SELECT item_code.*, item_masterr.item_group, item_masterr.item_description, color_master.color_name
  FROM item_code
  LEFT JOIN item_masterr ON item_code.product_id = item_masterr.id
  LEFT JOIN color_master ON item_code.color_id = color_master.id
  WHERE item_code.product_id = ${itemId}
  `;
  db.query(sql, [itemId], (err, result) => {
    
      if(err) {
          console.log(err);
      } else {
          res.send(result);
          console.log(result);
          console.log('Connected!');
      }
  });
}); 

// add an item color to the item_code table
 app.post('/additemcolor/:itemId', (req, res) => {
  const itemId = req.params.itemId;
  const code = req.body.code;
  const desc = req.body.desc;
  const color = req.body.color;

  const date = new Date().toLocaleDateString('en-GB', { timeZone: 'Africa/Lagos' });
  const parts = date.split('/');
  const day = parts[0].padStart(2, '0');
  const month = parts[1].padStart(2, '0');
  const year = parts[2];
  const currentDate = `${day}-${month}-${year}`;


  console.error('currentDate:', currentDate);
    
    // Check if the color already exists
    var checkSql = `SELECT * FROM item_code WHERE product_id="${itemId}" and product_code="${code}" `;
    db.query(checkSql, function (err, result) {
      if (err) {
        console.log(err);
        res.status(500).send({ message: "Color already exists" });
      } else {
        if (result.length > 0) {
          // Color already exists
          res.status(409).send({ message: "Error : Color already exists" });
        } else {
          // Color does not exist, add it to the database
          var insertSql = `INSERT INTO item_code (product_code, product_des, color_id, date, product_id) VALUES ("${code}", "${desc}", "${color}", "${currentDate}", "${itemId}")`;
          db.query(insertSql, function (err, result) {
            if (err) {
              console.log(err);
              res.status(500).send({ message: "An error occurred" });
            } else {
              res.status(200).send({ message: "Color added successfully" });
              console.log(result);
              
            }
          });
        }
      }
    });
  });

//getitemcode data
app.get('/getitemcodedata/:itemId', (req, res) => {
  const itemId = req.params.itemId;

  const query = `SELECT * FROM item_code WHERE id = ${itemId}`;

  // Execute the query and handle the result
  db.query(query, (error, results) => {
    if (error) {
      console.error('Error fetching item data:', error);
      res.status(500).json({ error: 'Failed to fetch item data' });
    } else {
      res.json(results);
    }
  });
});

// Update item color route
app.post('/updateitemcolor/:itemId', (req, res) => {
  const itemId = req.params.itemId;
  const { product_code, product_des, color_id } = req.body;

  // Perform the update operation in your MySQL database
  const updateQuery = 'UPDATE item_code SET product_code = ?, product_des = ?, color_id = ? WHERE id = ?';
  const updateValues = [product_code, product_des, color_id, itemId];

  db.query(updateQuery, updateValues, (error, results) => {
    if (error) {
      console.error('Error updating item color:', error);
      res.status(500).json({ error: 'Failed to update ItemMaster Color' });
    } else {
      console.log('ItemMaster Color updated');
      res.status(200).json({ message: 'ItemMaster Color updated successfully' });
    }
  });
});

// DELETE route for deleting an item by ID
app.delete('/deleteitemcode/:id', (req, res) => {
  const itemId = req.params.id;

db.query("DELETE FROM item_code WHERE id = ?", [itemId], (err, result) => {
  if (err) {
    console.log(err);
    res.status(500).json({ error: 'An error occurred while deleting the item_code.' });
  } else {
    console.log(result);
    res.json({ message: 'Deleted Successfully' });
  }
});
});

//edit itemmaster
app.get('/edititemmaster/:itemId', (req, res) => {
  const itemId = req.params.itemId;
  const query = `SELECT * FROM item_masterr WHERE id = ${itemId}`;

  // Execute the query and handle the result
  db.query(query, (error, results) => {
    if (error) {
      console.error('Error fetching item data:', error);
      res.status(500).json({ error: 'Failed to fetch item data' });
    } else {
      res.json(results);
    }
  });
});


//update itemmaster
app.post('/updateitemmaster/:itemId', (req, res) => {
  const itemId = req.params.itemId;
  const { category_id, item_group, item_description, tppp, net_weight, targeted_waste } = req.body;

  // Perform database update operation using the provided data
  const query = 'UPDATE item_masterr SET category_id = ?, item_group = ?, item_description = ?, tppp = ?, net_weight = ?, targeted_waste = ? WHERE id = ?';
  const values = [category_id, item_group, item_description, tppp, net_weight, targeted_waste, itemId];

  db.query(query, values, (error, result) => {
    if (error) {
      console.error('Error updating item:', error);
      res.status(500).json({ error: 'Failed to update ItemMaster' });
    } else {
      console.log('ItemMaster updated successfully');
      res.json({ message: 'ItemMaster updated successfully' });
    }
  });
});


// delete itemmaster by ID
app.delete("/itemmasterdelete/:id", (req, res) => {
  const id = req.params.id;
  const queries = [
    'DELETE FROM item_masterr WHERE id = ?',
    'DELETE FROM item_code WHERE product_id = ?',
    'DELETE FROM item_section_ota WHERE item_id = ?',
  ];

  db.query(queries[0], [id], (err, result) => {
    if (err) {
      console.log(err);
      return res.status(500).json({ error: 'An error occurred while deleting the item_masterr.' });
    }

    db.query(queries[1], [id], (err, result) => {
      if (err) {
        console.log(err);
        return res.status(500).json({ error: 'An error occurred while deleting the item_code.' });
      }

      db.query(queries[2], [id], (err, result) => {
        if (err) {
          console.log(err);
          return res.status(500).json({ error: 'An error occurred while deleting the item_section_ota.' });
        }

        res.json({ message: 'Item Master and Related Data Deleted Successfully' });
      });
    });
  });
});


// delete target
app.delete('/delete_target/:id', (req, res) => {
  const id = req.params.id;

  if (id) {
    const query = 'DELETE FROM item_section_ota WHERE id = ?';

    db.query(query, [id], (err, results) => {
      if (err) {
        console.error('Error executing MySQL query:', err);
        res.status(500).json({ status: 'Error', message: 'Internal Server Error' });
      } else {
        res.json({ status: 'Success', message: 'Delete Successfully' });
      }
    });
  } else {
    res.status(400).json({ status: 'Error', message: 'Invalid Request' });
  }
});

//-------------------------MASTER--------------------------------//

//----------------------------HRM--------------------------------//
//ADMIN START

//Admin List
app.get('/admin', (req, res) => {
  const roleid = 5; // Implement your logic to get the role ID
  const empId = 9; // Implement your logic to get the employee ID

  let query;
  if (roleid === 5 && empId === 9) {
    //query = 'SELECT * FROM geopos_users WHERE roleid = 5 AND id != 9 ORDER BY id DESC';
    query = 'SELECT gu.*, get.name as roleName FROM geopos_users gu JOIN geopos_emptype get ON gu.roleid = get.id WHERE gu.roleid = 5 AND gu.id != ? ORDER BY gu.id DESC';
  } else {
   // query = 'SELECT * FROM geopos_users WHERE id = ? AND roleid = 5 ORDER BY id DESC';
   query = ' SELECT geopos_users.*, geopos_emptype.name as roleName FROM geopos_users LEFT JOIN geopos_emptype ON geopos_users.roleid = geopos_emptype.id WHERE geopos_users.id = ? AND geopos_users.roleid = ? ORDER BY geopos_users.id DESC';
  }

  db.query(query, [empId], (err, results) => {
    if (err) {
      console.error('Error executing MySQL query:', err);
      res.status(500).json({ error: 'Internal Server Error' });
      return;
    }

    console.log('Query Results:', results); // Log the results to the console

    res.status(200).json({ data: results }); // Send the response with the array directly under the "data" key
  });
});

//add admin
app.post('/addnewadmin1', async (req, res) => {
  //const { entryid, email, password, name } = req.body;
  const entryid = req.body.entryid;
  const email = req.body.email;
  let password = req.body.password || '123456'; // Default password if not provided
  const name = req.body.name;
  const roleid = '5';
  const production_type = 'both';
  const category_type = 'both';

  console.log('EntryId:', entryid);
  console.log('Email:', email);
  console.log('Password:', password);
  console.log('Name:', name);
  console.log('RoleId:', roleid);

  if (roleid < 4) {
    return res.json({ status: 'Error', message: 'Unauthorized' });
  }

  const query = `
    SELECT * FROM geopos_users 
    WHERE entryid = ? OR email = ?
  `;

  const updateQuery = `
    UPDATE geopos_users
    SET entryid = ?, name = ?, roleid = '5', production_type = 'both', category_type = 'both'
    WHERE id = ?
  `;

  db.query(query, [entryid, email], async (err, result) => {
    if (err) {
      console.error('MySQL query error:', err);
      return res.json({ status: 'Error', message: 'Database error' });
    }

    if (result.length > 0) {
      return res.json({ status: 'Error', message: 'EntryId or Email Already Exist' });
    } else {
      const newUser = {
        email: email,
        pass: await hashPassword1(password, entryid),
        username: email,
        name: name,
      };

      console.log('newUser:',newUser);

      db.query('INSERT INTO geopos_users SET ?', newUser, async (err, result) => {
        if (err) {
          console.error('MySQL insert error:', err);
          return res.json({ status: 'Error', message: 'Database error' });
        }

        const nuid = result.insertId;

        if (nuid > 0) {
          const userId = result.insertId;

          db.query(updateQuery, [entryid, name, userId], async (err, updateResult) => {
            if (err) {
              console.error('MySQL update error:', err);
              return res.json({ status: 'Error', message: 'Error updating user' });
            }

            console.log('Admin added and updated successfully:', newUser);

            return res.json({ status: 'Success', message: 'Admin added successfully' });
          });
        } else {
          return res.json({ status: 'Error', message: 'Error creating user' });
        }
      });
    }
  });
});
// Function to hash a password
async function hashPassword1(password, entryid) {
  if (configVars.usePasswordHash) {
    const saltRounds = configVars.passwordHashOptions.saltRounds || 10;
    return bcrypt.hash(password, saltRounds);
  } else {
    const salt = crypto.createHash('md5').update(entryid  || '').digest('hex');
    const hashAlgorithm = configVars.hash || 'sha256';
    return crypto.createHash(hashAlgorithm).update(salt + password).digest('hex');
  }
}

app.post('/addnewadmin', async (req, res) => {
  const entryid = req.body.entryid;
  const email = req.body.email;
  let password = req.body.password || '123456'; // Default password if not provided
  const name = req.body.name;
  const roleid = '5';
  const production_type = 'both';
  const category_type = 'both';

  console.log('EntryId:', entryid);
  console.log('Email:', email);
  console.log('Password:', password);
  console.log('Name:', name);
  console.log('RoleId:', roleid);

  if (roleid < 4) {
    return res.json({ status: 'Error', message: 'Unauthorized' });
  }

  // Get the current date
  const date = new Date().toLocaleDateString('en-GB', {
    day: '2-digit',
    month: '2-digit',
    year: 'numeric',
  }).replace(/\//g, '-');
  //date time
  const currentDate = new Date();

  // Function to format the date in 'Y-m-d H:i:s' format
  const formatDate = (date) => {
    const year = date.getFullYear();
    const month = String(date.getMonth() + 1).padStart(2, '0');
    const day = String(date.getDate()).padStart(2, '0');
    const hours = String(date.getHours()).padStart(2, '0');
    const minutes = String(date.getMinutes()).padStart(2, '0');
    const seconds = String(date.getSeconds()).padStart(2, '0');

    return `${year}-${month}-${day} ${hours}:${minutes}:${seconds}`;
  };

  // Format the current date in 'Y-m-d H:i:s' format
  const formattedDate = formatDate(currentDate);

  const query = `
    SELECT * FROM geopos_users 
    WHERE entryid = ? OR email = ?
  `;

  const updateQuery = `
  UPDATE geopos_users
  SET entryid = ?, pass = ?, name = ?, roleid = '5', production_type = 'both', category_type = 'both'
  WHERE id = ?
`;

  db.query(query, [entryid, email], async (err, result) => {
    if (err) {
      console.error('MySQL query error:', err);
      return res.json({ status: 'Error', message: 'Database error' });
    }

    if (result.length > 0) {
      return res.json({ status: 'Error', message: 'EntryId or Email Already Exist' });
    } else {
      const hashedPassword = await hashPassword1(password, entryid); // Hash password using entryid

      const newUser = {
        email: email,
        pass: hashedPassword,
        username: email,
        name: name,
        date_created: formattedDate,
      };

      console.log('newUser:', newUser);

      db.query('INSERT INTO geopos_users SET ?', newUser, async (err, result) => {
        if (err) {
          console.error('MySQL insert error:', err);
          return res.json({ status: 'Error', message: 'Database error' });
        }

        const nuid = result.insertId;
        console.log('nuid:', nuid);

        if (nuid > 0) {
          const userId = result.insertId;
          console.log('userId:', userId);

          // Hash password using userId when updating
          const hashedPasswordForUpdate = await hashPassword2(password, userId);

          db.query(updateQuery, [entryid, hashedPasswordForUpdate, name, userId], async (err, updateResult) => {
            if (err) {
              console.error('MySQL update error:', err);
              return res.json({ status: 'Error', message: 'Error updating user' });
            }

            console.log('Admin added and updated successfully:', newUser);

            return res.json({ status: 'Success', message: 'Admin added successfully' });
          });
        } else {
          return res.json({ status: 'Error', message: 'Error creating user' });
        }
      });
    }
  });
});

// Function to hash a password
function hashPassword2(pass, userId) {
  userId = String(userId); // Ensure userId is a string
  if (configVars.usePasswordHash) {
    const saltRounds = configVars.passwordHashOptions.saltRounds || 10;
    return bcrypt.hash(pass, saltRounds);
  } else {
    const salt = crypto.createHash('md5').update(userId).digest('hex');
    const hashAlgorithm = configVars.hash || 'sha256';
    return crypto.createHash(hashAlgorithm).update(salt + pass).digest('hex');
  }
}

//Get admin data single 
app.get('/admin_data_single/:id', (req, res) => {
  const id = req.params.id
  db.query('SELECT * FROM geopos_users WHERE id=?',[id], (err, result) => {
    if (err) {
      console.log(err)
    }
    if (result.length > 0) {
      res.send(result[0]); // Send only the name value from the result
    } else {
      res.status(404).send("Admin not found");
    }
  })
})

//Get admin Role
app.get('/get_admin_role/:id', (req, res) => {
  const id = req.params.id;
  db.query(' SELECT u.*, r.* FROM geopos_users u LEFT JOIN geopos_emptype r ON u.roleid = r.id WHERE u.id = ?', id, (err, result) => {
    if (err) {
      console.log(err)
    }
    res.send(result)
  })
})

// Route for updating admin
app.post('/update_admin', (req, res) => {
  if (!req.body.id || !req.body.name) {
    return res.status(400).json({ status: 'Error', message: 'Missing required parameters' });
  }

  const sql = 'UPDATE geopos_users SET name = ? WHERE id = ?';

  const values = [req.body.name, req.body.id];

  db.query(sql, values, (err, result) => {
    if (err) {
      console.error('Error updating employee admin:', err);
      return res.status(500).json({ status: 'Error', message: 'Internal Server Error' });
    }

    if (result.affectedRows > 0) {
      return res.status(200).json({ status: 'Success', message: 'UPDATED' });
    } else {
      return res.status(404).json({ status: 'Error', message: 'Employee not found' });
    }
  });
});

//Get admin username single
app.get('/admin_data_username/:id', (req, res) => {
  const id = req.params.id;
  db.query('SELECT * FROM geopos_users WHERE entryid=?', id, (err, result) => {
    if (err) {
      console.log(err);
      return res.status(500).json({ status: 'Error', message: 'Internal Server Error' });
    }

    if (result.length === 0) {
      return res.status(404).json({ status: 'Error', message: 'Admin not found' });
    }

    // Return the full result as a JSON response
    res.status(200).json({ status: 'Success', data: result });
  });
});


// Admin change password
app.post('/admin_change_password', async (req, res) => {
  const password = req.body.confirmPassword;
  const entryid = req.body.entryid;
  const userId = req.body.adminid;
  console.log('userId:',userId);
  try {
    const hashedPassword = await hashPassword2(password, userId);

    db.query('UPDATE geopos_users SET pass=? WHERE entryid = ?', [hashedPassword, entryid], (err, result) => {
      if (err) {
        res.status(500).json({ message: 'Error updating record' });
      } else if (result.affectedRows === 0) {
        res.status(404).json({ message: 'Record not updated' });
      } else {
        res.status(200).json({ message: 'Record updated successfully' });
      }
    });
  } catch (error) {
    console.error('Error hashing password:', error);
    res.status(500).json({ message: 'Error hashing password' });
  }
});

//Delete admin
app.delete('/admin_delete/:id', (req, res) => {
  const id = req.params.id; // ID will be a string here
  console.log(id,'----------------');
  db.query('DELETE FROM geopos_users WHERE id = ?',[id], (err, result1) => {
    if (err) {
      console.error("Error selecting employee:", err);
      return res.status(500).send('Error deleting record');
    }

    if (result1.length === 0) {
      return res.status(404).send('Record not found');
    }
    res.status(200).send('Data Deleted successfully');
   
  });
});


//IKEJA START

app.get('/ikeja/operator_data_view', (req, res) => {
  const query = `SELECT geopos_employees.*, geopos_users.banned, geopos_users.roleid, geopos_users.email, geopos_users.loc,geopos_emptype.name as empname
  FROM geopos_employees
  LEFT JOIN geopos_users ON geopos_employees.entryid = geopos_users.entryid
  LEFT JOIN geopos_emptype ON geopos_employees.roleid = geopos_emptype.id
  WHERE geopos_users.roleid = ?
  AND geopos_users.production_type = ?
  AND geopos_users.banned = ?
  ORDER BY geopos_users.name ASC`
  db.query(query, ['3','ikeja', '0'], (err, result) => {
    if (err) {
      console.log(err)
    }
    res.send(result)
  })
})

//get machines data
app.get('/ikeja/getMachines/:id', (req, res) => {
  const id = req.params.id
  db.query('SELECT * FROM geopos_machine WHERE zone=?', id, (err, result) => {
    if (err) {
      console.log(err)
    }
    if (result.length > 0) {
      res.send(result[0].machine); // Send only the name value from the result
    } else {
      res.send('',)
    }
  })
})

//add operator data submit
app.post('/ikeja/add_operator', (req, res) => {
  const name = req.body.name;
  const username = req.body.username;
  const email = req.body.email;
  const entryid = req.body.entryid;
  const pass = req.body.password !== "" ? req.body.password : '123456';
  const worktyp = req.body.workertype;
  const shift = req.body.shift;
  const zone = req.body.zone;
  const machine = req.body.machiness;
  const type = req.body.type;
  const roleid = '3';
  // Get the current date
  const date = new Date().toLocaleDateString('en-GB', {
    day: '2-digit',
    month: '2-digit',
    year: 'numeric',
  }).replace(/\//g, '-');
  //date time
  const currentDate = new Date();

  // Function to format the date in 'Y-m-d H:i:s' format
  const formatDate = (date) => {
    const year = date.getFullYear();
    const month = String(date.getMonth() + 1).padStart(2, '0');
    const day = String(date.getDate()).padStart(2, '0');
    const hours = String(date.getHours()).padStart(2, '0');
    const minutes = String(date.getMinutes()).padStart(2, '0');
    const seconds = String(date.getSeconds()).padStart(2, '0');

    return `${year}-${month}-${day} ${hours}:${minutes}:${seconds}`;
  };

  // Format the current date in 'Y-m-d H:i:s' format
  const formattedDate = formatDate(currentDate);

  const tags = machine.split(',');
  const numTags = tags.length - 1;
  const empCount = (1 / numTags).toFixed(4);

  const rowcheck = `SELECT * FROM geopos_users WHERE entryid="${entryid}"`;
  const rowcheck1 = `SELECT * FROM geopos_employees WHERE entryid="${entryid}"`;
  const rowcheck2 = `SELECT * FROM geopos_users WHERE email="${email}" OR username="${username}" OR name="${name}"`;

  db.query(rowcheck, function (err, result) {
    const id = result.id;
    if (result.length > 0) {
      res.status(200).json({status: 409, message: 'Entry Id already Exists'});
    } else {
      db.query(rowcheck2, function (err, resultt) {
        if (resultt.length > 0) {
          // Handle if email, username, or name already exists
        } else {
          db.query(
            'INSERT INTO geopos_users (email, username, name, entryid, date_created) VALUES (?, ?, ?, ?, ?)',
            [email, username, name, entryid, formattedDate],
            (err, result) => {
              if (err) {
                // Handle error
                console.error("Error occurred:", err);
              } else {
                if (result && result.insertId) {
                  const userId = result.insertId;
                  console.log("Insertion successful. Inserted user ID:", userId);

                  db.query(rowcheck1, function (err, resultt1) {
                    if (resultt1.length > 0) {
                      if(type=='BRAID'){
                        db.query(
                          'UPDATE geopos_employees SET roleid=?, workertype=?, shift=?, zone=?, machine=?, emp_count=?, section_id=? , category_type=? WHERE entryid=?',
                          [roleid, worktyp, shift, zone, machine, empCount,'0',type, entryid],
                          (err2, result2) => {
                            if (result2) {
                              const userIdAsString = userId.toString(); // Convert the number to a string
                              console.log("userIdAsString1:", userIdAsString);
                              const hashedPassword = hashPassword(pass, userIdAsString);
                              db.query(
                                'UPDATE geopos_users SET roleid=?, name=?, production_type=?, category_type=?,pass=? WHERE entryid=?',
                                [roleid, name, 'ikeja', type, hashedPassword, entryid],
                                (err3, result3) => {
                                  if (err3) {
                                    res.status(500).json({ status:500,message: 'Error updated record' })
                                  } else if (result3.affectedRows === 0) {
                                    res.status(404).json({status:404, message: 'Record not updated' })
                                  } else {
                                    res.status(200).json({message: 'Record updated successfully' })
                                  }
                                },
                              )
                            }
                          },
                        )
                      }else{
                        // Handle other cases if needed
                      }
                    }else{
                      if(type=='BRAID'){
                        db.query(
                          'INSERT INTO geopos_employees (username,entryid,email,name,roleid,workertype,shift,zone,machine,emp_count,passive_type,date,category_type) VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?)',
                          [username, entryid, email, name, roleid, worktyp,shift, zone, machine, empCount,'ACT',date,type],
                          (err22, result22) => {
                            if (result22) {
                              const userIdAsString = userId.toString(); // Convert the number to a string
                              console.log("userIdAsString2:", userIdAsString);
                              const hashedPassword = hashPassword(pass, userIdAsString);
                              console.log("hashedPassword:", hashedPassword);
                              //console.log("SQL Query:", 'UPDATE geopos_users SET roleid=?, name=?, production_type=?, category_type=?, pass=? WHERE entryid=?', [roleid, name, 'ikeja', type, entryid, hashedPassword]);
                              db.query(
                                'UPDATE geopos_users SET roleid=?, name=?, production_type=?, category_type=?, pass=? WHERE entryid=?',
                                [roleid, name, 'ikeja', type, hashedPassword, entryid],
                                (err22, result222) => {
                                  if (err22) {
                                    res.status(500).json({ status:500,message: 'Error inserted record' })
                                  } else if (result222.affectedRows === 0) {
                                    res.status(404).json({status:404, message: 'Record not inserted' })
                                  } else {
                                    res.status(200).json({ message: 'Record inserted successfully' })
                                  }
                                },
                              )
                            }
                          },
                        )
                      }else{
                        db.query(
                          'INSERT INTO geopos_employees (username,entryid,email,name,roleid,workertype,shift,date,category_type) VALUES (?,?,?,?,?,?,?,?,?)',
                          [username, entryid, email, name, roleid, worktyp,shift,date,type],
                          (err22, result222) => {
                            if (result222) {
                              const userIdAsString = userId.toString(); // Convert the number to a string
                              console.log("userIdAsString3:", userIdAsString);
                              const hashedPassword = hashPassword(pass, userIdAsString);
                              db.query(
                                'UPDATE geopos_users SET roleid=?, name=?, production_type=?, category_type=?, pass=? WHERE entryid=?',
                                [roleid, name, 'ikeja', type, hashedPassword, entryid],
                                (err222, result2222) => {
                                  if (err222) {
                                    res.status(500).json({ status:500 ,message: 'Error inserted record' })
                                  } else if (result2222.affectedRows === 0) {
                                    res.status(404).json({ status:404 ,message: 'Record not inserted' })
                                  } else {
                                    res.status(200).json({ message: 'Record inserted successfully' })
                                  }
                                },
                              )
                            }
                          },
                        )
                      }
                    }
                  })
                } else {
                  // Query was successful but no auto-increment ID was generated
                  console.log("Insertion successful but no auto-increment ID generated.");
                }
              }
            }
          );
        }
      });
    }
  });
});


//getconvert data of category
app.get('/ikeja/getConvertdata/:id', (req, res) => {
  const id = req.params.id;
  const query = `SELECT * FROM geopos_employees WHERE id=?`;
  db.query(query,[id], (error, results) => {
    if (error) {
      console.error('Error fetching shift data:', error);
      res.status(500).json({ error: 'Failed to fetch item data' });
    } else {
      res.json(results[0]);
    }
  });
});
//add operator category convert data submit
app.post('/ikeja/category_convert_op', (req, res) => {
  const id = req.body.id
  const entryid = req.body.entryid
  const worktyp = req.body.workertype
  const shift = req.body.shift
  const zone = req.body.zone
  const machine = req.body.machiness
  const type = req.body.typ

  const tags = machine.split(',');
  const numTags = tags.length - 1;
  const empCount = (1 / numTags).toFixed(4);

  const rowcheck = `SELECT * FROM geopos_employees WHERE id="${id}"`
  
  db.query(rowcheck, function (err, result) {
    if (result.length > 0) {
      
      if(type === 'NBRAID'){
         //get user id
         const query = `SELECT * FROM geopos_users WHERE entryid=?`;
         db.query(query, [entryid], (error, results) => {
           if (error) {
             return res.status(500).json({ message: 'Error while fetching user record' });
           }
           const eid = results.length > 0 ? results[0].id : null;
            db.query(
              'UPDATE geopos_employees SET workertype=?, shift=?, zone=?, machine=?, emp_count=?, section_id=? , category_type=? WHERE entryid=?',
              [worktyp, shift, '', '', '','0',type, entryid],
              (err2, result1) => {
                if (result1) {
                  db.query(
                    'UPDATE geopos_users SET category_type=? WHERE id=?',
                    [type,eid],
                    (err3, result2) => {
                      if (err3) {
                        res.status(500).json({ message: 'Error updated record' })
                      } else if (result2.affectedRows === 0) {
                        res.status(404).json({ message: 'Record not updated' })
                      } else {
                        if(result){
                          res.status(200).json({ message: 'Record updated successfully' })
                        }
                      }
                    },
                  )
                }
              },
            )
         })
      }else{
        //get user id
        const query = `SELECT * FROM geopos_users WHERE entryid=?`;
        db.query(query, [entryid], (error, results) => {
          if (error) {
            return res.status(500).json({ message: 'Error while fetching user record' });
          }
          const eid = results.length > 0 ? results[0].id : null;
        db.query(
          'UPDATE geopos_employees SET workertype=?, shift=?, zone=?, machine=?, emp_count=?, section_id=? , category_type=?, product=?, line=? WHERE entryid=?',
          [worktyp, shift,zone,machine,empCount,'0',type,'','',entryid],
          (err2, result1) => {
            if (result1) {
              db.query(
                'UPDATE geopos_users SET category_type=? WHERE id=?',
                [type,eid],
                (err3, result2) => {
                  if (err3) {
                    res.status(500).json({ message: 'Error updated record' })
                  } else if (result2.affectedRows === 0) {
                    res.status(404).json({ message: 'Record not updated' })
                  } else {
                    db.query('DELETE FROM operator_assign_ikeja WHERE operator_id= ?', eid, (err, result) => {
                      if(result){
                        res.status(200).json({ message: 'Record updated successfully' })
                      }
                    });
                    
                  }
                },
              )
            }
          },
        )
        })
      }
    }
  })
})
//Get operator data single 
app.get('/ikeja/operator_data_single/:id', (req, res) => {
  const id = req.params.id
  db.query('SELECT * FROM geopos_employees WHERE id=?',[id], (err, result) => {
    if (err) {
      console.log(err)
    }
    if (result.length > 0) {
      res.send(result[0]); // Send only the name value from the result
    } else {
      res.status(404).send("Operator not found");
    }
  })
})

//get zone
app.get('/ikeja/getzone', (req, res) => {
  db.query('SELECT * FROM geopos_machine', (err, result) => {
    if (err) {
      console.log(err)
    }
      res.send(result); // Send only the name value from the result
    
  })
})
//get user id
app.get('/ikeja/getuserid/:id', (req, res) => {
  const id = req.params.id
  db.query('SELECT * FROM geopos_users WHERE entryid=?',[id], (err, result) => {
    if (err) {
      console.log(err)
    }
    res.send(result[0]); // Send only the name value from the result

  })
})
//
//get ikeja items
app.get('/ikeja/getItems/:id', (req, res) => {
  const id = req.params.id
  db.query('SELECT * FROM operator_assign_ikeja WHERE operator_id=?',[id], (err, result) => {
    if (err) {
      console.log(err)
    }
    res.send(result); // Send only the name value from the result

  })
})
//submit zone data
app.post("/ikeja/add_zone", (req, res) => {   
var id = req.body.id;
var zone = req.body.zone;
var machiness = req.body.machiness;

    const options = { timeZone: 'Africa/Lagos', day: 'numeric', month: 'numeric', year: 'numeric' };
    const currentTime = new Date().toLocaleString('en-US', options);

    const [date, month, year] = currentTime.split('/');
    const formattedDate = `${date.padStart(2, '0')}-${month.padStart(2, '0')}-${year}`;


const rowcheck = `SELECT * FROM operator_assign_ikeja WHERE zone="${zone}" AND operator_id="${id}"`

  db.query(rowcheck, function (err, result) {
    if (result.length > 0) {
      db.query(
        'UPDATE operator_assign_ikeja SET machine=? WHERE operator_id=? AND zone=?',
        [machiness, id, zone],
        (err2, result2) => {
          if (err2) {
            res.status(500).json({ message: 'Error updated record' })
          } else if (result2.affectedRows === 0) {
            res.status(404).json({ message: 'Record not updated' })
          } else {
            res.status(200).json({ message: 'Record updated successfully' })
          }
        },
      )
    }else{
      db.query(
        'INSERT INTO operator_assign_ikeja (operator_id,zone,machine,date_time,category_type) VALUES (?,?,?,?,?)',
        [id,zone,machiness,formattedDate,'BRAID'],
        (err2, result2) => {
          if (err2) {
            res.status(500).json({ message: 'Error Inserted record' })
          } else if (result2.affectedRows === 0) {
            res.status(404).json({ message: 'Record not Inserted' })
          } else {
            res.status(200).json({ message: 'Record Inserted successfully' })
          }
        },
      )
    }
  });

});
//operator zone Delete i
app.delete('/ikeja/item_zone_delete/:id', (req, res) => {
  const id = req.params.id
  db.query('DELETE FROM operator_assign_ikeja WHERE id= ?', id, (err, result) => {
    if (err) {
      res.status(500).send('Error deleting record')
    } else{
      res.status(200).send('Data Deleted successfully')
    }
  })
})

//get Line master
app.get('/ikeja/getlinemaster', (req, res) => {
  db.query('SELECT * FROM line_master WHERE status=?',['1'], (err, result) => {
    if (err) {
      console.log(err)
    }
    res.send(result); // Send only the name value from the result

  })
})
//get Line master
app.get('/ikeja/getSection', (req, res) => {
  db.query('SELECT * FROM section WHERE status=?',['1'], (err, result) => {
    if (err) {
      console.log(err)
    }
    res.send(result); // Send only the name value from the result

  })
})

//get operator section data
app.get('/ikeja/getSectionitem/:id', (req, res) => {
  const operatorId = req.params.id;

  const query = `
    SELECT operator_assign_ikeja.*, section.section_name
    FROM operator_assign_ikeja
    LEFT JOIN section ON operator_assign_ikeja.section = section.id
    WHERE operator_assign_ikeja.operator_id = ?
  `;

  db.query(query, [operatorId], (err, result) => {
    if (err) {
      console.error('Error fetching data from MySQL:', err);
      res.status(500).json({ message: 'Error fetching data from MySQL' });
    } else {
      res.json(result);
    }
  });
});

//submit section op  data
app.post("/ikeja/addSectionOp", (req, res) => {   
  var id = req.body.id;
  var shift = req.body.shift;
  var line = req.body.line;
  var section = req.body.section;

  
      const options = { timeZone: 'Africa/Lagos', day: 'numeric', month: 'numeric', year: 'numeric' };
      const currentTime = new Date().toLocaleString('en-US', options);
  
      const [date, month, year] = currentTime.split('/');
      const formattedDate = `${date.padStart(2, '0')}-${month.padStart(2, '0')}-${year}`;
  
  
  const rowcheck = `SELECT * FROM operator_assign_ikeja WHERE section="${section}" and line="${line}" and shift="${shift}"`
  
    db.query(rowcheck, function (err, result) {
      if (result.length > 0) {
              res.status(200).json({ message: 'Already assigned to same operator or other' })
      }else{
        db.query(
          'INSERT INTO operator_assign_ikeja (operator_id,section,line,shift,date_time,category_type) VALUES (?,?,?,?,?,?)',
          [id,section,line,shift,formattedDate,'NBRAID'],
          (err2, result2) => {
            if (err2) {
              res.status(500).json({ message: 'Error Inserted record' })
            } else if (result2.affectedRows === 0) {
              res.status(404).json({ message: 'Record not Inserted' })
            } else {
              res.status(200).json({ message: 'Record Inserted successfully' })
            }
          },
        )
      }
    });
  
  });
  //assign section Delete 
  app.delete('/ikeja/delete_section_assign/:id', (req, res) => {
    const id = req.params.id
    db.query('DELETE FROM operator_assign_ikeja WHERE id= ?', id, (err, result) => {
      if (err) {
        res.status(500).send('Error deleting record')
      } else{
        res.status(200).send('Data Deleted successfully')
      }
    })
  })
  //Get all users
  app.get('/ikeja/get_users/:id', (req, res) => {
    const id = req.params.id
    db.query('SELECT * FROM geopos_users WHERE roleid=? AND production_type=? AND banned=? AND category_type=? AND id!=?',
    ['3','ikeja','0','NBRAID',id], (err, result) => {
      if (err) {
        console.error('Error executing MySQL query:', err)
        res.status(500).send('Internal Server Error')
        return
      }
      res.send(result)
    })
  })
  //Operator section exit check
  app.get('/ikeja/assign_check', (req, res) => {
    const { where } = req.query
    db.query(`SELECT * FROM operator_assign_ikeja WHERE ${where}`, (err, result) => {
      if (err) {
        console.log(err)
      }
      res.send(result)
    })
  })
  //update assign operator
  app.get('/ikeja/update_assign_operator/:id', (req, res) => {
    const { where } = req.query
    const userid = req.params.id
    db.query(`UPDATE operator_assign_ikeja SET operator_id= ${userid} WHERE ${where}`, (err, result) => {
      if (err) {
        res.status(500).json({ message: 'Error update record' })
      } else if (result.affectedRows === 0) {
        res.status(404).json({ message: 'Record not Updated' })
      } else {
        res.status(200).json({ message: 'Record Updated successfully' })
      }
    })
  })
// Update operator
app.post('/ikeja/update_operator', (req, res) => {
  const name = req.body.name;
  const entryid = req.body.entryid;
  const worktyp = req.body.workertype;
  const shift = req.body.shift;
  const section_id = req.body.section_id;
  const id = req.body.id;
  db.query(
    'UPDATE geopos_employees SET entryid=?, name=?, workertype=?, shift=?, section_id=? WHERE id = ?',
    [entryid, name, worktyp, shift, section_id, id],
    (err, result) => {
      if (err) {
        res.status(500).json({ message: 'Error update record' });
      } else if (result.affectedRows === 0) {
        res.status(404).json({ message: 'Record not Updated' });
      } else {
        // Corrected syntax in the second query
        db.query('UPDATE geopos_users SET name=? WHERE entryid=?', [name, entryid], (err, result) => {
          if (err) {
            res.status(500).json({ message: 'Error updating user record' });
          } else if (result.affectedRows === 0) {
            res.status(404).json({ message: 'User record not updated' });
          } else {
            res.status(200).json({ message: 'Record Updated successfully' });
          }
        });
      }
    }
  );
});


//Get operator username single
app.get('/ikeja/operator_data_username/:id', (req, res) => {
  const id = req.params.id;
  console.log('id:', id);
  db.query('SELECT * FROM geopos_employees JOIN geopos_users ON geopos_employees.entryid = geopos_users.entryid WHERE geopos_employees.id=?', [id], (err, result) => {
    if (err) {
      console.log(err);
      res.status(500).send("Internal Server Error");
    } else {
      res.json(result); // Sending the full result as JSON
    }
  });
});


//Operator change password
app.post('/ikeja/change_password', (req, res) => {
  const newpassword = req.body.confirmPassword;
  const uid = req.body.id;
  console.log("uid", uid);
  const userId = `${uid}`; // Converts the integer to a string using template literals
  try {
    const hashedPassword = hashPassword(newpassword, userId);
    console.log("userId :", userId);
    console.log("hashedPassword :", hashedPassword);
    //const entryid = req.body.entryid;
    const query = `UPDATE geopos_users SET pass = '${hashedPassword}' WHERE id = '${uid}'`;
    console.log('Update query:', query); // Log the generated SQL query
    db.query(query, (err, result) => {
      if (err) {
        res.status(500).json({ message: 'Error updating record' });
      } else if (result.affectedRows === 0) {
        res.status(404).json({ message: 'Record not updated' });
      } else {
        res.status(200).json({ message: 'Record updated successfully' });
      }
    });
  } catch (error) {
    console.error('Error:', error);
    res.status(500).json({ message: 'Error hashing password' });
  }
});


//Delete operator
app.delete('/ikeja/operator_delete/:id', (req, res) => {
  const id = req.params.id; // ID will be a string here

  db.query('SELECT * FROM geopos_employees WHERE entryid = ?', id, (err, result1) => {
    if (err) {
      console.error("Error selecting employee:", err);
      return res.status(500).send('Error deleting record');
    }

    if (result1.length === 0) {
      return res.status(404).send('Record not found');
    }

    const employeeId = result1[0].id; // Assuming 'id' is the column name for employee ID

    db.query('DELETE FROM operator_assign_ikeja WHERE operator_id = ?', employeeId, (err, result3) => {
      if (err) {
        console.error("Error deleting operator assignment:", err);
        return res.status(500).send('Error deleting record');
      }

      db.query('DELETE FROM geopos_employees WHERE entryid = ?', id, (err, result) => {
        if (err) {
          console.error("Error deleting employee:", err);
          return res.status(500).send('Error deleting record');
        }

        db.query('DELETE FROM geopos_users WHERE entryid = ?', id, (err2, result2) => {
          if (err2) {
            console.error("Error deleting user:", err2);
            return res.status(500).send('Error deleting record');
          }

          res.status(200).send('Data Deleted successfully');
        });
      });
    });
  });
});

//get all assign worker list
app.get('/ikeja/get_operator_assign_list', (req, res) => {
  const query = `SELECT operator_assign_ikeja.*, geopos_users.entryid, geopos_users.roleid, geopos_users.name
                 FROM operator_assign_ikeja
                 LEFT JOIN geopos_users ON operator_assign_ikeja.operator_id = geopos_users.id
                 WHERE operator_assign_ikeja.category_type = ?`;

  db.query(query, ['BRAID'], (err, result) => {
    if (err) {
      console.error(err);
      res.status(500).send('Error fetching operator assignments');
    } else {
      res.send(result);
    }
  });
});


//Filter search data
app.post('/ikeja/search_operator_assignlist', async (req, res) => {
  try {
    // Extract data from request body
    const name = req.body.operator_name;
    const fullname = req.body.name;
    const shift = req.body.shift;
    const line = req.body.line_no;
    const section = req.body.section;
    const section_name = req.body.section_name;
    

    // Log the received data
    console.log('Received data:');
    console.log('Operator:', name);
    console.log('Operator Full name:', fullname);
    console.log('Shift:', shift);
    console.log('Line:', line);
    console.log('Section:', section);
    console.log('Section Name:', section_name);
    

    let whereClause = "(operator_assign_ikeja.category_type ='NBRAID')";

    if (shift) {
      whereClause += " AND operator_assign_ikeja.shift='" + shift + "'";
    }
    if (section) {
      whereClause += " AND operator_assign_ikeja.section='" + section + "'";
    }
    if (line) {
      whereClause += " AND operator_assign_ikeja.line='" + line + "'";
    }
    if (name) {
      whereClause += " AND operator_assign_ikeja.operator_id='" + name + "'";
    }

    const sql = `
      SELECT operator_assign_ikeja.*, geopos_users.entryid, geopos_users.roleid,
             geopos_users.name, section.section_name
      FROM operator_assign_ikeja
      LEFT JOIN geopos_users ON operator_assign_ikeja.operator_id = geopos_users.id
      LEFT JOIN section ON operator_assign_ikeja.section = section.id
      WHERE ${whereClause};
    `;

    const results = await query(sql);

    res.json({ timesheet: results,  name: fullname, shift, line: line,  section_name });
  } catch (error) {
    console.error('Error executing MySQL query: ' + error);
    res.status(500).json({ error: 'Internal server error' });
  }
});

// Function to execute MySQL queries
const query = (sql) => {
  return new Promise((resolve, reject) => {
    db.query(sql, (err, results) => {
      if (err) {
        reject(err);
        return;
      }
      resolve(results);
    });
  });
};


//Delete assign braid and nonbraid list
app.delete('/ikeja/delete_assign_list/:id', (req, res) => {
  const id = req.params.id
  db.query('DELETE FROM operator_assign_ikeja WHERE id= ?', id, (err, result) => {
    if (err) {
      res.status(500).send('Error deleting record')
    } else if (result.affectedRows === 0) {
      res.status(404).send('Not Deleted')
    } else {
      res.status(200).send('Delete successfully')
    }
  })
})

//get all assign worker list nonbraid
app.get('/ikeja/get_operator_nbraid_assign_list', (req, res) => {
  const query = `SELECT operator_assign_ikeja.*, geopos_users.entryid, geopos_users.roleid, geopos_users.name,section.section_name
                 FROM operator_assign_ikeja
                 LEFT JOIN geopos_users ON operator_assign_ikeja.operator_id = geopos_users.id
                 LEFT JOIN section ON operator_assign_ikeja.section = section.id
                 WHERE operator_assign_ikeja.category_type = ?`;

  db.query(query, ['NBRAID'], (err, result) => {
    if (err) {
      console.error(err);
      res.status(500).send('Error fetching operator assignments');
    } else {
      res.send(result);
    }
  });
});          

//Change shift operator//

// Get employee  data
app.get('/ikeja/getEmployees', (req, res) => {
  let query =
    `SELECT geopos_employees.*, geopos_users.banned, geopos_users.roleid, geopos_users.email, geopos_users.loc, geopos_emptype.name AS role
    FROM geopos_employees
    LEFT JOIN geopos_emptype ON geopos_employees.roleid = geopos_emptype.id
    LEFT JOIN geopos_users ON geopos_employees.entryid = geopos_users.entryid
    WHERE geopos_users.roleid = ? AND geopos_users.production_type = ? AND geopos_users.banned = ?`;
    
  db.query(query, ['3', 'ikeja', 0], (err, result) => {
    if (err) {
      console.log(err);
      res.status(500).send('Internal Server Error');
    } else {
      res.send(result);
    }
  });
});

//get changez shift employee entryid
app.post('/ikeja/changeshift_entryid', (req, res) => {
  const { entryIds } = req.body;
  const entryIdsArray = Array.isArray(entryIds) ? entryIds : [entryIds];

  // Use the IN operator in the SQL query to check for multiple entryid values
  const query = 'SELECT entryid FROM geopos_employees WHERE id IN (?)';

  db.query(query, [entryIdsArray], (err, results) => {
    if (err) {
      console.log(err);
      res.status(500).json({ error: 'Internal Server Error' });
    } else {
      res.json(results);
    }
  });
});

// check all entryids and update shift
app.post('/ikeja/update_shift', (req, res) => {
  const { shift, entryIds } = req.body;
  
  if (!shift || !entryIds) {
    return res.status(400).json({ status: 'Error', message: 'Shift and entryIds are required.' });
  }

  const entryIdsArray = entryIds.split(',');

  // Query to check if the employee with the given entryId exists
  const checkQuery = 'SELECT id FROM geopos_employees WHERE id = ? ';

  // Query to update data for each entryId
  const updateQuery = 'UPDATE geopos_employees SET shift = ? WHERE id = ?';

  // Counter to keep track of processed entries
  let processedCount = 0;

  entryIdsArray.forEach((entryId) => {
    const checkValues = [entryId];

    // Check if the employee exists
    db.query(checkQuery, checkValues, (checkErr, checkResult) => {
      if (checkErr) {
        console.error('Error checking employee:', checkErr);
        res.status(500).json({ status: 'Error', message: 'Internal Server Error' });
      } else {
        if (checkResult.length === 1) {
          // Employee exists, update the data
          const updateValues = [shift, entryId];
          db.query(updateQuery, updateValues, (updateErr, updateResult) => {
            if (updateErr) {
              console.error('Error updating data:', updateErr);
              res.status(500).json({ status: 'Error', message: 'Internal Server Error' });
            } else {
              processedCount++;
              console.log(`Data updated for entryId: ${entryId}`);

              // Check if all entries have been processed
              if (processedCount === entryIdsArray.length) {
                res.json({ status: 'Success', message: 'Details updated successfully.' });
              }
            }
          });
        } else {
          // Employee does not exist, skip the update for this entryId
          processedCount++;
          console.log(`Employee not found for entryId: ${entryId}`);

          // Check if all entries have been processed
          if (processedCount === entryIdsArray.length) {
            res.json({ status: 'Success', message: 'Details updated successfully.' });
          }
        }
      }
    });
  });
});

//Employee

//Employee Default data search
app.get('/ikeja/get_employeess', (req, res) => {
  const query = `
    SELECT geopos_employees.*, section.section_name, geopos_emptype.name AS role
    FROM geopos_employees
    LEFT JOIN geopos_emptype ON geopos_employees.roleid = geopos_emptype.id
    LEFT JOIN section ON geopos_employees.section_id = section.id
    WHERE (geopos_employees.roleid != '3' AND geopos_employees.roleid != '5')
      AND geopos_employees.passive_type = 'ACT'
      AND geopos_employees.category_type = 'BRAID';
  `;

  db.query(query, (err, result) => {
    if (err) {
      console.error(err);
      return res.status(500).json({ message: 'Error retrieving records' });
    }
    res.json(result);
  });
});

//Employee filter data search
app.get('/ikeja/get_employees', (req, res) => {
  const { where } = req.query

  let query = `
      SELECT geopos_employees.*, section.section_name,geopos_emptype.name as role
      FROM geopos_employees
      LEFT JOIN geopos_emptype ON geopos_employees.roleid = geopos_emptype.id
      LEFT JOIN section ON geopos_employees.section_id = section.id
      WHERE ${where}
    `

  db.query(query, (err, result) => {
    if (err) {
      console.log(err)
      res.status(500).json({ message: 'Error retrieving records' })
    } else {
      res.json(result)
    }
  })
})

//Get user Role
app.get('/ikeja/get_role/:id', (req, res) => {
  const id = req.params.id
  db.query('SELECT * FROM geopos_emptype WHERE id=?', id, (err, result) => {
    if (err) {
      console.log(err)
    }
    res.send(result)
  })
})

//Update employee
app.post('/ikeja/update_employee', (req, res) => {
  const name = req.body.name
  const entryid = req.body.entryid
  const worktyp = req.body.workertype
  const shift = req.body.shift
  const section_id = req.body.section_id
  const roleid = req.body.roleid
  const zone = req.body.zone
  const id = req.body.id
  const machine = req.body.machiness

  const tags = machine.split(',');
  const numTags = tags.length - 1;
  const empCount = (1 / numTags).toFixed(4);
console.log(req.body)
  db.query(
    'UPDATE geopos_employees SET entryid=?,name=?,workertype=?,shift=?,section_id=?,zone=?,machine=?,emp_count=? WHERE id = ?',
    [entryid, name, worktyp, shift, section_id, zone, machine, empCount, id],
    (err, result) => {
      if (err) {
        res.status(500).json({ message: 'Error update record' })
      } else if (result.affectedRows === 0) {
        res.status(404).json({ message: 'Record not Updated' })
      } else {
        res.status(200).json({ message: 'Record Updated successfully' });
        
      }
    },
  )
})

//update employee nbraid data
app.post('/ikeja/update_employee_nbraid', (req, res) => {
  const name = req.body.name
  const entryid = req.body.entryid
  const worktyp = req.body.workertype
  const shift = req.body.shift
  const section_id = req.body.section_id
  const usection_id = req.body.usection_id
  const roleid = req.body.roleid
  const line = req.body.line
  const uline = req.body.uline
  const id = req.body.id
console.log(req.body)
  db.query(
    'UPDATE geopos_employees SET name=?,workertype=?,shift=?,section_id=?,line=?,roleid=? WHERE id = ?',
    [name, worktyp, shift, usection_id, uline, roleid, id],
    (err, result) => {
      if (err) {
        res.status(500).json({ message: 'Error update record' })
      } else if (result.affectedRows === 0) {
        res.status(404).json({ message: 'Record not Updated' })
      } else {
        db.query('INSERT INTO change_product (entryid,emp_id,line_old,line_new,section_old,section_new) VALUES (?,?,?,?,?,?)',
          [entryid, id, line, uline, section_id,usection_id],
          (err3, result3) => {
          if (err3) {
            res.status(500).json({ message: 'Error updating user record' });
          } else if (result3.affectedRows === 0) {
            res.status(404).json({ message: 'User record not updated' });
          } else {
            res.status(200).json({ message: 'Record Updated successfully' });
          }
        });
      }
    },
  )
})

//Delete employee 
app.delete('/ikeja/delete_user/:id', (req, res) => {
  const id = req.params.id
  db.query('DELETE FROM geopos_employees WHERE id= ?',id, (err, result) => {
    if (err) {
      res.status(500).send('Error deleting record')
    } else{
      res.status(200).send('Data Deleted successfully')
    }
  })
})

//employee to operator change
app.post('/ikeja/changeEmpToOp', (req, res) => {
  const entryid = req.body.entryid
  const username = req.body.unm
  const pass = req.body.password
  const roleid = req.body.rlid
  const name = req.body.name
  const email = req.body.unm
  const worktyp = req.body.workertype
  const shift = req.body.shift
  const zone = req.body.zone
  const machine = req.body.machine
  const type = req.body.category_type 

  const tags = machine.split(',');
  const numTags = tags.length - 1;
  const empCount = (1 / numTags).toFixed(4);


    db.query(
      'INSERT INTO geopos_users (username,entryid,email,name,roleid) VALUES (?,?,?,?,?)',
      [username, entryid, email, name, roleid],
      (err3, result3) => {
        if (err3) {
          res.status(500).json({ message: 'Error inserted record' })
        } else if (result3.affectedRows === 0) {
          res.status(404).json({ message: 'Record not Inserted' })
        } else {

          const userId = result3.insertId;
          console.log("Insertion successful. Inserted user ID:", userId);

          const rowcheck = `SELECT * FROM geopos_employees WHERE entryid="${entryid}"`

          db.query(rowcheck, function (err, result) {
            if (result.length > 0) {
              db.query(
                'UPDATE geopos_employees SET roleid=?,workertype=?,shift=?,zone=?,machine=?,emp_count=?,section_id=?,category_type=? WHERE entryid=?',
                [roleid, worktyp, shift,zone,machine,empCount,'0',type,entryid],
                (err2, result2) => {
                  if (result2) {
                    const userIdAsString = userId.toString(); // Convert the number to a string
                              console.log("userIdAsString1:", userIdAsString);
                              const hashedPassword = hashPassword(pass, userIdAsString);
                    db.query(
                      'UPDATE geopos_users SET entryid=?,name=?,roleid=?,production_type=?,category_type=?, pass=? WHERE entryid=?',
                      [entryid, name, roleid,'ikeja',type,hashedPassword,entryid],
                      (err3, result3) => {
                        if (err3) {
                          res.status(500).json({ message: 'Error inserted record' })
                        } else if (result3.affectedRows === 0) {
                          res.status(404).json({ message: 'Record not Inserted' })
                        } else {
                          res.status(200).json({ message: 'Record updated successfully' })
                        }
                      },
                    )
                  }
                },
              )
            }
          })
        }
      },
    )
})

//Employee Default date
app.get('/ikeja/get_employeess_nbraid_date', (req, res) => {
  const query = `SELECT * FROM geopos_employees order by id asc limit 1`;

  db.query(query, (err, result) => {
    if (err) {
      console.error(err);
      return res.status(500).json({ message: 'Error retrieving records' });
    }
    res.json(result[0]);
  });
});

//Nonbraid Employee Defulte data search
app.get('/ikeja/get_employeess_nbraid', (req, res) => {
  const query = `
    SELECT geopos_employees.*, section.section_name,item_masterr.item_description,geopos_emptype.name as role
    FROM geopos_employees
    LEFT JOIN geopos_emptype ON geopos_employees.roleid = geopos_emptype.id
    LEFT JOIN section ON geopos_employees.section_id = section.id
    LEFT JOIN item_masterr ON geopos_employees.product = item_masterr.id
    WHERE geopos_employees.roleid != '3'
      AND geopos_employees.passive_type = 'ACT'
      AND geopos_employees.category_type = 'NBRAID';
  `;

  db.query(query, (err, result) => {
    if (err) {
      console.error(err);
      return res.status(500).json({ message: 'Error retrieving records' });
    }
    res.json(result);
  });
});

//Nonbraid Employee filter data search
app.get('/ikeja/get_employees_nbraid', (req, res) => {
  const { where } = req.query

  let query = `
      SELECT geopos_employees.*, section.section_name,geopos_emptype.name as role
      FROM geopos_employees
      LEFT JOIN geopos_emptype ON geopos_employees.roleid = geopos_emptype.id
      LEFT JOIN section ON geopos_employees.section_id = section.id
      WHERE ${where}
    `

  db.query(query, (err, result) => {
    if (err) {
      console.log(err)
      res.status(500).json({ message: 'Error retrieving records' })
    } else {
      
      res.json(result)
    }
  })
})

//Change zone
// Get zone data default view
app.get('/ikeja/getZonedata', (req, res) => {
  let query =
    `SELECT geopos_employees.*, section.section_name,geopos_emptype.name as role
    FROM geopos_employees
    LEFT JOIN geopos_emptype ON geopos_employees.roleid = geopos_emptype.id
    LEFT JOIN section ON geopos_employees.section_id = section.id
    WHERE (geopos_employees.roleid !='3' AND geopos_employees.roleid !='5') AND geopos_employees.passive_type='ACT' and  geopos_employees.category_type='BRAID'`;
    
  db.query(query, (err, result) => {
    if (err) {
      console.log(err);
      res.status(500).send('Internal Server Error');
    } else {
      res.send(result);
    }
  });
});

// Get zone data search  view
app.get('/ikeja/get_zonedata_search', (req, res) => {
  const { where } = req.query
 
  let query =
    `SELECT geopos_employees.*, section.section_name,geopos_emptype.name as role
    FROM geopos_employees
    LEFT JOIN geopos_emptype ON geopos_employees.roleid = geopos_emptype.id
    LEFT JOIN section ON geopos_employees.section_id = section.id
    WHERE ${where}`;
    
  db.query(query, (err, result) => {
    if (err) {
      console.log(err);
      res.status(500).send('Internal Server Error');
    } else {
      res.send(result);
    }
  });
});

// Change zone braid multiple entry id wise zone update
app.post('/ikeja/update_multiple_zone', (req, res) => {
  const { shift, entryIds, section_id, zone, machines } = req.body;
  // Date format d-m-Y H:i:s
  const options = {
    timeZone: 'Africa/Lagos',
    day: '2-digit',
    month: '2-digit',
    year: 'numeric',
    hour: '2-digit',
    minute: '2-digit',
    second: '2-digit'
  };
  const currentTime = new Date().toLocaleString('en-US', options);

  const [datePart, timePart] = currentTime.split(', ');
  const [month, date, year] = datePart.split('/');
  const [time, amPm] = timePart.split(' ');
  const [hours, minutes, seconds] = time.split(':');
  const tdate = `${date.padStart(2, '0')}-${month.padStart(2, '0')}-${year} ${hours}:${minutes}:${seconds}`;

  const tags = machines.split(',');
  const numTags = tags.length - 1;
  const empCount = (1 / numTags).toFixed(4);

  const entryIdsArray = entryIds.split(',');

  const checkQuery = 'SELECT * FROM geopos_employees WHERE id = ? ';
  const InsertQuery =
    'INSERT INTO geopos_changezonemachine (zone_old,machine_old,zone_new,machine_new,shift_old,section_old,shift_new,section_new,emp_id,entry_id,date_time) VALUES (?,?,?,?,?,?,?,?,?,?,?)';
  const updateQuery =
    'UPDATE geopos_employees SET zone=?,machine=?,emp_count=?,shift=?,section_id=? WHERE id = ?';

  let processedCount = 0;

  entryIdsArray.forEach((entryId) => {
    const checkValues = [entryId];

    db.query(checkQuery, checkValues, (checkErr, checkResult) => {
      if (checkErr) {
        console.error('Error checking employee:', checkErr);
        res.status(500).json({ status: 'Error', message: 'Internal Server Error' });
      } else {
        if (checkResult.length === 1) {
          const {
            entryid,
            zone: zone_old,
            machine: machine_old,
            shift: shift_old,
            section_id: section_old,
            id
          } = checkResult[0];

          const insertValues = [
            zone_old,
            machine_old,
            zone,
            machines,
            shift_old,
            section_old,
            shift,
            section_id,
            id,
            entryid,
            tdate
          ];

          db.query(InsertQuery, insertValues, (InsertErr, insertResult) => {
            if (InsertErr) {
              console.error('Error inserting data:', InsertErr);
              res.status(500).json({ status: 'Error', message: 'Internal Server Error' });
            } else {
              const updateValue = [zone, machines, empCount, shift, section_id, id];
              db.query(updateQuery, updateValue, (updateErr, updateResult) => {
                if (updateErr) {
                  console.error('Error updating data:', updateErr);
                  res.status(500).json({ status: 'Error', message: 'Internal Server Error' });
                } else {
                  processedCount++;
                  console.log(`Data updated for entryId: ${entryId}`);

                  if (processedCount === entryIdsArray.length) {
                    res.json({ status: 'Success', message: 'Details updated successfully.' });
                  }
                }
              });
            }
          });
        } else {
          processedCount++;
          console.log(`Employee not found for entryId: ${entryId}`);

          if (processedCount === entryIdsArray.length) {
            res.json({ status: 'Success', message: 'Details updated successfully.' });
          }
        }
      }
    });
  });
});

// change zone braid to nbraid assign 
app.post('/ikeja/update_multiple_zone_to_nbraid', (req, res) => {
  const { entryIds,line, section_id } = req.body;
  const entryIdsArray = entryIds.split(',');
  const checkQuery = 'SELECT * FROM geopos_employees WHERE id = ? ';
  const updateQuery =
    'UPDATE geopos_employees SET zone=?,machine=?,emp_count=?,line=?,section_id=?,category_type=? WHERE id = ?';
  let processedCount = 0;

  entryIdsArray.forEach((entryId) => {
    const checkValues = [entryId];
  
    db.query(checkQuery, checkValues, (checkErr, checkResult) => {
      if (checkErr) {
        console.error('Error checking employee:', checkErr);
        res.status(500).json({ status: 'Error', message: 'Internal Server Error' });
      } else {
        if (checkResult.length === 1) {
          const {id} = checkResult[0];
          const updateValue = ['','','', line, section_id,'NBRAID', id];
          db.query(updateQuery, updateValue, (updateErr, updateResult) => {
            if (updateErr) {
              console.error('Error updating data:', updateErr);
              res.status(500).json({ status: 'Error', message: 'Internal Server Error' });
            } else {
              processedCount++;
              console.log(`Data updated for entryId: ${entryId}`);

              if (processedCount === entryIdsArray.length) {
                res.json({ status: 'Success', message: 'Details updated successfully.' });
              }
            }
          });
        } else {
          processedCount++;
          console.log(`Employee not found for entryId: ${entryId}`);

          if (processedCount === entryIdsArray.length) {
            res.json({ status: 'Success', message: 'Details updated successfully.' });
          }
        }
      }
    });
  });
});

// Get zone nbraid data default view
app.get('/ikeja/getZonedataNbraid', (req, res) => {
  let query =
    `SELECT geopos_employees.*, section.section_name,item_masterr.item_description,geopos_emptype.name as role
    FROM geopos_employees
    LEFT JOIN geopos_emptype ON geopos_employees.roleid = geopos_emptype.id
    LEFT JOIN section ON geopos_employees.section_id = section.id
    LEFT JOIN item_masterr ON geopos_employees.product = item_masterr.id
    WHERE geopos_employees.roleid !='3' AND geopos_employees.passive_type='ACT' and  geopos_employees.category_type='NBRAID'`;
    
  db.query(query, (err, result) => {
    if (err) {
      console.log(err);
      res.status(500).send('Internal Server Error');
    } else {
      res.send(result);
    }
  });
});

// Get zone nbraid data search view
app.get('/ikeja/get_zoneNbraid_search', (req, res) => {
  const { where } = req.query
  let query =
    `SELECT geopos_employees.*, section.section_name,geopos_emptype.name as role
    FROM geopos_employees
    LEFT JOIN geopos_emptype ON geopos_employees.roleid = geopos_emptype.id
    LEFT JOIN section ON geopos_employees.section_id = section.id
    WHERE ${where}`;
    
  db.query(query, (err, result) => {
    if (err) {
      console.log(err);
      res.status(500).send('Internal Server Error');
    } else {
      res.send(result);
    }
  });
});

// Entryids wise machine data update Nbraid
app.post('/ikeja/update_multiple_zone_nbraid', (req, res) => {
  const { entryIds,line, section_id} = req.body;
  
  const entryIdsArray = entryIds.split(',');

  const checkQuery = 'SELECT * FROM geopos_employees WHERE id = ? ';
  const InsertQuery =
    'INSERT INTO change_product (emp_id,entryid,line_old,line_new,section_old,section_new) VALUES (?,?,?,?,?,?)';
  const updateQuery =
    'UPDATE geopos_employees SET line=?,section_id=? WHERE id = ?';

  let processedCount = 0;

  entryIdsArray.forEach((entryId) => {
    const checkValues = [entryId];

    db.query(checkQuery, checkValues, (checkErr, checkResult) => {
      if (checkErr) {
        console.error('Error checking employee:', checkErr);
        res.status(500).json({ status: 'Error', message: 'Internal Server Error' });
      } else {
        if (checkResult.length === 1) {
          const id=checkResult[0].id;
          const entryid=checkResult[0].entryid;
          const line_old=checkResult[0].line;
          const section_old=checkResult[0].section_id;
        
       
          const insertValues = [
            id,
            entryid,
            line_old,
            line,
            section_old,
            section_id
          ];

          db.query(InsertQuery, insertValues, (InsertErr, insertResult) => {
            if (InsertErr) {
              console.error('Error inserting data:', InsertErr);
              res.status(500).json({ status: 'Error', message: 'Internal Server Error' });
            } else {
              const updateValue = [line,section_id,id];
              db.query(updateQuery, updateValue, (updateErr, updateResult) => {
                if (updateErr) {
                  console.error('Error updating data:', updateErr);
                  res.status(500).json({ status: 'Error', message: 'Internal Server Errors' });
                } else {
                  processedCount++;
                  console.log(`Data updated for entryId: ${entryId}`);

                  if (processedCount === entryIdsArray.length) {
                    res.json({ status: 'Success', message: 'Details updated successfully.' });
                  }
                }
              });
            }
          });
        } else {
          processedCount++;
          console.log(`Employee not found for entryId: ${entryId}`);

          if (processedCount === entryIdsArray.length) {
            res.json({ status: 'Success', message: 'Details updated successfully.' });
          }
        }
      }
    });
  });
});

// Entryids wise zone braid update
app.post('/ikeja/update_multiple_zone_braid', (req, res) => {
  const { shift, entryIds, section_id, zone, machines } = req.body;
  
  const tags = machines.split(',');
  const numTags = tags.length - 1;
  const empCount = (1 / numTags).toFixed(4);

  const entryIdsArray = entryIds.split(',');
  const checkQuery = 'SELECT * FROM geopos_employees WHERE id = ? ';
  const updateQuery =
    'UPDATE geopos_employees SET zone=?,machine=?,emp_count=?,line=?,shift=?,section_id=?,category_type=? WHERE id = ?';

  let processedCount = 0;

  entryIdsArray.forEach((entryId) => {
    const checkValues = [entryId];

    db.query(checkQuery, checkValues, (checkErr, checkResult) => {
      const id=checkResult[0].id
      if (checkErr) {
        console.error('Error checking employee:', checkErr);
        res.status(500).json({ status: 'Error', message: 'Internal Server Error' });
      } else {
         if (checkResult.length === 1) {
          const updateValue = [zone, machines, empCount,'', shift, section_id,'BRAID', id];
          db.query(updateQuery, updateValue, (updateErr, updateResult) => {
            if (updateErr) {
              console.error('Error updating data:', updateErr);
              res.status(500).json({ status: 'Error', message: 'Internal Server Error' });
            } else {
              processedCount++;
              console.log(`Data updated for entryId: ${entryId}`);

              if (processedCount === entryIdsArray.length) {
                res.json({ status: 'Success', message: 'Details updated successfully.' });
              }
            }
          });
          } else {
          processedCount++;
          console.log(`Employee not found for entryId: ${entryId}`);

          if (processedCount === entryIdsArray.length) {
            res.json({ status: 'Success', message: 'Details updated successfully.' });
          }
        }
      }
    });
  });
});

//Change Shift //
// Get shift data default view
app.get('/ikeja/getShiftdata', (req, res) => {
  let query =
    `SELECT geopos_employees.*, section.section_name,geopos_emptype.name as role
    FROM geopos_employees
    LEFT JOIN geopos_emptype ON geopos_employees.roleid = geopos_emptype.id
    LEFT JOIN section ON geopos_employees.section_id = section.id
    WHERE (geopos_employees.roleid !='3' AND geopos_employees.roleid !='5') AND geopos_employees.passive_type='ACT'`;
    
  db.query(query, (err, result) => {
    if (err) {
      console.log(err);
      res.status(500).send('Internal Server Error');
    } else {
      res.send(result);
      console.log(result,'---------------')
    }
  });
});   

// Get shift data search  view
app.get('/ikeja/get_shiftdata_search', (req, res) => {
  const { where } = req.query
  let query =
    `SELECT geopos_employees.*, section.section_name,geopos_emptype.name as role
    FROM geopos_employees
    LEFT JOIN geopos_emptype ON geopos_employees.roleid = geopos_emptype.id
    LEFT JOIN section ON geopos_employees.section_id = section.id
    WHERE ${where}`;
    
  db.query(query, (err, result) => {
    if (err) {
      console.log(err);
      res.status(500).send('Internal Server Error');
    } else {
      res.send(result);
    }
  });
}); 

// Multiple shift data update
app.post('/ikeja/update_multiple_shift', (req, res) => {
  const { shift, entryIds} = req.body;
  
  const entryIdsArray = entryIds.split(',');
  const checkQuery = 'SELECT * FROM geopos_employees WHERE id = ? ';
  const updateQuery =
    'UPDATE geopos_employees SET shift=? WHERE id = ?';

  let processedCount = 0;

  entryIdsArray.forEach((entryId) => {
    const checkValues = [entryId];

    db.query(checkQuery, checkValues, (checkErr, checkResult) => {
      const id=checkResult[0].id
      if (checkErr) {
        console.error('Error checking employee:', checkErr);
        res.status(500).json({ status: 'Error', message: 'Internal Server Error' });
      } else {
         if (checkResult.length === 1) {
          const updateValue = [shift,id];
          db.query(updateQuery, updateValue, (updateErr, updateResult) => {
            if (updateErr) {
              console.error('Error updating data:', updateErr);
              res.status(500).json({ status: 'Error', message: 'Internal Server Error' });
            } else {
              processedCount++;
              console.log(`Data updated for entryId: ${entryId}`);

              if (processedCount === entryIdsArray.length) {
                res.json({ status: 'Success', message: 'Details updated successfully.' });
              }
            }
          });
          } else {
          processedCount++;
          console.log(`Employee not found for entryId: ${entryId}`);

          if (processedCount === entryIdsArray.length) {
            res.json({ status: 'Success', message: 'Details updated successfully.' });
          }
        }
      }
    });
  });
});  

//Change worker type
// Get worker data search  view
app.get('/ikeja/get_workerdata_search', (req, res) => {
  const { where } = req.query
 
  let query =
    `SELECT geopos_employees.*, section.section_name,geopos_emptype.name as role
    FROM geopos_employees
    LEFT JOIN geopos_emptype ON geopos_employees.roleid = geopos_emptype.id
    LEFT JOIN section ON geopos_employees.section_id = section.id
    WHERE ${where}`;
    
  db.query(query, (err, result) => {
    if (err) {
      console.log(err);
      res.status(500).send('Internal Server Error');
    } else {
      res.send(result);
    }
  });
}); 
 
// Multiple workertype data update
app.post('/ikeja/update_multiple_workertype', (req, res) => {
  const { wtype, entryIds} = req.body;
  
  const entryIdsArray = entryIds.split(',');
  const checkQuery = 'SELECT * FROM geopos_employees WHERE id = ? ';
  const updateQuery =
    'UPDATE geopos_employees SET workertype=? WHERE id = ?';

  let processedCount = 0;

  entryIdsArray.forEach((entryId) => {
    const checkValues = [entryId];

    db.query(checkQuery, checkValues, (checkErr, checkResult) => {
      const id=checkResult[0].id
      if (checkErr) {
        console.error('Error checking employee:', checkErr);
        res.status(500).json({ status: 'Error', message: 'Internal Server Error' });
      } else {
         if (checkResult.length === 1) {
          const updateValue = [wtype,id];
          db.query(updateQuery, updateValue, (updateErr, updateResult) => {
            if (updateErr) {
              console.error('Error updating data:', updateErr);
              res.status(500).json({ status: 'Error', message: 'Internal Server Error' });
            } else {
              processedCount++;
              console.log(`Data updated for entryId: ${entryId}`);

              if (processedCount === entryIdsArray.length) {
                res.json({ status: 'Success', message: 'Details updated successfully.' });
              }
            }
          });
          } else {
          processedCount++;
          console.log(`Employee not found for entryId: ${entryId}`);

          if (processedCount === entryIdsArray.length) {
            res.json({ status: 'Success', message: 'Details updated successfully.' });
          }
        }
      }
    });
  });
});       

//Employee FDA
// Get employee fda data default view
app.get('/ikeja/getEmployeeFdaData', (req, res) => {
  const today = new Date();
 const dateThreeMonthsAgo = new Date(today);
dateThreeMonthsAgo.setMonth(today.getMonth() - 3);
const firstDayOfCurrentMonth = new Date(today.getFullYear(), today.getMonth(), 1);

  const query =
    `SELECT geopos_employees_attrition.*
    FROM geopos_employees_attrition
    WHERE STR_TO_DATE(exitdate, "%d-%m-%Y") >= ? 
      AND STR_TO_DATE(exitdate, "%d-%m-%Y") < ?;`;
  const values = [dateThreeMonthsAgo, firstDayOfCurrentMonth];

  db.query(query,values, (err, result) => {
    if (err) {
      console.log(err);
      res.status(500).send('Internal Server Error');
    } else {
      res.send(result);
      console.log(result,'---------------')
    }
  });
});                     
//------------------IKEJA END----------------------//

//------------------OTA START----------------------//

//Supervisor data
app.get('/ota/supervisor_data_view', (req, res) => {
  const query = `
    SELECT supervisor_assign.*, section.section_name, employees_ota.name
    FROM supervisor_assign
    LEFT JOIN employees_ota ON supervisor_assign.entryid = employees_ota.entryid
    LEFT JOIN section ON supervisor_assign.section = section.id
    WHERE supervisor_assign.site = 'ota'
  `;

  db.query(query, (err, results) => {
    if (err) {
      console.error('Error executing query: ' + err.stack);
      res.status(500).json({ error: 'An error occurred' });
      return;
    }
    res.json({ timesheet: results });
  });
});

// Get Supervisor details
app.get('/supervisor_details', (req, res) => {
  const query = "SELECT * FROM employees_ota WHERE roleid IN (1, 3) AND passive_type='ACT'";
  
  db.query(query, (err, results) => {
    if (err) {
      console.error('Error executing query: ' + err.stack);
      res.status(500).json({ error: 'An error occurred' });
      return;
    }
    res.json(results);
  });
});

//add new supervisor
app.post('/addsupervisorota', (req, res) => {
  const { supervisor, shift, section, line_no } = req.body;
  console.log("Supervisor:", supervisor);
  console.log("Shift:", shift);
  console.log("Section:", section);
  console.log("Line:", line_no);
  const date = new Date().toLocaleDateString('en-GB', { timeZone: 'Africa/Lagos' });
  const parts = date.split('/');
  const formattedDay = parts[0].padStart(2, '0');
  const formattedMonth = parts[1].padStart(2, '0');
  const year = parts[2];
  const date1 = `${formattedDay}-${formattedMonth}-${year}`;
  /* const timestamp = new Date(date).getTime(); // Convert date to timestamp in milliseconds
  const timestampInSeconds = timestamp / 1000; // Convert timestamp to seconds
  console.log('timestampInSeconds:',timestampInSeconds); */

  const currentDate = new Date(); // Get current date and time
const timestampInSeconds = Math.floor(currentDate.getTime() / 1000); // Get timestamp in seconds

// Log timestamp for debugging
console.log('Timestamp:', timestampInSeconds);
  
  const productlist = [];
  let prodindex = 0;
  let totalIterations = line_no.length * section.length; // Total iterations needed

  line_no.forEach((lineValue) => {
    section.forEach((sectionValue) => {
      const data = {
        entryid: supervisor,
        section: sectionValue,
        shift: shift,
        date: date1,
        line: lineValue,
        category_type: 'NBRAID',
        timestamp: timestampInSeconds,
        site: 'ota'
      };
  
      console.log("Data to be inserted:", data); // Log data before insert
  
      const where = `line='${lineValue}' AND section='${sectionValue}' AND shift='${shift}'`;
      console.log("Where clause:", where); // Log where clause
     // Define the SELECT query
    const selectQuery = `SELECT * FROM supervisor_assign WHERE ${where}`;
    console.log("selectQuery:", selectQuery); // Log where clause

    // Execute the SELECT query
    db.query(selectQuery, (error, results) => {
        if (error) {
          console.error('Error querying database: ' + error.stack);
          res.status(500).json({ success: false, message: 'Internal server error' });
          return;
        }
        if (results.length > 0) {
          prodindex++;
        } else {
          db.query('INSERT INTO supervisor_assign SET ?', data, (err, result) => {
            if (err) {
              console.error('Error inserting into database: ' + err.stack);
              res.status(500).json({ success: false, message: 'Internal server error' });
              return;
            }
            console.log("Inserted data:", data); // Log inserted data
            productlist.push(data); // Push inserted data to productlist
            prodindex++;
            if (prodindex === totalIterations) {
              // All iterations completed, send response
              sendResponse();
            }
          });
        }
      });
    });
  });

  // Function to send response
  function sendResponse() {
    if (prodindex > 0) {
      const successMessage = `${prodindex} Number Of Data Successfully Inserted And ${prodindex} Already assigned to same or other operator.`;
      console.log("Success message:", successMessage); // Log success message
      res.status(200).json({ success: true, message: successMessage, productlist: productlist });
    } else {
      console.log("No data inserted."); // Log no data inserted
      res.status(500).json({ success: false, message: 'ERROR' });
    }
  }
});

// Delete supervisor route
app.delete('/ota/delete_supervisor/:id', (req, res) => {
  const id = req.params.id;
  console.log("id:", id); // Log where clause
  if (id) {
    // Delete supervisor from database
    db.query('DELETE FROM supervisor_assign WHERE id = ?', [id], (err, result) => {
      if (err) {
        console.error(err);
        res.status(500).json({ status: 'Error', message: 'Internal Server Error' });
      } else {
        res.json({ status: 'Success', message: 'Delete Successfully' });
      }
    });
  } else {
    res.status(400).json({ status: 'Error', message: 'Invalid Request' });
  }
});

// API endpoint to delete items by IDs
app.delete('/ota/delete_multiple_supervisor', (req, res) => {
  const { ids } = req.body;
  console.log("ids:", ids); // Log where clause
  // Validate request body
  if (!ids || !Array.isArray(ids)) {
    return res.status(400).json({ message: 'Invalid request body. Expected an array of IDs.' });
  }

  // Delete supervisors from the database for each ID
  ids.forEach(id => {
    // Delete supervisor from database
    db.query('DELETE FROM supervisor_assign WHERE id = ?', [id], (err, result) => {
      if (err) {
        console.error(err);
        res.status(500).json({ status: 'Error', message: 'Internal Server Error' });
      } else {
        console.log(`Supervisor with ID ${id} deleted successfully.`);
      }
    });
  });

  // Send response after all deletions are completed
  res.status(200).json({ message: 'Supervisors deleted successfully.' });
});




//Operator Data
app.get('/ota/operator_data_view', (req, res) => {
  const query = `SELECT employees_ota.*, geopos_users.banned, geopos_users.roleid, geopos_users.email, geopos_users.loc,geopos_emptype.name as empname
  FROM employees_ota
  LEFT JOIN geopos_users ON employees_ota.entryid = geopos_users.entryid
  LEFT JOIN geopos_emptype ON employees_ota.roleid = geopos_emptype.id
  WHERE geopos_users.roleid = ?
  AND employees_ota.roleid = ?
  AND geopos_users.production_type = ?
  AND geopos_users.banned = ?
  ORDER BY geopos_users.name ASC`
  db.query(query, ['3','3','ota','0'], (err, result) => {
    if (err) {
      console.log(err)
    }
    res.send(result)
  })
})

//add operator data submit
app.post('/ota/add_operator', (req, res) => {
  const name = req.body.name
  const username = req.body.username
  const email = req.body.email
  const entryid = req.body.entryid
  const pass = req.body.password !== "" ? req.body.password : '123456';
  const worktyp = req.body.workertype
  const shift = req.body.shift
  const site = req.body.site
  const zone = req.body.zone
  const machine = req.body.machiness
  const type = req.body.type
  const roleid = '3'
  //date time d-m-Y H:is:s
  console.log(type)
  const currentDate = new Date();
  const formatDate = (date) => {
    const year = date.getFullYear();
    const month = String(date.getMonth() + 1).padStart(2, '0');
    const day = String(date.getDate()).padStart(2, '0');
    const hours = String(date.getHours()).padStart(2, '0');
    const minutes = String(date.getMinutes()).padStart(2, '0');
    const seconds = String(date.getSeconds()).padStart(2, '0');

    return `${year}-${month}-${day} ${hours}:${minutes}:${seconds}`;
  };
  const formattedDate = formatDate(currentDate);
  //d-m-Y
  const options = { timeZone: 'Africa/Lagos', day: 'numeric', month: 'numeric', year: 'numeric' };
  const currentTime = new Date().toLocaleString('en-US', options);
  const [date, month, year] = currentTime.split('/');
  const tdate = `${date.padStart(2, '0')}-${month.padStart(2, '0')}-${year}`;

  const tags = machine.split(',');
  const numTags = tags.length - 1;
  const empCount = (1 / numTags).toFixed(4);

  const rowcheck = `SELECT * FROM geopos_users WHERE entryid="${entryid}"`;
  const rowcheck1 = `SELECT * FROM employees_ota WHERE entryid="${entryid}"`;
  const rowcheck2 = `SELECT * FROM geopos_users WHERE email="${email}" OR username="${username}" OR name="${name}"`;

  db.query(rowcheck, function (err, result) {
    const id = result.id;
    if (result.length > 0) {
      res.status(200).json({status: 409, message: 'Entry Id already Exists'});
    } else {
      db.query(rowcheck2, function (err, resultt) {
        if (resultt.length > 0) {
          // Handle if email, username, or name already exists
        } else {
          db.query(
            'INSERT INTO geopos_users (email, username, name, entryid, date_created) VALUES (?, ?, ?, ?, ?)',
            [email, username, name, entryid, formattedDate],
            (err, result) => {
              if (err) {
                // Handle error
                console.error("Error occurred:", err);
              } else {
                if (result && result.insertId) {
                  const userId = result.insertId;
                  console.log("Insertion successful. Inserted user ID:", userId);

                  db.query(rowcheck1, function (err, resultt1) {
                    if (resultt1.length > 0) {
                      if(type=='BRAID'){
                        db.query(
                          'UPDATE employees_ota SET roleid=?, workertype=?, shift=?, staff=?, zone=?, machine=?, emp_count=?, section_id=? , category_type=? WHERE entryid=?',
                          [roleid, worktyp, shift,site, zone, machine, empCount,'0',type, entryid],
                          (err2, result2) => {
                            if (result2) {
                              const userIdAsString = userId.toString(); // Convert the number to a string
                              console.log("userIdAsString1:", userIdAsString);
                              const hashedPassword = hashPassword(pass, userIdAsString);
                              db.query(
                                'UPDATE geopos_users SET roleid=?, name=?, category_type=?,pass=? WHERE entryid=?',
                                [roleid, name, 'ikeja', hashedPassword, entryid],
                                (err3, result3) => {
                                  if (err3) {
                                    res.status(500).json({ status:500,message: 'Error updated record' })
                                  } else if (result3.affectedRows === 0) {
                                    res.status(404).json({status:404, message: 'Record not updated' })
                                  } else {
                                    res.status(200).json({message: 'Record updated successfully' })
                                  }
                                },
                              )
                            }
                          },
                        )
                      }else{
                        db.query(
                          'UPDATE employees_ota SET roleid=?, workertype=?, shift=?, staff=?, category_type=? WHERE entryid=?',
                          [roleid, worktyp, shift,site,type, entryid],
                          (err2, result2222) => {
                            if (result2222) {
                              const userIdAsString = userId.toString(); // Convert the number to a string
                              console.log("userIdAsString1:", userIdAsString);
                              const hashedPassword = hashPassword(pass, userIdAsString);
                              db.query(
                                'UPDATE geopos_users SET roleid=?, name=?, production_type=?, category_type=?,pass=? WHERE entryid=?',
                                [roleid,name,'ota',type, hashedPassword, entryid],
                                (err3333, result3333) => {
                                  if (err3333) {
                                    res.status(500).json({ message: 'Error updated record' })
                                  } else if (result3333.affectedRows === 0) {
                                    res.status(404).json({ message: 'Record not updated' })
                                  } else {
                                    res.status(200).json({ message: 'Record updated successfully' })
                                  }
                                },
                              )
                            }
                          },
                        )
                      }
                    }else{
                      if(type=='BRAID'){
                        db.query(
                          'INSERT INTO employees_ota (username,entryid,email,name,roleid,workertype,shift,staff,zone,machine,emp_count,passive_type,date,category_type) VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?,?)',
                           [username, entryid, email, name, roleid, worktyp,shift,site,zone, machine, empCount,'ACT',tdate,type],
                          (err22, result22) => {
                            if (result22) {
                              const userIdAsString = userId.toString(); // Convert the number to a string
                              console.log("userIdAsString2:", userIdAsString);
                              const hashedPassword = hashPassword(pass, userIdAsString);
                              console.log("hashedPassword:", hashedPassword);
                              //console.log("SQL Query:", 'UPDATE geopos_users SET roleid=?, name=?, production_type=?, category_type=?, pass=? WHERE entryid=?', [roleid, name, 'ikeja', type, entryid, hashedPassword]);
                              db.query(
                                'UPDATE geopos_users SET roleid=?, name=?, production_type=?, category_type=?, pass=? WHERE entryid=?',
                                [roleid, name, 'ota', type, hashedPassword, entryid],
                                (err22, result222) => {
                                  if (err22) {
                                    res.status(500).json({ status:500,message: 'Error inserted record' })
                                  } else if (result222.affectedRows === 0) {
                                    res.status(404).json({status:404, message: 'Record not inserted' })
                                  } else {
                                    res.status(200).json({ message: 'Record inserted successfully' })
                                  }
                                },
                              )
                            }
                          },
                        )
                      }else{
                        console.log('-----nbraid')
                        db.query(
                          'INSERT INTO employees_ota (username,entryid,email,name,roleid,workertype,shift,date,category_type,staff) VALUES (?,?,?,?,?,?,?,?,?,?)',
                         [username, entryid, email, name, roleid, worktyp,shift,tdate,type,site],
                          (err22, result222) => {
                            if (result222) {
                              const userIdAsString = userId.toString(); // Convert the number to a string
                              console.log("userIdAsString3:", userIdAsString);
                              const hashedPassword = hashPassword(pass, userIdAsString);
                              db.query(
                                'UPDATE geopos_users SET roleid=?, name=?, production_type=?, category_type=?, pass=? WHERE entryid=?',
                                [roleid, name, 'ota', type, hashedPassword, entryid],
                                (err222, result2222) => {
                                  if (err222) {
                                    res.status(500).json({ status:500 ,message: 'Error inserted record' })
                                  } else if (result2222.affectedRows === 0) {
                                    res.status(404).json({ status:404 ,message: 'Record not inserted' })
                                  } else {
                                    res.status(200).json({ message: 'Record inserted successfully' })
                                  }
                                },
                              )
                            }
                          },
                        )
                      }
                    }
                  })
                } else {
                  // Query was successful but no auto-increment ID was generated
                  console.log("Insertion successful but no auto-increment ID generated.");
                }
              }
            }
          );
        }
      });
    }
  });
});

//getconvert data of category
app.get('/ota/getConvertdata/:id', (req, res) => {
  const id = req.params.id;
  const query = `SELECT * FROM employees_ota WHERE id=?`;
  db.query(query,[id], (error, results) => {
    if (error) {
      console.error('Error fetching shift data:', error);
      res.status(500).json({ error: 'Failed to fetch item data' });
    } else {
      res.json(results[0]);
    }
  });
});

//get machines data
app.get('/ota/getMachines/:id', (req, res) => {
  const id = req.params.id
  db.query('SELECT * FROM geopos_machine WHERE zone=?', id, (err, result) => {
    if (err) {
      console.log(err)
    }
    if (result.length > 0) {
      res.send(result[0].machine); // Send only the name value from the result
    } else {
      res.send('',)
    }
  })
})

//add operator category convert data submit
app.post('/ota/category_convert_op', (req, res) => {
  const id = req.body.id
  const entryid = req.body.entryid
  const worktyp = req.body.workertype
  const shift = req.body.shift
  const staff = req.body.staff
  const zone = req.body.zone
  const machine = req.body.machiness
  const type = req.body.typ

  const tags = machine.split(',');
  const numTags = tags.length - 1;
  const empCount = (1 / numTags).toFixed(4);

  const rowcheck = `SELECT * FROM employees_ota WHERE id="${id}"`
  
  db.query(rowcheck, function (err, result) {
    if (result.length > 0) {
      
      if(type === 'NBRAID'){
         //get user id
         const query = `SELECT * FROM geopos_users WHERE entryid=?`;
         db.query(query, [entryid], (error, results) => {
           if (error) {
             return res.status(500).json({ message: 'Error while fetching user record' });
           }
           const eid = results.length > 0 ? results[0].id : null;
            db.query(
              'UPDATE employees_ota SET workertype=?, shift=?, staff=?, zone=?, machine=?, emp_count=?, section_id=? , category_type=? WHERE entryid=?',
              [worktyp, shift,staff, '', '', '','0',type, entryid],
              (err2, result1) => {
                if (result1) {
                  db.query(
                    'UPDATE geopos_users SET category_type=? WHERE id=?',
                    [type,eid],
                    (err3, result2) => {
                      if (err3) {
                        res.status(500).json({ message: 'Error updated record' })
                      } else if (result2.affectedRows === 0) {
                        res.status(404).json({ message: 'Record not updated' })
                      } else {
                        res.status(200).json({ message: 'Record updated successfully' })
                      }
                    },
                  )
                }
              },
            )
         })
      }else{
        //get user id
        const query = `SELECT * FROM geopos_users WHERE entryid=?`;
        db.query(query, [entryid], (error, results) => {
          if (error) {
            return res.status(500).json({ message: 'Error while fetching user record' });
          }
          const eid = results.length > 0 ? results[0].id : null;
        db.query(
          'UPDATE employees_ota SET workertype=?, shift=?, staff=?, zone=?, machine=?, emp_count=?, section_id=? , category_type=?, product=?, line=? WHERE entryid=?',
          [worktyp, shift,staff,zone,machine,empCount,'0',type,'','',entryid],
          (err2, result1) => {
            if (result1) {
              db.query(
                'UPDATE geopos_users SET category_type=? WHERE id=?',
                [type,eid],
                (err3, result2) => {
                  if (err3) {
                    res.status(500).json({ message: 'Error updated record' })
                  } else if (result2.affectedRows === 0) {
                    res.status(404).json({ message: 'Record not updated' })
                  } else {
                    res.status(200).json({ message: 'Record updated successfully' })
                  }
                },
              )
            }
          },
        )
        })
      }
    }
  })
})

//Get operator data single 
app.get('/ota/operator_data_single/:id', (req, res) => {
  const id = req.params.id
  db.query('SELECT * FROM employees_ota WHERE id=?',[id], (err, result) => {
    if (err) {
      console.log(err)
    }
    if (result.length > 0) {
      res.send(result[0]); // Send only the name value from the result
    } else {
      res.status(404).send("Operator not found");
    }
  })
})

//get zone
app.get('/ota/getzone', (req, res) => {
  db.query('SELECT * FROM geopos_machine', (err, result) => {
    if (err) {
      console.log(err)
    }
      res.send(result); // Send only the name value from the result
    
  })
})

//get user id
app.get('/ota/getuserid/:id', (req, res) => {
  const id = req.params.id
  db.query('SELECT * FROM geopos_users WHERE entryid=?',[id], (err, result) => {
    if (err) {
      console.log(err)
    }
    res.send(result[0]); // Send only the name value from the result

  })
})

//get ota items
app.get('/ota/getItems/:id', (req, res) => {
  const id = req.params.id
  db.query('SELECT * FROM operator_assign WHERE name_id=? AND category_type=?',[id,'BRAID'], (err, result) => {
    if (err) {
      console.log(err)
    }
    res.send(result); // Send only the name value from the result

  })
})

//submit zone data
app.post("/ota/add_zone", (req, res) => {   
  var id = req.body.id;
  var zone = req.body.zone;
  var machiness = req.body.machiness;
  
  const options = { timeZone: 'Africa/Lagos', day: 'numeric', month: 'numeric', year: 'numeric' };
  const currentTime = new Date().toLocaleString('en-US', options);

  const [date, month, year] = currentTime.split('/');
  const formattedDate = `${date.padStart(2, '0')}-${month.padStart(2, '0')}-${year}`;
  
  
  const rowcheck = `SELECT * FROM operator_assign WHERE zone="${zone}" AND name_id="${id}" AND category_type='BRAID'`
  
    db.query(rowcheck, function (err, result) {
      if (result.length > 0) {
        db.query(
          'UPDATE operator_assign SET machine=? WHERE name_id=? AND zone=?',
          [machiness, id, zone],
          (err2, result2) => {
            if (err2) {
              res.status(500).json({ message: 'Error updated record' })
            } else if (result2.affectedRows === 0) {
              res.status(404).json({ message: 'Record not updated' })
            } else {
              res.status(200).json({ message: 'Record updated successfully' })
            }
          },
        )
      }else{
        db.query(
          'INSERT INTO operator_assign (name_id,zone,machine,date,category_type) VALUES (?,?,?,?,?)',
          [id,zone,machiness,formattedDate,'BRAID'],
          (err2, result2) => {
            if (err2) {
              res.status(500).json({ message: 'Error Inserted record' })
            } else if (result2.affectedRows === 0) {
              res.status(404).json({ message: 'Record not Inserted' })
            } else {
              res.status(200).json({ message: 'Record Inserted successfully' })
            }
          },
        )
      }
    });
  
  });

//ota operator item  Delete 
  app.delete('/ota/item_zone_delete/:id', (req, res) => {
    const id = req.params.id
    db.query('DELETE FROM operator_assign WHERE id= ?', id, (err, result) => {
      if (err) {
        res.status(500).send('Error deleting record')
      } else{
        res.status(200).send('Data Deleted successfully')
      }
    })
  })

//get operator section data
app.get('/ota/getSectionitem/:id', (req, res) => {
  const operatorId = req.params.id;

  const query = `
    SELECT operator_assign.*, section.section_name
    FROM operator_assign
    LEFT JOIN section ON operator_assign.section = section.id
    WHERE operator_assign.name_id = ?
  `;

  db.query(query, [operatorId], (err, result) => {
    if (err) {
      console.error('Error fetching data from MySQL:', err);
      res.status(500).json({ message: 'Error fetching data from MySQL' });
    } else {
      res.json(result);
    }
  });
});

//get Line master
app.get('/ota/getlinemaster', (req, res) => {
  db.query('SELECT * FROM line_master WHERE status=?',['1'], (err, result) => {
    if (err) {
      console.log(err)
    }
    res.send(result); // Send only the name value from the result

  })
})

//get Line master
app.get('/ota/getSection', (req, res) => {
  db.query('SELECT * FROM section WHERE status=?',['1'], (err, result) => {
    if (err) {
      console.log(err)
    }
    res.send(result); // Send only the name value from the result

  })
})

//submit section op  data
app.post("/ota/addSectionOp", (req, res) => {   
  var id = req.body.id;
  var shift = req.body.shift;
  var line = req.body.line;
  var section = req.body.section;

      const options = { timeZone: 'Africa/Lagos', day: 'numeric', month: 'numeric', year: 'numeric' };
      const currentTime = new Date().toLocaleString('en-US', options);
  
      const [date, month, year] = currentTime.split('/');
      const formattedDate = `${date.padStart(2, '0')}-${month.padStart(2, '0')}-${year}`;
  
  
  const rowcheck = `SELECT * FROM operator_assign WHERE section="${section}" and line="${line}" and shift="${shift}"`
  
    db.query(rowcheck, function (err, result) {
      if (result.length > 0) {
              res.status(200).json({ message: 'Already assigned to same operator or other' })
      }else{
        db.query(
          'INSERT INTO operator_assign (name_id,section,line,shift,date,category_type) VALUES (?,?,?,?,?,?)',
          [id,section,line,shift,formattedDate,'NBRAID'],
          (err2, result2) => {
            if (err2) {
              res.status(500).json({ message: 'Error Inserted record' })
            } else if (result2.affectedRows === 0) {
              res.status(404).json({ message: 'Record not Inserted' })
            } else {
              res.status(200).json({ message: 'Record Inserted successfully'})
            }
          },
        )
      }
    });
  
  });

//assign section Delete 
   app.delete('/ota/delete_section_assign/:id', (req, res) => {
    const id = req.params.id
    db.query('DELETE FROM operator_assign WHERE id= ?', id, (err, result) => {
      if (err) {
        res.status(500).send('Error deleting record')
      } else{
        res.status(200).send('Data Deleted successfully')
      }
    })
  })

//Get all users
  app.get('/ota/get_users', (req, res) => {
    db.query('SELECT * FROM geopos_users WHERE roleid=? AND production_type=? AND banned=? AND category_type=?',
    ['3','ota','0','NBRAID'], (err, result) => {
      if (err) {
        console.error('Error executing MySQL query:', err)
        res.status(500).send('Internal Server Error')
        return
      }
      res.send(result)
    })
  })

 //Operator section exit check
 app.get('/ota/assign_check', (req, res) => {
  const { where } = req.query
  db.query(`SELECT * FROM operator_assign WHERE ${where}`, (err, result) => {
    if (err) {
      console.log(err)
    }
    res.send(result)
  })
})

//update assign operator
app.get('/ota/update_assign_operator/:id', (req, res) => {
  const { where } = req.query
  const userid = req.params.id
  db.query(`UPDATE operator_assign SET name_id= ${userid} WHERE ${where}`, (err, result) => {
    if (err) {
      res.status(500).json({ message: 'Error update record' })
    } else if (result.affectedRows === 0) {
      res.status(404).json({ message: 'Record not Updated' })
    } else {
      res.status(200).json({ message: 'Record Updated successfully' })
    }
  })
}) 

//get role id
app.get('/ota/get_role/:id', (req, res) => {
  const id = req.params.id
  db.query('SELECT * FROM geopos_emptype WHERE id=?', id, (err, result) => {
    if (err) {
      console.log(err)
    }
    res.send(result)
  })
})

//Update operator
app.post('/ota/update_operator', (req, res) => {
  const name = req.body.name
  const worktyp = req.body.workertype
  const shift = req.body.shift
  const id = req.body.id
  const entryid = req.body.entryid;

  db.query(
    'UPDATE employees_ota SET name=?,workertype=?,shift=? WHERE id = ?',
    [name, worktyp, shift,id],
    (err, result) => {
      if (err) {
        res.status(500).json({ message: 'Error update record' })
      } else if (result.affectedRows === 0) {
        res.status(404).json({ message: 'Record not Updated' })
      } else {
        //res.status(200).json({ message: 'Record Updated successfully' })
        db.query('UPDATE geopos_users SET name=? WHERE entryid=?', [name, entryid], (err, result) => {
          if (err) {
            res.status(500).json({ message: 'Error updating user record' });
          } else if (result.affectedRows === 0) {
            res.status(404).json({ message: 'User record not updated' });
          } else {
            res.status(200).json({ message: 'Record Updated successfully' });
          }
        });
      }
    },
  )
})

//Get operator username single
app.get('/ota/operator_data_username/:id', (req, res) => {
  const id = req.params.id;
  console.log('id:', id);
  db.query('SELECT * FROM employees_ota JOIN geopos_users ON employees_ota.entryid = geopos_users.entryid WHERE employees_ota.id=?', [id], (err, result) => {
    if (err) {
      console.log(err);
      res.status(500).send("Internal Server Error");
    } else {
      res.json(result); // Sending the full result as JSON
    }
  });
});

//Operator change password
app.post('/ota/change_password', (req, res) => {
  const newpassword = req.body.confirmPassword;
  const uid = req.body.id;
  console.log("uid", uid);
  const userId = `${uid}`; // Converts the integer to a string using template literals
  try {
    const hashedPassword = hashPassword(newpassword, userId);
    console.log("userId :", userId);
    console.log("hashedPassword :", hashedPassword);
    //const entryid = req.body.entryid;
    const query = `UPDATE geopos_users SET pass = '${hashedPassword}' WHERE id = '${uid}'`;
    console.log('Update query:', query); // Log the generated SQL query
    db.query(query, (err, result) => {
      if (err) {
        res.status(500).json({ message: 'Error updating record' });
      } else if (result.affectedRows === 0) {
        res.status(404).json({ message: 'Record not updated' });
      } else {
        res.status(200).json({ message: 'Record updated successfully' });
      }
    });
  } catch (error) {
    console.error('Error:', error);
    res.status(500).json({ message: 'Error hashing password' });
  }
});

// Delete operator ota
app.delete('/ota/operator_delete/:id', (req, res) => {
  const id = req.params.id; // ID will be a string here
  const selectQuery = `
    SELECT geopos_users.id AS userId
    FROM geopos_users
    LEFT JOIN employees_ota ON geopos_users.entryid = employees_ota.entryid
    WHERE employees_ota.id = ?
  `;

// Get the user ID associated with the operator from the geopos_users table
  db.query(selectQuery, id, (err, result1) => {
    if (err) {
      console.error(err);
      return res.status(500).json({ error: 'Internal server error' });
    }

    if (result1.length === 0) {
      return res.status(404).json({ error: 'Operator not found' });
    }

    const userId = result1[0].userId;

    // Update the 'banned' column in employees_ota table
    const updateOtaQuery = 'UPDATE employees_ota SET banned = ? WHERE id = ?';
    db.query(updateOtaQuery, [1, id], (error, result2) => {
      if (error) {
        console.error(error);
        return res.status(500).json({ error: 'Internal server error' });
      }

      // Update the 'banned' column in geopos_users table
      const updateGeoposQuery = 'UPDATE geopos_users SET banned = ? WHERE id = ?';
      db.query(updateGeoposQuery, [1, userId], (error, result3) => {
        if (error) {
          console.error(error);
          return res.status(500).json({ error: 'Internal server error' });
        }

        // Delete related records from operator_assign table
        const deleteAssignQuery = 'DELETE FROM operator_assign WHERE name_id = ?';
        db.query(deleteAssignQuery, userId, (err, result4) => {
          if (err) {
            console.error("Error deleting employee:", err);
            return res.status(500).send('Error deleting record');
          }

          // All operations completed successfully
          res.status(200).json({ message: 'Operator deleted and related records updated successfully' });
        });
      });
    });
  });
});

// Convert operator to worker
app.delete('/ota/convert/:id', (req, res) => {
  const id = req.params.id; // ID will be a string here
  const selectQuery = `
    SELECT geopos_users.*,employees_ota.id as idd
    FROM geopos_users
    LEFT JOIN employees_ota ON geopos_users.entryid = employees_ota.entryid
    WHERE employees_ota.id = ?
  `;

// Get the user ID associated with the operator from the geopos_users table
  db.query(selectQuery, id, (err, result1) => {
    if (err) {
      console.error(err);
      return res.status(500).json({ error: 'Internal server error' });
    }

    if (result1.length === 0) {
      return res.status(404).json({ error: 'Operator not found' });
    }

    const userId = result1[0].id;

    // Update the 'banned' column in employees_ota table
    const updateOtaQuery = 'UPDATE employees_ota SET roleid = ? WHERE id = ?';
    db.query(updateOtaQuery, [1, id], (error, result2) => {
      if (error) {
        console.error(error);
        return res.status(500).json({ error: 'Internal server error' });
      }

      // Update the 'banned' column in geopos_users table
      const updateGeoposQuery = 'UPDATE geopos_users SET banned = ?,roleid=? WHERE id = ?';
      db.query(updateGeoposQuery, [1,1, userId], (error, result3) => {
        if (error) {
          console.error(error);
          return res.status(500).json({ error: 'Internal server error' });
        }

        // Delete related records from operator_assign table
        const deleteAssignQuery = 'DELETE FROM operator_assign WHERE name_id = ?';
        db.query(deleteAssignQuery, userId, (err, result4) => {
          if (err) {
            console.error("Error deleting employee:", err);
            return res.status(500).send('Error deleting record');
          }

          // All operations completed successfully
          res.status(200).json({ message: 'Operator successfully converted to Worker' });
        });
      });
    });
  });
});

//get all assign worker list
app.get('/ota/get_operator_assign_list', (req, res) => {
  const query = `SELECT operator_assign.*,geopos_users.entryid,geopos_users.roleid,geopos_users.name,section.section_name
                 FROM operator_assign
                 LEFT JOIN geopos_users ON operator_assign.name_id = geopos_users.id
                 LEFT JOIN section ON operator_assign.section = section.id
                 WHERE operator_assign.category_type = ?`;

  db.query(query, ['BRAID'], (err, result) => {
    if (err) {
      console.error(err);
      res.status(500).send('Error fetching operator assignments');
    } else {
      res.send(result);
    }
  });
});

//Filter search data
app.post('/ota/search_operator_assignlist_ota', async (req, res) => {
  try {
    // Extract data from request body
    const name = req.body.operator_name;
    const fullname = req.body.name;
    const shift = req.body.shift;
    const line = req.body.line_no;
    const section = req.body.section;
    const section_name = req.body.section_name;
    

    // Log the received data
    console.log('Received data:');
    console.log('Operator:', name);
    console.log('Operator Full name:', fullname);
    console.log('Shift:', shift);
    console.log('Line:', line);
    console.log('Section:', section);
    console.log('Section Name:', section_name);
    

    let whereClause = "(operator_assign.category_type ='NBRAID')";

    if (shift) {
      whereClause += " AND operator_assign.shift='" + shift + "'";
    }
    if (section) {
      whereClause += " AND operator_assign.section='" + section + "'";
    }
    if (line) {
      whereClause += " AND operator_assign.line='" + line + "'";
    }
    if (name) {
      whereClause += " AND operator_assign.name_id='" + name + "'";
    }

    const sql = `
      SELECT operator_assign.*, geopos_users.entryid, geopos_users.roleid,
             geopos_users.name, section.section_name
      FROM operator_assign
      LEFT JOIN geopos_users ON operator_assign.name_id = geopos_users.id
      LEFT JOIN section ON operator_assign.section = section.id
      WHERE ${whereClause};
    `;

    const results = await queryota(sql);

    res.json({ timesheet: results,  name: fullname, shift, line: line,  section_name });
  } catch (error) {
    console.error('Error executing MySQL query: ' + error);
    res.status(500).json({ error: 'Internal server error' });
  }
});

// Function to execute MySQL queries
const queryota = (sql) => {
  return new Promise((resolve, reject) => {
    db.query(sql, (err, results) => {
      if (err) {
        reject(err);
        return;
      }
      resolve(results);
    });
  });
};

//Delete assign braid and nonbraid list
app.delete('/ota/delete_assign_list/:id', (req, res) => {
  const id = req.params.id
  db.query('DELETE FROM operator_assign WHERE id= ?', id, (err, result) => {
    if (err) {
      res.status(500).send('Error deleting record')
    } else if (result.affectedRows === 0) {
      res.status(404).send('Not Deleted')
    } else {
      res.status(200).send('Delete successfully')
    }
  })
})

//get all assign worker list nonbraid
app.get('/ota/get_operator_nbraid_assign_list', (req, res) => {
  const query = `SELECT operator_assign.*,geopos_users.entryid,geopos_users.roleid,geopos_users.name,section.section_name
  FROM operator_assign
  LEFT JOIN geopos_users ON operator_assign.name_id = geopos_users.id
  LEFT JOIN section ON operator_assign.section = section.id
  WHERE operator_assign.category_type = ?`;

  db.query(query, ['NBRAID'], (err, result) => {
    if (err) {
      console.error(err);
      res.status(500).send('Error fetching operator assignments');
    } else {
      res.send(result);
    }
  });
});  

//Delete assign braid and nonbraid list
app.delete('/ota/delete_assign_list/:id', (req, res) => {
  const id = req.params.id
  db.query('DELETE FROM operator_assign WHERE id= ?', id, (err, result) => {
    if (err) {
      res.status(500).send('Error deleting record')
    } else if (result.affectedRows === 0) {
      res.status(404).send('Not Deleted')
    } else {
      res.status(200).send('Delete successfully')
    }
  })
})

// Get change shift operator data
app.get('/ota/getEmployees', (req, res) => {
  let query =
    `SELECT employees_ota.*, geopos_emptype.name as role
    FROM employees_ota
    LEFT JOIN geopos_emptype ON employees_ota.roleid = geopos_emptype.id
    WHERE employees_ota.roleid = ? AND employees_ota.banned = ?`;
    
  db.query(query, ['3', '0'], (err, result) => {
    if (err) {
      console.log(err);
      res.status(500).send('Internal Server Error');
    } else {
      res.send(result);
    }
  });
});

//get changez shift employee entryid
app.post('/ota/changeshift_entryid', (req, res) => {
  const { entryIds } = req.body;
  const entryIdsArray = Array.isArray(entryIds) ? entryIds : [entryIds];

  // Use the IN operator in the SQL query to check for multiple entryid values
  const query = 'SELECT entryid FROM employees_ota WHERE id IN (?)';

  db.query(query, [entryIdsArray], (err, results) => {
    if (err) {
      console.log(err);
      res.status(500).json({ error: 'Internal Server Error' });
    } else {
      res.json(results);
    }
  });
});

// update shift operator
app.post('/ota/update_shift', (req, res) => {
  const { shift, entryIds } = req.body;
  
  if (!shift || !entryIds) {
    return res.status(400).json({ status: 'Error', message: 'Shift and entryIds are required.' });
  }

  const entryIdsArray = entryIds.split(',');

  // Query to check if the employee with the given entryId exists
  const checkQuery = 'SELECT id FROM employees_ota WHERE id = ? ';

  // Query to update data for each entryId
  const updateQuery = 'UPDATE employees_ota SET shift = ? WHERE id = ?';

  // Counter to keep track of processed entries
  let processedCount = 0;

  entryIdsArray.forEach((entryId) => {
    const checkValues = [entryId];

    // Check if the employee exists
    db.query(checkQuery, checkValues, (checkErr, checkResult) => {
      if (checkErr) {
        console.error('Error checking employee:', checkErr);
        res.status(500).json({ status: 'Error', message: 'Internal Server Error' });
      } else {
        if (checkResult.length === 1) {
          // Employee exists, update the data
          const updateValues = [shift, entryId];
          db.query(updateQuery, updateValues, (updateErr, updateResult) => {
            if (updateErr) {
              console.error('Error updating data:', updateErr);
              res.status(500).json({ status: 'Error', message: 'Internal Server Error' });
            } else {
              processedCount++;
              console.log(`Data updated for entryId: ${entryId}`);

              // Check if all entries have been processed
              if (processedCount === entryIdsArray.length) {
                res.json({ status: 'Success', message: 'Details updated successfully.' });
              }
            }
          });
        } else {
          // Employee does not exist, skip the update for this entryId
          processedCount++;
          console.log(`Employee not found for entryId: ${entryId}`);

          // Check if all entries have been processed
          if (processedCount === entryIdsArray.length) {
            res.json({ status: 'Success', message: 'Details updated successfully.' });
          }
        }
      }
    });
  });
});

//BRAID Employee Defulte data search
app.get('/ota/get_employeess', (req, res) => {
  const query = `
    SELECT employees_ota.*, section.section_name,geopos_emptype.name as role
    FROM employees_ota
    LEFT JOIN geopos_emptype ON employees_ota.roleid = geopos_emptype.id
    LEFT JOIN section ON employees_ota.section_id = section.id
    WHERE (employees_ota.roleid != '3' AND employees_ota.roleid != '5')
      AND employees_ota.passive_type = 'ACT'
      AND employees_ota.category_type = 'BRAID';
  `;

  db.query(query, (err, result) => {
    if (err) {
      console.error(err);
      return res.status(500).json({ message: 'Error retrieving records' });
    }
    res.json(result);
  });
});

//BRAID Employee filter data search
app.get('/ota/get_employees', (req, res) => {
  const { where } = req.query

  let query = `
      SELECT employees_ota.*, section.section_name,geopos_emptype.name as role
      FROM employees_ota
      LEFT JOIN geopos_emptype ON employees_ota.roleid = geopos_emptype.id
      LEFT JOIN section ON employees_ota.section_id = section.id
      WHERE ${where}
    `

  db.query(query, (err, result) => {
    if (err) {
      console.log(err)
      res.status(500).json({ message: 'Error retrieving records' })
    } else {
      res.json(result)
    }
  })
})

//employee to operator change
app.post('/ota/changeEmpToOp', (req, res) => {
  const entryid = req.body.entryid
  const username = req.body.unm
  const pass = req.body.password
  const roleid = req.body.rlid
  const name = req.body.name
  const email = req.body.unm
  const worktyp = req.body.workertype
  const shift = req.body.shift
  const zone = req.body.zone
  const machine = req.body.machine
  const type = req.body.category_type 
  const staff=req.body.staff

  const tags = machine.split(',');
  const numTags = tags.length - 1;
  const empCount = (1 / numTags).toFixed(4);


    db.query(
      'INSERT INTO geopos_users (username,entryid,email,name,roleid) VALUES (?,?,?,?,?)',
      [username, entryid, email, name, roleid],
      (err3, result3) => {
        if (err3) {
          res.status(500).json({ message: 'Error inserted record' })
        } else if (result3.affectedRows === 0) {
          res.status(404).json({ message: 'Record not Inserted' })
        } else {

          const userId = result3.insertId;
          console.log("Insertion successful. Inserted user ID:", userId);

          const rowcheck = `SELECT * FROM employees_ota WHERE entryid="${entryid}"`

          db.query(rowcheck, function (err, result) {
            if (result.length > 0) {
              db.query(
                'UPDATE employees_ota SET username=?,roleid=?,workertype=?,shift=?,zone=?,machine=?,emp_count=?,section_id=?,category_type=?,staff=? WHERE entryid=?',
                [username,roleid, worktyp, shift,zone,machine,empCount,'0',type,staff,entryid,],
                (err2, result2) => {
                  if (result2) {
                    const userIdAsString = userId.toString(); // Convert the number to a string
                    console.log("userIdAsString1:", userIdAsString);
                    const hashedPassword = hashPassword(pass, userIdAsString);
                    db.query(
                      'UPDATE geopos_users SET entryid=?,name=?,roleid=?,production_type=?,category_type=?, pass=? WHERE entryid=?',
                      [entryid, name, roleid,'ota',type,hashedPassword,entryid],
                      (err3, result3) => {
                        if (err3) {
                          res.status(500).json({ message: 'Error Updated record' })
                        } else if (result3.affectedRows === 0) {
                          res.status(404).json({ message: 'Record not Updated' })
                        } else {
                          res.status(200).json({ message: 'Record Updated successfully' })
                        }
                      },
                    )
                  }
                },
              )
            }
          })
        }
      },
    )
})

//Update employee 
app.post('/ota/update_employee', (req, res) => {
  const name = req.body.name
  const entryid = req.body.entryid
  const worktyp = req.body.workertype
  const shift = req.body.shift
  const section_id = req.body.section_id
  const roleid = req.body.roleid
  const zone = req.body.uzone
  const id = req.body.id
  const machine = req.body.machiness

  const tags = machine.split(',');
  const numTags = tags.length - 1;
  const empCount = (1 / numTags).toFixed(4);
console.log(req.body)
  db.query(
    'UPDATE employees_ota SET entryid=?,name=?,workertype=?,shift=?,section_id=?,zone=?,machine=?,emp_count=? WHERE id = ?',
    [entryid, name, worktyp, shift, section_id, zone, machine, empCount, id],
    (err, result) => {
      if (err) {
        res.status(500).json({ message: 'Error update record' })
      } else if (result.affectedRows === 0) {
        res.status(404).json({ message: 'Record not Updated' })
      } else {
        res.status(200).json({ message: 'Record Updated successfully' });
       
      }
    },
  )
})

//Employee Default date
app.get('/ota/get_employeess_date', (req, res) => {
  const query = `SELECT * FROM employees_ota order by id asc limit 1`;

  db.query(query, (err, result) => {
    if (err) {
      console.error(err);
      return res.status(500).json({ message: 'Error retrieving records' });
    }
    res.json(result[0]);
  });
});

//Delete employee 
app.delete('/ota/delete_user/:id', (req, res) => {
  const id = req.params.id
  db.query('DELETE FROM employees_ota WHERE id= ?',id, (err, result) => {
    if (err) {
      res.status(500).send('Error deleting record')
    } else{
      res.status(200).send('Data Deleted successfully')
    }
  })
})

//Employee Default date
app.get('/ota/get_employeess_nbraid_date', (req, res) => {
  const query = `SELECT * FROM employees_ota order by id asc limit 1`;

  db.query(query, (err, result) => {
    if (err) {
      console.error(err);
      return res.status(500).json({ message: 'Error retrieving records' });
    }
    res.json(result[0]);
  });
});

//Nonbraid Employee Defulte data search
app.get('/ota/get_employeess_nbraid', (req, res) => {
  const query = `
    SELECT employees_ota.*, section.section_name,item_masterr.item_description,geopos_emptype.name as role
    FROM employees_ota
    LEFT JOIN geopos_emptype ON employees_ota.roleid = geopos_emptype.id
    LEFT JOIN section ON employees_ota.section_id = section.id
    LEFT JOIN item_masterr ON employees_ota.product = item_masterr.id
    WHERE employees_ota.roleid != '3'
      AND employees_ota.passive_type = 'ACT'
      AND employees_ota.category_type = 'NBRAID';
  `;

  db.query(query, (err, result) => {
    if (err) {
      console.error(err);
      return res.status(500).json({ message: 'Error retrieving records' });
    }
    res.json(result);
  });
});

//Nonbraid Employee filter data search
app.get('/ota/get_employees_nbraid', (req, res) => {
  const { where } = req.query

  let query = `
      SELECT employees_ota.*, section.section_name,geopos_emptype.name as role
      FROM employees_ota
      LEFT JOIN geopos_emptype ON employees_ota.roleid = geopos_emptype.id
      LEFT JOIN section ON employees_ota.section_id = section.id
      WHERE ${where}
    `

  db.query(query, (err, result) => {
    if (err) {
      console.log(err)
      res.status(500).json({ message: 'Error retrieving records' })
    } else {
      res.json(result)
    }
  })
})

//get section Name from id
app.get('/ota/getSectionName/:id', (req, res) => {
  const id = req.params.id
  db.query('SELECT * FROM section WHERE id=?',[id], (err, result) => {
    if (err) {
      console.log(err)
    }
    res.send(result[0].section_name); // Send only the name value from the result

  })
})

//get section Name from id
app.get('/ikeja/getSectionName/:id', (req, res) => {
  const id = req.params.id
  db.query('SELECT * FROM section WHERE id=?',[id], (err, result) => {
    if (err) {
      console.log(err)
    }
    res.send(result[0].section_name); // Send only the name value from the result

  })
})

//employee to opeartor change
app.post('/ota/updateemployee', (req, res) => {
  const id = req.body.id
  const name = req.body.name
  const entryid = req.body.entryid
  const workertype = req.body.workertype
  const shift = req.body.shift
  const roleid = req.body.roleid
  const line = req.body.line
  const section_id = req.body.section_id
  const usection_id = req.body.usection_id
  const uline = req.body.uline
  
  db.query(
    'UPDATE employees_ota SET name=?,workertype=?,shift=?,section_id=?,line=?,roleid=? WHERE id=?',
    [name,workertype,shift,usection_id,uline,roleid,id],
    (err2, result2) => {
      if (result2) {
        db.query(
          'INSERT INTO change_product (entryid,emp_id,line_old,line_new,section_old,section_new) VALUES (?,?,?,?,?,?)',
          [entryid, id, line,uline,section_id,usection_id],
          (err3, result3) => {
            if (err3) {
              res.status(500).json({ message: 'Error Updated record' })
            } else if (result3.affectedRows === 0) {
              res.status(404).json({ message: 'Record not Updated' })
            } else {
              res.status(200).json({ message: 'Record Updated successfully' })
            }
          },
        )
      }
    },
  )
  
})

//Change zone OTA
// Get zone data default view
app.get('/ota/getZonedata', (req, res) => {
  let query =
    `SELECT employees_ota.*, section.section_name,geopos_emptype.name as role
    FROM employees_ota
    LEFT JOIN geopos_emptype ON employees_ota.roleid = geopos_emptype.id
    LEFT JOIN section ON employees_ota.section_id = section.id
    WHERE (employees_ota.roleid !='3' AND employees_ota.roleid !='5') AND employees_ota.passive_type='ACT' and  employees_ota.category_type='BRAID'`;
    
  db.query(query, (err, result) => {
    if (err) {
      console.log(err);
      res.status(500).send('Internal Server Error');
    } else {
      res.send(result);
    }
  });
});

// Get zone data search  view
app.get('/ota/get_zonedata_search', (req, res) => {
  const { where } = req.query
  let query =
    `SELECT employees_ota.*, section.section_name,geopos_emptype.name as role
    FROM employees_ota
    LEFT JOIN geopos_emptype ON employees_ota.roleid = geopos_emptype.id
    LEFT JOIN section ON employees_ota.section_id = section.id
    WHERE ${where}`;
    
  db.query(query, (err, result) => {
    if (err) {
      console.log(err);
      res.status(500).send('Internal Server Error');
    } else {
      res.send(result);
    }
  });
});

// Change zone braid multiple entry id wise zone update
app.post('/ota/update_multiple_zone', (req, res) => {
  const { shift, entryIds, section_id, zone, machines } = req.body;
  // Date format d-m-Y H:i:s
  const options = {
    timeZone: 'Africa/Lagos',
    day: '2-digit',
    month: '2-digit',
    year: 'numeric',
    hour: '2-digit',
    minute: '2-digit',
    second: '2-digit'
  };
  const currentTime = new Date().toLocaleString('en-US', options);

  const [datePart, timePart] = currentTime.split(', ');
  const [month, date, year] = datePart.split('/');
  const [time, amPm] = timePart.split(' ');
  const [hours, minutes, seconds] = time.split(':');
  const tdate = `${date.padStart(2, '0')}-${month.padStart(2, '0')}-${year} ${hours}:${minutes}:${seconds}`;

  const category_type='BRAID';
  const production_type='OTA';

  const tags = machines.split(',');
  const numTags = tags.length - 1;
  const empCount = (1 / numTags).toFixed(4);

  const entryIdsArray = entryIds.split(',');

  const checkQuery = 'SELECT * FROM employees_ota WHERE id = ? ';
  const InsertQuery =
    'INSERT INTO geopos_changezonemachine (zone_old,machine_old,zone_new,machine_new,shift_old,section_old,shift_new,section_new,emp_id,entry_id,date_time,category_type,production_type) VALUES (?,?,?,?,?,?,?,?,?,?,?,?,?)';
  const updateQuery =
    'UPDATE employees_ota SET zone=?,machine=?,emp_count=?,shift=?,section_id=? WHERE id = ?';

  let processedCount = 0;

  entryIdsArray.forEach((entryId) => {
    const checkValues = [entryId];

    db.query(checkQuery, checkValues, (checkErr, checkResult) => {
      if (checkErr) {
        console.error('Error checking employee:', checkErr);
        res.status(500).json({ status: 'Error', message: 'Internal Server Error' });
      } else {
        if (checkResult.length === 1) {
          const {
            entryid,
            zone: zone_old,
            machine: machine_old,
            shift: shift_old,
            section_id: section_old,
            id
          } = checkResult[0];

          const insertValues = [
            zone_old,
            machine_old,
            zone,
            machines,
            shift_old,
            section_old,
            shift,
            section_id,
            id,
            entryid,
            tdate,
            category_type,
            production_type
          ];

          db.query(InsertQuery, insertValues, (InsertErr, insertResult) => {
            if (InsertErr) {
              console.error('Error inserting data:', InsertErr);
              res.status(500).json({ status: 'Error', message: 'Internal Server Error' });
            } else {
              const updateValue = [zone, machines, empCount, shift, section_id, id];
              db.query(updateQuery, updateValue, (updateErr, updateResult) => {
                if (updateErr) {
                  console.error('Error updating data:', updateErr);
                  res.status(500).json({ status: 'Error', message: 'Internal Server Error' });
                } else {
                  processedCount++;
                  console.log(`Data updated for entryId: ${entryId}`);

                  if (processedCount === entryIdsArray.length) {
                    res.json({ status: 'Success', message: 'Details updated successfully.' });
                  }
                }
              });
            }
          });
        } else {
          processedCount++;
          console.log(`Employee not found for entryId: ${entryId}`);

          if (processedCount === entryIdsArray.length) {
            res.json({ status: 'Success', message: 'Details updated successfully.' });
          }
        }
      }
    });
  });
});

// change zone braid to nbraid assign 
app.post('/ota/update_multiple_zone_to_nbraid', (req, res) => {
  const { entryIds,line, section_id } = req.body;
  const entryIdsArray = entryIds.split(',');
  const checkQuery = 'SELECT * FROM employees_ota WHERE id = ? ';
  const updateQuery =
    'UPDATE employees_ota SET zone=?,machine=?,emp_count=?,line=?,section_id=?,category_type=? WHERE id = ?';
  let processedCount = 0;

  entryIdsArray.forEach((entryId) => {
    const checkValues = [entryId];
  
    db.query(checkQuery, checkValues, (checkErr, checkResult) => {
      if (checkErr) {
        console.error('Error checking employee:', checkErr);
        res.status(500).json({ status: 'Error', message: 'Internal Server Error' });
      } else {
        if (checkResult.length === 1) {
          const {id} = checkResult[0];
          const updateValue = ['','','', line, section_id,'NBRAID', id];
          db.query(updateQuery, updateValue, (updateErr, updateResult) => {
            if (updateErr) {
              console.error('Error updating data:', updateErr);
              res.status(500).json({ status: 'Error', message: 'Internal Server Error' });
            } else {
              processedCount++;
              console.log(`Data updated for entryId: ${entryId}`);

              if (processedCount === entryIdsArray.length) {
                res.json({ status: 'Success', message: 'Details updated successfully.' });
              }
            }
          });
        } else {
          processedCount++;
          console.log(`Employee not found for entryId: ${entryId}`);

          if (processedCount === entryIdsArray.length) {
            res.json({ status: 'Success', message: 'Details updated successfully.' });
          }
        }
      }
    });
  });
});

// Get zone nbraid data default view
app.get('/ota/getZonedataNbraid', (req, res) => {
  let query =
    `SELECT employees_ota.*, section.section_name,item_masterr.item_description,geopos_emptype.name as role
    FROM employees_ota
    LEFT JOIN geopos_emptype ON employees_ota.roleid = geopos_emptype.id
    LEFT JOIN section ON employees_ota.section_id = section.id
    LEFT JOIN item_masterr ON employees_ota.product = item_masterr.id
    WHERE employees_ota.roleid !='3' AND employees_ota.passive_type='ACT' and  employees_ota.category_type='NBRAID'`;
    
  db.query(query, (err, result) => {
    if (err) {
      console.log(err);
      res.status(500).send('Internal Server Error');
    } else {
      res.send(result);
    }
  });
});

// Get zone nbraid data search view OTA
app.get('/ota/get_zoneNbraid_search', (req, res) => {
  const { where } = req.query
  let query =
    `SELECT employees_ota.*, section.section_name,geopos_emptype.name as role
    FROM employees_ota
    LEFT JOIN geopos_emptype ON employees_ota.roleid = geopos_emptype.id
    LEFT JOIN section ON employees_ota.section_id = section.id
    WHERE ${where}`;
    
  db.query(query, (err, result) => {
    if (err) {
      console.log(err);
      res.status(500).send('Internal Server Error');
    } else {
      res.send(result);
    }
  });
});

// Entryids wise section/line data update Nbraid OTA
app.post('/ota/update_multiple_zone_nbraid', (req, res) => {
  const { entryIds,line, section_id} = req.body;
  
  const entryIdsArray = entryIds.split(',');

  const checkQuery = 'SELECT * FROM employees_ota WHERE id = ? ';
  const InsertQuery =
    'INSERT INTO change_product (emp_id,entryid,line_old,line_new,section_old,section_new) VALUES (?,?,?,?,?,?)';
  const updateQuery =
    'UPDATE employees_ota SET line=?,section_id=? WHERE id = ?';

  let processedCount = 0;

  entryIdsArray.forEach((entryId) => {
    const checkValues = [entryId];

    db.query(checkQuery, checkValues, (checkErr, checkResult) => {
      if (checkErr) {
        console.error('Error checking employee:', checkErr);
        res.status(500).json({ status: 'Error', message: 'Internal Server Error' });
      } else {
        if (checkResult.length === 1) {
          const id=checkResult[0].id;
          const entryid=checkResult[0].entryid;
          const line_old=checkResult[0].line;
          const section_old=checkResult[0].section_id;
        
       
          const insertValues = [
            id,
            entryid,
            line_old,
            line,
            section_old,
            section_id
          ];

          db.query(InsertQuery, insertValues, (InsertErr, insertResult) => {
            if (InsertErr) {
              console.error('Error inserting data:', InsertErr);
              res.status(500).json({ status: 'Error', message: 'Internal Server Error' });
            } else {
              const updateValue = [line,section_id,id];
              db.query(updateQuery, updateValue, (updateErr, updateResult) => {
                if (updateErr) {
                  console.error('Error updating data:', updateErr);
                  res.status(500).json({ status: 'Error', message: 'Internal Server Errors' });
                } else {
                  processedCount++;
                  console.log(`Data updated for entryId: ${entryId}`);

                  if (processedCount === entryIdsArray.length) {
                    res.json({ status: 'Success', message: 'Details updated successfully.' });
                  }
                }
              });
            }
          });
        } else {
          processedCount++;
          console.log(`Employee not found for entryId: ${entryId}`);

          if (processedCount === entryIdsArray.length) {
            res.json({ status: 'Success', message: 'Details updated successfully.' });
          }
        }
      }
    });
  });
});

// Entryids wise zone braid update
app.post('/ota/update_multiple_zone_braid', (req, res) => {
  const { shift, entryIds, section_id, zone, machines } = req.body;
  
  const tags = machines.split(',');
  const numTags = tags.length - 1;
  const empCount = (1 / numTags).toFixed(4);

  const entryIdsArray = entryIds.split(',');
  const checkQuery = 'SELECT * FROM employees_ota WHERE id = ? ';
  const updateQuery =
    'UPDATE employees_ota SET zone=?,machine=?,emp_count=?,line=?,shift=?,section_id=?,category_type=? WHERE id = ?';

  let processedCount = 0;

  entryIdsArray.forEach((entryId) => {
    const checkValues = [entryId];

    db.query(checkQuery, checkValues, (checkErr, checkResult) => {
      const id=checkResult[0].id
      if (checkErr) {
        console.error('Error checking employee:', checkErr);
        res.status(500).json({ status: 'Error', message: 'Internal Server Error' });
      } else {
         if (checkResult.length === 1) {
          const updateValue = [zone, machines, empCount,'', shift, section_id,'BRAID', id];
          db.query(updateQuery, updateValue, (updateErr, updateResult) => {
            if (updateErr) {
              console.error('Error updating data:', updateErr);
              res.status(500).json({ status: 'Error', message: 'Internal Server Error' });
            } else {
              processedCount++;
              console.log(`Data updated for entryId: ${entryId}`);

              if (processedCount === entryIdsArray.length) {
                res.json({ status: 'Success', message: 'Details updated successfully.' });
              }
            }
          });
          } else {
          processedCount++;
          console.log(`Employee not found for entryId: ${entryId}`);

          if (processedCount === entryIdsArray.length) {
            res.json({ status: 'Success', message: 'Details updated successfully.' });
          }
        }
      }
    });
  });
});

//Change Shift Ota//
// Get shift data default view
app.get('/ota/getShiftdata', (req, res) => {
  let query =
    `SELECT employees_ota.*, section.section_name,item_masterr.item_description,geopos_emptype.name as role
    FROM employees_ota
    LEFT JOIN geopos_emptype ON employees_ota.roleid = geopos_emptype.id
    LEFT JOIN section ON employees_ota.section_id = section.id
    LEFT JOIN item_masterr ON employees_ota.product = item_masterr.id
    WHERE (employees_ota.roleid !='3' AND employees_ota.roleid !='5') AND employees_ota.passive_type='ACT' AND employees_ota.category_type='NBRAID'`;
    
  db.query(query, (err, result) => {
    if (err) {
      console.log(err);
      res.status(500).send('Internal Server Error');
    } else {
      res.send(result);
    }
  });
});           

// Get shift data search  view
app.get('/ota/get_shiftdata_search', (req, res) => {
  const { where } = req.query
  let query =
    `SELECT employees_ota.*, section.section_name,geopos_emptype.name as role
    FROM employees_ota
    LEFT JOIN geopos_emptype ON employees_ota.roleid = geopos_emptype.id
    LEFT JOIN section ON employees_ota.section_id = section.id
    WHERE ${where} ORDER BY employees_ota.name ASC`;
    
  db.query(query, (err, result) => {
    if (err) {
      console.log(err);
      res.status(500).send('Internal Server Error');
    } else {
      res.send(result);
    }
  });
});    

// Multiple shift data update
app.post('/ota/update_multiple_shift', (req, res) => {
  const { shift, entryIds} = req.body;
  
  const entryIdsArray = entryIds.split(',');
  const checkQuery = 'SELECT * FROM employees_ota WHERE id = ? ';
  const updateQuery =
    'UPDATE employees_ota SET shift=? WHERE id = ?';

  let processedCount = 0;

  entryIdsArray.forEach((entryId) => {
    const checkValues = [entryId];

    db.query(checkQuery, checkValues, (checkErr, checkResult) => {
      const id=checkResult[0].id
      if (checkErr) {
        console.error('Error checking employee:', checkErr);
        res.status(500).json({ status: 'Error', message: 'Internal Server Error' });
      } else {
         if (checkResult.length === 1) {
          const updateValue = [shift,id];
          db.query(updateQuery, updateValue, (updateErr, updateResult) => {
            if (updateErr) {
              console.error('Error updating data:', updateErr);
              res.status(500).json({ status: 'Error', message: 'Internal Server Error' });
            } else {
              processedCount++;
              console.log(`Data updated for entryId: ${entryId}`);

              if (processedCount === entryIdsArray.length) {
                res.json({ status: 'Success', message: 'Details updated successfully.' });
              }
            }
          });
          } else {
          processedCount++;
          console.log(`Employee not found for entryId: ${entryId}`);

          if (processedCount === entryIdsArray.length) {
            res.json({ status: 'Success', message: 'Details updated successfully.' });
          }
        }
      }
    });
  });
}); 

//Change worker type
// Get worker type  default view
app.get('/ota/getWorkerTypeDefaultData', (req, res) => {
  let query =
    `SELECT employees_ota.*, section.section_name,item_masterr.item_description,geopos_emptype.name as role
    FROM employees_ota
    LEFT JOIN geopos_emptype ON employees_ota.roleid = geopos_emptype.id
    LEFT JOIN section ON employees_ota.section_id = section.id
    LEFT JOIN item_masterr ON employees_ota.product = item_masterr.id
    WHERE (employees_ota.roleid !='3') AND employees_ota.passive_type='ACT' AND employees_ota.category_type='NBRAID'`;
    
  db.query(query, (err, result) => {
    if (err) {
      console.log(err);
      res.status(500).send('Internal Server Error');
    } else {
      res.send(result);
    }
  });
});    

//Get worker type search data
app.get('/ota/get_workerdata_search', (req, res) => {
  const { where } = req.query
  let query =
    `SELECT employees_ota.*, section.section_name,geopos_emptype.name as role
    FROM employees_ota
    LEFT JOIN geopos_emptype ON employees_ota.roleid = geopos_emptype.id
    LEFT JOIN section ON employees_ota.section_id = section.id
    WHERE ${where} ORDER BY employees_ota.name ASC`;
    
  db.query(query, (err, result) => {
    if (err) {
      console.log(err);
      res.status(500).send('Internal Server Error');
    } else {
      res.send(result);
    }
  });
});   

//Multiple update worker type data    
app.post('/ota/update_multiple_workertype', (req, res) => {
  const { wtype, entryIds} = req.body;
  
  const entryIdsArray = entryIds.split(',');
  const checkQuery = 'SELECT * FROM employees_ota WHERE id = ? ';
  const updateQuery =
    'UPDATE employees_ota SET workertype=? WHERE id = ?';

  let processedCount = 0;

  entryIdsArray.forEach((entryId) => {
    const checkValues = [entryId];

    db.query(checkQuery, checkValues, (checkErr, checkResult) => {
      const id=checkResult[0].id
      if (checkErr) {
        console.error('Error checking employee:', checkErr);
        res.status(500).json({ status: 'Error', message: 'Internal Server Error' });
      } else {
         if (checkResult.length === 1) {
          const updateValue = [wtype,id];
          db.query(updateQuery, updateValue, (updateErr, updateResult) => {
            if (updateErr) {
              console.error('Error updating data:', updateErr);
              res.status(500).json({ status: 'Error', message: 'Internal Server Error' });
            } else {
              processedCount++;
              console.log(`Data updated for entryId: ${entryId}`);

              if (processedCount === entryIdsArray.length) {
                res.json({ status: 'Success', message: 'Details updated successfully.' });
              }
            }
          });
          } else {
          processedCount++;
          console.log(`Employee not found for entryId: ${entryId}`);

          if (processedCount === entryIdsArray.length) {
            res.json({ status: 'Success', message: 'Details updated successfully.' });
          }
        }
      }
    });
  });
}); 

//Employee FDA
// Get employee fda data default view
  app.get('/ota/getEmployeeFdaData', (req, res) => {
    const today = new Date();
    const dateThreeMonthsAgo = new Date(today);
   dateThreeMonthsAgo.setMonth(today.getMonth() - 3);
   const firstDayOfCurrentMonth = new Date(today.getFullYear(), today.getMonth(), 1);
  
    const query =
      `SELECT employees_ota_attrition.*
      FROM employees_ota_attrition
      WHERE STR_TO_DATE(exitdate, "%d-%m-%Y") >= ? 
        AND STR_TO_DATE(exitdate, "%d-%m-%Y") < ?;`;
    const values = [dateThreeMonthsAgo, firstDayOfCurrentMonth];
  
    db.query(query,values, (err, result) => {
      if (err) {
        console.log(err);
        res.status(500).send('Internal Server Error');
      } else {
        res.send(result);
        console.log(result,'---------------')
      }
    });
  });        
//------------------OTA END----------------------//

//----------------------------HRM--------------------------------//

//getshift
app.get('/getShiftOptions', (req, res) => {
  const itemId = req.params.itemId;

  const query = `SELECT * FROM geopos_shift`;

  // Execute the query and handle the result
  db.query(query, (error, results) => {
    if (error) {
      console.error('Error fetching shift data:', error);
      res.status(500).json({ error: 'Failed to fetch item data' });
    } else {
      res.json(results);
    }
  });
});


//getsection
app.get('/getSectionOptions', (req, res) => {
  const itemId = req.params.itemId;

  const query = `SELECT * FROM section where status='1'`;

  // Execute the query and handle the result
  db.query(query, (error, results) => {
    if (error) {
      console.error('Error fetching shift data:', error);
      res.status(500).json({ error: 'Failed to fetch item data' });
    } else {
      res.json(results);
    }
  });
});

//getsection for operator login
app.get('/getSectionOptionsOpLogin/:userid', (req, res) => {
  const { userid } = req.params;

  console.log('userid:', userid);

  const userQuery = `
    SELECT * FROM geopos_users WHERE id = ?
  `;

  db.query(userQuery, [userid], (userError, userResults) => {
    if (userError) {
      console.error('Error fetching user:', userError);
      res.status(500).json({ error: 'Failed to fetch user' });
    } else {
      const eid = userResults[0].entryid;
      const site = userResults[0].production_type;
      const ctype = userResults[0].category_type;

      if (site === 'ota' && ctype === 'NBRAID') {
        const shiftQuery = `
          SELECT * FROM employees_ota WHERE entryid = ?
        `;

        db.query(shiftQuery, [eid], (shiftError, shiftResults) => {
          if (shiftError) {
            console.error('Error fetching shift:', shiftError);
            res.status(500).json({ error: 'Failed to fetch shift' });
          } else {
            const shift = shiftResults[0].shift;

            const sectionsQuery = `
              SELECT operator_assign.*, section.*
              FROM operator_assign
              LEFT JOIN section ON operator_assign.section = section.id
              WHERE operator_assign.name_id = ? AND operator_assign.shift = ? AND operator_assign.category_type = 'NBRAID'
              GROUP BY operator_assign.section
            `;

            db.query(sectionsQuery, [userid, shift], (sectionsError, sectionsResults) => {
              if (sectionsError) {
                console.error('Error fetching sections:', sectionsError);
                res.status(500).json({ error: 'Failed to fetch sections' });
              } else {
                res.json(sectionsResults);
              }
            });
          }
        });
      } else {
        const q = `
          SELECT * FROM geopos_employees WHERE entryid = ?`;
        db.query(q, [eid], (qError, qResults) => {
          if (qError) {
            console.error('Error fetching employees:', qError);
            res.status(500).json({ error: 'Failed to fetch employees' });
          } else {
            const shift = qResults[0].shift;

            const sectionsQuery = `
              SELECT operator_assign_ikeja.*, section.*
              FROM operator_assign_ikeja
              LEFT JOIN section ON operator_assign_ikeja.section = section.id
              WHERE operator_assign_ikeja.operator_id = ? AND operator_assign_ikeja.shift = ? AND operator_assign_ikeja.category_type = 'NBRAID'
              GROUP BY operator_assign_ikeja.section
            `;

            db.query(sectionsQuery, [userid, shift], (sectionsError, sectionsResults) => {
              if (sectionsError) {
                console.error('Error fetching sections:', sectionsError);
                res.status(500).json({ error: 'Failed to fetch sections' });
              } else {
                res.json(sectionsResults);
              }
            });
          }
        });
      }
    }
  });
});

//get product name braid
app.get('/getProductOptions', (req, res) => {
  const itemId = req.params.itemId;

  const query = `SELECT * FROM item_masterr WHERE category_id='1' or category_id='3'`;

  // Execute the query and handle the result
  db.query(query, (error, results) => {
    if (error) {
      console.error('Error fetching shift data:', error);
      res.status(500).json({ error: 'Failed to fetch item data' });
    } else {
      res.json(results);
    }
  });
});

//get product name nbraid
app.get('/getProductOptionsnbraid', (req, res) => {
  const itemId = req.params.itemId;

  const query = `SELECT * FROM item_masterr WHERE category_id='2' or category_id='3'`;

  // Execute the query and handle the result
  db.query(query, (error, results) => {
    if (error) {
      console.error('Error fetching shift data:', error);
      res.status(500).json({ error: 'Failed to fetch item data' });
    } else {
      res.json(results);
    }
  });
});

//get product name nbraid
app.get('/getProductOptionsnbraidotalist', (req, res) => {
  //const itemId = req.params.itemId;

  /* const query = `SELECT item_masterr.*, item_category.category_name
  FROM item_masterr
  LEFT JOIN item_category ON item_masterr.category_id = item_category.id`; */

  const query = `SELECT * FROM item_masterr WHERE category_id='2' or category_id='3'`;

  // Execute the query and handle the result
  db.query(query, (error, results) => {
    if (error) {
      console.error('Error fetching shift data:', error);
      res.status(500).json({ error: 'Failed to fetch item data' });
    } else {
      res.json(results);
    }
  });
});




// Define a route for fetching line options
app.get('/getLineOptions/:line', (req, res) => {
  //const { selectedProduct } = req.params;
  const line = req.params.line;

 const query = `SELECT * FROM line_master WHERE id = ? AND status = 1`;

  // Execute the query and handle the result
  db.query(query, [line], (error, results) => {
    if (error) {
      console.error('Error fetching line:', error);
      res.status(500).json({ error: 'Failed to fetch line' });
    } else {
      res.json(results);
    }
  });
});

//getline without product 
app.get('/getindividualLineOptions/:roleid/:userid', (req, res) => {
  const { roleid, userid } = req.params;
  console.log('roleid:', roleid);
  console.log('userid:', userid);

  if (roleid === '3') {
    // Implement logic for roleid 3
    const id = userid;  // Assuming user data is available in req.user
    console.log('id:', id);
    const query = `SELECT * FROM geopos_users WHERE id = ?`;
    
    // Query the database for user data
    db.query(query, [id], (error, userData) => {
      if (error) {
        console.error('Error querying the database:', error);
        res.status(500).json({ error: 'Internal Server Error' });
        return;
      }

      const site = userData[0].production_type;
      const ctype = userData[0].category_type;

      let strQuery, params;

      if (site === 'ota' && ctype === 'NBRAID') {
        strQuery = `SELECT * FROM operator_assign WHERE name_id = ? GROUP BY line`;
        params = [id];
      } else if (site === 'ikeja' && ctype === 'NBRAID') {
        strQuery = `SELECT * FROM operator_assign_ikeja WHERE operator_id = ? GROUP BY line`;
        params = [id];
      } else {
        // Handle other cases or return an appropriate response
        res.status(400).json({ error: 'Invalid site or category type' });
        return;
      }

      // Execute the query and handle the result
      db.query(strQuery, params, (error, results) => {
        if (error) {
          console.error('Error fetching line:', error);
          res.status(500).json({ error: 'Failed to fetch line' });
        } else {
          res.json(results);
        }
      });
    });
  } else if (roleid === '5') {
    // Implement logic for roleid 5
    const query = `SELECT * FROM line_master WHERE status = 1`;

    // Execute the query and handle the result
    db.query(query, (error, results) => {
      if (error) {
        console.error('Error fetching line:', error);
        res.status(500).json({ error: 'Failed to fetch line' });
      } else {
        res.json(results);
      }
    });
  } else {
    // Handle other cases or return an appropriate response
    res.status(400).json({ error: 'Invalid roleid' });
  }
});


//getline without product 
app.get('/getindividualLineOptionss', (req, res) => {
  const itemId = req.params.itemId;

  const query = `SELECT * FROM line_master WHERE status = 1`;

 // Execute the query and handle the result
 db.query(query, (error, results) => {
  if (error) {
    console.error('Error fetching line:', error);
    res.status(500).json({ error: 'Failed to fetch line' });
  } else {
    res.json(results);
  }
});
});


//get worker name 
app.get('/getWorkerOptions', (req, res) => {
  const where = "roleid != '3'";
  const query = `
    SELECT *
    FROM employees_moz
    WHERE ${where}
    GROUP BY name
  `;

// Execute the query and handle the result
  db.query(query, (error, results) => {
    if (error) {
      console.error('Error fetching shift data:', error);
      res.status(500).json({ error: 'Failed to fetch item data' });
    } else {
      res.json(results);
    }
  });
});

//get category name options
app.get('/getCategoryOptions', (req, res) => {
 
  const query = `
    SELECT *
    FROM item_category
  `;


  // Execute the query and handle the result
  db.query(query, (error, results) => {
    if (error) {
      console.error('Error fetching shift data:', error);
      res.status(500).json({ error: 'Failed to fetch item data' });
    } else {
      res.json(results);
    }
  });
});

//get operators for ikeja
app.get('/getIkejaOperatorOptions', (req, res) => {
  

  const query = `SELECT * FROM geopos_users WHERE roleid = 3 AND production_type = 'ikeja' AND banned = 0;`;

 // Execute the query and handle the result
 db.query(query, (error, results) => {
  if (error) {
    console.error('Error fetching operator:', error);
    res.status(500).json({ error: 'Failed to fetch operator' });
  } else {
    res.json(results);
  }
});
});

//get operators for ota
app.get('/getOtaOperatorOptions', (req, res) => {
  

  const query = `SELECT * FROM geopos_users WHERE roleid = 3 AND production_type = 'ota' AND banned = 0;`;

 // Execute the query and handle the result
 db.query(query, (error, results) => {
  if (error) {
    console.error('Error fetching operator:', error);
    res.status(500).json({ error: 'Failed to fetch operator' });
  } else {
    res.json(results);
  }
});
});


//-----------------------------------------------------------REPORTS ----------------------------------------------------------------//

//BRAID REPORTS

//Performance Eff individual Report

//Performance eff individual braid
app.get('/report/getEmployeesikeja', (req, res) => {
  db.query('SELECT * FROM operator_section GROUP BY empid ORDER BY emp ASC', (err, result) => {
    if (err) {
      console.error('Error executing MySQL query:', err);
      res.status(500).send('Internal Server Error');
      return;
    }
    res.send(result);
  });
});

//Get Filter Search  Performance Eff individual data 
app.post('/braid/get_performance_eff_individual', async (req, res) => {
  try {
    const employee = req.body.employees;
  const fromdate = req.body.fromdate;
  const fdParts = fromdate.split('-');
  const fd = `${fdParts[2]}-${fdParts[1]}-${fdParts[0]}`;

  const todate = req.body.todate;
  const tdParts = todate.split('-');
  const td = `${tdParts[2]}-${tdParts[1]}-${tdParts[0]}`;

  const dateObj = new Date(fromdate);
  const day = dateObj.getDate().toString().padStart(2, '0');
  const month = (dateObj.getMonth() + 1).toString().padStart(2, '0');
  const year = dateObj.getFullYear();

  const convertedDate = `${day}-${month}-${year}`;

  const dateObj1 = new Date(todate);
  const day1 = dateObj1.getDate().toString().padStart(2, '0');
  const month1 = (dateObj1.getMonth() + 1).toString().padStart(2, '0');
  const year1 = dateObj1.getFullYear();

  const convertedDate1 = `${day1}-${month1}-${year1}`;

 

    let whereConditions = [];
    whereConditions.push(`date BETWEEN '${convertedDate}' AND '${convertedDate1}'`);

    if (employee !== '') {
      whereConditions.push(`AND empid = '${employee}'`);
    }

    const whereClause = whereConditions.join(' ');

    const query = `SELECT * FROM operator_section WHERE ${whereClause}`;

    console.log(query, '---');

    const results = await new Promise((resolve, reject) => {
      db.query(query, (error, results) => {
        if (error) {
          reject(error);
        } else {
          resolve(results);
        }
      });
    });

    const operatorSections = {
      fd: convertedDate,
      ld: convertedDate1,
      items: []
    };

    ///
    ///
    let dateArr = [];
    let dayCount = 0;

    // Use Promise.all for parallel processing of multiple async operations
    await Promise.all(results.map(async (item) => {
      const ids = item.opmanual_id.split(',');

      const getOperatorData = async (ids) => {
        return new Promise((resolve, reject) => {
          db.query('SELECT geopos_operator.*, COUNT(*) as individual_complete FROM geopos_operator WHERE id IN (?) GROUP BY item, zone, machine', [ids], (err, result) => {
            if (err) {
              reject(err);
            } else {
              resolve(result);
            }
          });
        });
      };
      const operatorData = await getOperatorData(ids);

      const mj = [];
      operatorData.forEach((res1) => {
        const str = `${item.empid}-${res1.item}-${res1.zone}-${res1.machine}-${item.date}`;
        if (!mj.includes(str)) {
          mj.push(str);
        }
      });

      let tar1 = '';
      let total = 0;
      let numb = 0;
      let eff = '';
      let total_eff_count = 0;
      let total_eff = 0;

      // Use Promise.all for parallel processing of multiple async operations
      await Promise.all(operatorData.map(async (res) => {
        const target = item.target;
        const str1 = `${item.empid}-${res.item}-${res.zone}-${res.machine}-${item.date}`;

        if (mj.includes(str1)) {
          const entryidoResult = await dbQueryPromise('SELECT * FROM employees_ota WHERE entryid=?', [item.empid]);
          const entryido = entryidoResult.length > 0 ? entryidoResult[0].entryid : null;
          //
          const entryidiResult = await dbQueryPromise('SELECT * FROM geopos_employees WHERE entryid=?', [item.empid]);
          const entryidi = entryidiResult.length > 0 ? entryidiResult[0].entryid : null;
          
          const sectionNameResult = await dbQueryPromise('SELECT section_name FROM section WHERE id=?', [item.section_id]);
          const sectionName = sectionNameResult[0].section_name;

          const itemNameResult = await dbQueryPromise('SELECT item_description FROM item_masterr WHERE id=?', [res.item]);
          const itemDescription = itemNameResult[0].item_description;
          
          const querysResult = await dbQueryPromise('SELECT * FROM employees_ota WHERE entryid=?', [item.empid]);
          const num = querysResult.length;
          let site;
          let diff;
          let regg;
          // ... (similar changes for other async operations)

          if (num > 0) {
            const entryidoResult = await dbQueryPromise('SELECT * FROM employees_ota WHERE entryid=?', [item.empid]);
            const entryido = entryidoResult.length > 0 ? entryidoResult[0].entryid : null;

            regg = new Date(entryidoResult[0].joindate || null);
            const day = regg.getDate().toString().padStart(2, '0');
            const month = (regg.getMonth() + 1).toString().padStart(2, '0');
            const year = regg.getFullYear();

            regg = `${day}-${month}-${year}`;

            const datek1 = item.date;

            const reggParts = regg.split('-').map(Number);
            const datek1Parts = datek1.split('-').map(Number);

            const earlier = new Date(reggParts[2], reggParts[1] - 1, reggParts[0]);
            const later = new Date(datek1Parts[2], datek1Parts[1] - 1, datek1Parts[0]);

            if (!isNaN(earlier) && !isNaN(later)) {
              const timeDiff = Math.abs(later - earlier);
              diff = Math.ceil(timeDiff / (1000 * 60 * 60 * 24));
            } else {
              console.log('Date parsing failed for regg or datek1');
            }
            // ... (similar changes for OTA scenario)
            site = 'OTA';
          } else {
            const entryidiResult = await dbQueryPromise('SELECT * FROM geopos_employees WHERE entryid=?', [item.empid]);
            const entryidi = entryidiResult.length > 0 ? entryidiResult[0].entryid : null;

            regg = new Date(entryidiResult[0].joindate);
            const day = regg.getDate().toString().padStart(2, '0');
            const month = (regg.getMonth() + 1).toString().padStart(2, '0');
            const year = regg.getFullYear();

            regg = `${day}-${month}-${year}`;

            const datek1 = item.date;

            const reggParts = regg.split('-').map(Number);
            const datek1Parts = datek1.split('-').map(Number);

            const earlier = new Date(reggParts[2], reggParts[1] - 1, reggParts[0]);
            const later = new Date(datek1Parts[2], datek1Parts[1] - 1, datek1Parts[0]);

            if (!isNaN(earlier) && !isNaN(later)) {
              const timeDiff = Math.abs(later - earlier);
              diff = Math.ceil(timeDiff / (1000 * 60 * 60 * 24));
            } else {
              console.log('Date parsing failed for regg or datek1');
            }
            // ... (similar changes for IKEJA scenario)
            site = 'IKEJA';

            if (convertedDate !== '' && convertedDate1 !== '') {
              const rows = await dbQueryPromise('SELECT * FROM operator_section WHERE date = ? AND empid = ?', [item.date, item.empid]);

              if (Array.isArray(rows) && rows.length > 0) {
                for (const rs of rows) {
                  const ra = rs.opmanual_id.split(',');
                  const comp1 = rs.complete.split(',');

                  const results = await dbQueryPromise('SELECT geopos_operator.*, COUNT(*) AS datewise_individual_complete FROM geopos_operator WHERE id IN (?) AND item = ? AND zone = ? AND machine = ?', [ra, res.item, res.zone, res.machine]);

                  if (Array.isArray(results) && results.length > 0) {
                    numb = results[0].datewise_individual_complete;

                    const results2 = await dbQueryPromise('SELECT geopos_operator.* FROM geopos_operator WHERE id IN (?) AND item = ? AND zone = ? AND machine = ?', [ra, res.item, res.zone, res.machine]);

                    for (const rs2 of results2) {
                      const numericValue = parseFloat(rs2.id.toString().replace(/\s/g, ''));

                      if (!isNaN(numericValue)) {
                        const index = ra.findIndex(id => id === numericValue.toString());

                        if (index !== -1) {
                          total += +comp1[index];
                        }
                      }
                    }


                    tar1 = target * numb;
                    const eff1 = (total / tar1) * 100;
                    eff = eff1.toFixed(2);
                    total_eff +=eff;
                    total_eff_count++;
                    // Assuming $itt is an array in PHP, you can create a similar array in JavaScript
                      const datee = item.date;
                    
                      if (!dateArr.includes(datee)) {
                        dateArr.push(datee);
                        dayCount++;
                      }
                     

                      
                    let tteff=total_eff/total_eff_count;
                    let ttefff=tteff.toFixed(2);
                                  
                    // Now dateArr contains unique dates, and dayCount has the count of unique dates
                   
                    
                    const data = {
                      emp: item.emp,
                      empid: item.empid,
                      doj: regg,
                      total_days: `${diff} Days`,
                      shift: res.shift,
                      section: sectionName,
                      item_name: itemDescription,
                      zone: res.zone,
                      machine: res.machine,
                      tar1: tar1,
                      total: total,
                      eff: eff,
                      dt: item.date,
                      site: site,
                      fd: convertedDate,
                      ld: convertedDate1,
                      daycount:dayCount,
                      avgeff:ttefff,
                    };

                    operatorSections.items.push(data);
                    console.log(operatorSections);
                  }
                }
              }
            }
          }
        }
      }));

    }));

    res.json(operatorSections);
  } catch (error) {
    console.error('Error executing database query:', error);
    res.status(500).json({ error: 'Internal Server Error' });
  }
});

// Define a helper function for database queries using promises
const dbQueryPromise = (sql, params) => {
  return new Promise((resolve, reject) => {
    db.query(sql, params, (error, results) => {
      if (error) {
        reject(error);
      } else {
        resolve(results);
      }
    });
  });
};

//PLAN  VS ACTUAL Report

//Plan Vs Actual Report default search
app.get('/braid/getPlanVsactualReportDefault', (req, res) => {
  const timeZone = 'Africa/Lagos';

  // Get the current date in the specified format (d-m-Y)
  const options = {
    day: '2-digit',
    month: '2-digit',
    year: 'numeric',
  };

  const date = new Date().toLocaleDateString('en-NG', options).replace(/\//g, '-');
 
  const targetPlan = 0;
  const category = 1;
  const itemCodeId = 0;
  const query = `
  SELECT *, target_plan as tot
  FROM target_plan_ota
  WHERE date = ? AND target_plan > ? AND category = ? AND item_code_id != ?
`;
console.log(query)
  db.query(query, [date, targetPlan, category, itemCodeId], (err, results) => {
    if (err) {
      console.error('Error executing the SQL query: ' + err.stack);
      return res.status(500).json({ error: 'Internal Server Error' });
    }
  
    const data = [];

    // Counter to keep track of completed queries
    let completedQueries = 0;
    if (results.length > 0) {
    
    // Loop through the results and process each item
    for (const item of results) {
      const prdd = item.item_code_id;
    
      // Execute the second SQL query
      const itemCodeQuery = `
        SELECT * FROM item_code WHERE id = ?
      `;

      db.query(itemCodeQuery, [prdd], (err, rows) => {
        if (err) {
          console.error('Error executing the itemCodeQuery: ' + err.stack);
          return res.status(500).json({ error: 'Internal Server Error' });
        }

        if (rows.length > 0) {
         
          const pro = rows[0].product_des;
          const col = rows[0].color_id;
          const prdid = rows[0].product_id;
console.log(pro,col,prdid,'===========')
          // Execute the third SQL query
          const where2 = `date='${date}' and color_id='${col}'`;
          const geoposOperatorQuery = `
            SELECT SUM(fg_output) as tar
            FROM geopos_operator
            WHERE ${where2}
            GROUP BY item, date
          `;
        console.log(geoposOperatorQuery,'====')
          db.query(geoposOperatorQuery, (err, rows) => {
            if (err) {
              console.error('Error executing the geoposOperatorQuery: ' + err.stack);
              return res.status(500).json({ error: 'Internal Server Error' });
            }

            if (rows.length > 0) {
              const sump = rows[0].tar;

              // Here, you can use the prdd, pro, col, prdid, and sump variables as needed.
              // Push the data for this item into the data array.
              data.push({
                product: pro,
                total: item.tot,
                sump: sump,
              });

              // Increment the completed queries counter
              completedQueries++;

              // Check if all queries have completed before sending the JSON response
              if (completedQueries === results.length) {
                // Check if data is empty, and send a blank response if so
                if (data.length === 0) {
                  res.json({});
            
                } else {
                  res.json(data);
                 
                }
              }else{
                console.log('00000000000000')
              }
            }
          });
        }else{
          console.log('pppppppppppppppppppp')
        }
      });
    }
  }else{
    res.json({});
  }
  });
});

//Plan Vs Actual Report date wise search 
app.post('/braid/getPlanVsactualReportSearch', (req, res) => {
  const timeZone = 'Africa/Lagos';

  // Get the current date in the specified format (d-m-Y)
  const options = {
    day: '2-digit',
    month: '2-digit',
    year: 'numeric',
  };

  const date = new Date().toLocaleDateString('en-NG', options).replace(/\//g, '-');

  

const fromdate = req.body.fromdate;
const fdParts = fromdate.split('-');
const fd = `${fdParts[2]}-${fdParts[1]}-${fdParts[0]}`;

const todate = req.body.todate;
const tdParts = todate.split('-');
const td = `${tdParts[2]}-${tdParts[1]}-${tdParts[0]}`;


const dateObj = new Date(fromdate);
const day = dateObj.getDate().toString().padStart(2, '0');
const month = (dateObj.getMonth() + 1).toString().padStart(2, '0');
const year = dateObj.getFullYear();

const convertedDate = `${day}-${month}-${year}`;

const dateObj1 = new Date(todate);
const day1 = dateObj1.getDate().toString().padStart(2, '0');
const month1 = (dateObj1.getMonth() + 1).toString().padStart(2, '0');
const year1 = dateObj1.getFullYear();

const convertedDate1 = `${day1}-${month1}-${year1}`;
//console.log('Converted:', convertedDate);
//console.log('Converted2:', convertedDate1);


const fd2 = Math.floor(new Date(fromdate).getTime() / 1000);
const td1 = Math.floor(new Date(todate).getTime() / 1000);
const fd1 = Math.floor(new Date(fd2 * 1000).setDate(new Date(fd2 * 1000).getDate() - 1) / 1000);

var newfd = fd2;
var newtd = td1;

  // Construct the where clause for your SQL query
  const where = `(timestamp BETWEEN ${newfd} AND ${newtd} AND target_plan > 0 AND category = '1' AND item_code_id != '0')`;

  const query = `
    SELECT *, SUM(target_plan) as tot
    FROM target_plan_ota
    WHERE ${where}
    GROUP BY item_code_id
  `;

  db.query(query, (err, results) => {
    if (err) {
      console.error('Error executing the SQL query: ' + err.stack);
      return res.status(500).json({ error: 'Internal Server Error' });
    }

    const data = [];
  
    // Counter to keep track of completed queries
    let completedQueries = 0;

    // Loop through the results and process each item
    for (const item of results) {
      const prdd = item.item_code_id;
      
      // Execute the second SQL query
      const itemCodeQuery = `
        SELECT * FROM item_code WHERE id = ?
      `;

      db.query(itemCodeQuery, [prdd], (err, rows) => {
        if (err) {
          console.error('Error executing the itemCodeQuery: ' + err.stack);
          return res.status(500).json({ error: 'Internal Server Error' });
        }

        if (rows.length > 0) {
          const pro = rows[0].product_des;
          const col = rows[0].color_id;
          const prdid = rows[0].product_id;
         
          // Execute the third SQL query
          //const where2 = `date='${date}' and item='${prdid}' and color_id='${col}'`;
          const geoposOperatorQuery = `SELECT SUM(a.tar) as res
          FROM (SELECT SUM(fg_output) as tar
                FROM geopos_operator
                WHERE timestamp BETWEEN ? AND ?
                AND item = ?
                AND color_id = ?
                GROUP BY item, timestamp) a`;
          console.log(prdid,'')
          db.query(geoposOperatorQuery,[newfd,newtd,prdid,col], (err, rows) => {
            if (err) {
              console.error('Error executing the geoposOperatorQuery: ' + err.stack);
              return res.status(500).json({ error: 'Internal Server Error' });
            }
          console.log(geoposOperatorQuery)
            if (rows.length > 0) {
              const sump = rows[0].res;
              // Here, you can use the prdd, pro, col, prdid, and sump variables as needed.
              // Push the data for this item into the data array.
              data.push({
                product: pro,
                total: item.tot,
                sump: sump,
                fdate: convertedDate,
                tdate: convertedDate1,
              });

              // Increment the completed queries counter
              completedQueries++;
             
              // Check if all queries have completed before sending the JSON response
              if (completedQueries === results.length) {
                // Check if data is empty, and send a blank response if so
                if (data.length === 0) {
                  res.json({});
                } else {
                  res.json(data);
                }
              }
            }else{
             // console.log('no rows')
            }
          });
        }
      });
      
    }
  });
});


//MTD AVG PPP REPORT

//get Mtd ppp average category options
app.get('/braid/getCategoryOptions', (req, res) => {
  const query = `
    SELECT *
    FROM item_category WHERE status='1'
  `;
  // Execute the query and handle the result
  db.query(query, (error, results) => {
    if (error) {
      console.error('Error fetching shift data:', error);
      res.status(500).json({ error: 'Failed to fetch item data' });
    } else {
      res.json(results);
    }
  });
});

//get Mtd ppp average default data
app.get('/braid/getMtdPppAverageDefaultData', (req, res) => {
  const datem = new Date().toLocaleDateString('en-US', { month: 'numeric', year: 'numeric' }).replace(/\//g, '-');
  const date = new Date().toLocaleDateString('en-GB', { timeZone: 'Africa/Lagos' });
  const parts = date.split('/');
  const day = parts[0].padStart(2, '0');
  const month = parts[1].padStart(2, '0');
  const year = parts[2];
  const currentMonth = `${month}-${year}`;
  const currentDate = `${day}-${month}-${year}`;
  console.log('currentMonth:',currentMonth);
  const array = [`geopos_operator.month = '${currentMonth}'`, "geopos_operator.item IS NOT NULL"];

  const query = `
    SELECT
      geopos_operator.*,
      item_masterr.item_description,
      item_category.category_name,
      COUNT(geopos_operator.id) AS tot
    FROM
      geopos_operator
    LEFT JOIN
      item_masterr ON item_masterr.id = geopos_operator.item
    LEFT JOIN
      item_category ON item_masterr.category_id = item_category.id
    WHERE
      ${array.join(' AND ')}
    GROUP BY
      geopos_operator.item, geopos_operator.month
  `;
  //console.log(datem,query)
  db.query(query, (err, results) => {
    if (err) {
      console.error('Query execution failed:', err);
      res.status(500).json({ error: 'Internal Server Error' });
      return;
    }

    const data = []; // Initialize an array to store the result objects
    // Loop through the results and calculate averages for each result
    if(results.length > 0 ){
  
    results.forEach((result) => {
      const kk = result.item;
      const where = `item='${kk}' AND month='${currentMonth}'`;

      const query2 = `SELECT max(iemp_count) AS it, max(demp_count) AS at 
               FROM geopos_operator 
               WHERE ${where} 
               GROUP BY zone, machine, item, date`;

               console.log('query2:',query2);
      //const query2 = `SELECT COUNT(*) AS tot FROM geopos_operator WHERE month = '${currentMonth}' AND item = '${kk}' GROUP BY item`;
      db.query(query2, (err2, results2) => {
        if (err2) {
          console.error('Query 2 execution failed:', err2);
          res.status(500).json({ error: 'Internal Server Error' });
          return;
        }

       // const workerk = results2[0] ? results2[0].tot : 0;

        let workerk = 0;
        results2.forEach((row) => {
          workerk +=+ row.at + +row.it;
        });

        //const query3 = `SELECT SUM(fg_output) AS tar FROM geopos_operator WHERE month = '${currentMonth}' AND item = '${kk}' GROUP BY item`;
        const query3 = `SELECT * FROM geopos_operator 
        WHERE ${where} 
        GROUP BY item, date, zone, machine, hr_start`;

        console.log('query3:',query3);
       
        db.query(query3, (err3, results3) => {
          if (err3) {
            console.error('Query 3 execution failed:', err3);
            res.status(500).json({ error: 'Internal Server Error' });
            return;
          }

          let sum = 0;
          results3.forEach((ws) => {
            sum +=+ ws.fg_output;
          });

          //const sum = results3[0] ? results3[0].tar : 0;

          const rew = workerk > 0 ? sum / workerk : 0;
          console.log(rew.toFixed(2)); // Output the result rounded to 2 decimal places
          //const rew = sum / workerk;
          //const responseValue = rew === Infinity ? 0 : rew;
          const responseValue = rew;

          // Create an object for each result set and push it to the data array
          data.push({
            category: result.category_name,
            item: result.item_description,
            avg: responseValue.toFixed(2),
          });

          // Check if we have processed all results before sending the response
          if (data.length === results.length) {
            res.json(data); // Send the data array as a JSON response
          }
        });
      });
    });
  }else{
    res.json(''); 
  }
  });
});

//get Mtd ppp average search data
app.post('/braid/getMtdPppAverageSearch', (req, res) => {
  const start_year = req.body.start_year;
  const end_year = req.body.end_year;
  const start_month = req.body.start_month;
  const end_month = req.body.end_month;

  const s_year = start_month + '-' + start_year;
  const e_year = end_month + '-' + end_year;
  const cat = req.body.category;
  console.log(s_year + '' + e_year);

  const year_s = `${start_year}-${start_month}`;
  const year_e = `${end_year}-${end_month}`;

  const year_ss = `${start_month}-${start_year}`;
  const year_ee = `${end_month}-${end_year}`;

  const startDate = new Date(year_s);
  const endDate = new Date(year_e);
  const monthsArray = [];
  const monthsArray1 = [];
  const timeZone = 'Africa/Lagos';

  const formattedStartDate = startDate.toLocaleDateString('en-US', { year: 'numeric', month: 'long' });
  const formattedEndDate = endDate.toLocaleDateString('en-US', { year: 'numeric', month: 'long' });

  console.log('Start Date:', formattedStartDate);
  console.log('End Date:', formattedEndDate);

  const monthDifference = (endDate.getFullYear() - startDate.getFullYear()) * 12 + (endDate.getMonth() - startDate.getMonth()) + 1;

  for (let i = 0; i < monthDifference; i++) {
   
    const currentMonth = new Date(startDate.getFullYear(), startDate.getMonth() + i, 1);
    const monthName = currentMonth.toLocaleDateString('en-US', { month: 'long' });
    const mths = currentMonth.toLocaleDateString('en-US', { month: '2-digit', year: 'numeric' }).replace(/\//g, '-');

    monthsArray.push(mths);
    monthsArray1.push(monthName);
  }

  let where = `(geopos_operator.month between '${s_year}' and '${e_year}' and geopos_operator.item !='')`;

  if (cat !== '') {
    where += ` AND item_masterr.category_id='${cat}'`;
  }

  const query = `
    SELECT geopos_operator.*, item_masterr.item_description, item_category.category_name,
           COUNT(geopos_operator.id) as tot
    FROM geopos_operator
    LEFT JOIN item_masterr ON item_masterr.id = geopos_operator.item
    LEFT JOIN item_category ON item_masterr.category_id = item_category.id
    WHERE ${where}
    GROUP BY geopos_operator.item
  `;

  db.query(query, async (err, results) => {
    if (err) {
      console.error("Error:", err);
      return res.status(500).json({ error: "An error occurred" });
    }
  
    const data = { // Initialize an object to store the response data
      fdt: year_s,
      edt: year_e,
      fdtt: year_ss,
      edtt: year_ee,
      items: [], // Initialize an array to store the result objects
    };
  
    // Loop through the results and calculate averages for each result
  
    for (const result of results) {
      const monthlyAverages = [];
    
      // Loop through the monthsArray to calculate averages
      await Promise.all(monthsArray.map(async (dt1) => {
        const mths = dt1;
        console.log(mths);
    
        const kk = result.item;
        const where = `item='${kk}' AND month='${mths}'`;
    
        const query = `SELECT max(iemp_count) AS it, max(demp_count) AS at 
                       FROM geopos_operator 
                       WHERE ${where} 
                       GROUP BY zone, machine, item, date`;
    
        try {
          const queryResults = await new Promise((resolve, reject) => {
            db.query(query, (error, results) => {
              if (error) {
                console.error('Error executing query: ' + error.stack);
                reject(error);
                return;
              }
              resolve(results);
            });
          });
    
          let workerk = 0;
          queryResults.forEach((row) => {
            workerk += +row.at + +row.it;
          });
    
          const query2 = `SELECT * FROM geopos_operator 
                          WHERE ${where} 
                          GROUP BY item, date, zone, machine, hr_start`;
    
          const secondQueryResults = await new Promise((resolve, reject) => {
            db.query(query2, (error, results) => {
              if (error) {
                console.error('Error executing second query: ' + error.stack);
                reject(error);
                return;
              }
              resolve(results);
            });
          });
    
          let sum = 0;
          secondQueryResults.forEach((ws) => {
            sum += +ws.fg_output;
          });
    
          const rew = workerk > 0 ? sum / workerk : 0;
          console.log(rew.toFixed(2));
          const rew1 = rew.toFixed(2);
          monthlyAverages.push(rew1);
        } catch (error) {
          console.error('Error:', error);
        }
      }));
    
      data.items.push({
        category: result.category_name,
        item: result.item_description,
        monthlyAverages: monthlyAverages,
        months: monthsArray1,
      });
    }
    
  
    res.json({ data });
  });
});

//EmployeeTimesheet Report 

//Employee Timesheet Reports Default data
app.get('/braid/getEmployeeTimesheetDefaultData', async (req, res) => {
  try {
    /* const tDate = new Date().toLocaleDateString('en-US', {
      day: '2-digit',
      month: '2-digit',
      year: 'numeric',
    }).replace(/\//g, '-'); */

    const date = new Date().toLocaleDateString('en-GB', { timeZone: 'Africa/Lagos' });
    const parts = date.split('/');
    const formattedDay = parts[0].padStart(2, '0');
    const formattedMonth = parts[1].padStart(2, '0');
    const year = parts[2];
    const tDate = `${formattedDay}-${formattedMonth}-${year}`;

    console.log(tDate);

    const results1 = await promisifyQuery7(db, 'SELECT * FROM operator_section WHERE date = ?', [tDate]);
    const resultData = [];

    for (const item of results1) {
      const ids = item.opmanual_id.split(',');

      const results2 = await promisifyQuery7(db, `
        SELECT geopos_operator.*, COUNT(id) AS individual_complete, GROUP_CONCAT(id) AS idk
        FROM geopos_operator
        WHERE id IN (?)
        GROUP BY item, zone, machine
      `, [ids]);

      for (const res2 of results2) {
        const target = item.target;
        const comp = item.complete.split(',');
        const idg = res2.idk ? res2.idk.split(',') : [];
        const zone = res2.zone;
        const machine = res2.machine;
        const shift = res2.shift;

        let total = 0;
        let numb = 0;
        let complete = '';

        for (const vall of idg) {
          const index = ids.indexOf(vall);
          total += parseInt(comp[index]);
          complete += comp[index] + ',';
          numb = res2.individual_complete;
        }

        const tar1 = target * numb;
        const eff1 = (total / tar1) * 100;
        const eff = eff1.toFixed(2);

        const entry = item.empid;

        const entryidoResult = await promisifyQuery7(db, "SELECT entryid FROM employees_ota WHERE entryid = ?", [item.empid]);
        const entryido = entryidoResult[0]?.entryid;

        const entryidiResult = await promisifyQuery7(db, "SELECT entryid FROM geopos_employees WHERE entryid = ?", [item.empid]);
        const entryidi = entryidiResult[0]?.entryid;

        const rows = await promisifyQuery7(db, 'SELECT * FROM employees_ota WHERE entryid = ?', [item.empid]);
        const num = rows.length;

        let regg, site, diff;

        if (num > 0) {
          const query1 = await promisifyQuery7(db, 'SELECT * FROM employees_ota WHERE entryid = ?', [entryido]);
          regg = query1 ? new Date(query1[0].joindate).toLocaleDateString('en-US', { day: '2-digit', month: '2-digit', year: 'numeric' }).replace(/\//g, '-') : null;
          site = query1 ? query1[0].new_staff : null;
          const datek1 = new Date().toLocaleDateString('en-US', { day: '2-digit', month: '2-digit', year: 'numeric' }).replace(/\//g, '-');
          const earlier = new Date(query1[0].joindate);
          const later = new Date(datek1);
          diff = Math.floor((later - earlier) / (1000 * 60 * 60 * 24));
        } else {
          const rows5 = await promisifyQuery7(db, 'SELECT * FROM geopos_employees WHERE entryid = ?', [entryidi]);

          if (rows5.length > 0) {
            const query2 = await promisifyQuery7(db, 'SELECT * FROM geopos_employees WHERE entryid = ?', [entryidi]);
            regg = query2 ? new Date(query2[0].joindate).toLocaleDateString('en-US', { day: '2-digit', month: '2-digit', year: 'numeric' }).replace(/\//g, '-') : null;
            site = 'IKEJA';
            const datek1 = new Date().toLocaleDateString('en-US', { day: '2-digit', month: '2-digit', year: 'numeric' }).replace(/\//g, '-');
            const earlier = new Date(query2[0].joindate);
            const later = new Date(datek1);
            diff = Math.floor((later - earlier) / (1000 * 60 * 60 * 24));
          }
        }

        const [sectionResult] = await promisifyQuery7(db, "SELECT section_name FROM section WHERE id = ?", [item.section_id]);
        const section_name = sectionResult?.section_name;

        const [itemResult] = await promisifyQuery7(db, "SELECT item_description FROM item_masterr WHERE id = ?", [res2.item]);
        const item_description = itemResult?.item_description;

        const dataObject = {
          emp: item.emp,
          empid: item.empid,
          site,
          regg,
          diff,
          item_description,
          section_name,
          zone,
          machine,
          shift,
          complete,
          tar1,
          total,
          eff,
          tDate,
        };

        resultData.push(dataObject);

        console.log('Result:', dataObject);
      }
    }

    console.log('Result Data:', resultData);
    res.json({ message: 'Successfully processed data', resultData });
  } catch (error) {
    console.error('Error executing SQL queries:', error);
    res.status(500).json({ error: 'Database error' });
  }
});

function promisifyQuery7(db, sql, params) {
  return new Promise((resolve, reject) => {
    db.query(sql, params, (err, results) => {
      if (err) {
        reject(err);
      } else {
        resolve(results);
      }
    });
  });
}

//Employee Timesheet Braid Reports search data
app.post('/braid/getEmployeeTimesheetDataNew', async (req, res) => {
  try {
    //const fdate = req.body.fromdate;
    const fromdate = req.body.fromdate ? req.body.fromdate.replace(/\//g, '-') : '';
    
let fdate = ''; // Initialize fdate as an empty string

if (fromdate && !isNaN(Date.parse(fromdate))) {
  // If fromdate is defined and can be successfully parsed as a date
  const dateObj = new Date(fromdate);
  const day = dateObj.getDate().toString().padStart(2, '0');
  const month = (dateObj.getMonth() + 1).toString().padStart(2, '0');
  const year = dateObj.getFullYear();
  fdate = `${day}-${month}-${year}`;
}

//console.log(fdate + '--------------');

  if (fdate !== '') {
    // Clear tables
    await promisifyQuery6(db, 'TRUNCATE TABLE geopos_operator_timesheet');
    await promisifyQuery6(db, 'TRUNCATE TABLE operator_section_timesheet');
  }


    // Copy data from 'operator_section' to 'operator_section_timesheet'
    await promisifyQuery6(db, 'INSERT INTO operator_section_timesheet SELECT * FROM operator_section WHERE date = ?', [fdate]);

    // Copy data from 'geopos_operator' to 'geopos_operator_timesheet'
    await promisifyQuery6(db, 'INSERT INTO geopos_operator_timesheet SELECT * FROM geopos_operator WHERE date = ?', [fdate]);

    // Get the last recorded date from 'operator_section_timesheet'
    const [dateRow] = await promisifyQuery6(db, 'SELECT MAX(date) as date FROM operator_section_timesheet');
    const lastRecordedDate = dateRow.date;

    const results1 = await promisifyQuery6(db, 'SELECT * FROM operator_section WHERE date = ?', [lastRecordedDate]);
    const resultData = [];
   
    let date;
    if (typeof fdate !== 'undefined' && fdate !== '') {
      date = fdate;
    }else{
      date = lastRecordedDate;
    }
    for (const item of results1) {
      const ids = item.opmanual_id.split(',');

      const results2 = await promisifyQuery6(db, `
        SELECT geopos_operator.*, COUNT(id) AS individual_complete, GROUP_CONCAT(id) AS idk
        FROM geopos_operator
        WHERE id IN (?)
        GROUP BY item, zone, machine
      `, [ids]);

      for (const res2 of results2) {
        const target = item.target;
        const comp = item.complete.split(',');
        const idg = res2.idk ? res2.idk.split(',') : [];
        const zone = res2.zone;
        const machine = res2.machine;
        const shift = res2.shift;
        let total = 0;
        let numb = 0;
        let complete = '';

        for (const vall of idg) {
          const index = ids.indexOf(vall);
          total += parseInt(comp[index]);
          complete += comp[index] + ',';
          numb = res2.individual_complete;
        }

        const tar1 = target * numb;
        const eff1 = (total / tar1) * 100;
        const eff = eff1.toFixed(2);

        const entry = item.empid;

        const entryidoResult = await promisifyQuery6(db, "SELECT entryid FROM employees_ota WHERE entryid = ?", [item.empid]);
        const entryido = entryidoResult[0]?.entryid;

        const entryidiResult = await promisifyQuery6(db, "SELECT entryid FROM geopos_employees WHERE entryid = ?", [item.empid]);
        const entryidi = entryidiResult[0]?.entryid;

        const rows = await promisifyQuery6(db, 'SELECT * FROM employees_ota WHERE entryid = ?', [item.empid]);
        const num = rows.length;

        let regg, site, diff;

        if (num > 0) {
          const query1 = await promisifyQuery6(db, 'SELECT * FROM employees_ota WHERE entryid = ?', [entryido]);
          regg = query1 ? new Date(query1[0].joindate).toLocaleDateString('en-US', { day: '2-digit', month: '2-digit', year: 'numeric' }).replace(/\//g, '-') : null;
          site = query1 ? query1[0].new_staff : null;
          const datek1 = new Date().toLocaleDateString('en-US', { day: '2-digit', month: '2-digit', year: 'numeric' }).replace(/\//g, '-');
          const earlier = new Date(query1[0].joindate);
          const later = new Date(datek1);
          diff = Math.floor((later - earlier) / (1000 * 60 * 60 * 24)) + 1;
        } else {
          const rows5 = await promisifyQuery6(db, 'SELECT * FROM geopos_employees WHERE entryid = ?', [entryidi]);

          if (rows5.length > 0) {
            const query2 = await promisifyQuery6(db, 'SELECT * FROM geopos_employees WHERE entryid = ?', [entryidi]);
            regg = query2 ? new Date(query2[0].joindate).toLocaleDateString('en-US', { day: '2-digit', month: '2-digit', year: 'numeric' }).replace(/\//g, '-') : null;
            site = 'IKEJA';
            const datek1 = new Date().toLocaleDateString('en-US', { day: '2-digit', month: '2-digit', year: 'numeric' }).replace(/\//g, '-');
            const earlier = new Date(query2[0].joindate);
            const later = new Date(datek1);
            diff = Math.floor((later - earlier) / (1000 * 60 * 60 * 24)) + 1;
          }
        }

        const [sectionResult] = await promisifyQuery6(db, "SELECT section_name FROM section WHERE id = ?", [item.section_id]);
        const section_name = sectionResult?.section_name;

        const [itemResult] = await promisifyQuery6(db, "SELECT item_description FROM item_masterr WHERE id = ?", [res2.item]);
        const item_description = itemResult?.item_description;

        const dataObject = {
          emp: item.emp,
          empid: item.empid,
          site,
          regg,
          diff,
          item_description,
          section_name,
          zone,
          machine,
          shift,
          complete,
          tar1,
          total,
          eff,
          date,
        };

        resultData.push(dataObject);

        console.log('Result:', dataObject);
      }
    }

    console.log('Result Data:', resultData);
    res.json({ message: 'Successfully processed data', resultData });
  } catch (error) {
    console.error('Error executing SQL queries:', error);
    res.status(500).json({ error: 'Database error' });
  }
});

function promisifyQuery6(db, sql, params) {
  return new Promise((resolve, reject) => {
    db.query(sql, params, (err, results) => {
      if (err) {
        reject(err);
      } else {
        resolve(results);
      }
    });
  });
}


//Performance Efficiency Report

//Get performance eff data default wise
app.get('/braid/get_performance_Eff_report_braid_default', async (req, res) => {
  try {
    const date = new Date().toLocaleDateString('en-GB', { timeZone: 'Africa/Lagos' });
    const parts = date.split('/');
    const formattedDay = parts[0].padStart(2, '0');
    const formattedMonth = parts[1].padStart(2, '0');
    const year = parts[2];
    const date1 = `${formattedDay}-${formattedMonth}-${year}`;
    const tDate = new Date().toLocaleDateString('en-US', {
      day: '2-digit',
      month: '2-digit',
      year: 'numeric',
    }).replace(/\//g, '-');

    const results1 = await promisifyQuery5(db, 'SELECT * FROM operator_section WHERE date = ?', [date1]);
    const resultData = [];
    const tpr = []; 
    for (const item of results1) {
      const ids = item.opmanual_id.split(',');

      const results2 = await promisifyQuery5(db, `
        SELECT geopos_operator.*, COUNT(id) AS individual_complete, GROUP_CONCAT(id) AS idk
        FROM geopos_operator
        WHERE id IN (?)
        GROUP BY item, zone, machine
      `, [ids]);
      const mj = [];

      results2.forEach((res2) => {
        const str = `${item.empid}-${res2.item}-${res2.zone}-${res2.machine}`;
        if (!tpr.includes(str)) {
          tpr.push(str);
          mj.push(str);
        }
      });
      for (const res2 of results2) {
        const target = item.target;
        const zone = res2.zone;
        const machine = res2.machine;
        const shift = res2.shift;
        const str1 = `${item.empid}-${res2.item}-${res2.zone}-${res2.machine}`;
        if (mj.includes(str1)) {
     

        const entryidoResult = await promisifyQuery5(db, "SELECT entryid FROM employees_ota WHERE entryid = ?", [item.empid]);
        const entryido = entryidoResult[0]?.entryid;

        const entryidiResult = await promisifyQuery5(db, "SELECT entryid FROM geopos_employees WHERE entryid = ?", [item.empid]);
        const entryidi = entryidiResult[0]?.entryid;

        const rows = await promisifyQuery5(db, 'SELECT * FROM employees_ota WHERE entryid = ?', [item.empid]);
        const num = rows.length;

        let regg, site, diff;

        if (num > 0) {
          const query1 = await promisifyQuery5(db, 'SELECT * FROM employees_ota WHERE entryid = ?', [entryido]);
          regg = query1 ? new Date(query1[0].joindate).toLocaleDateString('en-US', { day: '2-digit', month: '2-digit', year: 'numeric' }).replace(/\//g, '-') : null;
          site = query1 ? query1[0].new_staff : null;
          const datek1 = new Date().toLocaleDateString('en-US', { day: '2-digit', month: '2-digit', year: 'numeric' }).replace(/\//g, '-');
          const earlier = new Date(query1[0].joindate);
          const later = new Date(datek1);
          diff = Math.floor((later - earlier) / (1000 * 60 * 60 * 24))+1;
        } else {
          const rows5 = await promisifyQuery5(db, 'SELECT * FROM geopos_employees WHERE entryid = ?', [entryidi]);

          if (rows5.length > 0) {
            const query2 = await promisifyQuery5(db, 'SELECT * FROM geopos_employees WHERE entryid = ?', [entryidi]);
            regg = query2 ? new Date(query2[0].joindate).toLocaleDateString('en-US', { day: '2-digit', month: '2-digit', year: 'numeric' }).replace(/\//g, '-') : null;
            site = 'IKEJA';
            const datek1 = new Date().toLocaleDateString('en-US', { day: '2-digit', month: '2-digit', year: 'numeric' }).replace(/\//g, '-');
            const earlier = new Date(query2[0].joindate);
            const later = new Date(datek1);
            diff = Math.floor((later - earlier) / (1000 * 60 * 60 * 24))+1;
          }
        }

        const [sectionResult] = await promisifyQuery5(db, "SELECT section_name FROM section WHERE id = ?", [item.section_id]);
        const section_name = sectionResult?.section_name;

        const [itemResult] = await promisifyQuery5(db, "SELECT item_description FROM item_masterr WHERE id = ?", [res2.item]);
        const item_description = itemResult?.item_description;
       //

        const comp = item.complete.split(",");
        let total = 0;
        let numb = 0;
        let flag = 0;

        for (let j = 0; j < res2.individual_complete; j++) {
          total += parseInt(comp[flag]);
          numb = res2.individual_complete;
          flag++;
        }

        const tar1 = target * numb;
        const eff1 = (total / tar1) * 100;
        const eff = parseFloat(eff1.toFixed(2));
       

        const dataObject = {
          emp: item.emp,
          empid: item.empid,
          site,
          regg,
          diff,
          section_name,
          item_description,
          zone,
          machine,
          eff,
          shift,
        };

        resultData.push(dataObject);

        console.log('Result:', dataObject);
       }
      }
    }

    console.log('Result Data:', resultData);
    res.json({ message: 'Successfully processed data', resultData });
  } catch (error) {
    console.error('Error executing SQL queries:', error);
    res.status(500).json({ error: 'Database error' });
  }
});

function promisifyQuery5(db, sql, params) {
  return new Promise((resolve, reject) => {
    db.query(sql, params, (err, results) => {
      if (err) {
        reject(err);
      } else {
        resolve(results);
      }
    });
  });
}
 
//Get performance eff data search wise
app.post('/braid/get_performance_eff_braid_searchh', async (req, res) => {
  try {
    const fromdate = req.body.fromdate;
    const todate = req.body.todate;

    const dateObj = new Date(fromdate);
    const day = dateObj.getDate().toString().padStart(2, '0');
    const month = (dateObj.getMonth() + 1).toString().padStart(2, '0');
    const year = dateObj.getFullYear();

    const convertedDate = `${day}-${month}-${year}`;

    const dateObj1 = new Date(todate);
    const day1 = dateObj1.getDate().toString().padStart(2, '0');
    const month1 = (dateObj1.getMonth() + 1).toString().padStart(2, '0');
    const year1 = dateObj1.getFullYear();
   
    const convertedDate1 = `${day1}-${month1}-${year1}`;
    
    console.log('Converted Date:', convertedDate);
    console.log('Converted Date1:', convertedDate1);
    
    const whereConditions = [
      `date >= ?`,
      `date <= ?`
    ];
    
    const whereClause = whereConditions.join(' AND ');
    
    const sqlQuery = `
      SELECT *
      FROM operator_section
      WHERE STR_TO_DATE(date, '%d-%m-%Y') >= STR_TO_DATE(?, '%d-%m-%Y')
      AND STR_TO_DATE(date, '%d-%m-%Y') <= STR_TO_DATE(?, '%d-%m-%Y');
    `;
    
    const results1 = await promisifyQuery4(db, sqlQuery, [convertedDate, convertedDate1]);

    /////
    const fdate = convertedDate;
    const tdate = convertedDate1;

    const startDateParts = fdate.split('-').map(Number);
    const endDateParts = tdate.split('-').map(Number);

    const startDate = new Date(startDateParts[2], startDateParts[1] - 1, startDateParts[0]);
    const endDate = new Date(endDateParts[2], endDateParts[1] - 1, endDateParts[0]);

    const dateIncrement = 24 * 60 * 60 * 1000; // 1 day in milliseconds
    const dates = [];
   for (let currentDate = new Date(startDate); currentDate <= endDate; currentDate.setTime(currentDate.getTime() + dateIncrement)) {
      const day = currentDate.getDate().toString().padStart(2, '0');
      const month = (currentDate.getMonth() + 1).toString().padStart(2, '0');
      const year = currentDate.getFullYear();
      const datt = `${day}-${month}-${year}`;
      dates.push(datt);
    }
    ////
    const resultData = {
      fdate: convertedDate,
      tdate: convertedDate1,
      dates:dates,
      items:[],
    }
    
    for (const item of results1) {
      //console.log(sqlQuery);
      const ids = item.opmanual_id.split(',');

      const results2 = await promisifyQuery4(db, `
        SELECT geopos_operator.*, COUNT(id) AS individual_complete, GROUP_CONCAT(id) AS idk
        FROM geopos_operator
        WHERE id IN (?)
        GROUP BY item, zone, machine
      `, [ids]);

      const tpr = [];
      const mj = [];

      results2.forEach((res2) => {
        const str = `${item.empid}-${res2.item}-${res2.zone}-${res2.machine}`;
        if (!tpr.includes(str)) {
          tpr.push(str);
          mj.push(str);
        }
      });

      for (const res2 of results2) {
        const target = item.target;
        const zone = res2.zone;
        const machine = res2.machine;
        const shift = res2.shift;
        const str1 = `${item.empid}-${res2.item}-${res2.zone}-${res2.machine}`;
        
        if (mj.includes(str1)) {
          const entryidoResult = await promisifyQuery4(db, 'SELECT entryid FROM employees_ota WHERE entryid = ?', [item.empid]);
          const entryido = entryidoResult[0]?.entryid;

          const entryidiResult = await promisifyQuery4(db, 'SELECT entryid FROM geopos_employees WHERE entryid = ?', [item.empid]);
          const entryidi = entryidiResult[0]?.entryid;

          const rows = await promisifyQuery4(db, 'SELECT * FROM employees_ota WHERE entryid = ?', [item.empid]);
          const num = rows.length;

          let regg, site, diff;

          if (num > 0) {
            const query1 = await promisifyQuery4(db, 'SELECT * FROM employees_ota WHERE entryid = ?', [entryido]);
            regg = query1 ? new Date(query1[0].joindate).toLocaleDateString('en-US', { day: '2-digit', month: '2-digit', year: 'numeric' }).replace(/\//g, '-') : null;
            site = query1 ? query1[0].new_staff : null;
            const datek1 = new Date().toLocaleDateString('en-US', { day: '2-digit', month: '2-digit', year: 'numeric' }).replace(/\//g, '-');
            const earlier = new Date(query1[0].joindate);
            const later = new Date(datek1);
            diff = Math.floor((later - earlier) / (1000 * 60 * 60 * 24)) + 1;
          } else {
            const rows5 = await promisifyQuery4(db, 'SELECT * FROM geopos_employees WHERE entryid = ?', [entryidi]);

            if (rows5.length > 0) {
              const query2 = await promisifyQuery4(db, 'SELECT * FROM geopos_employees WHERE entryid = ?', [entryidi]);
              regg = query2 ? new Date(query2[0].joindate).toLocaleDateString('en-US', { day: '2-digit', month: '2-digit', year: 'numeric' }).replace(/\//g, '-') : null;
              site = 'IKEJA';
              const datek1 = new Date().toLocaleDateString('en-US', { day: '2-digit', month: '2-digit', year: 'numeric' }).replace(/\//g, '-');
              const earlier = new Date(query2[0].joindate);
              const later = new Date(datek1);
              diff = Math.floor((later - earlier) / (1000 * 60 * 60 * 24))+ 1;
            }
          }

          const [sectionResult] = await promisifyQuery4(db, 'SELECT section_name FROM section WHERE id = ?', [item.section_id]);
          const section_name = sectionResult?.section_name;

          const [itemResult] = await promisifyQuery4(db, 'SELECT item_description FROM item_masterr WHERE id = ?', [res2.item]);
          const item_description = itemResult?.item_description;

          const fdate = convertedDate;
          const tdate = convertedDate1;

          const startDateParts = fdate.split('-').map(Number);
          const endDateParts = tdate.split('-').map(Number);

          const startDate = new Date(startDateParts[2], startDateParts[1] - 1, startDateParts[0]);
          const endDate = new Date(endDateParts[2], endDateParts[1] - 1, endDateParts[0]);

          const dateIncrement = 24 * 60 * 60 * 1000; // 1 day in milliseconds
          const eff_data = [];
          const dates = [];
          
          for (let currentDate = new Date(startDate); currentDate <= endDate; currentDate.setTime(currentDate.getTime() + dateIncrement)) {
            const day = currentDate.getDate().toString().padStart(2, '0');
            const month = (currentDate.getMonth() + 1).toString().padStart(2, '0');
            const year = currentDate.getFullYear();
            const datt = `${day}-${month}-${year}`;
            dates.push(datt);
            //console.log(datt + '---------------');
            let total = 0;
            let numb = 0;
         
            const resu = await promisifyQuery4(db, 'SELECT * FROM operator_section WHERE date = ? AND empid = ?', [datt, item.empid]);
         
            if (resu.length === 0) {
              // No data available for this date, push a placeholder to eff_data
              eff_data.push('-'); // You can use another placeholder if needed
              continue; // Skip the rest of the loop for this date
            }

            for (const rs of resu) {
              const ra = rs.opmanual_id.split(',');
              const comp1 = rs.complete.split(',');
         
              const results = await promisifyQuery4(db, `
                SELECT geopos_operator.*, COUNT(id) AS datewise_individual_complete
                FROM geopos_operator
                WHERE id IN (?)
                AND item = ?
                AND zone = ?
                AND machine = ?
              `, [ra, res2.item, res2.zone, res2.machine]);
            
              if (results.length > 0) {
                numb = results[0].datewise_individual_complete;
              }
             //console.log(numb+'--------------Numb')
              const results2 = await promisifyQuery4(db, `
                SELECT geopos_operator.*
                FROM geopos_operator
                WHERE id IN (?)
                AND item = ?
                AND zone = ?
                AND machine = ?
              `, [ra, res2.item, res2.zone, res2.machine]);
             //console.log(JSON.stringify(results2, null, 2), 'arrayyyyyyyyyyyyyyyyyyy');

            // Initialize total to 0
            

            for (const rs2 of results2) {
              const idToSearch = String(rs2.id); // Convert to string to ensure matching
            
              const index = ra.indexOf(idToSearch);
              console.log('index:', index);
              if (index !== -1) {
                // Use reduce to sum the values in comp1
                total += parseFloat(comp1[index]);
              }
            }

           // console.log('Total:', total);

              const tar1 = target * numb;
              const eff1 = (total / tar1) * 100;
              const eff = isNaN(eff1) ? '-' : eff1.toFixed(2);
              eff_data.push(eff);
            }
          }

          const dataObject = {
            emp: item.emp,
            empid: item.empid,
            site,
            regg,
            diff,
            section_name,
            item_description,
            zone,
            machine,
            shift,
            eff: eff_data,
          };

          resultData.items.push(dataObject);
          //console.log('Result:', dataObject);
        }
      }
    }

    //console.log('Result Data:', resultData);
    res.json({ message: 'Successfully processed data', resultData });
  } catch (error) {
    console.error('Error executing SQL queries:', error);
    res.status(500).json({ error: 'Database error' });
  }
});

function promisifyQuery4(db, sql, params) {
  return new Promise((resolve, reject) => {
    db.query(sql, params, (err, results) => {
      if (err) {
        reject(err);
      } else {
        resolve(results);
      }
    });
  });
}


//Get performance eff previous date wise
app.post('/braid/getPerformanceEffNew', async (req, res) => {
  try {
    //const fdate = req.body.fromdate;
    const fromdate = req.body.fromdate ? req.body.fromdate.replace(/\//g, '-') : '';

let fdate = ''; // Initialize fdate as an empty string

if (fromdate && !isNaN(Date.parse(fromdate))) {
  // If fromdate is defined and can be successfully parsed as a date
  const dateObj = new Date(fromdate);
  const day = dateObj.getDate().toString().padStart(2, '0');
  const month = (dateObj.getMonth() + 1).toString().padStart(2, '0');
  const year = dateObj.getFullYear();
  fdate = `${day}-${month}-${year}`;
}

//console.log(fdate + '--------------');

  if (fdate !== '') {
    // Clear tables
    await promisifyQuery3(db, 'TRUNCATE TABLE geopos_operator_new');
    await promisifyQuery3(db, 'TRUNCATE TABLE operator_section_new');
  }


    // Copy data from 'operator_section' to 'operator_section_new'
    await promisifyQuery3(db, 'INSERT INTO operator_section_new SELECT * FROM operator_section WHERE date = ?', [fdate]);

    // Copy data from 'geopos_operator' to 'geopos_operator_new'
    await promisifyQuery3(db, 'INSERT INTO geopos_operator_new SELECT * FROM geopos_operator WHERE date = ?', [fdate]);

    // Get the last recorded date from 'operator_section_timesheet'
    const [dateRow] = await promisifyQuery3(db, 'SELECT MAX(date) as date FROM operator_section_new');
    const lastRecordedDate = dateRow.date;

    const results1 = await promisifyQuery3(db, 'SELECT * FROM operator_section_new WHERE date = ?', [lastRecordedDate]);
    const resultData = [];
   
    let date;
    if (typeof fdate !== 'undefined' && fdate !== '') {
      date = fdate;
    }else{
      date = lastRecordedDate;
    }
    for (const item of results1) {
      const ids = item.opmanual_id.split(',');

      const results2 = await promisifyQuery3(db, `
        SELECT geopos_operator_new.*, COUNT(id) AS individual_complete, GROUP_CONCAT(id) AS idk
        FROM geopos_operator_new
        WHERE id IN (?)
        GROUP BY item, zone, machine
      `, [ids]);

      for (const res2 of results2) {
        const target = item.target;
        const comp = item.complete.split(',');
        const idg = res2.idk ? res2.idk.split(',') : [];
        const zone = res2.zone;
        const machine = res2.machine;
        const shift = res2.shift;
        let total = 0;
        let numb = 0;
        let complete = '';

        for (const vall of idg) {
          const index = ids.indexOf(vall);
          total += parseInt(comp[index]);
          complete += comp[index] + ',';
          numb = res2.individual_complete;
        }

        const tar1 = target * numb;
        const eff1 = (total / tar1) * 100;
        const eff = eff1.toFixed(2);

        const entry = item.empid;

        const entryidoResult = await promisifyQuery3(db, "SELECT entryid FROM employees_ota WHERE entryid = ?", [item.empid]);
        const entryido = entryidoResult[0]?.entryid;

        const entryidiResult = await promisifyQuery3(db, "SELECT entryid FROM geopos_employees WHERE entryid = ?", [item.empid]);
        const entryidi = entryidiResult[0]?.entryid;

        const rows = await promisifyQuery3(db, 'SELECT * FROM employees_ota WHERE entryid = ?', [item.empid]);
        const num = rows.length;

        let regg, site, diff;

        if (num > 0) {
          const query1 = await promisifyQuery3(db, 'SELECT * FROM employees_ota WHERE entryid = ?', [entryido]);
          regg = query1 ? new Date(query1[0].joindate).toLocaleDateString('en-US', { day: '2-digit', month: '2-digit', year: 'numeric' }).replace(/\//g, '-') : null;
          site = query1 ? query1[0].new_staff : null;
          const datek1 = new Date().toLocaleDateString('en-US', { day: '2-digit', month: '2-digit', year: 'numeric' }).replace(/\//g, '-');
          const earlier = new Date(query1[0].joindate);
          const later = new Date(datek1);
          diff = Math.floor((later - earlier) / (1000 * 60 * 60 * 24));
        } else {
          const rows5 = await promisifyQuery3(db, 'SELECT * FROM geopos_employees WHERE entryid = ?', [entryidi]);

          if (rows5.length > 0) {
            const query2 = await promisifyQuery3(db, 'SELECT * FROM geopos_employees WHERE entryid = ?', [entryidi]);
            regg = query2 ? new Date(query2[0].joindate).toLocaleDateString('en-US', { day: '2-digit', month: '2-digit', year: 'numeric' }).replace(/\//g, '-') : null;
            site = 'IKEJA';
            const datek1 = new Date().toLocaleDateString('en-US', { day: '2-digit', month: '2-digit', year: 'numeric' }).replace(/\//g, '-');
            const earlier = new Date(query2[0].joindate);
            const later = new Date(datek1);
            diff = Math.floor((later - earlier) / (1000 * 60 * 60 * 24));
          }
        }

        const [sectionResult] = await promisifyQuery3(db, "SELECT section_name FROM section WHERE id = ?", [item.section_id]);
        const section_name = sectionResult?.section_name;

        const [itemResult] = await promisifyQuery3(db, "SELECT item_description FROM item_masterr WHERE id = ?", [res2.item]);
        const item_description = itemResult?.item_description;

        const dataObject = {
          emp: item.emp,
          empid: item.empid,
          site,
          regg,
          diff,
          item_description,
          section_name,
          zone,
          machine,
          shift,
          eff,
          date,
        };

        resultData.push(dataObject);

        console.log('Result:', dataObject);
      }
    }

    console.log('Result Data:', resultData);
    res.json({ message: 'Successfully processed data', resultData });
  } catch (error) {
    console.error('Error executing SQL queries:', error);
    res.status(500).json({ error: 'Database error' });
  }
});

function promisifyQuery3(db, sql, params) {
  return new Promise((resolve, reject) => {
    db.query(sql, params, (err, results) => {
      if (err) {
        reject(err);
      } else {
        resolve(results);
      }
    });
  });
}


// Production Breakdown

//default data fetch
app.get('/getdefaultproductionbreakdown', async (req, res) => {
  try {
    
    const date = new Date().toLocaleDateString('en-GB', { timeZone: 'Africa/Lagos' });
    const [formattedDay, formattedMonth, year] = date.split('/').map(part => part.padStart(2, '0'));
    const date1 = `${formattedDay}-${formattedMonth}-${year}`;

    let where = `date = '${date1}'`;

   // console.log('Step 7: itemsResponse:', itemsResponse);

   
    const roleid = 5;

    if (roleid === 5) {
      
      const operatorResults = await getOperatorResults(where);
      const itemsResponse = {
        items: operatorResults.map((result) => ({
          item: result.item,
          date: result.date, // Replace 'date' with the actual name of the date field in your database
          tdate: 1,
          wh: where,
          zone:result.zone,
          machine:result.machine,
          shift:result.shift,
        })),
      };
      res.json(itemsResponse);
    } else {
      
      const id1 = req.query.id1 || 9; // Get 'id1' from the query parameter or set a default value
      const employee = await getEmployeeById(id1);
      console.log(id1,'-------')
      if (!employee) {
       // console.log('Step 4: No employee found.');
        return res.status(404).json({ error: 'Employee not found' });
      }

      const empId = employee.id;
     // console.log('Step 4: Employee found. Employee ID:', empId);
      where += ` AND emp_id = '${empId}'`;
      const operatorResults = await getOperatorResults(where);

      //console.log('Step 6: geopos_operator results:', operatorResults);

      const itemsResponse = {
        items: operatorResults.map((result) => ({
          item: result.item,
          date: result.date, // Replace 'date' with the actual name of the date field in your database
          tdate: 1,
          wh: where,
          zone:result.zone,
          machine:result.machine,
          shift:result.shift,
        })),
      };

     // console.log('Step 7: itemsResponse:', itemsResponse);

      res.json(itemsResponse);
      
    }

    ////
    
   

  } catch (error) {
    console.error('Error:', error);
    res.status(500).json({ error: 'Internal Server Error' });
  }
});

// Function to get employee by ID
function getEmployeeById(id) {
  const sql = `
    SELECT geopos_employees.*
    FROM geopos_employees
    LEFT JOIN geopos_users ON geopos_employees.entryid = geopos_users.entryid
    WHERE geopos_users.id = ?
  `;

  return new Promise((resolve, reject) => {
    db.query(sql, [id], (err, results) => {
      if (err) {
        reject(err);
      } else {
        resolve(results.length > 0 ? results[0] : null);
      }
    });
  });
}

// Function to get operator results
function getOperatorResults(where) {
  const operatorSql = `
    SELECT *
    FROM geopos_operator
    WHERE ${where}
    GROUP BY item
  `;

  return new Promise((resolve, reject) => {
    db.query(operatorSql, (err, results) => {
      if (err) {
        reject(err);
      } else {
        resolve(results);
      }
    });
  });
}

// filter data fetch
app.post('/getsearchproductionbreakdown', (req, res) => {
  try {
    var zone = req.body.zone;
    var machine = req.body.machine1;
    var shift = req.body.shift;

    const fromdate = req.body.fromdate;
    const fdParts = fromdate.split('-');
    const fd = `${fdParts[2]}-${fdParts[1]}-${fdParts[0]}`;

    const todate = req.body.todate;
    const tdParts = todate.split('-');
    const td = `${tdParts[2]}-${tdParts[1]}-${tdParts[0]}`;

    const dateObj = new Date(fromdate);
    const day = dateObj.getDate().toString().padStart(2, '0');
    const month = (dateObj.getMonth() + 1).toString().padStart(2, '0');
    const year = dateObj.getFullYear();

    const convertedDate = `${day}-${month}-${year}`;

    const dateObj1 = new Date(todate);
    const day1 = dateObj1.getDate().toString().padStart(2, '0');
    const month1 = (dateObj1.getMonth() + 1).toString().padStart(2, '0');
    const year1 = dateObj1.getFullYear();

    const convertedDate1 = `${day1}-${month1}-${year1}`;
    console.log('Converted:', convertedDate);
    console.log('Converted2:', convertedDate1);

    const fd2 = Math.floor(new Date(fromdate).getTime() / 1000);
    const td1 = Math.floor(new Date(todate).getTime() / 1000);
    const fd1 = Math.floor(new Date(fd2 * 1000).setDate(new Date(fd2 * 1000).getDate() - 1) / 1000);

    var newfd = fd2;
    var newtd = td1;

    // Parse the ISO 8601 date string
    const parsedDate = new Date(fromdate);
    const parsedDate1 = new Date(todate);

    // Add one day to the parsed dates
    parsedDate1.setDate(parsedDate1.getDate() + 1);

    // Format the date in a more human-readable format (e.g., "YYYY-MM-DD HH:MM:SS")
    const formattedDate = `${parsedDate.getFullYear()}-${(parsedDate.getMonth() + 1).toString().padStart(2, '0')}-${parsedDate.getDate().toString().padStart(2, '0')} ${parsedDate.getHours().toString().padStart(2, '0')}:${parsedDate.getMinutes().toString().padStart(2, '0')}:${parsedDate.getSeconds().toString().padStart(2, '0')}`;
    const formattedDate1 = `${parsedDate1.getFullYear()}-${(parsedDate1.getMonth() + 1).toString().padStart(2, '0')}-${parsedDate1.getDate().toString().padStart(2, '0')} ${parsedDate1.getHours().toString().padStart(2, '0')}:${parsedDate1.getMinutes().toString().padStart(2, '0')}:${parsedDate1.getSeconds().toString().padStart(2, '0')}`;

    // Log the received data
    console.log('Received data:');
    console.log('zone:', zone);
    console.log('machine:', machine);
    console.log('shift:', shift);

    console.log('From Date:', fromdate);
    console.log('To Date:', todate);
    console.log('Converted Timestamp:', newfd);
    console.log('Converted Timestamp:', newtd);
    console.log('Converted Datetime:', formattedDate);
    console.log('Converted Datetime:', formattedDate1);

    // Build the WHERE clause
    let where = `datetime between '${formattedDate}' and '${formattedDate1}'`;

    if (zone) {
      where += ` AND zone='${zone}'`;
    }
    if (machine) {
      where += ` AND machine='${machine}'`;
    }
    if (shift) {
      where += ` AND shift='${shift}'`;
    }

    // Continue with the database query for 'geopos_operator'
    const operatorSql = `
      SELECT *
      FROM geopos_operator
      WHERE ${where}
      GROUP BY item
    `;

    console.log('operatorSql', operatorSql);

    db.query(operatorSql, (err, operatorResults) => {
      if (err) {
        console.error('Error executing SQL query', err);
        return res.status(500).json({ error: 'Database error' });
      }

      const itemsResponse = {
        items: operatorResults.map((result) => ({
          item: result.item,
          date: result.date,
          tdate: 0,
          wh: where,
          fromdate: convertedDate,
          todate: convertedDate1,
          zone: zone,
          machine: machine,
          shift: shift,
        }))
      };

      res.json(itemsResponse);
    });
  } catch (error) {
    console.error('Error in try-catch block', error);
    res.status(500).json({ error: 'Internal server error' });
  }
});


//get item description
app.get('/get-item-description', (req, res) => {
  const itemId = req.query.item;
  //console.log('itemId:', itemId);

  // Query the database to get the item description
  db.query('SELECT item_description FROM item_masterr WHERE id = ?', [itemId], (err, result) => {
    if (err) {
      console.error('Error fetching item description:', err);
      return res.status(500).json({ error: 'Internal server error' });
    }

    if (result.length === 0) {
      console.error('Item not found:', itemId);
      return res.status(404).json({ error: 'Item not found' });
    }

    const itemDescription = result[0].item_description; // Access the item_description property from the first object
    //console.log('Item:', itemDescription);

    // Respond with the item description
    res.json({ item_description: itemDescription });
  });
});

// API endpoint to calculate SUM(fg_output) for a specific item
app.get('/get-fg-output', (req, res) => {
  const itemId = req.query.id; // Get the 'item' value from the 'id' query parameter
  const wh = req.query.wh; // Get the 'wh' value from the 'wh' query parameter
  //console.log('itemId:', itemId);
  //console.log('wh:', wh);

     db.query(
      'SELECT SUM(fg_output) AS fg_output FROM geopos_operator WHERE item = ? AND ' + wh,
      [itemId],
      (err, rows) => {
       

        if (err) {
          console.error('Error executing the query:', err);
          res.status(500).json({ error: 'Internal server error' });
          return;
        }

        if (rows.length > 0) {
          res.json({ fg_output: rows[0].fg_output });
        } else {
          res.status(404).json({ error: 'Item not found' });
        }
      }
    ); 
  
});

// get direct worker
app.get('/get-direct-worker', (req, res) => {
  const item = req.query.id;         // Get the 'item' value from the 'id' query parameter
  const wh = req.query.wh;        // Get the 'wh' value from the 'wh' query parameter
  const zone = req.query.zone;    // Get the 'zone' value from the 'zone' query parameter
  const machine = req.query.machine;  // Get the 'machine' value from the 'machine' query parameter
  const shift = req.query.shift;  // Get the 'shift' value from the 'shift' query parameter
  const date = req.query.date;    // Get the 'date' value from the 'date' query parameter

  const workerSql = `
  SELECT *, max(demp_count) as at
  FROM geopos_operator
  WHERE ${wh} AND item = '${item}'
  GROUP BY zone, machine, item, date, shift
`;

//console.log('Query :', workerSql);

db.query(workerSql, (err, results) => {
   

    if (err) {
      console.error('Error executing the query:', err);
      res.status(500).json({ error: 'Internal server error' });
      return;
    }

    if (results.length > 0) {
      // Calculate the sum of 'at' values
      const sumOfAt = results.reduce((accumulator, row) => accumulator + parseFloat(row.at), 0);
  
      // Return the sum as part of the response
      res.json({ fg_output: sumOfAt });
    } else {
      res.status(404).json({ error: 'Item not found' });
    }
  });
});

//Daywise Production Summary Report

//Daywise production data default
app.get('/braid/get_daywise_production_default', async (req, res) => {
  try {
    const now = new Date();
    const day = String(now.getDate()).padStart(2, '0');
    const month = String(now.getMonth() + 1).padStart(2, '0'); // January is 0!
    const year = now.getFullYear();
    const date = `${day}-${month}-${year}`;
    const period = [date];
    const where = `geopos_operator.date=${date}`; // Specify the table alias for "date"
    
    const promises = period.map(async (d1) => {
      const where = `geopos_operator.date='${d1}'`;

      // Calculate Total FG
      const fgQuery = `SELECT SUM(fg_output) AS fg_output FROM geopos_operator WHERE ${where}`;
      const fgResults = await promisifyQuery2(fgQuery);
      const tfg = fgResults[0].fg_output;

      // Calculate Total Active Worker
      const workerQuery = `SELECT *, max(demp_count) as at FROM geopos_operator WHERE ${where} GROUP BY zone, machine, item, date, shift`;
      const workerResults = await promisifyQuery2(workerQuery);
      let tw = 0;
      for (const wr of workerResults) {
        tw += parseInt(wr.at, 10);
      }

      // Calculate Daily PPP
      let ppp = 'X';
      if (tfg !== null) {
        ppp = tfg / tw;
        ppp = isNaN(ppp) ? 'X' : ppp.toFixed(2);
      }

      // Store the results in an object
      const result = {
        date: d1, // You may want to store the date as well
        totalFG: tfg,
        totalActiveWorker: tw,
        dailyPPP: ppp,
      };
      return result;
    });

    // Execute all the promises for 'resultData'
    const resultData = await Promise.all(promises);
   
    const results1 = await promisifyQuery2(`
    SELECT geopos_operator.*, color_master.color_name, item_masterr.item_description
    FROM geopos_operator
    LEFT JOIN color_master ON geopos_operator.color_id = color_master.id
    LEFT JOIN item_masterr ON geopos_operator.item = item_masterr.id
    WHERE geopos_operator.date='${date}'
    GROUP BY geopos_operator.item, geopos_operator.color_id`);
   console.log(results1,'========')
    const tfgPromises = results1.map(async (item) => {
      const subWhere = `geopos_operator.item='${item.item}' AND geopos_operator.date='${date}' AND geopos_operator.color_id='${item.color_id}'`;
    
      // Execute the query to get the tfg
      const results2 = await promisifyQuery2(`
        SELECT SUM(fg_output) AS fg_output
        FROM geopos_operator
        WHERE ${subWhere}`);
    
      console.log(results2); // Check the results in the console
    
      // Get the totalFG value from the results or set a default value
      const totalFG = results2.length > 0 ? results2[0].fg_output || '-' : '-';
    
      // Return the tfgData object
      return {
        item: item.item_description,
        color: item.color_name,
        shift: item.shift,
        site: item.site,
        tfg: totalFG,
      };
    });
    
    // Wait for all tfg promises to resolve
    const tfgData = await Promise.all(tfgPromises);
    
    // Combine the data from both sets of queries
    const responseData = {
      resultData: resultData,
      tfgData: tfgData,
    };
    
    // Send the final response
    res.json(responseData);
    

    console.log(responseData);
  } catch (error) {
    console.error(error);
    res.status(500).json({ error: 'An error occurred' });
  }
});

// Helper function to promisify queries
function promisifyQuery2(query) {
  return new Promise((resolve, reject) => {
    db.query(query, (error, results) => {
      if (error) {
        reject(error);
      } else {
        resolve(results);
      }
    });
  });
}

//Daywise production data date wise search
app.post("/braid/get_daywise_production_search", async (req, res) => {
  try {
    const hr_start = req.body.fromdate;
    const hr_end = req.body.todate;
    const shift = req.body.shift;
    const site = req.body.site;

    // Set the timezone (if needed, you can change "Africa/Lagos" to your desired timezone)
    const timezone = "Africa/Lagos";
    const from = new Date(hr_start);
    const to = new Date(hr_end);

    // Set the timezone for the "from" and "to" dates
    from.toLocaleString("en-US", { timeZone: timezone });
    to.toLocaleString("en-US", { timeZone: timezone });

    // Calculate the start and end dates
    const st = from.toISOString().slice(0, 10);
    const ed = new Date(to.getTime() + 24 * 60 * 60 * 1000)
      .toISOString()
      .slice(0, 10);

    // Create the date range condition
    let where = `datetime BETWEEN '${st}' AND '${ed}'`;
    if (shift !== "") {
      where += ` AND shift='${shift}'`;
    }

    if (site !== "") {
      where += ` AND site='${site}'`;
    }

    // Initialize an array to store the date range
    const period = [];
    const date = new Date(st); // Initialize the date variable

    // Loop through the date range from start to end date
    while (date <= to) {
      period.push(new Date(date));
      date.setDate(date.getDate() + 1); // Increment the date by one day
    }

    const dates = period.map((d1) => {
      const day = d1.getDate().toString().padStart(2, "0");
      const month = (d1.getMonth() + 1).toString().padStart(2, "0");
      const year = d1.getFullYear();
      return `${day}-${month}-${year}`;
    });

  
    // Promises for Total FG, Total Active Worker, and Daily PPP calculations
    const totalFGPromises = dates.map(async (formattedDate) => {
      let dateCondition = `geopos_operator.date='${formattedDate}'`;

      if (shift !== "") {
        dateCondition += ` AND shift='${shift}'`;
      }

      if (site !== "") {
        dateCondition += ` AND site='${site}'`;
      }

      // Calculate Total FG for the specific date
      const fgQuery = `SELECT SUM(fg_output) AS fg_output FROM geopos_operator WHERE ${dateCondition}`;
      const fgResults = await promisifyQuery1(fgQuery);
      const tfg = fgResults[0].fg_output;

      return tfg;
    });

    const totalActiveWorkerPromises = dates.map(async (formattedDate) => {
      let dateCondition = `geopos_operator.date='${formattedDate}'`;

      if (shift !== "") {
        dateCondition += ` AND shift='${shift}'`;
      }

      if (site !== "") {
        dateCondition += ` AND site='${site}'`;
      }

      // Calculate Total Active Worker for the specific date
      const workerQuery = `SELECT *, MAX(demp_count) AS at FROM geopos_operator WHERE ${dateCondition} GROUP BY zone, machine, item, date, shift, site`;
      const workerResults = await promisifyQuery1(workerQuery);
      
      let tw = 0;
      for (const wr of workerResults) {
        // Convert the 'at' value to a number using the unary plus operator
        tw += +wr.at;
      }
      
      // Convert the result to a string with dynamic precision
      tw = tw.toString(); // Convert to string
      tw = parseFloat(tw).toString();
      return tw;
     
    });

    const dailyPPPPromises = dates.map(async (formattedDate) => {
      let dateCondition = `date='${formattedDate}'`;

      if (shift !== "") {
        dateCondition += ` AND shift='${shift}'`;
      }

      if (site !== "") {
        dateCondition += ` AND site='${site}'`;
      }

      // Calculate Total FG for the specific date
      const fgQuery = `SELECT SUM(fg_output) AS fg_output FROM geopos_operator WHERE ${dateCondition}`;
      const fgResults = await promisifyQuery1(fgQuery);
      const tfg = fgResults[0].fg_output;

      // Calculate Total Active Worker for the specific date
      const workerQuery = `SELECT *, MAX(demp_count) AS at FROM geopos_operator WHERE ${dateCondition} GROUP BY zone, machine, item, date, shift, site`;
      const workerResults = await promisifyQuery1(workerQuery);
      let tw = 0;
      for (const wr of workerResults) {
        tw += + wr.at;
      }
      
      // Calculate Daily PPP for the specific date
      let ppp = "N/A";
      if (tfg !== null) {
        ppp = tfg / tw;
        ppp = isNaN(ppp) ? "N/A" : ppp.toFixed(4);
      }

      return ppp;
    });

    // Wait for all promises to resolve
    const totalFGs = await Promise.all(totalFGPromises);
    const totalActiveWorkers = await Promise.all(totalActiveWorkerPromises);
    const dailyPPPs = await Promise.all(dailyPPPPromises);

    // Create an array to store the final result data
    const resultData = dates.map((d1, index) => {
      const tfg = totalFGs[index];
      const tw = totalActiveWorkers[index];
      const ppp = dailyPPPs[index];
      //console.log(tw+']]]]]]]]]]]]]]]]]]]]]]]]')
      // Store the results in an object for each date
      return {
        date: d1,
        totalFG: tfg,
        totalActiveWorker: tw,
        dailyPPP: ppp,
        dates:dates,
        fdate:hr_start,
        tdate:hr_end,
      };
    });

    // Execute the first query using the connection pool
    const results1 = await promisifyQuery1(`
      SELECT geopos_operator.*, color_master.color_name, item_masterr.item_description
      FROM geopos_operator
      LEFT JOIN color_master ON geopos_operator.color_id = color_master.id
      LEFT JOIN item_masterr ON geopos_operator.item = item_masterr.id
      WHERE ${where}
      GROUP BY geopos_operator.item, geopos_operator.color_id`);
    //console.log(dates + "==============");

    // Create an array of promises for the second queries
    const tfgPromises = results1.map(async (item) => {
      const totalFG = [];
      for (const formattedDate of dates) {
        const subWhere = `geopos_operator.item='${item.item}' AND geopos_operator.date='${formattedDate}' AND geopos_operator.color_id='${item.color_id}'`;

        const results2 = await promisifyQuery1(`
          SELECT SUM(fg_output) AS fg_output
          FROM geopos_operator
          WHERE ${subWhere}`);

        const tfg = results2[0].fg_output;
        const totalFGs = tfg !== null && tfg !== "" ? tfg : "0";
        totalFG.push(totalFGs);
      }
      return {
        item: item.item_description,
        color: item.color_name,
        shift: item.shift,
        site: item.site,
        tfg: totalFG,
      };
    });

    // Wait for all tfg promises to resolve
    const tfgData = await Promise.all(tfgPromises);

    // Send the final response
    const responseData = {
      resultData: resultData,
      tfgData: tfgData,
    };

    res.json(responseData);
    console.log(responseData);
  } catch (error) {
    console.error(error);
    res.status(500).json({ error: "An error occurred" });
  }
});

// Helper function to promisify queries
function promisifyQuery1(query) {
  return new Promise((resolve, reject) => {
    db.query(query, (error, results) => {
      if (error) {
        reject(error);
      } else {
        resolve(results);
      }
    });
  });
}


//Wastage Report

//default data fetch
app.get('/wastage', (req, res) => {
  const date = new Date().toLocaleDateString('en-GB', { timeZone: 'Africa/Lagos' });
  const parts = date.split('/');
  const formattedDay = parts[0].padStart(2, '0');
  const formattedMonth = parts[1].padStart(2, '0');
  const year = parts[2];
  const date1 = `${formattedDay}-${formattedMonth}-${year}`;

   const sql = `
     SELECT item_masterr.*, geopos_operator.item
     FROM item_masterr
     LEFT JOIN geopos_operator ON item_masterr.id = geopos_operator.item
     WHERE geopos_operator.date='${date1}'
     GROUP BY geopos_operator.item
   `;
 
   db.query(sql, (err, results) => {
     if (err) {
       console.error('Error executing SQL query: ' + err.message);
       res.status(500).json({ error: 'Internal Server Error' });
       return;
     }
 
     const data = {
       items: results,
       from: date1,
       to: date1,
       tdate: 0,
     };
 
     res.status(200).json({ data});
   });
});

//filter data search
app.post('/wastage-daterangeview', (req, res) => {
  const fromdate = req.body.fromdate;
  const fdParts = fromdate.split('-');
  const fd = `${fdParts[2]}-${fdParts[1]}-${fdParts[0]}`;

  const todate = req.body.todate;
  const tdParts = todate.split('-');
  const td = `${tdParts[2]}-${tdParts[1]}-${tdParts[0]}`;


  const dateObj = new Date(fromdate);
  const day = dateObj.getDate().toString().padStart(2, '0');
  const month = (dateObj.getMonth() + 1).toString().padStart(2, '0');
  const year = dateObj.getFullYear();

  const convertedDate = `${day}-${month}-${year}`;

  const dateObj1 = new Date(todate);
  const day1 = dateObj1.getDate().toString().padStart(2, '0');
  const month1 = (dateObj1.getMonth() + 1).toString().padStart(2, '0');
  const year1 = dateObj1.getFullYear();

  const convertedDate1 = `${day1}-${month1}-${year1}`;
  console.log('Converted:', convertedDate);
  console.log('Converted2:', convertedDate1);


  const fd2 = Math.floor(new Date(fromdate).getTime() / 1000);
  const td1 = Math.floor(new Date(todate).getTime() / 1000);
  const fd1 = Math.floor(new Date(fd2 * 1000).setDate(new Date(fd2 * 1000).getDate() - 1) / 1000);

  var newfd = fd2;
  var newtd = td1;

// Parse the ISO 8601 date string
const parsedDate = new Date(fromdate);
const parsedDate1 = new Date(todate);

// Add one day to the parsed dates

parsedDate1.setDate(parsedDate1.getDate() + 1);

// Format the date in a more human-readable format (e.g., "YYYY-MM-DD HH:MM:SS")
const formattedDate = `${parsedDate.getFullYear()}-${(parsedDate.getMonth() + 1).toString().padStart(2, '0')}-${parsedDate.getDate().toString().padStart(2, '0')} ${parsedDate.getHours().toString().padStart(2, '0')}:${parsedDate.getMinutes().toString().padStart(2, '0')}:${parsedDate.getSeconds().toString().padStart(2, '0')}`;
const formattedDate1 = `${parsedDate1.getFullYear()}-${(parsedDate1.getMonth() + 1).toString().padStart(2, '0')}-${parsedDate1.getDate().toString().padStart(2, '0')} ${parsedDate1.getHours().toString().padStart(2, '0')}:${parsedDate1.getMinutes().toString().padStart(2, '0')}:${parsedDate1.getSeconds().toString().padStart(2, '0')}`;

   // Log the received data
  const where = `geopos_operator.datetime BETWEEN '${formattedDate}' AND '${formattedDate1}'`;

  const sql = `
    SELECT item_masterr.*, geopos_operator.item
    FROM item_masterr
    LEFT JOIN geopos_operator ON item_masterr.id = geopos_operator.item
    WHERE ${where}
    GROUP BY geopos_operator.item
  `;

  db.query(sql, (err, results) => {
    if (err) {
      console.error('Error executing SQL query: ' + err.message);
      res.status(500).json({ error: 'Internal Server Error' });
      return;
    }

    const data = {
      items: results,
      from: convertedDate,
      to: convertedDate1,
      tdate: 0,
    };

    res.status(200).json({ data});
  });
});

// get target expected and waste weight
app.post('/wastage-target-expected-wasteweight', async (req, res) => {
  try {
    const receivedData = req.body;
    const { dateColumns, responseData } = receivedData;
    const roleid = 5;
  
    const resultArray = [];

    for (const item of responseData.items) {
      const id = item.id;
      const itemDescription = item.item_description;

      // Assuming each item has a 'net_weight' and 'targeted_waste' property
      const netWeight = item.net_weight;
      const targetedWaste = item.targeted_waste;

      const itemData = [];

      for (const dateColumn of dateColumns) {
        let where;

        if (roleid === 5) {
          where = `item='${item.id}' AND date='${dateColumn.data}'`;
        }

        else {
          //const empid = 9; // Assuming user id is available in req.user
          //where = `item='${id}' AND date='${dateColumn.data}' AND emp_id='${empid}'`;

          const id1 = 9;
          const query=`SELECT geopos_employees.*
          FROM geopos_employees
          LEFT JOIN geopos_users ON geopos_employees.entryid = geopos_users.entryid
          WHERE geopos_users.id =${id1}`;
  
          db.query(query, (err, results) => {
            if (err) {
              console.error('Error executing SQL query: ' + err.message);
              res.status(500).json({ error: 'Internal Server Error' });
              return;
            }
        
            if (results.length === 0) {
              return res.status(404).json({ error: 'Employee not found' });
            }
    
            const empid = results[0].id;
            where = `item='${item.id}' AND date='${dateColumn}' AND emp_id='${empid}'`;
          });
  
        }

        const query = `
          SELECT *
          FROM geopos_operator
          WHERE ${where}
          GROUP BY item,date,zone,machine,hr_start
        `;

        //console.log('Query:', query);

        const operatorResults = await new Promise((resolve, reject) => {
          db.query(query, (err, results) => {
            if (err) {
              console.error('Error executing SQL query', err);
              reject(err);
            } else {
              resolve(results);
            }
          });
        });

        //console.log('Operator Results:', operatorResults); // Add this line for console logging
        

        let re = 0;
        let t = 0;
        let wst = 0;

        for (const ws of operatorResults) {
          const tf = parseFloat(ws.fiber);
          re += parseFloat(ws.fg_output);
          t += tf; // Accumulate tf into t
          wst += parseFloat(ws.waste_weight);

          /*console.log('Fiber:', tf);
          console.log('fg_output:', parseFloat(ws.fg_output));
          console.log('Total t:', t);
          console.log('Waste Weight:', parseFloat(ws.waste_weight));*/
        }

        const tg = t * 1000;
      
        const twww = (parseInt(t) * 1000) - (parseInt(item.net_weight) * (parseInt(t) * 1000) / (parseInt(item.net_weight) + parseInt(item.targeted_waste)));
        const tww=twww.toFixed(3) + ' gm';
       // console.log('tww:', tww);
        const eww = (tg - item.net_weight * re).toFixed(0) + ' gm';

        itemData.push({
          item_id: id,
          item_description: itemDescription,
          tww,
          eww,
          wst: wst.toFixed(0) + ' gm',
        });
      }

      resultArray.push({
       // item_id: id,
        item_description: itemDescription,
        item_data: itemData,
      });
    }

    // Wrap the resultArray in a data object
    const responseDataObject = {
      data: resultArray,
    };

    // Send the responseDataObject as the response
    res.json(responseDataObject);
  } catch (err) {
    console.error('Error:', err);
    res.status(500).json({ error: 'Server error' });
  }
});


//Wastage Per Item Report

//Wastage percentage per item search data
app.post('/braid/get_wastage_item_search_data', async (req, res) => {
  try {
    const timezone = 'Africa/Lagos';
    const fromdate = req.body.fromdate;
    const fdParts = fromdate.split('-');
    const fd = `${fdParts[2]}-${fdParts[1]}-${fdParts[0]}`;

    const todate = req.body.todate;
    const tdParts = todate.split('-');
    const td = `${tdParts[2]}-${tdParts[1]}-${tdParts[0]}`;

    const dateObj = new Date(fromdate);
    const day = dateObj.getDate().toString().padStart(2, '0');
    const month = (dateObj.getMonth() + 1).toString().padStart(2, '0');
    const year = dateObj.getFullYear();
    const convertedDate = `${year}-${month}-${day}`;

    const dateObj1 = new Date(todate);
    const day1 = dateObj1.getDate().toString().padStart(2, '0');
    const month1 = (dateObj1.getMonth() + 1).toString().padStart(2, '0');
    const year1 = dateObj1.getFullYear();
    const convertedDate1 = `${year1}-${month1}-${day1}`;

    if (fromdate && todate) {
      from = new Date(fromdate);
      to = new Date(todate);
    }

    from.toLocaleString('en-US', { timeZone: timezone });
    to.toLocaleString('en-US', { timeZone: timezone });

    const period = [];
    const date = new Date(from);

    while (date <= to) {
      period.push(new Date(date));
      date.setDate(date.getDate() + 1);
    }

    // Function to format a date as "d-m-Y"
    
    const formatDate = (date) => {
      const day = String(date.getDate()).padStart(2, '0');
      const month = String(date.getMonth() + 1).padStart(2, '0');
      const year = date.getFullYear();
      return `${day}-${month}-${year}`;
    };
    
  
    const formattedDates = period.map((date) => formatDate(date));
    // Fetch data for geopos_machine
    const sql=`
    SELECT item_masterr.*, geopos_operator.item
    FROM item_masterr
    LEFT JOIN geopos_operator ON item_masterr.id = geopos_operator.item
    WHERE geopos_operator.datetime between '${convertedDate}' and '${convertedDate1}'
    GROUP BY geopos_operator.item`;
    console.log(sql);
    const zoneRows = await wastagePerQuery1(sql);
      const responseData ={
        dates: formattedDates,
        fdate:convertedDate,
        tdate:convertedDate1,
        datas:[],
      }; // Collect response data here
           
      for (const zoneItem of zoneRows) {
        const items = zoneItem.item_description;
        const id = zoneItem.id;
        const valuesByDate = {}; // Store values by date
          for (const dt of period) {
            const d1 = formatDate(dt); // Format as "d-m-Y"
            
            const where = `item='${id}' AND date='${d1}' `;

            try {
              // Fetch data for geopos_operator
              const operatorRows = await wastagePerQuery(`
              SELECT * FROM geopos_operator WHERE ${where}
              `);
              
              const values = [];

              if (operatorRows.length > 0) {
                let rs = 0;
                let re = 0;
                let j = 1;
                let t = 0;
                let wst = 0;
                let pw = 0; // Initialize pw
                
                for (const ws of operatorRows) {
                  const tf = parseInt(ws.fiber, 10);
                  const fgOutput = parseInt(ws.fg_output, 10);
                  const wasteWeight = parseFloat(ws.waste_weight);
                 
                  re +=fgOutput;
                  t +=tf;
                  wst +=wasteWeight;
                  j++;
                }
                
                if (t !== 0) {
                 
                  pw = (wst / (t * 1000)) * 100;
                  // Convert pw to an integer using parseInt
                  pw = parseInt(Math.round(pw * 100), 10) / 100;
                  values.push(pw.toFixed(2) + ' %');
                } else {
                  values.push(pw + ' %');
                }

              }else {
                // Handle case when operatorRows is empty
                values.push('-');
              }

              // Store values for this date
              valuesByDate[d1] = values;
              console.log(`Values for date ${d1}:`, valuesByDate[d1]);
            } catch (dbError) {
              console.error('Database Error:', dbError);
              // Initialize values for this date as an array containing an error message
              valuesByDate[d1] = ['Error fetching data'];
            }
          }

          // Push the data for this machine to responseData
          responseData.datas.push({
            items: items,
            values: valuesByDate,
          });

      }

      // Send the response data
      res.json(responseData);
   
  } catch (error) {
    console.error(error);
    res.status(500).json({ error: 'An error occurred' });
  }
});


function wastagePerQuery1(query, values) {
  return new Promise((resolve, reject) => {
    db.query(query, values, (err, results) => {
      if (err) {
        reject(err);
      } else {
        resolve(results);
      }
    });
  });
}

//get default data
app.get('/get_wastage_item_data', async (req, res) => {
  try {
    const now = new Date();
    const day = String(now.getDate()).padStart(2, '0');
    const month = String(now.getMonth() + 1).padStart(2, '0'); // January is 0!
    const year = now.getFullYear();
    const date = `${day}-${month}-${year}`;
    const period = [date];
  
    const formattedDates = period.map((date) => date);
    // Fetch data for geopos_machine
    const ItemsRows = await wastagePerQuery('SELECT * FROM item_masterr');

    if (ItemsRows.length > 0) {
      const responseData = []; // Collect response data here

      for (const zoneItem of ItemsRows) {
        const items = zoneItem.item_description;

        const valuesByDate = {}; // Store values by date
          for (const dt of period) {
            const d1 = dt; // Format as "d-m-Y"
          
            const where = `item='${zoneItem.id}' AND date='${d1}' `;

            try {
              // Fetch data for geopos_operator
              const operatorRows = await wastagePerQuery(`
              SELECT * FROM geopos_operator WHERE ${where}
              `);
              
              const values = [];

              if (operatorRows.length > 0) {
                let rs = 0;
                let re = 0;
                let j = 1;
                let t = 0;
                let wst = 0;

                for (const ws of operatorRows) {
                  const tf = ws.fiber;
                  re = re + ws.fg_output;
                  t = t + tf;
                  wst = wst + ws.waste_weight;
                  j++;
                }

                if (t !== 0) {
                  const pw = (wst / (t * 1000)) * 100;
                  values.push(pw.toFixed(2) + ' %');
                } else {
                  values.push('-');
                }
              }else {
                // Handle case when operatorRows is empty
                values.push('-');
              }

              // Store values for this date
              valuesByDate[d1] = values;
              //console.log(`Values for date ${d1}:`, valuesByDate[d1]);
            } catch (dbError) {
              console.error('Database Error:', dbError);
              // Initialize values for this date as an array containing an error message
              valuesByDate[d1] = ['Error fetching data'];
            }
          }

          // Push the data for this machine to responseData
          responseData.push({
            items: items,
            values: valuesByDate,
            dates: formattedDates,
          });
      }

      // Send the response data
      res.json(responseData);
      console.log(responseData);
    } else {
      // Handle case when zoneRows is empty
      res.status(404).json({ error: 'No data found' });
    }
  } catch (error) {
    console.error(error);
    res.status(500).json({ error: 'An error occurred' });
  }
});


function wastagePerQuery(query, values) {
  return new Promise((resolve, reject) => {
    db.query(query, values, (err, results) => {
      if (err) {
        reject(err);
      } else {
        resolve(results);
      }
    });
  });
}


//Production Dashboard Report

//Braid Report performance dashboard
app.get('/braid/get_dashboard_default_data', (req, res) => {
  //const date = new Date().toLocaleDateString('en-US', { timeZone: 'Africa/Lagos' });
  
  const date = new Date().toLocaleDateString('en-GB', { timeZone: 'Africa/Lagos' });
  const parts = date.split('/');
  const day = parts[0].padStart(2, '0');
  const month = parts[1].padStart(2, '0');
  const year = parts[2];
  const currentMonth = `${month}-${year}`;
  const currentDate = `${day}-${month}-${year}`;
 console.log(date)
  const sql = `
    SELECT item_masterr.*, geopos_operator.item
    FROM item_masterr
    LEFT JOIN geopos_operator ON item_masterr.id = geopos_operator.item
    WHERE geopos_operator.date = ?
    GROUP BY geopos_operator.item
  `;

  console.log(sql)
  db.query(sql, [currentDate], (err, results) => {
    if (err) {
      console.error('Error executing SQL query:', err);
      res.status(500).json({ error: 'Internal Server Error' });
      return;
    }
    const response = {
      Dates: [currentDate],
      results: results,
    };
    res.json(response);
    console.log(response)
  });
});

//Braid Report Performance dashboard search report
app.post('/braid/get_dashboard_search_data', (req, res) => {
  
  const timezone = 'Africa/Lagos';
    const fromdate = req.body.fromdate;
    const fdParts = fromdate.split('-');
    const fd = `${fdParts[2]}-${fdParts[1]}-${fdParts[0]}`;

    const todate = req.body.todate;
    const tdParts = todate.split('-');
    const td = `${tdParts[2]}-${tdParts[1]}-${tdParts[0]}`;

    const dateObj = new Date(fromdate);
    const day = dateObj.getDate().toString().padStart(2, '0');
    const month = (dateObj.getMonth() + 1).toString().padStart(2, '0');
    const year = dateObj.getFullYear();
    const convertedDate = `${year}-${month}-${day}`;

    const dateObj1 = new Date(todate);
    const day1 = dateObj1.getDate().toString().padStart(2, '0');
    const month1 = (dateObj1.getMonth() + 1).toString().padStart(2, '0');
    const year1 = dateObj1.getFullYear();
    const convertedDate1 = `${year1}-${month1}-${day1}`;


  const period = [];
  const date = new Date(dateObj);

  while (date <= dateObj1) {
    period.push(new Date(date));
    date.setDate(date.getDate() + 1);
  }

  // Function to format a date as "d-m-Y"
  
  const formatDate = (date) => {
    const day = String(date.getDate()).padStart(2, '0');
    const month = String(date.getMonth() + 1).padStart(2, '0');
    const year = date.getFullYear();
    return `${day}-${month}-${year}`;
  };
  
  const formattedDates = period.map((date) => formatDate(date));
  const where = `geopos_operator.datetime BETWEEN '${convertedDate}' AND '${convertedDate1}'`;
  const sql = `
  SELECT item_masterr.*, geopos_operator.item
  FROM item_masterr
  LEFT JOIN geopos_operator ON item_masterr.id = geopos_operator.item
  WHERE ${where}
  GROUP BY geopos_operator.item
`;
console.log(sql)
  db.query(sql, [date], (err, results) => {
    if (err) {
      console.error('Error executing SQL query:', err);
      res.status(500).json({ error: 'Internal Server Error' });
      return;
    }
    const response = {
      Dates: formattedDates,
      results: results,
    };
    res.json(response);
    console.log(formattedDates)
  });
});


//Braid Report performance dashboard fg output data
app.get('/braid/get_fg_output_data', (req, res) => {
  const itemId = req.query.item;
  const dates = req.query.date; // Assuming date is in a valid format, e.g., "Y-m-d"
  const inputDate = new Date(dates); // Replace with your input date
  const options = { year: 'numeric', month: '2-digit', day: '2-digit' };
  const formattedDate = inputDate.toLocaleDateString('en-US', options).replace(/\//g, '-');;


  //const empId = req.query.emp_id; // Make sure you have a query parameter for emp_id
  const sql = `
  SELECT *
  FROM geopos_operator
  WHERE item = '${itemId}' AND date = '${dates}'
  GROUP BY item, date, zone, machine, hr_start
`;
 
  db.query(sql, (err, results) => {
    if (err) {
      console.error('Error executing SQL query:', err);
      res.status(500).json({ error: 'Internal Server Error' });
      return;
    }
    //console.log(results)
    res.json(results);
  });
});

//Braid Report performance dashboard labour data
app.get('/braid/get_labour_worker_data', (req, res) => {
  const itemId = req.query.item;
  const dates = req.query.date; // Assuming date is in a valid format, e.g., "Y-m-d"

  const inputDate = new Date(dates); // Replace with your input date
  const options = { year: 'numeric', month: '2-digit', day: '2-digit' };
  const formattedDate = inputDate.toLocaleDateString('en-US', options).replace(/\//g, '-');;
  
  console.log(formattedDate);
  
  const sql = `
      SELECT *, MAX(demp_count) as at, MAX(iemp_count) AS it
      FROM geopos_operator
      WHERE item = '${itemId}' AND date = '${dates}'
      GROUP BY zone, machine, item, date
    `;
 
  console.log(sql);
  db.query(sql, (err, results) => {
    if (err) {
      console.error('Error executing SQL query:', err);
      res.status(500).json({ error: 'Internal Server Error' });
      return;
    }
    //console.log(results)
    res.json(results);
  });
});

//Braid Report performance dashboard ppp data
app.get('/braid/get_ppp_data', async (req, res) => {
  try {
    const itemId = req.query.item;
    const dates = req.query.date; // Assuming date is in a valid format, e.g., "Y-m-d"

    const inputDate = new Date(dates);
    const options = { year: 'numeric', month: '2-digit', day: '2-digit' };
    const formattedDate = inputDate.toLocaleDateString('en-US', options).replace(/\//g, '-');

    // Execute the first query
    const query1 = `
      SELECT *
      FROM geopos_operator
      WHERE item = '${itemId}' AND date = '${dates}'
      GROUP BY item, date, zone, machine, hr_start
    `;
    const query1Result = await pppQuery(query1);
    //console.log(query1 + '1----------------------')
    let fg = 0;
    for (const ws of query1Result) {
      fg +=+ ws.fg_output;
    }

    // Execute the second query
    const query2 = `
      SELECT *, MAX(demp_count) as at, MAX(iemp_count) AS it
      FROM geopos_operator
      WHERE item = '${itemId}' AND date = '${dates}'
      GROUP BY zone, machine, item, date
    `;
    const query2Result = await pppQuery(query2);
   // console.log(query2 + '2----------------------');
    let tw = 0;
    for (const wr of query2Result) {
      tw +=+ wr.at + +wr.it;
    }

    console.log(fg + '----------------------' + tw);
    tw1 = tw.toFixed(4);
    console.log(tw1 + '----------------------' );
    const divide = fg / tw1;
    res.json(divide);
    console.log(divide + '----------------------');
  } catch (error) {
    console.error('Error:', error);
    res.status(500).json({ error: 'Internal Server Error' });
  }
});
// Function to execute a query and return a promise
function pppQuery(query, params) {
  return new Promise((resolve, reject) => {
    db.query(query, params, (err, results) => {
      if (err) {
        reject(err);
      } else {
        resolve(results);
      }
    });
  });
}

//PPP Overall Report

//default data
app.get('/getdefault_ppp_overall', (req, res) => {
  const date = new Date().toLocaleDateString('en-GB', { timeZone: 'Africa/Lagos' });
  const parts = date.split('/');
  const day = parts[0].padStart(2, '0');
  const month = parts[1].padStart(2, '0');
  const year = parts[2];
  const newcurrentDate1 = `${day}-${month}-${year}`;
  let pw = (0).toFixed(2);

  // Replace this with your database query logic
  const query = 'SELECT * FROM item_masterr';

  db.query(query, (err, results) => {
    if (err) {
      console.error('Error querying database:', err);
      res.status(500).json({ error: 'Internal Server Error' });
    } else {
      // Construct the data object to send to the client
      const data = {
        items: results,
        from: newcurrentDate1,
        to: newcurrentDate1,
        tdate: 0, // You can set this value as needed
      };

      res.json(data);
    }
  });
});

// date filter search
app.post('/ppp_overall_daterangeview', (req, res) => {
  const fromdate = req.body.fromdate;
  const fdParts = fromdate.split('-');
  const fd = `${fdParts[2]}-${fdParts[1]}-${fdParts[0]}`;

  const todate = req.body.todate;
  const tdParts = todate.split('-');
  const td = `${tdParts[2]}-${tdParts[1]}-${tdParts[0]}`;


  const dateObj = new Date(fromdate);
  const day = dateObj.getDate().toString().padStart(2, '0');
  const month = (dateObj.getMonth() + 1).toString().padStart(2, '0');
  const year = dateObj.getFullYear();

  const convertedDate = `${day}-${month}-${year}`;

  const dateObj1 = new Date(todate);
  const day1 = dateObj1.getDate().toString().padStart(2, '0');
  const month1 = (dateObj1.getMonth() + 1).toString().padStart(2, '0');
  const year1 = dateObj1.getFullYear();

  const convertedDate1 = `${day1}-${month1}-${year1}`;
  console.log('Converted:', convertedDate);
  console.log('Converted2:', convertedDate1);


   // Replace this with your database query logic
  const query = `SELECT * FROM item_masterr `;

  db.query(query, (err, results) => {
    if (err) {
      console.error('Error querying database:', err);
      res.status(500).json({ error: 'Internal Server Error' });
    } else {
      // Construct the data object to send to the client
      const data = {
        items: results,
        from: convertedDate,
        to: convertedDate1,
        tdate: 0, // You can set this value as needed
      };

      res.json(data);
    }
  });
});


//get ppp overall 
app.post('/getpppvalue', async (req, res) => {
  try {
    const receivedData = req.body;
    const { dateColumns } = receivedData;

    //console.log('dateColumns:', dateColumns);
   
    const roleid = 5;

    const resultArray = [];

    const itemData = [];

      for (const dateColumn of dateColumns) {
         console.log('dateColumn:', dateColumn.data); // Log each dateColumn
        let where;

        if (roleid === 5) {
          where = `date='${dateColumn.data}'`;
        } else {
          

          const id1 = 9;
          const query = `
            SELECT geopos_employees.*
            FROM geopos_employees
            LEFT JOIN geopos_users ON geopos_employees.entryid = geopos_users.entryid
            WHERE geopos_users.id = ${id1}
          `;

          const results = await new Promise((resolve, reject) => {
            db.query(query, (err, results) => {
              if (err) {
                console.error('Error executing SQL query:', err);
                reject(err);
              } else {
                resolve(results);
              }
            });
          });

          if (results.length === 0) {
            return res.status(404).json({ error: 'Employee not found' });
          }

          const empid = results[0].id;
          where = `date='${dateColumn}' AND emp_id='${empid}'`;
        }

        const query = `
          SELECT *
          FROM geopos_operator
          WHERE ${where}
          
        `;

        const operatorResults = await new Promise((resolve, reject) => {
          db.query(query, (err, results) => {
            if (err) {
              console.error('Error executing SQL query', err);
              reject(err);
            } else {
              resolve(results);
            }
          });
        });

        //console.log('Operator Results:', operatorResults); // Add this line for console logging
        

        // Now, add another query here
        const anotherQuery = `
            SELECT 
            SUM(iemp_count) AS totalw,
            SUM(demp_count) AS totalwd
           
          FROM geopos_operator
          WHERE ${where}
        
      `;

        

      
      const anotherResults = await new Promise((resolve, reject) => {
        db.query(anotherQuery, (err, results) => {
          if (err) {
            console.error('Error executing another SQL query', err);
            reject(err);
          } else {
            resolve(results);
          }
        });
      });

      //console.log('anotherResults :', anotherResults); // Add this line for console logging
        
          
        let tw = 0;
        let twd = 0; 
        

        for (const wr of anotherResults) {
          tw += parseFloat(wr.totalw);
          twd += parseFloat(wr.totalwd);
          
        }

        const totalw = tw;
        const totalwd = twd;
        const total = (tw + twd).toFixed(2);

        //console.log('total :', total);

       // Now, continue processing 'operatorResults'

        let t = 0;
        let tf = 0;
        

        for (const ws of operatorResults) {
         tf = ws.fg_output;
         t += tf;
         
        }

        const top = t;
        //console.log('tf :', tf);
        //console.log('t :', t);
        //console.log('top :', top);
       
        // Calculate $pw here
        let pw = 0;

        if (top !== 0) {
          pw = (top / total).toFixed(2);
        }
        else{
          pw = 0;
        }
        

   
        itemData.push({
          
          date: dateColumn.data,
          pw,
          
          
        });
      }

      resultArray.push({
        
        item_data: itemData,
      });

     

    // Wrap the resultArray in a data object
    const responseDataObject = {
      data: resultArray,
    };

    // Send the responseDataObject as the response
    res.json(responseDataObject);
  } catch (err) {
    console.error('Error:', err);
    res.status(500).json({ error: 'Server error' });
  }
});


//Machine DownTime Report

//Machine downtime default data 
app.post('/braid/get_machineDowntime_data1', async (req, res) => {
  try {
    const now = new Date();
    const day = String(now.getDate()).padStart(2, '0');
    const month = String(now.getMonth() + 1).padStart(2, '0'); // January is 0!
    const year = now.getFullYear();
    const date = `${day}-${month}-${year}`;
    const period = [date];
  
    const formattedDates = period.map((date) => date);
    // Fetch data for geopos_machine
    const zoneRows = await promisifyQuery10('SELECT * FROM geopos_machine');

    if (zoneRows.length > 0) {
      const responseData = []; // Collect response data here

      for (const zoneItem of zoneRows) {
        const machineList = zoneItem.machine.split(',');

        for (const mach of machineList) {
          const id = zoneItem.zone;
          const zones = `${zoneItem.zone}->${mach}`;
          const valuesByDate = {}; // Store values by date

          for (const dt of period) {
            const d1 = dt; // Format as "d-m-Y"
          
            const where = `zone='${id}' AND machine='${mach}' AND date='${d1}' AND shift='DAY'`;

            try {
              // Fetch data for geopos_operator
              const operatorRows = await promisifyQuery10(`
                SELECT *
                FROM geopos_operator
                WHERE ${where}
                GROUP BY hr_start
              `);
              
              const values = [];

              if (operatorRows.length > 0) {
                const stime = [];
                const etime = [];
                //console.log('ppppp')
                for (const ws of operatorRows) {
                  stime.push(ws.hr_start);
                  etime.push(ws.hr_end);
                }

                stime.sort((a, b) => a.localeCompare(b));
                etime.sort((a, b) => a.localeCompare(b));

                let totalt = 0;

                for (let k = 0; k < stime.length; k++) {
                  if (k === 0) {
                    trange = '07:30';
                    ed = stime[k];
                  } else {
                    trange = etime[k - 1];
                    ed = stime[k];
                  }

                  const time1 = new Date(`1970-01-01T${trange}:00Z`);
                  const time2 = new Date(`1970-01-01T${ed}:00Z`);
                  const difference = Math.abs((time2 - time1) / 60000);

                  totalt += difference;

                  if (trange !== ed) {
                    //values.push(`${trange}-${ed}`);
                    values.push(`<span style="background-color:#6edde2;line-height: 2;font-size: 11px;">${trange}-${ed}</span>`);
                  }

                  if (k === stime.length - 1) {
                    ed = '18:30';
                    const time11 = new Date(`1970-01-01T${etime[k]}:00Z`);
                    const time21 = new Date(`1970-01-01T${ed}:00Z`);
                    const difference1 = Math.abs((time21 - time11) / 60000);

                    totalt += difference1;

                    if (etime[k] !== ed) {
                      //values.push(`${etime[k]}-${ed}`);
                      values.push(`<span style="background-color:#6edde2;line-height: 2;font-size: 11px;">${etime[k]}-${ed}</span>`);
                    }
                  }
                }

                let color = '#59d474';
                let color1 = 'black';
                let hours = `${Math.floor(totalt / 60)} hrs & ${totalt % 60} mins`;

                if (operatorRows.length === 0) {
                  hours = 'X';
                  color = '#fff';
                  color1 = 'red';
                }

                values.push(`<span style="background-color:${color};line-height: 2;font-size: 14px;padding: 2px 2px 2px 2px;color:${color1};">${hours}</span>`);
              } else {
                // Handle case when operatorRows is empty
                values.push('X');
              }

              // Store values for this date
              valuesByDate[d1] = values;
              //console.log(`Values for date ${d1}:`, valuesByDate[d1]);
            } catch (dbError) {
              console.error('Database Error:', dbError);
              // Initialize values for this date as an array containing an error message
              valuesByDate[d1] = ['Error fetching data'];
            }
          }

          // Push the data for this machine to responseData
          responseData.push({
            zones: zones,
            values: valuesByDate,
            dates: formattedDates,
          });
        }
      }

      // Send the response data
      res.json(responseData);
      console.log(responseData);
    } else {
      // Handle case when zoneRows is empty
      res.status(404).json({ error: 'No data found' });
    }
  } catch (error) {
    console.error(error);
    res.status(500).json({ error: 'An error occurred' });
  }
});


function promisifyQuery10(query, values) {
  return new Promise((resolve, reject) => {
    db.query(query, values, (err, results) => {
      if (err) {
        reject(err);
      } else {
        resolve(results);
      }
    });
  });
}

//machine downtime search data
app.post('/braid/get_machineDowntime_data2', async (req, res) => {
  try {
    const { fromdate, todate } = req.body;
    const timezone = 'Africa/Lagos';

    let from = '';
    let to = '';

    if (fromdate && todate) {
      from = new Date(fromdate);
      to = new Date(todate);
    } else {
      const now = new Date();
      const day = String(now.getDate()).padStart(2, '0');
      const month = String(now.getMonth() + 1).padStart(2, '0');
      const year = now.getFullYear();
      const date = `${day}-${month}-${year}`;
      from = new Date(date);
      to = new Date(date);
    }
console.log(from,'----');
    from.toLocaleString('en-US', { timeZone: timezone });
    to.toLocaleString('en-US', { timeZone: timezone });

    const period = [];
    const date = new Date(from);

    while (date <= to) {
      period.push(new Date(date));
      date.setDate(date.getDate() + 1);
    }

    // Function to format a date as "d-m-Y"
    
    const formatDate = (date) => {
      const day = String(date.getDate()).padStart(2, '0');
      const month = String(date.getMonth() + 1).padStart(2, '0');
      const year = date.getFullYear();
      return `${day}-${month}-${year}`;
    };
    
  
    const formattedDates = period.map((date) => formatDate(date));
    // Fetch data for geopos_machine
    const zoneRows = await promisifyQuery10('SELECT * FROM geopos_machine');

    if (zoneRows.length > 0) {
      const responseData = []; // Collect response data here

      for (const zoneItem of zoneRows) {
        const machineList = zoneItem.machine.split(',');

        for (const mach of machineList) {
          const id = zoneItem.zone;
          const zones = `${zoneItem.zone}->${mach}`;
          const valuesByDate = {}; // Store values by date

          for (const dt of period) {
            const d1 = formatDate(dt); // Format as "d-m-Y"
          
            const where = `zone='${id}' AND machine='${mach}' AND date='${d1}' AND shift='DAY'`;

            try {
              // Fetch data for geopos_operator
              const operatorRows = await promisifyQuery10(`
                SELECT *
                FROM geopos_operator
                WHERE ${where}
                GROUP BY hr_start
              `);
              
              const values = [];

              if (operatorRows.length > 0) {
                const stime = [];
                const etime = [];
                //console.log('ppppp')
                for (const ws of operatorRows) {
                  stime.push(ws.hr_start);
                  etime.push(ws.hr_end);
                }

                stime.sort((a, b) => a.localeCompare(b));
                etime.sort((a, b) => a.localeCompare(b));

                let totalt = 0;

                for (let k = 0; k < stime.length; k++) {
                  if (k === 0) {
                    trange = '07:30';
                    ed = stime[k];
                  } else {
                    trange = etime[k - 1];
                    ed = stime[k];
                  }

                  const time1 = new Date(`1970-01-01T${trange}:00Z`);
                  const time2 = new Date(`1970-01-01T${ed}:00Z`);
                  const difference = Math.abs((time2 - time1) / 60000);

                  totalt += difference;

                  if (trange !== ed) {
                    //values.push(`${trange}-${ed}`);
                    values.push(`<span style="background-color:#6edde2;line-height: 2;font-size: 11px;">${trange}-${ed}</span>`);
                  }

                  if (k === stime.length - 1) {
                    ed = '18:30';
                    const time11 = new Date(`1970-01-01T${etime[k]}:00Z`);
                    const time21 = new Date(`1970-01-01T${ed}:00Z`);
                    const difference1 = Math.abs((time21 - time11) / 60000);

                    totalt += difference1;

                    if (etime[k] !== ed) {
                      //values.push(`${etime[k]}-${ed}`);
                      values.push(`<span style="background-color:#6edde2;line-height: 2;font-size: 11px;">${etime[k]}-${ed}</span>`);
                    }
                  }
                }

                let color = '#59d474';
                let color1 = 'black';
                let hours = `${Math.floor(totalt / 60)} hrs & ${totalt % 60} mins`;

                if (operatorRows.length === 0) {
                  hours = 'X';
                  color = '#fff';
                  color1 = 'red';
                }

                values.push(`<span style="background-color:${color};line-height: 2;font-size: 14px;padding: 2px 2px 2px 2px;color:${color1};">${hours}</span>`);
              } else {
                // Handle case when operatorRows is empty
                values.push('X');
              }

              // Store values for this date
              valuesByDate[d1] = values;
             // console.log(`Values for date ${d1}:`, valuesByDate[d1]);
            } catch (dbError) {
              console.error('Database Error:', dbError);
              // Initialize values for this date as an array containing an error message
              valuesByDate[d1] = ['Error fetching data'];
            }
          }

          // Push the data for this machine to responseData
          responseData.push({
            zones: zones,
            values: valuesByDate,
            dates: formattedDates,
            fdate: from,
            tdate:to,
          });
        }
      }

      // Send the response data
      res.json(responseData);
     // console.log(responseData);
    } else {
      // Handle case when zoneRows is empty
      res.status(404).json({ error: 'No data found' });
    }
  } catch (error) {
    console.error(error);
    res.status(500).json({ error: 'An error occurred' });
  }
});


function promisifyQuery10(query, values) {
  return new Promise((resolve, reject) => {
    db.query(query, values, (err, results) => {
      if (err) {
        reject(err);
      } else {
        resolve(results);
      }
    });
  });
}


//Machine Efficiency FG Output Report

//Machine Eff FgOutput default data
app.get('/braid/get_machineEffFgoutput_data', async (req, res) => {
  try {
    const now = new Date();
    const day = String(now.getDate()).padStart(2, '0');
    const month = String(now.getMonth() + 1).padStart(2, '0'); // January is 0!
    const year = now.getFullYear();
    const date = `${day}-${month}-${year}`;
    console.log('Dates:', date);
    const period = [date];
  
    const formattedDates = period.map((date) => date);
     console.log('Formatted Dates:', formattedDates);
    // Fetch data for geopos_machine
    const zoneRows = await machineEffQuery('SELECT * FROM geopos_machine');

    if (zoneRows.length > 0) {
      const responseData = []; // Collect response data here

      for (const zoneItem of zoneRows) {
        const machineList = zoneItem.machine.split(',');

        for (const mach of machineList) {
          const id = zoneItem.zone;
          const zones = `${zoneItem.zone}->${mach}`;
          const valuesByDate = {}; // Store values by date

          for (const dt of period) {
            const d1 = dt; // Format as "d-m-Y"
          
            const where = `geopos_operator.zone='${id}' AND geopos_operator.machine='${mach}' AND geopos_operator.date='${d1}' AND geopos_operator.shift='DAY'`;

            try {
              // Fetch data for geopos_operator
              const operatorRows = await machineEffQuery(`
              SELECT *
              FROM geopos_operator
              LEFT JOIN item_masterr ON item_masterr.id = geopos_operator.item
              WHERE ${where}
              `);
              
              const values = [];

              if (operatorRows.length > 0) {
                let rs = 0; // Initialize as a float
                let re = 0; // Initialize as a float
              
                for (const ws of operatorRows) {
                  const tf = parseFloat(ws.fiber); // Convert to float
                  const netWeight = parseFloat(ws.net_weight);
                  const targetedWaste = parseFloat(ws.targeted_waste);
                  const fgOutput = parseFloat(ws.fg_output);
                  console.log(`Processing Operator Row: tf=${tf}, netWeight=${netWeight}, targetedWaste=${targetedWaste}, fgOutput=${fgOutput}`);
              
                  // Check if denominator is not zero to avoid division by zero
                  if (netWeight + targetedWaste !== 0) {
                    const tfg = (tf * 1000) / (netWeight + targetedWaste);
                    rs += tfg; // Add to rs without Math.floor
                    re += fgOutput; // Convert to float
                    console.log(`Intermediate Calculation: tfg=${tfg}, rs=${rs}, re=${re}`);
                  }
                }
              
                if (rs !== 0.0) { // Check against float value
                  const pw = (re / rs) * 100;
                  values.push(`${pw.toFixed(2)}%`);
                  console.log(`Calculated Percentage: ${pw.toFixed(2)}%`);
                } else {
                  values.push('N/A');
                }
              }else {
                // Handle case when operatorRows is empty
                values.push('N/A');
              }

              // Store values for this date
              valuesByDate[d1] = values;
              console.log(`Values for date ${d1}:`, valuesByDate[d1]);
             // console.log(`Values for date ${d1}:`, valuesByDate[d1]);
            } catch (dbError) {
              console.error('Database Error:', dbError);
              // Initialize values for this date as an array containing an error message
              valuesByDate[d1] = ['Error fetching data'];
            }
          }

          // Push the data for this machine to responseData
          responseData.push({
            zones: zones,
            values: valuesByDate,
            dates: formattedDates,
          });
        }
      }

      // Send the response data
      res.json(responseData);
      console.log(responseData);
    } else {
      // Handle case when zoneRows is empty
      res.status(404).json({ error: 'No data found' });
    }
  } catch (error) {
    console.error(error);
    res.status(500).json({ error: 'An error occurred' });
  }
});


function machineEffQuery(query, values) {
  return new Promise((resolve, reject) => {
    db.query(query, values, (err, results) => {
      if (err) {
        reject(err);
      } else {
        resolve(results);
      }
    });
  });
}

//machine eff fgoutput search wise data
app.post('/braid/get_machineEffFgoutput_search_data', async (req, res) => {
  try {
    const { fromdate, todate } = req.body;
    const timezone = 'Africa/Lagos';

    let from = '';
    let to = '';

    if (fromdate && todate) {
      from = new Date(fromdate);
      to = new Date(todate);
    }

    from.toLocaleString('en-US', { timeZone: timezone });
    to.toLocaleString('en-US', { timeZone: timezone });

    const period = [];
    const date = new Date(from);

    while (date <= to) {
      period.push(new Date(date));
      date.setDate(date.getDate() + 1);
    }

    // Function to format a date as "d-m-Y"
    
    const formatDate = (date) => {
      const day = String(date.getDate()).padStart(2, '0');
      const month = String(date.getMonth() + 1).padStart(2, '0');
      const year = date.getFullYear();
      return `${day}-${month}-${year}`;
    };
    
  
    const formattedDates = period.map((date) => formatDate(date));
    // Fetch data for geopos_machine
    const zoneRows = await machineEffQuery1('SELECT * FROM geopos_machine');

    if (zoneRows.length > 0) {
      const responseData = []; // Collect response data here

      for (const zoneItem of zoneRows) {
        const machineList = zoneItem.machine.split(',');

        for (const mach of machineList) {
          const id = zoneItem.zone;
          const zones = `${zoneItem.zone}->${mach}`;
          const valuesByDate = {}; // Store values by date

          for (const dt of period) {
            const d1 = formatDate(dt); // Format as "d-m-Y"
           console.log
            const where = `geopos_operator.zone='${id}' AND geopos_operator.machine='${mach}' AND geopos_operator.date='${d1}' AND geopos_operator.shift='DAY'`;

            try {
              // Fetch data for geopos_operator
              const operatorRows = await machineEffQuery1(`
              SELECT *
              FROM geopos_operator
              LEFT JOIN item_masterr ON item_masterr.id = geopos_operator.item
              WHERE ${where}
              `);
              
              const values = [];

              if (operatorRows.length > 0) {
                let rs = 0.0; // Initialize as a float
                let re = 0.0; // Initialize as a float
              
                for (const ws of operatorRows) {
                  const tf = parseFloat(ws.fiber); // Convert to float
                  const netWeight = parseFloat(ws.net_weight);
                  const targetedWaste = parseFloat(ws.targeted_waste);
                  const fgOutput = parseFloat(ws.fg_output);
              
                  // Check if denominator is not zero to avoid division by zero
                  if (netWeight + targetedWaste !== 0) {
                    const tfg = (tf * 1000) / (netWeight + targetedWaste);
                    rs += tfg; // Add to rs without Math.floor
                    re += fgOutput; // Convert to float
                  }
                }
              
                if (rs !== 0.0) { // Check against float value
                  const pw = (re / rs) * 100;
                  values.push(`${pw.toFixed(2)}%`);
                } else {
                  values.push('N/A');
                }
              }else {
                // Handle case when operatorRows is empty
                values.push('N/A');
              }

              // Store values for this date
              valuesByDate[d1] = values;
             // console.log(`Values for date ${d1}:`, valuesByDate[d1]);
            } catch (dbError) {
              console.error('Database Error:', dbError);
              // Initialize values for this date as an array containing an error message
              valuesByDate[d1] = ['Error fetching data'];
            }
          }

          // Push the data for this machine to responseData
          responseData.push({
            zones: zones,
            values: valuesByDate,
            dates: formattedDates,
            fdate:from,
            tdate:to,
          });
        }
      }

      // Send the response data
      res.json(responseData);
      console.log(responseData);
    } else {
      // Handle case when zoneRows is empty
      res.status(404).json({ error: 'No data found' });
    }
  } catch (error) {
    console.error(error);
    res.status(500).json({ error: 'An error occurred' });
  }
});


function machineEffQuery1(query, values) {
  return new Promise((resolve, reject) => {
    db.query(query, values, (err, results) => {
      if (err) {
        reject(err);
      } else {
        resolve(results);
      }
    });
  });
}


//Machine Efficiency Waste Report

//Machine Eff waste Report dafault data
app.get('/braid/get_machineEffWaste_data', async (req, res) => {
  try {
    const now = new Date();
    const day = String(now.getDate()).padStart(2, '0');
    const month = String(now.getMonth() + 1).padStart(2, '0'); // January is 0!
    const year = now.getFullYear();
    const date = `${day}-${month}-${year}`;
    const period = [date];
  
    const formattedDates = period.map((date) => date);
    // Fetch data for geopos_machine
    const zoneRows = await wasteEffQuery('SELECT * FROM geopos_machine');

    if (zoneRows.length > 0) {
      const responseData = []; // Collect response data here

      for (const zoneItem of zoneRows) {
        const machineList = zoneItem.machine.split(',');

        for (const mach of machineList) {
          const id = zoneItem.zone;
          const zones = `${zoneItem.zone}->${mach}`;
          const valuesByDate = {}; // Store values by date

          for (const dt of period) {
            const d1 = dt; // Format as "d-m-Y"
          
            const where = `geopos_operator.zone='${id}' AND geopos_operator.machine='${mach}' AND geopos_operator.date='${d1}' AND geopos_operator.shift='DAY'`;

            try {
              // Fetch data for geopos_operator
              const operatorRows = await wasteEffQuery(`
              SELECT *
              FROM geopos_operator
              LEFT JOIN item_masterr ON item_masterr.id = geopos_operator.item
              WHERE ${where}
              `);
              
              const values = [];

              if (operatorRows.length > 0) {
                let rs = 0;
                let wst = 0;

                for (const ws of operatorRows) {
                  // Convert string values to integers
                  const tf = parseInt(ws.fiber, 10);
                  const netWeight = parseInt(ws.net_weight, 10);
                  const targetedWaste = parseInt(ws.targeted_waste, 10);
                  const wasteWeight = parseInt(ws.waste_weight, 10);

                  const tfg = (tf * 1000) / (netWeight + targetedWaste);
                  const tww = tf * 1000 - netWeight * tfg;
                  rs += tww;
                  wst += wasteWeight;
                }

                if (wst !== 0) {
                  const pw = (wst / rs) * 100;
                  values.push(pw.toFixed(2) + '%');
                } else {
                  values.push('N/A');
                }


              }else {
                // Handle case when operatorRows is empty
                values.push('N/A');
              }

              // Store values for this date
              valuesByDate[d1] = values;
             // console.log(`Values for date ${d1}:`, valuesByDate[d1]);
            } catch (dbError) {
              console.error('Database Error:', dbError);
              // Initialize values for this date as an array containing an error message
              valuesByDate[d1] = ['Error fetching data'];
            }
          }

          // Push the data for this machine to responseData
          responseData.push({
            zones: zones,
            values: valuesByDate,
            dates: formattedDates,
          });
        }
      }

      // Send the response data
      res.json(responseData);
      console.log(responseData);
    } else {
      // Handle case when zoneRows is empty
      res.status(404).json({ error: 'No data found' });
    }
  } catch (error) {
    console.error(error);
    res.status(500).json({ error: 'An error occurred' });
  }
});


function wasteEffQuery(query, values) {
  return new Promise((resolve, reject) => {
    db.query(query, values, (err, results) => {
      if (err) {
        reject(err);
      } else {
        resolve(results);
      }
    });
  });
}

//Machine eff waste search report
app.post('/braid/get_machineEffWaste_search_data', async (req, res) => {
  try {
    const { fromdate, todate } = req.body;
    const timezone = 'Africa/Lagos';

    let from = '';
    let to = '';

    if (fromdate && todate) {
      from = new Date(fromdate);
      to = new Date(todate);
    }

    from.toLocaleString('en-US', { timeZone: timezone });
    to.toLocaleString('en-US', { timeZone: timezone });

    const period = [];
    const date = new Date(from);

    while (date <= to) {
      period.push(new Date(date));
      date.setDate(date.getDate() + 1);
    }

    // Function to format a date as "d-m-Y"
    
    const formatDate = (date) => {
      const day = String(date.getDate()).padStart(2, '0');
      const month = String(date.getMonth() + 1).padStart(2, '0');
      const year = date.getFullYear();
      return `${day}-${month}-${year}`;
    };
    
  
    const formattedDates = period.map((date) => formatDate(date));
    // Fetch data for geopos_machine
    const zoneRows = await machineEffQuery1('SELECT * FROM geopos_machine');

    if (zoneRows.length > 0) {
      const responseData = []; // Collect response data here

      for (const zoneItem of zoneRows) {
        const machineList = zoneItem.machine.split(',');

        for (const mach of machineList) {
          const id = zoneItem.zone;
          const zones = `${zoneItem.zone}->${mach}`;
          const valuesByDate = {}; // Store values by date

          for (const dt of period) {
            const d1 = formatDate(dt); // Format as "d-m-Y"
           console.log
            const where = `geopos_operator.zone='${id}' AND geopos_operator.machine='${mach}' AND geopos_operator.date='${d1}' AND geopos_operator.shift='DAY'`;

            try {
              // Fetch data for geopos_operator
              const operatorRows = await machineEffQuery1(`
              SELECT *
              FROM geopos_operator
              LEFT JOIN item_masterr ON item_masterr.id = geopos_operator.item
              WHERE ${where}
              `);
              
              const values = [];

              if (operatorRows.length > 0) {
                let rs = 0;
                let wst = 0;

                for (const ws of operatorRows) {
                  // Convert string values to integers
                  const tf = parseFloat(ws.fiber);
                  const netWeight = parseFloat(ws.net_weight);
                  const targetedWaste = parseFloat(ws.targeted_waste);
                  const wasteWeight = parseFloat(ws.waste_weight);

                  const tfg = (tf * 1000) / (netWeight + targetedWaste);
                  const tww = tf * 1000 - netWeight * tfg;
                  rs += tww;
                  wst += wasteWeight;
                }

                if (wst !== 0) {
                  const pw = (wst / rs) * 100;
                  values.push(pw.toFixed(2) + '%');
                } else {
                  values.push('N/A');
                }
              }else {
                // Handle case when operatorRows is empty
                values.push('N/A');
              }

              // Store values for this date
              valuesByDate[d1] = values;
             // console.log(`Values for date ${d1}:`, valuesByDate[d1]);
            } catch (dbError) {
              console.error('Database Error:', dbError);
              // Initialize values for this date as an array containing an error message
              valuesByDate[d1] = ['Error fetching data'];
            }
          }

          // Push the data for this machine to responseData
          responseData.push({
            zones: zones,
            values: valuesByDate,
            dates: formattedDates,
            fdate:from,
            tdate:to,
          });
        }
      }

      // Send the response data
      res.json(responseData);
      console.log(responseData);
    } else {
      // Handle case when zoneRows is empty
      res.status(404).json({ error: 'No data found' });
    }
  } catch (error) {
    console.error(error);
    res.status(500).json({ error: 'An error occurred' });
  }
});


function machineEffQuery1(query, values) {
  return new Promise((resolve, reject) => {
    db.query(query, values, (err, results) => {
      if (err) {
        reject(err);
      } else {
        resolve(results);
      }
    });
  });
}





//Machine Efficiency PPM Report

//Machine Eff PPM Report dafault data
app.get('/braid/get_machineEffPpm_data', async (req, res) => {
  try {
    const now = new Date();
    const day = String(now.getDate()).padStart(2, '0');
    const month = String(now.getMonth() + 1).padStart(2, '0'); // January is 0!
    const year = now.getFullYear();
    const date = `${day}-${month}-${year}`;
    const period = [date];
  
    const formattedDates = period.map((date) => date);
    // Fetch data for geopos_machine
    const zoneRows = await ppmEffQuery('SELECT * FROM geopos_machine');

    if (zoneRows.length > 0) {
      const responseData = []; // Collect response data here

      for (const zoneItem of zoneRows) {
        const machineList = zoneItem.machine.split(',');

        for (const mach of machineList) {
          const id = zoneItem.zone;
          const zones = `${zoneItem.zone}->${mach}`;
          const valuesByDate = {}; // Store values by date

          for (const dt of period) {
            const d1 = dt; // Format as "d-m-Y"
          
            const where = `geopos_operator.zone='${id}' AND geopos_operator.machine='${mach}' AND geopos_operator.date='${d1}' AND geopos_operator.shift='DAY'`;

            try {
              // Fetch data for geopos_operator
              const operatorRows = await ppmEffQuery(`
              SELECT *
              FROM geopos_operator
              LEFT JOIN item_masterr ON item_masterr.id = geopos_operator.item
              WHERE ${where}
              `);
              
              const values = [];

              if (operatorRows.length > 0) {
                let t = 0;
                let hour = 0;
                
                for (const ws of operatorRows) {
                  const tf =parseFloat(ws.fg_output);
                  t += tf;
                  hour++;
                }

                if (t !== 0) {
                  const pw = (t / hour).toFixed(2);
                  values.push(pw);
                } else {
                  values.push('N/A');
                }

              }else {
                // Handle case when operatorRows is empty
                values.push('N/A');
              }

              // Store values for this date
              valuesByDate[d1] = values;
              //console.log(`Values for date ${d1}:`, valuesByDate[d1]);
            } catch (dbError) {
              console.error('Database Error:', dbError);
              // Initialize values for this date as an array containing an error message
              valuesByDate[d1] = ['Error fetching data'];
            }
          }

          // Push the data for this machine to responseData
          responseData.push({
            zones: zones,
            values: valuesByDate,
            dates: formattedDates,
          });
        }
      }

      // Send the response data
      res.json(responseData);
      console.log(responseData);
    } else {
      // Handle case when zoneRows is empty
      res.status(404).json({ error: 'No data found' });
    }
  } catch (error) {
    console.error(error);
    res.status(500).json({ error: 'An error occurred' });
  }
});


function ppmEffQuery(query, values) {
  return new Promise((resolve, reject) => {
    db.query(query, values, (err, results) => {
      if (err) {
        reject(err);
      } else {
        resolve(results);
      }
    });
  });
}
//Machine eff waste search report
app.post('/braid/get_machineEffppm_search_data', async (req, res) => {
  try {
    const { fromdate, todate } = req.body;
    const timezone = 'Africa/Lagos';

    let from = '';
    let to = '';

    if (fromdate && todate) {
      from = new Date(fromdate);
      to = new Date(todate);
    }

    from.toLocaleString('en-US', { timeZone: timezone });
    to.toLocaleString('en-US', { timeZone: timezone });

    const period = [];
    const date = new Date(from);

    while (date <= to) {
      period.push(new Date(date));
      date.setDate(date.getDate() + 1);
    }

    // Function to format a date as "d-m-Y"
    
    const formatDate = (date) => {
      const day = String(date.getDate()).padStart(2, '0');
      const month = String(date.getMonth() + 1).padStart(2, '0');
      const year = date.getFullYear();
      return `${day}-${month}-${year}`;
    };
    
  
    const formattedDates = period.map((date) => formatDate(date));
    // Fetch data for geopos_machine
    const zoneRows = await ppmEffQuery1('SELECT * FROM geopos_machine');

    if (zoneRows.length > 0) {
      const responseData = []; // Collect response data here

      for (const zoneItem of zoneRows) {
        const machineList = zoneItem.machine.split(',');

        for (const mach of machineList) {
          const id = zoneItem.zone;
          const zones = `${zoneItem.zone}->${mach}`;
          const valuesByDate = {}; // Store values by date

          for (const dt of period) {
            const d1 = formatDate(dt); // Format as "d-m-Y"
           console.log
            const where = `geopos_operator.zone='${id}' AND geopos_operator.machine='${mach}' AND geopos_operator.date='${d1}' AND geopos_operator.shift='DAY'`;

            try {
              // Fetch data for geopos_operator
              const operatorRows = await ppmEffQuery1(`
              SELECT *
              FROM geopos_operator
              LEFT JOIN item_masterr ON item_masterr.id = geopos_operator.item
              WHERE ${where}
              `);
              
              const values = [];

              if (operatorRows.length > 0) {
                let t = 0;
                let hour = 0;
                
                for (const ws of operatorRows) {
                  const tf =parseFloat(ws.fg_output);
                  t += tf;
                  hour++;
                }

                if (t !== 0) {
                  const pw = (t / hour).toFixed(2);
                  values.push(pw);
                } else {
                  values.push('N/A');
                }
              }else {
                // Handle case when operatorRows is empty
                values.push('N/A');
              }

              // Store values for this date
              valuesByDate[d1] = values;
              //console.log(`Values for date ${d1}:`, valuesByDate[d1]);
            } catch (dbError) {
              console.error('Database Error:', dbError);
              // Initialize values for this date as an array containing an error message
              valuesByDate[d1] = ['Error fetching data'];
            }
          }

          // Push the data for this machine to responseData
          responseData.push({
            zones: zones,
            values: valuesByDate,
            dates: formattedDates,
            fdate:from,
            tdate:to,
          });
        }
      }

      // Send the response data
      res.json(responseData);
      console.log(responseData);
    } else {
      // Handle case when zoneRows is empty
      res.status(404).json({ error: 'No data found' });
    }
  } catch (error) {
    console.error(error);
    res.status(500).json({ error: 'An error occurred' });
  }
});


function ppmEffQuery1(query, values) {
  return new Promise((resolve, reject) => {
    db.query(query, values, (err, results) => {
      if (err) {
        reject(err);
      } else {
        resolve(results);
      }
    });
  });
}




//Machine Hour Report

//Braid Machine hours default data
app.get('/braid/get_machineHour_data', async (req, res) => {
  try {
    const now = new Date();
    const day = String(now.getDate()).padStart(2, '0');
    const month = String(now.getMonth() + 1).padStart(2, '0'); // January is 0!
    const year = now.getFullYear();
    const date = `${day}-${month}-${year}`;
    const period = [date];
  
    const formattedDates = period.map((date) => date);
    // Fetch data for geopos_machine
    const zoneRows = await machineHrQuery('SELECT * FROM geopos_machine');

     // Function to format a date as "d-m-Y"
    
    const formatDate = (date) => {
      const day = String(date.getDate()).padStart(2, '0');
      const month = String(date.getMonth() + 1).padStart(2, '0');
      const year = date.getFullYear();
      return `${day}-${month}-${year}`;
    };

    if (zoneRows.length > 0) {
      const responseData = []; // Collect response data here

      for (const zoneItem of zoneRows) {
        const machineList = zoneItem.machine.split(',');

        for (const mach of machineList) {
          const id = zoneItem.zone;
          const zones = `${zoneItem.zone}->${mach}`;
          const valuesByDate = {}; // Store values by date

          for (const dt of period) {
            const d1 = dt; // Format as "d-m-Y"
           console.log
            const where = `geopos_operator.zone='${id}' AND geopos_operator.machine='${mach}' AND geopos_operator.date='${d1}'`;

            try {
              // Fetch data for geopos_operator
              const operatorRows = await machineHrQuery1(`
              SELECT *
              FROM geopos_operator
              LEFT JOIN item_masterr ON item_masterr.id = geopos_operator.item
              WHERE ${where}
              `);
              
              const values = [];

              if (operatorRows.length > 0) {
                const count = operatorRows.length;
                values.push(count);
              }else {
                // Handle case when operatorRows is empty
                values.push('0');
              }

              // Store values for this date
              valuesByDate[d1] = values;
              //console.log(`Values for date ${d1}:`, valuesByDate[d1]);
            } catch (dbError) {
              console.error('Database Error:', dbError);
              // Initialize values for this date as an array containing an error message
              valuesByDate[d1] = ['Error fetching data'];
            }
          }

          // Push the data for this machine to responseData
          responseData.push({
            zones: zones,
            values: valuesByDate,
            dates: formattedDates,
          });
        }
      }

      // Send the response data
      res.json(responseData);
      console.log(responseData);
    } else {
      // Handle case when zoneRows is empty
      res.status(404).json({ error: 'No data found' });
    }
  } catch (error) {
    console.error(error);
    res.status(500).json({ error: 'An error occurred' });
  }
});


function machineHrQuery(query, values) {
  return new Promise((resolve, reject) => {
    db.query(query, values, (err, results) => {
      if (err) {
        reject(err);
      } else {
        resolve(results);
      }
    });
  });
}

//Machine hours search report
app.post('/braid/get_machineHour_search_data', async (req, res) => {
  try {
    const { fromdate, todate } = req.body;
    const timezone = 'Africa/Lagos';

    let from = '';
    let to = '';

    if (fromdate && todate) {
      from = new Date(fromdate);
      to = new Date(todate);
    }

    from.toLocaleString('en-US', { timeZone: timezone });
    to.toLocaleString('en-US', { timeZone: timezone });

    const period = [];
    const date = new Date(from);

    while (date <= to) {
      period.push(new Date(date));
      date.setDate(date.getDate() + 1);
    }

    // Function to format a date as "d-m-Y"
    
    const formatDate = (date) => {
      const day = String(date.getDate()).padStart(2, '0');
      const month = String(date.getMonth() + 1).padStart(2, '0');
      const year = date.getFullYear();
      return `${day}-${month}-${year}`;
    };
    
  
    const formattedDates = period.map((date) => formatDate(date));
    // Fetch data for geopos_machine
    const zoneRows = await machineHrQuery1('SELECT * FROM geopos_machine');

    if (zoneRows.length > 0) {
      const responseData = []; // Collect response data here

      for (const zoneItem of zoneRows) {
        const machineList = zoneItem.machine.split(',');

        for (const mach of machineList) {
          const id = zoneItem.zone;
          const zones = `${zoneItem.zone}->${mach}`;
          const valuesByDate = {}; // Store values by date

          for (const dt of period) {
            const d1 = formatDate(dt); // Format as "d-m-Y"
           console.log
            const where = `geopos_operator.zone='${id}' AND geopos_operator.machine='${mach}' AND geopos_operator.date='${d1}'`;

            try {
              // Fetch data for geopos_operator
              const operatorRows = await machineHrQuery1(`
              SELECT *
              FROM geopos_operator
              LEFT JOIN item_masterr ON item_masterr.id = geopos_operator.item
              WHERE ${where}
              `);
              
              const values = [];

              if (operatorRows.length > 0) {
                const count = operatorRows.length;
                values.push(count);
              }else {
                // Handle case when operatorRows is empty
                values.push('0');
              }

              // Store values for this date
              valuesByDate[d1] = values;
              //console.log(`Values for date ${d1}:`, valuesByDate[d1]);
            } catch (dbError) {
              console.error('Database Error:', dbError);
              // Initialize values for this date as an array containing an error message
              valuesByDate[d1] = ['Error fetching data'];
            }
          }

          // Push the data for this machine to responseData
          responseData.push({
            zones: zones,
            values: valuesByDate,
            dates: formattedDates,
            fdate:from,
            tdate:to,
          });
        }
      }

      // Send the response data
      res.json(responseData);
      console.log(responseData);
    } else {
      // Handle case when zoneRows is empty
      res.status(404).json({ error: 'No data found' });
    }
  } catch (error) {
    console.error(error);
    res.status(500).json({ error: 'An error occurred' });
  }
});


function machineHrQuery1(query, values) {
  return new Promise((resolve, reject) => {
    db.query(query, values, (err, results) => {
      if (err) {
        reject(err);
      } else {
        resolve(results);
      }
    });
  });
}


//Non Braid Report


// Attendance Report

//get default data
app.get('/Nbraid/get_attendance_default_data', async (req, res) => {
  try {
    const now = new Date();
    const day = String(now.getDate()).padStart(2, '0');
    const month = String(now.getMonth() + 1).padStart(2, '0'); // January is 0!
    const year = now.getFullYear();
    const date = `${day}-${month}-${year}`;
    const period = [date];
    //console.log(date, '=============');

    // Fetch data for geopos_machine
    const attendance_data = await AttendanceQuery(`SELECT employee_status, SUM(present) as present_count
    FROM ng_attendance
    WHERE employee_status IN ('Contract', 'Outsourcing', 'Casual', 'staff')
    AND date = '${date}'
    GROUP BY employee_status`);

    if (attendance_data.length > 0) {
      const responseData = [];

      for (const row of attendance_data) {
        const status = row.employee_status;
        const presentCount = row.present_count;

        // Create a row object for each status
        responseData.push({
          estatus: status,
          values:presentCount,
          // values: {
          //   [date]: [presentCount], // Set the value for the specific date
          // },
          dates: [date], // An array with a single date
        });
      }

      // Send the response as JSON
      res.json(responseData);
      //console.log(responseData);
    } else {
      // Send an empty array to indicate no data
      res.json('');
    }
  } catch (error) {
    console.error(error);
    res.status(500).json({ error: 'An error occurred' });
  }
});



function AttendanceQuery(query, values) {
  return new Promise((resolve, reject) => {
    db.query(query, values, (err, results) => {
      if (err) {
        reject(err);
      } else {
        resolve(results);
      }
    });
  });
}

//Attendance query search data
app.post('/Nbraid/get_attendance_search_data', async (req, res) => {
  try {
  
    const cat = req.body.category;
    const shift = req.body.shift;
    const site = req.body.site;

    const fromdate = req.body.fromdate;
    const todate = req.body.todate;
  
    const dateObj = new Date(fromdate);
    const day = dateObj.getDate().toString().padStart(2, '0');
    const month = (dateObj.getMonth() + 1).toString().padStart(2, '0');
    const year = dateObj.getFullYear();
    const convertedDate = `${day}-${month}-${year}`;

    const dateObj1 = new Date(todate);
    const day1 = dateObj1.getDate().toString().padStart(2, '0');
    const month1 = (dateObj1.getMonth() + 1).toString().padStart(2, '0');
    const year1 = dateObj1.getFullYear();
    const convertedDate1 = `${day1}-${month1}-${year1}`;

    const fd2 = Math.floor(new Date(fromdate).getTime() / 1000);
    const td1 = Math.floor(new Date(todate).getTime() / 1000);
    const fd1 = Math.floor(new Date(fd2 * 1000).setDate(new Date(fd2 * 1000).getDate() - 1) / 1000);

    const period = [];
    const date = new Date(dateObj);

    while (date <= dateObj1) {
      period.push(new Date(date));
      date.setDate(date.getDate() + 1);
    }

    // Function to format a date as "d-m-Y"
    
    const formatDate = (date) => {
      const day = String(date.getDate()).padStart(2, '0');
      const month = String(date.getMonth() + 1).padStart(2, '0');
      const year = date.getFullYear();
      return `${day}-${month}-${year}`;
    };
    
  
    const formattedDates = period.map((date) => formatDate(date));
    // Fetch data for geopos_machine
    let where = `(ng_attendance.time_stamp between '${fd2}' and '${td1}')`;

      if (cat) {
        where += ` AND ng_attendance.category_type='${cat}'`;
      }

      if (shift) {
        where += ` AND ng_attendance.shift='${shift}'`;
      }

      if (site) {
        where += ` AND ng_attendance.site='${site}'`;
      }
    const sql=`SELECT employee_status, SUM(present) as present_count
    FROM ng_attendance
    WHERE employee_status IN ('Contract', 'Outsourcing', 'Casual', 'staff')
    AND ${where}
    GROUP BY employee_status`;
   console.log(sql,'-------------');
    const attendanceSql = await AttendanceQuery1(sql);
    const responseData ={
        dates: formattedDates,
        date:convertedDate+' TO '+convertedDate1,
        cat:cat,
        shift:shift,
        site:site,
        data:[],
    } // Collect response data here
    
 
    
      for (const data of attendanceSql) {
        const e_status = data.employee_status;

        const valuesByDate = {}; // Store values by date
          for (const dt of period) {
            const d1 = formatDate(dt); // Format as "d-m-Y"
  
              let where = `(date = '${d1}' and employee_status='${e_status}')`;

              if (cat) {
                where += ` AND category_type='${cat}'`;
              }

              if (shift) {
                where += ` AND shift='${shift}'`;
              }

              if (site) {
                where += ` AND site='${site}'`;
              }

            try {
              // Fetch data for geopos_operator
              const AttendanceRows = await AttendanceQuery1(`
              SELECT SUM(present) as present_count FROM ng_attendance WHERE ${where}
              `);
              
              const values = [];

              if (AttendanceRows.length > 0) {
    
                for (const count of AttendanceRows) {
                  values.push(count.present_count);
                }
                
              }else {
                values.push('-');
              }

              // Store values for this date
              valuesByDate[d1] = values;
              //console.log(`Values for date ${d1}:`, valuesByDate[d1]);
            } catch (dbError) {
              console.error('Database Error:', dbError);
              // Initialize values for this date as an array containing an error message
              valuesByDate[d1] = ['Error fetching data'];
            }
          }

          // Push the data for this machine to responseData
          responseData.data.push({
            estatus: e_status,
            values: valuesByDate,
          });

      }

      // Send the response data
      res.json(responseData);
      console.log(responseData,"-----------|++++++++")
  } catch (error) {
    console.error(error);
    res.status(500).json({ error: 'An error occurred' });
  }
});


function AttendanceQuery1(query, values) {
  return new Promise((resolve, reject) => {
    db.query(query, values, (err, results) => {
      if (err) {
        reject(err);
      } else {
        resolve(results);
      }
    });
  });
}


//Fg Output Monthly Report

//fg monthly report nbraid default
app.get('/Nbraid/getFgMonthlyDefaultData', (req, res) => {
  const date = new Date().toLocaleDateString('en-GB', { timeZone: 'Africa/Lagos' });
  const parts = date.split('/');
  const formattedDay = parts[0].padStart(2, '0');
  const formattedMonth = parts[1].padStart(2, '0');
  const year = parts[2];
  const date1 = `${formattedDay}-${formattedMonth}-${year}`;
  const mon = `${formattedMonth}-${year}`;
  const fgQuery = `
    SELECT fg_details.*, item_masterr.item_description, SUM(fg_output) as tar
    FROM fg_details
    LEFT JOIN item_masterr ON fg_details.product_name = item_masterr.id
    WHERE SUBSTRING(fg_details.date_time, 4) = '${mon}'
    GROUP BY fg_details.product_name, fg_details.line
  `;

// Execute the first query
db.query(fgQuery, (err, fg) => {
  if (err) {
    console.error('Error executing the SQL query: ' + err.message);
    return res.status(500).json({ error: 'Internal Server Error' });
  }

  if (fg.length === 0) {
    // No data found for fgQuery
    return res.json([]);
  }
  
  const responseData = [];

  // Loop through the result rows
  for (const row of fg) {
    // Define the SQL query to count rows in worker_timesheet
    const countQuery = `
      SELECT * FROM worker_timesheet
      WHERE product_name = '${row.product_name}'
      AND line = '${row.line}'
      AND mon = '${mon}'
      AND shift = '${row.shift}'
      GROUP BY entry_id
    `;

    // Execute the count query
    db.query(countQuery, (err, countResult) => {
      if (err) {
        console.error('Error executing the count query: ' + err.message);
        return res.status(500).json({ error: 'Internal Server Error' });
      }

      // Get the number of rows counted
      const count = countResult.length;
      console.log(count)
      // Prepare the data for JSON response
      const jsonData = {
        item_description: row.item_description,
        line: row.line,
        tar: row.tar,
        countResult: count,
        shift: row.shift,
      };
   console.log(jsonData)
      // Push the JSON data to the response array
      responseData.push(jsonData);
      // Check if all queries have completed before sending the JSON response
      if (responseData.length === fg.length) {
        // Send the response as JSON
        res.json(responseData);
      }
    });
  }
});
});

//fg monthly report nbraid search
app.post('/Nbraid/getFgMonthlyDataSearch', (req, res) => {
  const timeZone = 'Africa/Lagos';
  const start_year = req.body.start_year;
  const start_month = req.body.start_month;

  const year_s = `${start_month}-${start_year}`;
  const startDate = new Date(year_s);
  const mon = year_s;
   // Define the SQL query to retrieve data from fg_details and item_masterr tables
   const fgQuery = `
   SELECT fg_details.*, item_masterr.item_description, SUM(fg_output) as tar
   FROM fg_details
   LEFT JOIN item_masterr ON fg_details.product_name = item_masterr.id
   WHERE SUBSTRING(fg_details.date_time, 4) = '${mon}'
   GROUP BY fg_details.product_name, fg_details.line
 `;

 // Execute the first query
 db.query(fgQuery, (err, fg) => {
   if (err) {
     console.error('Error executing the SQL query: ' + err.message);
     return res.status(500).json({ error: 'Internal Server Error' });
   }

   if (fg.length === 0) {
    // No data found for fgQuery
    return res.json([]);
  }

   const responseData = [];

   // Loop through the result rows
   for (const row of fg) {
     // Define the SQL query to count rows in worker_timesheet
     const countQuery = `
       SELECT * FROM worker_timesheet
       WHERE product_name = '${row.product_name}'
       AND line = '${row.line}'
       AND mon = '${mon}'
       AND shift = '${row.shift}'
       GROUP BY entry_id
     `;

     // Execute the count query
     db.query(countQuery, (err, countResult) => {
       if (err) {
         console.error('Error executing the count query: ' + err.message);
         return res.status(500).json({ error: 'Internal Server Error' });
       }

       // Get the number of rows counted
       const count = countResult.length;
       console.log(count)
       // Prepare the data for JSON response
       const jsonData = {
         item_description: row.item_description,
         line: row.line,
         tar: row.tar,
         countResult: count,
         shift: row.shift || '',
       };
      console.log(jsonData)
       // Push the JSON data to the response array
       responseData.push(jsonData);

       // Check if all queries have completed before sending the JSON response
       if (responseData.length === fg.length) {
         // Send the response as JSON
         res.json(responseData);
       }
     });
   }
 });
});

//Performance Eff Individual Report

//Get Performance Eff individual search data report
app.post('/nbraid/get_performance_eff_individual', async (req, res) => {
  const ikeja = req.body.employees;
  const ota = req.body.employeesota;

  const fromdate = req.body.fromdate;
const todate = req.body.todate;

const dateObj = new Date(fromdate);
const day = dateObj.getDate().toString().padStart(2, '0');
const month = (dateObj.getMonth() + 1).toString().padStart(2, '0');
const year = dateObj.getFullYear();

const convertedDate = `${day}-${month}-${year}`;

const dateObj1 = new Date(todate);
const day1 = dateObj1.getDate().toString().padStart(2, '0');
const month1 = (dateObj1.getMonth() + 1).toString().padStart(2, '0');
const year1 = dateObj1.getFullYear();

const convertedDate1 = `${day1}-${month1}-${year1}`;

const fd2 = Math.floor(dateObj.getTime() / 1000);
const td1 = Math.floor(dateObj1.getTime() / 1000);
const fd1 = Math.floor(new Date(fd2 * 1000).setDate(dateObj.getDate() - 1) / 1000);

console.log(convertedDate);
console.log(convertedDate1);
console.log(fd2);
console.log(td1);
console.log(fd1);



  const whereConditions = [];

  // Check if OTA employee is selected and add it to the WHERE conditions array
  if (ota !== '') {
    whereConditions.push(`(entry_id = '${ota}' AND time_stamp BETWEEN ${fd2} AND  ${td1})`);
  }

  // Check if IKEJA employee is selected and add it to the WHERE conditions array
  if (ikeja !== '') {
    whereConditions.push(`(entry_id = '${ikeja}' AND time_stamp BETWEEN ${fd2} AND  ${td1})`);
  }

  // Join the WHERE conditions using OR to get the combined WHERE clause
  const where = whereConditions.join(' OR ');
  const query = `SELECT *, HOUR1, HOUR2, HOUR3, HOUR4, HOUR5, HOUR6, HOUR7, HOUR8, HOUR9, HOUR10, HOUR11, HOUR1+HOUR2+HOUR3+HOUR4+HOUR5+HOUR6+HOUR7+HOUR8+HOUR9+HOUR10+HOUR11 AS value_sum
    FROM worker_timesheet WHERE ${where} GROUP BY shift, entry_id, product_name, line, section, date_time`;
  console.log(query+'-----');
    try {
      const timesheet = await executeQuery(query);
  
      const resultPromises = timesheet.map(async (item) => {
        let count = 0;
        for (let i = 1; i <= 11; i++) {
          const str = `HOUR${i}`;
          if (item[str] > 0) {
            count++;
          }
        }
        console.log(item.product_name);
        const proQuery = `SELECT * FROM item_masterr WHERE id='${item.product_name}'`;
        const secQuery = `SELECT * FROM section WHERE id='${item.section}'`;
  
        const [proResult, secResult] = await Promise.all([
          executeQuery(proQuery),
          executeQuery(secQuery),
        ]);
  
        const pro = proResult[0].item_description || '';
        const sec = secResult[0].section_name;
  
        const entry = item.entry_id;
        const site = item.site;
        let query1;
        let ss = '';
  
        if (site === 'both') {
          query1 = `SELECT * FROM employees_ota WHERE entryid='${entry}'`;
  
          const result1 = await executeQuery(query1);
  
          if (!result1 || result1.length === 0) {
            query1 = `SELECT * FROM geopos_employees WHERE entryid='${entry}'`;
            ss = 'ikeja';
          } else {
            ss = 'ota';
          }
        } else if (site === 'ikeja') {
          query1 = `SELECT * FROM geopos_employees WHERE entryid='${entry}'`;
          ss = 'ikeja';
        } else if (site === 'ota') {
          query1 = `SELECT * FROM employees_ota WHERE entryid='${entry}'`;
          ss = 'ota';
        }
        console.log(query1,'My query')
        if (query1) {
          const query1Result = await executeQuery(query1);

           const dateParts = query1Result[0].joindate.split(/[- :]/);
           /* const reggDate = new Date(Date.UTC(dateParts[2], dateParts[1] - 1, dateParts[0], dateParts[3], dateParts[4]));
            const regg = reggDate.toLocaleDateString('en-GB', {
              day: '2-digit',
              month: '2-digit',
              year: 'numeric',
            }).replace(/\//g, '-'); */

             let reggDate;
           if (dateParts.length === 3) {
            // Format: d-m-Y
            reggDate = new Date(Date.UTC(dateParts[2], dateParts[1] - 1, dateParts[0]));
            } else if (dateParts.length === 6) {
                // Format: Y-m-d h:i:s
                reggDate = new Date(Date.UTC(dateParts[0], dateParts[1] - 1, dateParts[2], dateParts[3], dateParts[4], dateParts[5]));
            } else {
                console.error('Unsupported date format');
            }

            const regg = `${reggDate.getUTCDate().toString().padStart(2, '0')}-${(reggDate.getUTCMonth() + 1).toString().padStart(2, '0')}-${reggDate.getUTCFullYear().toString()}`;
        
          const datek1 = item.date_time;
        
          const datek11 = new Date(datek1.split('-').reverse().join('-'));
         const regg1 = new Date(regg.split('-').reverse().join('-'));

         const timeDifference = datek11.getTime() - regg1.getTime();
          const diff = Math.floor(timeDifference / (1000 * 60 * 60 * 24)); // Convert to days
          console.log(datek1,regg)
  
          const response = {
            worker: item.worker,
            entry_id: item.entry_id,
            regg,
            diff,
            shift: item.shift,
            sec,
            pro,
            line: item.line,
          };
      
          if (item.actual_target > 0) {
            response.target = item.actual_target * count;
          } else {
            const targetQuery = `SELECT * FROM item_section_ota WHERE section_id='${item.section}' AND item_id='${item.product_name}'`;
            const targetResult = await executeQuery(targetQuery);
  
            response.target = targetResult[0].target * count;
          }
  
          const sum = item.value_sum;
          response.sum = sum ;
          if (item.actual_target > 0) {
            response.efficiency = ((sum / (item.actual_target * count)) * 100).toFixed(2);
          } else {
            response.efficiency = ((sum / response.target) * 100).toFixed(2);
          }
          response.date_time = item.date_time;
          response.ss = ss;
      
          const entry_id = item.entry_id;
          const product_name = item.product_name;
          const section = item.section;
          const line = item.line;
          const shift = item.shift;
          const whereConditions1 = [];

        // console.log('-------------------------------')
            whereConditions1.push(`(entry_id = '${entry_id}' AND (time_stamp BETWEEN ${fd2} AND ${td1}))`);
            const where1 = whereConditions1.join(' AND ');

            const query3 = `SELECT *, HOUR1, HOUR2, HOUR3, HOUR4, HOUR5, HOUR6, HOUR7, HOUR8, HOUR9, HOUR10, HOUR11, HOUR1+HOUR2+HOUR3+HOUR4+HOUR5+HOUR6+HOUR7+HOUR8+HOUR9+HOUR10+HOUR11 AS value_sum 
              FROM worker_timesheet WHERE ${where1} GROUP BY shift, entry_id, product_name, line, section, date_time`;

              //console.log(query3+'1-------------------------------')
          const res = await executeQuery(query3);
          let eff_sum = 0;
          let eff_count = 0;
          let day_count = 0;
          const date_arr = [];
       
          for (const itt of res) {
           
            let ctt = 0;
            for (let j = 1; j <= 11; j++) {
              const sttrr = `HOUR${j}`;
              if (itt[sttrr] > 0) {
                ctt++;
              }
            }

            if (itt.actual_target > 0) {
              const efff = (itt.value_sum / (itt.actual_target * ctt)) * 100;
              eff_sum += parseFloat(efff.toFixed(2));
            } else {
              const act_tarrr = (await executeQuery(`SELECT target FROM item_section_ota WHERE section_id='${itt.section}' AND item_id='${itt.product_name}'`))[0].target;
              const total_tarr = act_tarrr * ctt;
              const efff = (itt.value_sum / total_tarr) * 100;
              eff_sum += parseFloat(efff.toFixed(2));
            }

            const datee = itt.date_time;
            if (!date_arr.includes(datee)) {
              date_arr.push(datee);
              day_count++;
            }
            eff_count++;
          }

          const faef = (eff_sum / eff_count).toFixed(2);
          console.log(faef);
          response.faef = faef;
          response.day_count = day_count;
          return response;
        }
      });
  
      const results = await Promise.all(resultPromises);
  
      res.send(results);
      console.log(results);
    } catch (error) {
      console.error('Error executing MySQL query:', error);
      res.status(500).send('Internal Server Error');
    }
});

function executeQuery(query) {
  return new Promise((resolve, reject) => {
    db.query(query, (err, result) => {
      if (err) {
        reject(err);
      } else {
        resolve(result);
      }
    });
  });
}

//Plan Vs Actual Report

//Plan Vs Actual Report default search
app.get('/Nbraid/getPlanVsactualReportDefault', async (req, res) => {
  try {
    const timeZone = 'Africa/Lagos';
    const options = {
      day: '2-digit',
      month: '2-digit',
      year: 'numeric',
    };

    const date = new Date().toLocaleDateString('en-NG', options).replace(/\//g, '-');
    const targetPlan = 0;
    const category = 2;
    const itemCodeId = 0;
    const query = `
      SELECT *, target_plan as tot
      FROM target_plan_ota
      WHERE date = ? AND target_plan > ? AND category = ? AND item_code_id != ?
    `;

    const results = await new Promise((resolve, reject) => {
      db.query(query, [date, targetPlan, category, itemCodeId], (err, results) => {
        if (err) {
          console.error('Error executing the SQL query: ' + err.stack);
          reject(err);
        } else {
          resolve(results);
        }
      });
    });

    const data = [];

      for (const item of results) {
        const prdd = item.item_code_id;

        const itemCodeQuery = `
          SELECT * FROM item_code WHERE id = ?
        `;

        const rows = await new Promise((resolve, reject) => {
          db.query(itemCodeQuery, [prdd], (err, rows) => {
            if (err) {
              console.error('Error executing the itemCodeQuery: ' + err.stack);
              reject(err);
            } else {
              resolve(rows);
            }
          });
        });

        if (rows.length > 0) {
          const pro = rows[0].product_des;

          const where2 = `date_time='${date}' and product_code='${prdd}'`;
          const geoposOperatorQuery = `
            SELECT SUM(fg_output) as tar
            FROM fg_details
            WHERE ${where2}
            GROUP BY product_code, date_time
          `;

          const rowsGeoPos = await new Promise((resolve, reject) => {
            db.query(geoposOperatorQuery, (err, rows) => {
              if (err) {
                console.error('Error executing the geoposOperatorQuery: ' + err.stack);
                reject(err);
              } else {
                resolve(rows);
              }
            });
          });

          let sump;

          if (rowsGeoPos.length > 0) {
            sump = rowsGeoPos[0].tar;
          } else {
            // Set a default value or null when data is not available
            sump = null;
          }

          data.push({
            product: pro,
            total: item.tot,
            sump: sump,
          });
        }
      }




    if (data.length === 0) {
      res.json({});
    } else {
      res.json(data);
    }
  } catch (error) {
    console.error('Error in the request: ' + error);
    res.status(500).json({ error: 'Internal Server Error' });
  }
});


//Non-Braid Plan Vs Actual Report date wise search 
app.post('/Nbraid/getPlanVsactualReportSearch', async (req, res) => {
  const timeZone = 'Africa/Lagos';

  const options = {
    day: '2-digit',
    month: '2-digit',
    year: 'numeric',
  };

  const date = new Date().toLocaleDateString('en-NG', options).replace(/\//g, '-');

  const fromdate = req.body.fromdate;
  const fdParts = fromdate.split('-');
  const fd = `${fdParts[2]}-${fdParts[1]}-${fdParts[0]}`;

  const todate = req.body.todate;
  const tdParts = todate.split('-');
  const td = `${tdParts[2]}-${tdParts[1]}-${tdParts[0]}`;

  const dateObj = new Date(fromdate);
  const day = dateObj.getDate().toString().padStart(2, '0');
  const month = (dateObj.getMonth() + 1).toString().padStart(2, '0');
  const year = dateObj.getFullYear();
  const convertedDate = `${day}-${month}-${year}`;

  const dateObj1 =new Date(todate);
  const day1 = dateObj1.getDate().toString().padStart(2, '0');
  const month1 = (dateObj1.getMonth() + 1).toString().padStart(2, '0');
  const year1 = dateObj1.getFullYear();
  const convertedDate1 = `${day1}-${month1}-${year1}`;

  const fd2 = Math.floor((new Date(fromdate).getTime()- 2 * 24 * 60 * 60 * 1000) / 1000);
  const td1 = Math.floor(new Date(todate).getTime() / 1000);
  const fd1 = Math.floor(new Date(fd2 * 1000).setDate(new Date(fd2 * 1000).getDate() - 1) / 1000);

  var newfd = fd2;
  var newtd = td1;

  const where = `(timestamp BETWEEN ${newfd} AND ${newtd} AND target_plan > 0 AND category = '2' AND item_code_id != '0')`;

  const query = `
    SELECT *, SUM(target_plan) as tot
    FROM target_plan_ota
    WHERE ${where}
    GROUP BY item_code_id
  `;
  console.log(query);
  // Execute the main query
  try {
    const results = await new Promise((resolve, reject) => {
      db.query(query, (err, results) => {
        if (err) {
          console.error('Error executing the SQL query: ' + err.stack);
          reject('Internal Server Error');
        }
        resolve(results);
      });
    });

    const data={
      fdate: convertedDate,
      tdate: convertedDate1,
      items:[],
    };

    let completedQueries = 0;

    for (const item of results) {
      const prdd = item.item_code_id;

      const itemCodeQuery = `SELECT * FROM item_code WHERE id = ?`;

      try {
        const rows = await new Promise((resolve, reject) => {
          db.query(itemCodeQuery, [prdd], (err, rows) => {
            if (err) {
              console.error('Error executing the itemCodeQuery: ' + err.stack);
              reject('Internal Server Error');
            }
            resolve(rows);
          });
        });

        if (rows.length > 0) {
          const pro = rows[0].product_des;

          const geoposOperatorQuery = `SELECT SUM(a.tar) as res
            FROM (SELECT SUM(fg_output) as tar
                  FROM fg_details
                  WHERE date_time BETWEEN '${convertedDate}' AND '${convertedDate1}'
                  AND product_code = '${prdd}'
                  GROUP BY product_code, time_stamp) a`;

          try {
            const geoposRows = await new Promise((resolve, reject) => {
              db.query(geoposOperatorQuery, (err, geoposRows) => {
                if (err) {
                  console.error('Error executing the geoposOperatorQuery: ' + err.stack);
                  reject('Internal Server Error');
                }
                resolve(geoposRows);
              });
            });

            if (geoposRows.length > 0) {
              const sump = geoposRows[0].res;

              data.items.push({
                product: pro,
                total: item.tot,
                sump: sump,
              });

              completedQueries++;
              // console.log(completedQueries, results.length);

              // if (completedQueries === results.length) {
              //   if (data.length === 0) {
              //     res.json({});
              //   } else {
              //     res.json(data);
              //   }
              // }
            } else {
              console.log('no rows');
            }
          } catch (error) {
            console.error('Error executing the geoposOperatorQuery: ' + error);
            res.status(500).json({ error: 'Internal Server Error' });
          }
        }
      } catch (error) {
        console.error('Error executing the itemCodeQuery: ' + error);
        res.status(500).json({ error: 'Internal Server Error' });
      }
    }

    // Move the response sending part outside the loop
    // This ensures that the response is sent only once after processing all queries

      if (data.length === 0) {
        res.json({});
      } else {
        res.json(data);
      }
    
  } catch (error) {
    console.error('Error executing the main query: ' + error);
    res.status(500).json({ error: 'Internal Server Error' });
  }
});


//MTD AVG PPP Report
//Get MTD AVG PPP Report deafult data
app.get('/Nbraid/getMtdPppAverageDefaultData', (req, res) => {
  const date = new Date().toLocaleDateString('en-GB', { timeZone: 'Africa/Lagos' });
  const parts = date.split('/');
  const day = parts[0].padStart(2, '0');
  const month = parts[1].padStart(2, '0');
  const year = parts[2];
  const datem = `${month}-${year}`;
  const currentDate = `${day}-${month}-${year}`;

  const array = [`worker_timesheet.mon = '${datem}'`, "worker_timesheet.product_name IS NOT NULL"];
  console.log(datem);
  const query = `
    SELECT
    worker_timesheet.*,
      item_masterr.item_description,
      item_category.category_name,
      COUNT(worker_timesheet.id) AS tot
    FROM
    worker_timesheet
    LEFT JOIN
      item_masterr ON item_masterr.id = worker_timesheet.product_name
    LEFT JOIN
      item_category ON item_masterr.category_id = item_category.id
    WHERE
      ${array.join(' AND ')}
    GROUP BY
    worker_timesheet.product_name, worker_timesheet.mon
  `;
console.log(query,'---------------==');
  db.query(query, (err, results) => {
    if (err) {
      console.error('Query execution failed:', err);
      res.status(500).json({ error: 'Internal Server Error' });
      return;
    }

    const data = []; // Initialize an array to store the result objects
    // Loop through the results and calculate averages for each result
    if(results.length > 0 ){
       console.log('------------------')
    results.forEach((result) => {
      const kk = result.product_name;
      const query2 = `SELECT SUM(fg_output) as tar FROM fg_details WHERE SUBSTR(date_time,4) = '${datem}' AND product_name = '${kk}' GROUP BY product_name`;
      db.query(query2, (err2, results2) => {
        if (err2) {
          console.error('Query 2 execution failed:', err2);
          res.status(500).json({ error: 'Internal Server Error' });
          return;
        }

    

          const sum = results2[0] ? results2[0].tar : 0;
          const rew = sum / result.tot;
          const responseValue = rew === Infinity ? 0 : rew;

          // Create an object for each result set and push it to the data array
          data.push({
            category: result.category_name,
            item: result.item_description,
            avg: responseValue.toFixed(2),
          });

          // Check if we have processed all results before sending the response
          if (data.length === results.length) {
            res.json(data); // Send the data array as a JSON response
          }
   
      });
    });
  }else{
    res.json(''); 
  }
  });
})

//Get MTD AVG PPP Report search data
app.post('/Nbraid/getMtdPppAverageSearch', (req, res) => {
  const start_year = req.body.start_year;
  const end_year = req.body.end_year;
  const start_month = req.body.start_month;
  const end_month = req.body.end_month;

  const s_year = start_month + '-' + start_year;
  const e_year = end_month + '-' + end_year;
  const cat = req.body.category;
  console.log(s_year + '' + e_year);

  const year_s = `${start_year}-${start_month}`;
  const year_e = `${end_year}-${end_month}`;
  const startDate = new Date(year_s);
  const endDate = new Date(year_e);
  const monthsArray = [];
  const monthsArray1 = [];
  const timeZone = 'Africa/Lagos';

  const formattedStartDate = startDate.toLocaleDateString('en-US', { year: 'numeric', month: 'long' });
  const formattedEndDate = endDate.toLocaleDateString('en-US', { year: 'numeric', month: 'long' });

  console.log('Start Date:', formattedStartDate);
  console.log('End Date:', formattedEndDate);

  const monthDifference = (endDate.getFullYear() - startDate.getFullYear()) * 12 + (endDate.getMonth() - startDate.getMonth()) + 1;

  for (let i = 0; i < monthDifference; i++) {
   
    const currentMonth = new Date(startDate.getFullYear(), startDate.getMonth() + i, 1);
    const monthName = currentMonth.toLocaleDateString('en-US', { month: 'long' });
    const mths = currentMonth.toLocaleDateString('en-US', { month: '2-digit', year: 'numeric' }).replace(/\//g, '-');

    monthsArray.push(mths);
    monthsArray1.push(monthName);
  }

  let where = `(worker_timesheet.mon between '${s_year}' and '${e_year}' and worker_timesheet.product_name !='')`;

  if (cat !== '') {
    where += ` AND item_masterr.category_id='${cat}'`;
  }

  const query = `
    SELECT worker_timesheet.*, item_masterr.item_description, item_category.category_name,
           COUNT(worker_timesheet.id) as tot
    FROM worker_timesheet
    LEFT JOIN item_masterr ON item_masterr.id = worker_timesheet.product_name
    LEFT JOIN item_category ON item_masterr.category_id = item_category.id
    WHERE ${where}
    GROUP BY worker_timesheet.product_name
  `;

  db.query(query, async (err, results) => {
    if (err) {
      console.error("Error:", err);
      return res.status(500).json({ error: "An error occurred" });
    }
  
    const data ={
      months: monthsArray1,
      items:[],
    }; // Initialize an array to store the result objects
  
    // Loop through the results and calculate averages for each result

      for (const result of results) {
        const monthlyAverages = [];
  
        // Loop through the monthsArray to calculate averages
        const promises = monthsArray.map(async (dt1) => {
          const mths = dt1;
          //console.log(mths);
          // Query 1: Calculate SUM(fg_output)
          const p1 = await new Promise((resolve, reject) => {
            db.query("SELECT SUM(fg_output) as tar FROM fg_details WHERE SUBSTR(date_time,4) = ? AND product_name = ? GROUP BY product_name", [mths, result.product_name], (err, rows) => {
              if (err) {
                reject(err);
              } else {
                resolve(rows);
              }
            });
          });
  
          // Query 2: Calculate COUNT(*)
          const query3 = await new Promise((resolve, reject) => {
            db.query("SELECT count(*) as tot from worker_timesheet  WHERE mon=? and product_name=? group by product_name", [mths, result.product_name], (err, rows) => {
              if (err) {
                reject(err);
              } else {
                resolve(rows);
              }
            });
          });
  
          const sum1 = p1.length > 0 ? p1[0].tar : 0;
          const worker = query3.length > 0 ? query3[0].tot : 0;
          //console.log('Sum:', sum1);
          //console.log('Worker:', worker);
  
          let rew;
          if (worker > 0) {
            rew = sum1 / worker;
            if (isNaN(rew) || !isFinite(rew)) {
              rew = '-';
            } else {
              rew = rew.toFixed(2);
            }
          } else {
            rew = '-';
          }
          //console.log('Average:', rew);
          monthlyAverages.push(rew); // Push the monthly average into the array
        });
  
        // Wait for all promises to resolve for the current result
        await Promise.all(promises);
  
        data.items.push({
          category: result.category_name,
          item: result.item_description,
          monthlyAverages: monthlyAverages,
          
        });
       // console.log(data+'=====================')
      }
    
  
    res.json({ data });
   console.log(data)
  });
});


//Efficiency Overview Report

//NBraid Efficiency overview report search
app.post('/Nbraid/get_efficiencyOverview_search_data', async (req, res) => {
  try {
    const timezone = 'Africa/Lagos';
    const fromdate = req.body.fromdate;
    const fdParts = fromdate.split('-');
    const fd = `${fdParts[2]}-${fdParts[1]}-${fdParts[0]}`;

    const todate = req.body.todate;
    const tdParts = todate.split('-');
    const td = `${tdParts[2]}-${tdParts[1]}-${tdParts[0]}`;

    const dateObj = new Date(fromdate);
    const day = dateObj.getDate().toString().padStart(2, '0');
    const month = (dateObj.getMonth() + 1).toString().padStart(2, '0');
    const year = dateObj.getFullYear();
    const convertedDate = `${day}-${month}-${year}`;

    const dateObj1 = new Date(todate);
    const day1 = dateObj1.getDate().toString().padStart(2, '0');
    const month1 = (dateObj1.getMonth() + 1).toString().padStart(2, '0');
    const year1 = dateObj1.getFullYear();
    const convertedDate1 = `${day1}-${month1}-${year1}`;

    const fd2 = Math.floor((new Date(fromdate).getTime() - 2 * 24 * 60 * 60 * 1000) / 1000);
    const td1 = Math.floor(new Date(todate).getTime() / 1000);
    const fd1 = Math.floor(new Date(fd2 * 1000).setDate(new Date(fd2 * 1000).getDate() - 1) / 1000);

    var newfd = fd2;
    var newtd = td1;

    // Query 1: Get timesheet
    const timesheetQuery = "SELECT * from worker_timesheet WHERE (time_stamp between ? and ?) group by entry_id";
    const timesheet = await EffOverQuery(timesheetQuery, [newfd, newtd]);

    // Query 2: Get timesheetk
    const timesheetkQuery = "SELECT *, SUM(target) as target_sum, SUM(HOUR1+HOUR2+HOUR3+HOUR4+HOUR5+HOUR6+HOUR7+HOUR8+HOUR9+HOUR10+HOUR11) AS value_sum from worker_timesheet WHERE (time_stamp between ? and ?) group by entry_id, date_time";
    const timesheetk = await EffOverQuery(timesheetkQuery, [newfd, newtd]);

    dateObj.toLocaleString('en-US', { timeZone: timezone });
    dateObj1.toLocaleString('en-US', { timeZone: timezone });

    const period = [];
    const date = new Date(dateObj);

    while (date <= dateObj1) {
      period.push(new Date(date));
      date.setDate(date.getDate() + 1);
    }

    // Function to format a date as "d-m-Y"
    const formatDate = (date) => {
      const day = String(date.getDate()).padStart(2, '0');
      const month = String(date.getMonth() + 1).padStart(2, '0');
      const year = date.getFullYear();
      return `${day}-${month}-${year}`;
    };

    const formattedDates = period.map((date) => formatDate(date));

    const ard = [];
    const arr_tar = [];
    const arr_ach = [];
    const arr = [];

    // Query 3: Fetch data for ard array
    for (const itemk of timesheetk) {
      
      const dent = `${itemk.date_time}-${itemk.entry_id}`;
      ard.push(dent);

      // Query 4: Fetch data for query_t
      const query_t = "SELECT * FROM worker_timesheet WHERE entry_id=? and date_time=?";
      const queryTResults = await EffOverQuery(query_t, [itemk.entry_id, itemk.date_time]);

      let totalTarget = 0;
      for (const row_t of queryTResults) {
       
        let count = 0;
        for (let i = 1; i <= 11; i++) {
          const u = `HOUR${i}`;
          if (row_t[u] > 0) {
            count++;
          }
        }

        if (parseInt(row_t.actual_target) > 0) {
          totalTarget += parseInt(row_t.actual_target) * count;
       
        } else {
          // Fetch data for act_target
          const actTargetQuery = "SELECT target FROM item_section_ota WHERE section_id=? and item_id=?";
          const actTargetResult = await EffOverQuery(actTargetQuery, [row_t.section, row_t.product_name]);
          totalTarget += parseInt(actTargetResult[0].target) * count;
          
        }

        const e = (parseInt(itemk.value_sum) / totalTarget) * 100;

        const eff = parseFloat(e.toFixed(2));

        arr.push(eff);
        arr_tar.push(parseInt(itemk.target_sum));
        arr_ach.push(parseInt(itemk.value_sum));
      }
    }
    
    const responseData = {
      dates: formattedDates,
      effdata:[],
    };
    // Process timesheet2 and other data as needed using Promise.all
    const resultPromises = timesheet.map(async (item) => {
      const worker = item.worker;
      const worker_id = item.entry_id;
      const sec = item.section;
      const section = await EffOverQuery("SELECT * FROM section WHERE id = ?", [sec]);
      const section_name = section[0].section_name;

      let sum_ef = 0; // Change from const to let
      let present_days = 0;
      let sumef = 0;
      const valuesByDate = {}; // Store values by date
      const date = [];
      // Assuming you have "period" defined earlier
      for (const dt1 of period) {
        const dd1 = `${formatDate(dt1)}-${item.entry_id}`;
        const e_id = item.entry_id;
        const date23 = formatDate(dt1);
        date.push(date23);

        const values = [];

        if (ard.includes(dd1)) {
          
          present_days++;
          const ky = ard.indexOf(dd1);
         
          const url = `/reports/eff_overview_details?entry_id=${e_id}&date=${date23}`;
          if (ky >= 0 && ky < arr.length && !isNaN(arr[ky])) {
            sum_ef += arr[ky];
            sumef = `${arr[ky]}%`; // Assign value to sumef
            values.push(arr[ky]+'%');
          } else {
            // Handle the case where ky is out of bounds or arr[ky] is non-numeric
            values.push('-');
          }
        } else {
          values.push('-');
        }
        valuesByDate[date23] = values;
      }

      const avg_m = (sum_ef / present_days).toFixed(2);
      const avg = `${avg_m}%`;

      responseData.effdata.push({
        worker: worker,
        id: worker_id,
        section_name: section_name,
        sum_ef: valuesByDate,
        avg: avg,
        present_days: present_days,
        date:date,
      });
    });

    await Promise.all(resultPromises);
    res.send(responseData);
    console.log(responseData)
  } catch (error) {
    console.error('Error executing MySQL query:', error);
    res.status(500).send('Internal Server Error');
  }
});

function EffOverQuery(query, values) {
  return new Promise((resolve, reject) => {
    db.query(query, values, (err, result) => {
      if (err) {
        reject(err);
      } else {
        resolve(result);
      }
    });
  });
}

//Efficiency overview default data 
app.get('/Nbraid/get_efficiencyOverview_deafault_data', async (req, res) => {
  try {
    const date = new Date().toLocaleDateString('en-GB', { timeZone: 'Africa/Lagos' });
    const parts = date.split('/');
    const day = parts[0].padStart(2, '0');
    const month = parts[1].padStart(2, '0');
    const year = parts[2];
    const currentMonth = `${month}-${year}`;
    const td = `${day}-${month}-${year}`;

    const workerQuery = `SELECT *, COUNT(*) as cnt, SUM(HOUR1+HOUR2+HOUR3+HOUR4+HOUR5+HOUR6+HOUR7+HOUR8+HOUR9+HOUR10+HOUR11) as value_sum
    FROM worker_timesheet
    WHERE date_time = ?
    GROUP BY entry_id
    HAVING cnt = 1`;
    const workerResults = await EffOverQuery1(workerQuery, [td]);

    const responseData = [];
    
    const resultPromises = workerResults.map(async (workers) => {
        // Define worker, id, section_name, valuesByDate, avg, and present_days here
        const worker = workers.worker;
        const id = workers.entry_id;

                const query_t = "SELECT * FROM worker_timesheet WHERE entry_id=? and date_time=?";
                const queryTResults = await EffOverQuery1(query_t, [workers.entry_id, workers.date_time]);

                let totalTarget = 0;

                for (const row_t of queryTResults) {
                    let count = 0;
                    for (let i = 1; i <= 11; i++) {
                        const u = `HOUR${i}`;
                        if (row_t[u] > 0) {
                            count++;
                        }
                    }

                    if (parseInt(row_t.actual_target) > 0) {
                        totalTarget += parseInt(row_t.actual_target) * count;
                    } else {
                        const actTargetQuery = "SELECT target FROM item_section_ota WHERE section_id=? and item_id=?";
                        const actTargetResult = await EffOverQuery1(actTargetQuery, [row_t.section, row_t.product_name]);
                        totalTarget += parseInt(actTargetResult[0].target) * count;
                    }

                    const e = (parseInt(workers.value_sum) / totalTarget) * 100;
                    const eff = parseFloat(e).toFixed(2) + '%';  

                    // Push data to responseData
                    responseData.push({
                        worker: worker,
                        id: id,
                        dates: td,
                        eff: eff, // Define present_days
                    });
                }
          
    });

    await Promise.all(resultPromises);
    res.send(responseData);
    //console.log(responseData,"-----------------------")
  } catch (error) {
    console.error('Error executing MySQL query:', error);
    res.status(500).send('Internal Server Error');
  }
});

function EffOverQuery1(query, values) {
  return new Promise((resolve, reject) => {
    db.query(query, values, (err, result) => {
      if (err) {
        reject(err);
      } else {
        resolve(result);
      }
    });
  });
}

//Efficiency overview details wise view
app.get('/Nbraid/get_efficiencyOverview_details_data/:id1/:id2', async (req, res) => {
  try {
    const eid = req.params.id1;
    const date = req.params.id2;
    console.log(eid,date)
    const workerQuery = `SELECT *, COUNT(*) as cnt, SUM(HOUR1+HOUR2+HOUR3+HOUR4+HOUR5+HOUR6+HOUR7+HOUR8+HOUR9+HOUR10+HOUR11) as value_sum
    FROM worker_timesheet
    WHERE date_time = ? AND entry_id =?
    GROUP BY shift,entry_id,product_name,line,section,date_time`;
    const workerResults = await EffOverQuery2(workerQuery, [date,eid]);

  
    let total_tar=0;
    let total_sum=0;
    let total_eff=0;
    const responseData = {
      tot_tar: total_tar,
      tot_sum: total_sum,
      tot_eff: total_eff,
      date:date,
      items:[],
    };
    const resultPromises = workerResults.map(async (workers) => {
        // Define worker, id, section_name, valuesByDate, avg, and present_days here
        const worker = workers.worker;
        const id = workers.entry_id;

                  // Query to get item description
                const [productRows] = await EffOverQuery2(`SELECT * FROM item_masterr WHERE id = ?`, [workers.product_name]);
                const productDescription = productRows.item_description;

                // Query to get section name
                const [sectionRows] = await EffOverQuery2(`SELECT * FROM section WHERE id = ?`, [workers.section]);
                const sectionName = sectionRows.section_name;

                // Query to get target
                const [targetdata] = await EffOverQuery2(`SELECT * FROM item_section_ota WHERE section_id = ? AND item_id = ?`, [workers.section,workers.product_name]);
                const targett = targetdata.target;

            
                    let count = 0;
                    for (let i = 1; i <= 11; i++) {
                        const u = `HOUR${i}`;
                        if (workers[u] > 0) {
                            count++;
                        }
                    }
                   //calculatio 
                   const tar = targett * count;
                   total_tar+=tar;

                   const sum = workers.value_sum; 
                   total_sum+=sum;

                   const e = (parseInt(sum) / tar) * 100;
                   const eff = parseFloat(e).toFixed(2) + '%';
                   total_eff+=eff;

                    // Push data to responseData
                    responseData.items.push({
                        worker: worker,
                        eid: id,
                        prod:productDescription,
                        line:workers.line,
                        sec:sectionName,
                        target:targett,
                        h1:workers.HOUR1,
                        h2:workers.HOUR2,
                        h3:workers.HOUR3,
                        h4:workers.HOUR4,
                        h5:workers.HOUR5,
                        h6:workers.HOUR6,
                        h7:workers.HOUR7,
                        h8:workers.HOUR8,
                        h9:workers.HOUR9,
                        h10:workers.HOUR10,
                        h11:workers.HOUR11,
                        tar: tar, // Define present_days
                        sum:sum,
                        eff:eff,
                       
                    });
                
          
    });

    await Promise.all(resultPromises);

    responseData.tot_tar = total_tar;
    responseData.tot_sum = total_sum;
    //responseData.tot_eff = typeof total_eff === 'number' ? total_eff.toFixed(2) + '%' : '0.00%';
    const numericTotalEff = parseFloat(total_eff);
    responseData.tot_eff = !isNaN(numericTotalEff) ? numericTotalEff.toFixed(2) + '%' : '0.00%';

    res.send(responseData);
    console.log(responseData,"-----------------------")
  } catch (error) {
    console.error('Error executing MySQL query:', error);
    res.status(500).send('Internal Server Error');
  }
});

function EffOverQuery2(query, values) {
  return new Promise((resolve, reject) => {
    db.query(query, values, (err, result) => {
      if (err) {
        reject(err);
      } else {
        resolve(result);
      }
    });
  });
}



//Performance Efficiency Report

//Performance Efficiency default report 
app.get('/Nbraid/get_performance_efficiency_data', async (req, res) => {
  try {
    const timezone = 'Africa/Lagos';
    const currentDate = new Date();
    const day = currentDate.getDate().toString().padStart(2, '0');
    const month = (currentDate.getMonth() + 1).toString().padStart(2, '0');
    const year = currentDate.getFullYear();
    const todaydate = `${day}-${month}-${year}`;

    const fd2 = Math.floor((currentDate.getTime() - 24 * 60 * 60 * 1000) / 1000);
    const td1 = Math.floor(currentDate.getTime() / 1000);

    const fd1 = Math.floor(new Date(fd2 * 1000).setDate(currentDate.getDate() - 1) / 1000);

    console.log('Formatted Today Date:', todaydate);
    console.log('Timestamp for Today Date:', fd2);
    console.log('Timestamp for Previous Date:', td1);
    const dateObj = new Date(currentDate);
    const dateObj1 = new Date(currentDate);

    const newfd = fd2;
    const newtd = td1;
    // Query 1: Get timesheet
    const timesheetQuery = "SELECT *, HOUR1 + HOUR2 + HOUR3 + HOUR4 + HOUR5 + HOUR6 + HOUR7 + HOUR8 + HOUR9 + HOUR10 + HOUR11 AS value_sum FROM worker_timesheet WHERE (time_stamp BETWEEN ? AND ?) GROUP BY entry_id, product_name, section, line";
    const timesheet = await pefEffQuery1(timesheetQuery, [newfd, newtd]);

    // Query 2: Get timesheetk
    const timesheetkQuery = "SELECT *, HOUR1 + HOUR2 + HOUR3 + HOUR4 + HOUR5 + HOUR6 + HOUR7 + HOUR8 + HOUR9 + HOUR10 + HOUR11 AS value_sum FROM worker_timesheet WHERE (time_stamp BETWEEN ? AND ?) GROUP BY entry_id, product_name, section, line, date_time";
    const timesheetk = await pefEffQuery1(timesheetkQuery, [newfd, newtd]);

    dateObj.toLocaleString('en-US', { timeZone: timezone });
    dateObj1.toLocaleString('en-US', { timeZone: timezone });

    const period = [];
    const date = new Date(dateObj);

    while (date <= dateObj1) {
      period.push(new Date(date));
      date.setDate(date.getDate() + 1);
    }

    // Function to format a date as "d-m-Y"
    const formatDate = (date) => {
      const day = String(date.getDate()).padStart(2, '0');
      const month = String(date.getMonth() + 1).padStart(2, '0');
      const year = date.getFullYear();
      return `${day}-${month}-${year}`;
    };

    const formattedDates = period.map((date) => formatDate(date));

    const ard = [];
    const arr = [];
    
    for (const itemk of timesheetk) {
      const dent = `${itemk.date_time}-${itemk.entry_id}-${itemk.product_name}-${itemk.section}-${itemk.line}`;
      ard.push(dent);
      
      const e = (itemk.value_sum / itemk.target) * 100;
      const eff = parseFloat(e.toFixed(2));
      arr.push(eff);
    }

    const responseData = {
      dates: formattedDates,
      items:[],
    }
    // Process timesheet and other data as needed using Promise.all
    const resultPromises = timesheet.map(async (item) => {
      const entry = item.entry_id;
      const worker = item.worker;
      const line = item.line;
      const site = item.site;
      let query1;
      let ss = '';

      if (site === 'both') {
        query1 = `SELECT * FROM employees_ota WHERE entryid='${entry}'`;

        try {
          const result1 = await pefEffQuery1(query1);

          if (!result1 || result1.length === 0) {
            query1 = `SELECT * FROM geopos_employees WHERE entryid='${entry}'`;
            ss = 'ikeja';
          } else {
            ss = 'ota';
          }
        } catch (error) {
          // Handle database query error
          console.error('Error querying the database:', error);
        }
      } else if (site === 'ikeja') {
        query1 = `SELECT * FROM geopos_employees WHERE entryid='${entry}'`;
        ss = 'ikeja';
      } else if (site === 'ota') {
        query1 = `SELECT * FROM employees_ota WHERE entryid='${entry}'`;
        ss = 'ota';
      }

      let regg = '';
      let diff = '';

      if (query1) {
        try {
          const query1Result = await pefEffQuery1(query1);
      
          if (query1Result && query1Result[0] && query1Result[0].hasOwnProperty('joindate')) {
       
            const dateParts = query1Result[0].joindate.split(/[- :]/);
            console.log('Date parts:', dateParts);
           //const reggDate = new Date(Date.UTC(dateParts[2], dateParts[1] - 1, dateParts[0], dateParts[3], dateParts[4]));
           const reggDate = new Date(Date.UTC(dateParts[2], dateParts[1] - 1, dateParts[0]));

            regg = reggDate.toLocaleDateString('en-GB', {
              day: '2-digit',
              month: '2-digit',
              year: 'numeric',
            }).replace(/\//g, '-');

          console.log('regg within query1Result:', regg);
        
          const datek1 = item.date_time;
        
          const datek11 = new Date(datek1.split('-').reverse().join('-'));
         const regg1 = new Date(regg.split('-').reverse().join('-'));

          const timeDifference = datek11.getTime() - regg1.getTime();
          diff = Math.floor(timeDifference / (1000 * 60 * 60 * 24)); // Convert to days
           
          } else {
            regg = '';
            diff = '';
          }
        } catch (error) {
          // Handle database query error
          console.error('Error querying the database:', error);
        }
      }
      
      
      


      const productQuery = "SELECT item_description FROM item_masterr WHERE id = ?";
      let productRows;
      let itemDescription; 

      if (item.product_name) {
        [productRows] = await pefEffQuery1(productQuery, [item.product_name]);
        // Use optional chaining and provide a default value (empty string) in case item_description is undefined
        itemDescription = productRows?.item_description ?? ""; 
      } else {
        itemDescription = ''; // Replace '' with "" to maintain consistency in type
      }

     
      
// Now you can use productRows in the rest of your code


      const sectionQuery = "SELECT section_name FROM section WHERE id = ?";
      const [sectionRows] = await pefEffQuery1(sectionQuery, [item.section]);
    

      const valuesByDate = {}; // Store values by date

      for (const dt1 of period) {
        const date23 = formatDate(dt1);
        const dd1 = `${date23}-${item.entry_id}-${item.product_name}-${item.section}-${item.line}`;

        const values = [];

        if (ard.includes(dd1)) {
          const ky = ard.indexOf(dd1);

          if (ky >= 0 && ky < arr.length && !isNaN(arr[ky])) {
            values.push(arr[ky].toFixed(2));
           // console.log(arr[ky]+'----------')
          } else {
            values.push('-');
          }
        } else {
          values.push('-');
        }

        valuesByDate[date23] = values;
      }
      // const sectionName = sectionRows.length > 0 ? sectionRows.section_name : 'Section Name Not Found';
      // const itemDescription = productRows.length > 0 ? productRows.item_description : 'Item Description Not Found';
     
      responseData.items.push({
        worker: worker,
        entry_id: entry,
        regg: regg,
        diff: diff,
        section: sectionRows.section_name,
        product: itemDescription,
        line: line,
        count: valuesByDate,
        //dates: formattedDates,
      });
    });

    await Promise.all(resultPromises);
    res.send(responseData);
    console.log(responseData)
  } catch (error) {
    console.error('Error executing MySQL query:', error);
    res.status(500).send('Internal Server Error');
  }
});

function pefEffQuery1(query, values) {
  return new Promise((resolve, reject) => {
    db.query(query, values, (err, result) => {
      if (err) {
        reject(err);
      } else {
        resolve(result);
      }
    });
  });
}



//Performance efficiency search data
app.post('/Nbraid/get_performance_eff_search_data', async (req, res) => {
  try {
    const timezone = 'Africa/Lagos';
    const fromdate = req.body.fromdate;
    const fdParts = fromdate.split('-');
    const fd = `${fdParts[2]}-${fdParts[1]}-${fdParts[0]}`;

    const todate = req.body.todate;
    const tdParts = todate.split('-');
    const td = `${tdParts[2]}-${tdParts[1]}-${tdParts[0]}`;

    const dateObj = new Date(fromdate);
    const day = dateObj.getDate().toString().padStart(2, '0');
    const month = (dateObj.getMonth() + 1).toString().padStart(2, '0');
    const year = dateObj.getFullYear();
    const convertedDate = `${day}-${month}-${year}`;

    const dateObj1 = new Date(todate);
    const day1 = dateObj1.getDate().toString().padStart(2, '0');
    const month1 = (dateObj1.getMonth() + 1).toString().padStart(2, '0');
    const year1 = dateObj1.getFullYear();
    const convertedDate1 = `${day1}-${month1}-${year1}`;

    const fd2 = Math.floor((new Date(fromdate).getTime() -24 * 60 * 60 * 1000) / 1000);
    const td1 = Math.floor(new Date(todate).getTime() / 1000);
    const fd1 = Math.floor(new Date(fd2 * 1000).setDate(new Date(fd2 * 1000).getDate() - 1) / 1000);

    const newfd = fd2;
    const newtd = td1;

    // Query 1: Get timesheet
    const timesheetQuery = "SELECT *, HOUR1 + HOUR2 + HOUR3 + HOUR4 + HOUR5 + HOUR6 + HOUR7 + HOUR8 + HOUR9 + HOUR10 + HOUR11 AS value_sum FROM worker_timesheet WHERE (time_stamp BETWEEN ? AND ?) GROUP BY entry_id, product_name, section, line";
    const timesheet = await pefEffQuery(timesheetQuery, [newfd, newtd]);

    // Query 2: Get timesheetk
    const timesheetkQuery = "SELECT *, HOUR1 + HOUR2 + HOUR3 + HOUR4 + HOUR5 + HOUR6 + HOUR7 + HOUR8 + HOUR9 + HOUR10 + HOUR11 AS value_sum FROM worker_timesheet WHERE (time_stamp BETWEEN ? AND ?) GROUP BY entry_id, product_name, section, line, date_time";
    const timesheetk = await pefEffQuery(timesheetkQuery, [newfd, newtd]);

    dateObj.toLocaleString('en-US', { timeZone: timezone });
    dateObj1.toLocaleString('en-US', { timeZone: timezone });

    const period = [];
    const date = new Date(dateObj);

    while (date <= dateObj1) {
      period.push(new Date(date));
      date.setDate(date.getDate() + 1);
    }

    // Function to format a date as "d-m-Y"
    const formatDate = (date) => {
      const day = String(date.getDate()).padStart(2, '0');
      const month = String(date.getMonth() + 1).padStart(2, '0');
      const year = date.getFullYear();
      return `${day}-${month}-${year}`;
    };

    const formattedDates = period.map((date) => formatDate(date));

    const ard = [];
    const arr = [];
    
    for (const itemk of timesheetk) {
      const dent = `${itemk.date_time}-${itemk.entry_id}-${itemk.product_name}-${itemk.section}-${itemk.line}`;
      ard.push(dent);
      
      const e = (itemk.value_sum / itemk.target) * 100;
      const eff = parseFloat(e.toFixed(2));
      arr.push(eff);
    }

    const responseData = {
      dates: formattedDates,
      items:[],
    }
    // Process timesheet and other data as needed using Promise.all
    const resultPromises = timesheet.map(async (item) => {
      const entry = item.entry_id;
      const worker = item.worker;
      const line = item.line;
      const site = item.site;
      let query1;
      let ss = '';

      if (site === 'both') {
        query1 = `SELECT * FROM employees_ota WHERE entryid='${entry}'`;

        try {
          const result1 = await pefEffQuery(query1);

          if (!result1 || result1.length === 0) {
            query1 = `SELECT * FROM geopos_employees WHERE entryid='${entry}'`;
            ss = 'ikeja';
          } else {
            ss = 'ota';
          }
        } catch (error) {
          // Handle database query error
          console.error('Error querying the database:', error);
        }
      } else if (site === 'ikeja') {
        query1 = `SELECT * FROM geopos_employees WHERE entryid='${entry}'`;
        ss = 'ikeja';
      } else if (site === 'ota') {
        query1 = `SELECT * FROM employees_ota WHERE entryid='${entry}'`;
        ss = 'ota';
      }

      let regg = ''; // Declare outside the block
let diff = ''; // Declare outside the block

if (query1) {
    try {
        const query1Result = await pefEffQuery(query1);
        
        if (query1Result && query1Result[0] && query1Result[0].hasOwnProperty('joindate')) {
            const dateParts = query1Result[0].joindate.split(/[- :]/);
            console.log('dateParts:', dateParts);
            let reggDate;

            if (dateParts.length === 5) {
                // Format: Y-m-d h:i:s
                reggDate = new Date(Date.UTC(dateParts[2], dateParts[1] - 1, dateParts[0], dateParts[3], dateParts[4], 0));
            } else {
                console.error('Unsupported date format');
            }

            if (reggDate) {
                regg = reggDate.toLocaleDateString('en-GB', {
                    day: '2-digit',
                    month: '2-digit',
                    year: 'numeric',
                }).replace(/\//g, '-');

                console.log('regg:', regg);

                const datek1 = item.date_time;
                const datek11 = new Date(datek1.split('-').reverse().join('-'));
                const regg1 = new Date(regg.split('-').reverse().join('-'));

                const timeDifference = datek11.getTime() - regg1.getTime();
                diff = Math.floor(timeDifference / (1000 * 60 * 60 * 24)); // Convert to days

                console.log('Difference:', diff);
            } else {
                console.error('Error parsing registration date');
            }
        } else {
            console.error('No valid joindate found in query result');
        }
    } catch (error) {
        // Handle database query error
        console.error('Error querying the database:', error);
    }
}
    
    
      const productQuery = "SELECT item_description FROM item_masterr WHERE id = ?";
      let productRows;
      let itemDescription; 

      if (item.product_name) {
        [productRows] = await pefEffQuery(productQuery, [item.product_name]);
        // Use optional chaining and provide a default value (empty string) in case item_description is undefined
        itemDescription = productRows?.item_description ?? ""; 
      } else {
        itemDescription = ''; // Replace '' with "" to maintain consistency in type
      }

     
      
// Now you can use productRows in the rest of your code


      const sectionQuery = "SELECT section_name FROM section WHERE id = ?";
      const [sectionRows] = await pefEffQuery(sectionQuery, [item.section]);
    

      const valuesByDate = {}; // Store values by date

      for (const dt1 of period) {
        const date23 = formatDate(dt1);
        const dd1 = `${date23}-${item.entry_id}-${item.product_name}-${item.section}-${item.line}`;

        const values = [];

        if (ard.includes(dd1)) {
          const ky = ard.indexOf(dd1);

          if (ky >= 0 && ky < arr.length && !isNaN(arr[ky])) {
            values.push(arr[ky].toFixed(2));
           // console.log(arr[ky]+'----------')
          } else {
            values.push('-');
          }
        } else {
          values.push('-');
        }

        valuesByDate[date23] = values;
      }
      // const sectionName = sectionRows.length > 0 ? sectionRows.section_name : 'Section Name Not Found';
      // const itemDescription = productRows.length > 0 ? productRows.item_description : 'Item Description Not Found';
     
      responseData.items.push({
        worker: worker,
        entry_id: entry,
        regg: regg,
        diff: diff,
        section: sectionRows.section_name,
        product: itemDescription,
        line: line,
        count: valuesByDate,
        //dates: formattedDates,
      });
    });

    await Promise.all(resultPromises);
    console.log('Sending response...');
    res.send(responseData);
    console.log(responseData);
  } catch (error) {
    console.error('Error executing MySQL query:', error);
    res.status(500).send('Internal Server Error');
  }
});

function pefEffQuery(query, values) {
  return new Promise((resolve, reject) => {
    db.query(query, values, (err, result) => {
      if (err) {
        reject(err);
      } else {
        resolve(result);
      }
    });
  });
}



//Performance Overview Report

//Performance Overview Nbraid Report default
app.get('/Nbraid/get_performance_overview_data', async (req, res) => {
  try {
    const currentDate = new Date();
    const fd2 = Math.floor((currentDate.getTime() - 24 * 60 * 60 * 1000) / 1000);
    const td1 = Math.floor(currentDate.getTime() / 1000);
     
    const dateObj = new Date(currentDate);
    const day = dateObj.getDate().toString().padStart(2, '0');
    const month = (dateObj.getMonth() + 1).toString().padStart(2, '0');
    const year = dateObj.getFullYear();
    const convertedDate = `${day}-${month}-${year}`;

    const newfd = fd2;
    const newtd = td1;
    
    // Query 1: Get timesheet
    const timesheetQuery = "SELECT *, HOUR1 + HOUR2 + HOUR3 + HOUR4 + HOUR5 + HOUR6 + HOUR7 + HOUR8 + HOUR9 + HOUR10 + HOUR11 AS value_sum FROM worker_timesheet WHERE (time_stamp BETWEEN ? AND ?) GROUP BY entry_id, shift, mon";
    const timesheet = await pefOverQuery(timesheetQuery, [newfd, newtd]);

    const responseData ={
      dates: convertedDate + ' TO ' + convertedDate,
      items:[],
    }
    // Process timesheet and other data as needed using Promise.all
    const resultPromises = timesheet.map(async (item) => {
      const entry = item.entry_id;
      const worker = item.worker;
      const site = item.site;
      let query1;
      let ss = '';

      if (site === 'both') {
        query1 = `SELECT * FROM employees_ota WHERE entryid='${entry}'`;

        try {
          const result1 = await pefOverQuery(query1);

          if (!result1 || result1.length === 0) {
            query1 = `SELECT * FROM geopos_employees WHERE entryid='${entry}'`;
            ss = 'ikeja';
          } else {
            ss = 'ota';
          }
        } catch (error) {
          // Handle database query error
          console.error('Error querying the database:', error);
        }
      } else if (site === 'ikeja') {
        query1 = `SELECT * FROM geopos_employees WHERE entryid='${entry}'`;
        ss = 'ikeja';
      } else if (site === 'ota') {
        query1 = `SELECT * FROM employees_ota WHERE entryid='${entry}'`;
        ss = 'ota';
      } else {
        query1 = null;
        ss = '';
      }

      let regg = '';
      let diff = '';

      if (query1) {
        try {
          const query1Result = await pefOverQuery(query1);
      
          // Add some debug output to see the results of query1Result
          console.log('Query1Result:', query1Result);
      
          if (query1Result && query1Result[0] && query1Result[0].hasOwnProperty('joindate')) {
            const dateParts = query1Result[0].joindate.split(/[- :]/);
            const reggDate = new Date(Date.UTC(dateParts[2], dateParts[1] - 1, dateParts[0], dateParts[3], dateParts[4]));
            regg = reggDate.toLocaleDateString('en-GB', {
              day: '2-digit',
              month: '2-digit',
              year: 'numeric',
            }).replace(/\//g, '-');
        
           const datek1 = item.date_time;
        
          const datek11 = new Date(datek1.split('-').reverse().join('-'));
           const regg1 = new Date(regg.split('-').reverse().join('-'));

          const timeDifference = datek11.getTime() - regg1.getTime();
          diff = Math.floor(timeDifference / (1000 * 60 * 60 * 24)); // Convert to days

          } else {
            regg = '';
            diff = '';
          }
        } catch (error) {
          // Handle database query error
          console.error('Error querying the database:', error);
        }
      }
      

      // Initialize variables
      let targettm = 0;
      let totalTargetm = 0;
      let totalvalue_sum = 0;

      const querytm = `
        SELECT entry_id, time_stamp FROM worker_timesheet
        WHERE entry_id = ? AND (time_stamp BETWEEN ? AND ?)
        GROUP BY time_stamp
      `;

      const results1 = await pefOverQuery(querytm, [item.entry_id, newfd, newtd]);

      // Use Promise.all to ensure all sub-queries are completed
      await Promise.all(
        results1.map(async (itemtm) => {
          const querymn = `
            SELECT *, HOUR1 + HOUR2 + HOUR3 + HOUR4 + HOUR5 + HOUR6 + HOUR7 + HOUR8 + HOUR9 + HOUR10 + HOUR11 AS value_sum
            FROM worker_timesheet
            WHERE entry_id = ? AND time_stamp = ?
          `;

          const results2 = await pefOverQuery(querymn, [itemtm.entry_id, itemtm.time_stamp]);

          results2.forEach((itemmn) => {
            let count = 0;

            for (let j = 1; j <= 11; j++) {
              const str = 'HOUR' + j;
              if (itemmn[str] > 0) {
                count++;
              }
            }

            // Ensure itemmn.actual_target is defined and a valid number
            if (typeof itemmn.actual_target === 'number') {
              // Calculate targettm for the current item and accumulate it in totalTargetm
              targettm = itemmn.actual_target * count;
              totalTargetm += targettm;

              // Accumulate value_sum in totalvalue_sum
              totalvalue_sum += itemmn.value_sum;
            }
            //console.log('-----------')
          });
        })
      );

      const tvalue_sum = totalvalue_sum;
      const totalTarget = totalTargetm;
      const e = (tvalue_sum / totalTarget) * 100;
      const eff = e.toFixed(2);

      responseData.items.push({
        worker: worker,
        entry_id: entry,
        regg: regg,
        diff: diff,
        totalTarget: totalTarget,
        tvalue_sum: tvalue_sum,
        eff: eff,
        
      });
    });

    await Promise.all(resultPromises);
    res.send(responseData);
    console.log(responseData,'---------------------');
  } catch (error) {
    console.error('Error executing MySQL query:', error);
    res.status(500).send('Internal Server Error');
  }
});

function pefOverQuery(query, values) {
  return new Promise((resolve, reject) => {
    db.query(query, values, (err, result) => {
      if (err) {
        reject(err);
      } else {
        resolve(result);
      }
    });
  });
}

//Performance Overview search data
app.post('/Nbraid/get_performance_overview_search_data', async (req, res) => {
  try {
    const timezone = 'Africa/Lagos';
    const fromdate = req.body.fromdate;
    const fdParts = fromdate.split('-');
    const fd = `${fdParts[2]}-${fdParts[1]}-${fdParts[0]}`;

    const todate = req.body.todate;
    const tdParts = todate.split('-');
    const td = `${tdParts[2]}-${tdParts[1]}-${tdParts[0]}`;

    const dateObj = new Date(fromdate);
    const day = dateObj.getDate().toString().padStart(2, '0');
    const month = (dateObj.getMonth() + 1).toString().padStart(2, '0');
    const year = dateObj.getFullYear();
    const convertedDate = `${day}-${month}-${year}`;

    const dateObj1 = new Date(todate);
    const day1 = dateObj1.getDate().toString().padStart(2, '0');
    const month1 = (dateObj1.getMonth() + 1).toString().padStart(2, '0');
    const year1 = dateObj1.getFullYear();
    const convertedDate1 = `${day1}-${month1}-${year1}`;

    const fd2 = Math.floor((new Date(fromdate).getTime() - 2 * 24 * 60 * 60 * 1000) / 1000);
    const td1 = Math.floor(new Date(todate).getTime() / 1000);
    const fd1 = Math.floor(new Date(fd2 * 1000).setDate(new Date(fd2 * 1000).getDate() - 1) / 1000);

    const newfd = fd2;
    const newtd = td1;

    // Query 1: Get timesheet
    const timesheetQuery = "SELECT *, HOUR1 + HOUR2 + HOUR3 + HOUR4 + HOUR5 + HOUR6 + HOUR7 + HOUR8 + HOUR9 + HOUR10 + HOUR11 AS value_sum FROM worker_timesheet WHERE (time_stamp BETWEEN ? AND ?) GROUP BY entry_id, shift, mon";
    const timesheet = await pefOverQuery(timesheetQuery, [newfd, newtd]);

    const responseData ={
      dates: convertedDate + ' TO ' + convertedDate1,
      items:[],
    }
    // Process timesheet and other data as needed using Promise.all
    const resultPromises = timesheet.map(async (item) => {
      const entry = item.entry_id;
      const worker = item.worker;
      const site = item.site;
      let query1;
      let ss = '';

      if (site === 'both') {
        query1 = `SELECT * FROM employees_ota WHERE entryid='${entry}'`;

        try {
          const result1 = await pefOverQuery(query1);

          if (!result1 || result1.length === 0) {
            query1 = `SELECT * FROM geopos_employees WHERE entryid='${entry}'`;
            ss = 'ikeja';
          } else {
            ss = 'ota';
          }
        } catch (error) {
          // Handle database query error
          console.error('Error querying the database:', error);
        }
      } else if (site === 'ikeja') {
        query1 = `SELECT * FROM geopos_employees WHERE entryid='${entry}'`;
        ss = 'ikeja';
      } else if (site === 'ota') {
        query1 = `SELECT * FROM employees_ota WHERE entryid='${entry}'`;
        ss = 'ota';
      } else {
        query1 = null;
        ss = '';
      }

      let regg = ''; // Declare outside the block
      let diff = ''; // Declare outside the block

        if (query1) {
            try {
                const query1Result = await pefOverQuery(query1);
                
                if (query1Result && query1Result[0] && query1Result[0].hasOwnProperty('joindate')) {
                    const dateParts = query1Result[0].joindate.split(/[- :]/);
                    console.log('dateParts:', dateParts);
                    let reggDate;

                    if (dateParts.length === 5) {
                        // Format: Y-m-d h:i:s
                        reggDate = new Date(Date.UTC(dateParts[2], dateParts[1] - 1, dateParts[0], dateParts[3], dateParts[4], 0));
                    } else {
                        console.error('Unsupported date format');
                    }

                    if (reggDate) {
                        regg = reggDate.toLocaleDateString('en-GB', {
                            day: '2-digit',
                            month: '2-digit',
                            year: 'numeric',
                        }).replace(/\//g, '-');

                        console.log('regg:', regg);

                        const datek1 = item.date_time;
                        const datek11 = new Date(datek1.split('-').reverse().join('-'));
                        const regg1 = new Date(regg.split('-').reverse().join('-'));

                        const timeDifference = datek11.getTime() - regg1.getTime();
                        diff = Math.floor(timeDifference / (1000 * 60 * 60 * 24)); // Convert to days

                        console.log('Difference:', diff);
                    } else {
                        console.error('Error parsing registration date');
                    }
                } else {
                    console.error('No valid joindate found in query result');
                }
            } catch (error) {
                // Handle database query error
                console.error('Error querying the database:', error);
            }
        }



      

      // Initialize variables
      let targettm = 0;
      let totalTargetm = 0;
      let totalvalue_sum = 0;

      const querytm = `
        SELECT entry_id, time_stamp FROM worker_timesheet
        WHERE entry_id = ? AND (time_stamp BETWEEN ? AND ?)
        GROUP BY time_stamp
      `;

      const results1 = await pefOverQuery(querytm, [item.entry_id, newfd, newtd]);

      // Use Promise.all to ensure all sub-queries are completed
      await Promise.all(
        results1.map(async (itemtm) => {
          const querymn = `
            SELECT *, HOUR1 + HOUR2 + HOUR3 + HOUR4 + HOUR5 + HOUR6 + HOUR7 + HOUR8 + HOUR9 + HOUR10 + HOUR11 AS value_sum
            FROM worker_timesheet
            WHERE entry_id = ? AND time_stamp = ?
          `;

          const results2 = await pefOverQuery(querymn, [itemtm.entry_id, itemtm.time_stamp]);

          results2.forEach((itemmn) => {
            let count = 0;

            for (let j = 1; j <= 11; j++) {
              const str = 'HOUR' + j;
              if (itemmn[str] > 0) {
                count++;
              }
            }

            // Ensure itemmn.actual_target is defined and a valid number
            if (typeof itemmn.actual_target === 'number') {
              // Calculate targettm for the current item and accumulate it in totalTargetm
              targettm = itemmn.actual_target * count;
              totalTargetm += targettm;

              // Accumulate value_sum in totalvalue_sum
              totalvalue_sum += itemmn.value_sum;
            }
            //console.log('-----------')
          });
        })
      );

      const tvalue_sum = totalvalue_sum;
      const totalTarget = totalTargetm;
      const e = (tvalue_sum / totalTarget) * 100;
      const eff = e.toFixed(2);

      responseData.items.push({
        worker: worker,
        entry_id: entry,
        regg: regg,
        diff: diff,
        totalTarget: totalTarget,
        tvalue_sum: tvalue_sum,
        eff: eff,
        
      });
    });

    await Promise.all(resultPromises);
    res.send(responseData);
    console.log(responseData);
  } catch (error) {
    console.error('Error executing MySQL query:', error);
    res.status(500).send('Internal Server Error');
  }
});

function pefOverQuery(query, values) {
  return new Promise((resolve, reject) => {
    db.query(query, values, (err, result) => {
      if (err) {
        reject(err);
      } else {
        resolve(result);
      }
    });
  });
}



//Productivity Report

//Productivity Search data
app.post('/nbraid/getfilteredproductivity', async (req, res) => {
  const fdate = req.body.fromdate;
  const dateObj = new Date(fdate);
  const day = dateObj.getDate().toString().padStart(2, '0');
  const month = (dateObj.getMonth() + 1).toString().padStart(2, '0');
  const year = dateObj.getFullYear();
  const fd = `${day}-${month}-${year}`;
  console.log('fd:',fd);

  //const fd = new Date(fdate).toLocaleDateString('en-US', { day: '2-digit', month: '2-digit', year: 'numeric' }).replace(/\//g, '-');;
  const line = req.body.line_no;

  let query3;
  let query4;

  if (line === '2') {
    query3 = `SELECT line FROM worker_timesheet WHERE line LIKE 'EB%' AND date_time = '${fd}' GROUP BY line`;
    query4 = `SELECT * FROM worker_timesheet WHERE line LIKE 'EB%' AND date_time = '${fd}' GROUP BY section`;
  } else {
    query3 = `SELECT line FROM worker_timesheet WHERE line NOT LIKE 'EB%' AND date_time = '${fd}' GROUP BY line`;
    query4 = `SELECT * FROM worker_timesheet WHERE line NOT LIKE 'EB%' AND date_time = '${fd}' GROUP BY section`;
  }

  try {
    const timesheet = await queryPromise(query3);
    const timesheet1 = await queryPromise(query4);

    const sections = [];
    for (const itemk of timesheet1) {
      const sectionNameQuery = `SELECT section_name FROM section WHERE id = ${itemk.section}`;
      const result = await queryPromise(sectionNameQuery);
      if (result.length > 0) {
   
        sections.push(result[0].section_name);
      }
    }

    const totals = [];
    const totalData = ["Total ManPower", "Total Productionb FG OUTPUT", "PPP"];
    for (const data of totalData) {
      totals.push({ totalData: data });
    }

    const responseData = {
      section: sections,
      items:[],
    }


    // Use Promise.all to execute the mapping function in parallel
    await Promise.all(
      timesheet.map(async (item) => {
        let l = 0;
        const section_data =[];
        for (const item1 of timesheet1) {
          const section_name = item.section_name; // Use the correct syntax to access section_name
          //const values = [];
          const date = fd || new Date().toLocaleDateString('en-US', { day: '2-digit', month: '2-digit', year: 'numeric' });
          const queryk = `SELECT id FROM worker_timesheet WHERE date_time = '${date}' AND line = '${item.line}' AND section = '${item1.section}' GROUP BY date_time, line, section, entry_id`;
          const result = await queryPromise(queryk);
          console.log(queryk);

          if (result) {
            const k = result.length;
            console.log(k,'length of k')
            l += k;
            section_data.push(k);
            console.log(k,"--'''''''--");
          }
          //section_data = values;
        }
        console.log(section_data,"section data");
        if (fd) {
          console.log("ffdate");
          const queryfg = `SELECT SUM(fg_output) as tar FROM fg_details WHERE date_time = '${fd}' AND line = '${item.line}' GROUP BY line`;
          const fgResult = await queryPromise(queryfg);
          if (fgResult.length > 0) {
            console.log('--++--');
            const fgproduct = fgResult.tar || 0;
            console.log(fgproduct,'Division',l)
            const pp = fgproduct / l;
            const eff = isFinite(pp) ? pp.toFixed(2) : '0';

            responseData.items.push({
              lines: item.line,
              section_data: section_data,
              totals: totals,
              tm: l,
              pp: fgproduct,
              eff: eff,
            });
            console.log(responseData,"response")
          }
        }
      })
    );

    res.json(responseData);
    //console.log(responseData,"======______")
  } catch (error) {
    console.error('Error:', error);
    res.status(500).json({ error: 'Database error' });
  }
});

// Create a function to wrap MySQL queries in a Promise
function queryPromise(sql) {
  return new Promise((resolve, reject) => {
    db.query(sql, (error, results) => {
      if (error) {
        reject(error);
      } else {
        resolve(results);
      }
    });
  });
}

//Get productivity Default data
app.get('/nbraid/getfilteredproductivitydefault', async (req, res) => {
  const date = new Date().toLocaleDateString('en-GB', { timeZone: 'Africa/Lagos' });
  const parts = date.split('/');
  const day = parts[0].padStart(2, '0');
  const month = parts[1].padStart(2, '0');
  const year = parts[2];
  const currentMonth = `${month}-${year}`;
  const td = `${day}-${month}-${year}`;
  console.log('td:',td);

  let query3;
  let query4;

  
    query3 = `SELECT line FROM worker_timesheet WHERE line NOT LIKE 'EB%' AND date_time = '${td}' GROUP BY line`;
    query4 = `SELECT * FROM worker_timesheet WHERE line NOT LIKE 'EB%' AND date_time = '${td}' GROUP BY section`;
  

  try {
    const timesheet = await queryPromise(query3);
    const timesheet1 = await queryPromise(query4);

    const sections = [];
    for (const itemk of timesheet1) {
      const sectionNameQuery = `SELECT section_name FROM section WHERE id = ${itemk.section}`;
      const result = await queryPromise(sectionNameQuery);
      if (result.length > 0) {
   
        sections.push(result[0].section_name);
      }
    }

    const totals = [];
    const totalData = ["Total ManPower", "Total Productionb FG OUTPUT", "PPP"];
    for (const data of totalData) {
      totals.push({ totalData: data });
    }

    const responseData = {
      section: sections,
      items:[],
    }

    // Use Promise.all to execute the mapping function in parallel
    await Promise.all(
      timesheet.map(async (item) => {
        let l = 0;
        const section_data =[];
        for (const item1 of timesheet1) {
          const section_name = item.section_name; // Use the correct syntax to access section_name
          //const values = [];
          const date = td || new Date().toLocaleDateString('en-US', { day: '2-digit', month: '2-digit', year: 'numeric' });
          const queryk = `SELECT id FROM worker_timesheet WHERE date_time = '${date}' AND line = '${item.line}' AND section = '${item1.section}' GROUP BY date_time, line, section, entry_id`;
          const result = await queryPromise(queryk);
          console.log(queryk);

          if (result) {
            const k = result.length;
            l += k;
            section_data.push(k);
            console.log(k,"--'''''''--");
          }
          //section_data = values;
        }
        console.log(section_data,"section data");
        if (td) {
          
          const queryfg = `SELECT SUM(fg_output) as tar FROM fg_details WHERE date_time = '${td}' AND line = '${item.line}' GROUP BY line`;
          const fgResult = await queryPromise(queryfg);
          console.log(queryfg,'----');
          if (fgResult.length > 0) {
            console.log('--++--');
            const fgproduct = fgResult[0].tar || 0;
            console.log(fgproduct,'Division',l)
            const pp = fgproduct / l;
            const eff = isFinite(pp) ? pp.toFixed(2) : '0';

            responseData.items.push({
              lines: item.line,
              
              section_data: section_data,
              totals: totals,
              tm: l,
              pp: fgproduct,
              eff: eff,
            });
            //console.log(responseData,"response")
            console.log('response:',responseData);
          }
        }
      })
    );

    res.json(responseData);
    //console.log(responseData,"======")
    console.log('responsedata:',responseData);
  } catch (error) {
    console.error('Error:', error);
    res.status(500).json({ error: 'Database error' });
  }
});

// Create a function to wrap MySQL queries in a Promise
function queryPromise(sql) {
  return new Promise((resolve, reject) => {
    db.query(sql, (error, results) => {
      if (error) {
        reject(error);
      } else {
        resolve(results);
      }
    });
  });
}



//Employee Timesheet Data

// filter data fetch
app.post('/getempreportData', async (req, res) => {
  try {
    var product_name = req.body.product_id;
    var line_no = req.body.line_no;
    var section = req.body.section;
    var shift = req.body.shift;
    var site = req.body.site;
    const fromdate = req.body.fromdate;
    const fdParts = fromdate.split('-');
    const fd = `${fdParts[2]}-${fdParts[1]}-${fdParts[0]}`;
    
    const todate = req.body.todate;
    const tdParts = todate.split('-');
    const td = `${tdParts[2]}-${tdParts[1]}-${tdParts[0]}`;
    
    const dateObj = new Date(fromdate);
    const day = dateObj.getDate().toString().padStart(2, '0');
    const month = (dateObj.getMonth() + 1).toString().padStart(2, '0');
    const year = dateObj.getFullYear();
    
    const convertedDate = `${day}-${month}-${year}`;
    
    const dateObj1 = new Date(todate);
    const day1 = dateObj1.getDate().toString().padStart(2, '0');
    const month1 = (dateObj1.getMonth() + 1).toString().padStart(2, '0');
    const year1 = dateObj1.getFullYear();
    
    const convertedDate1 = `${day1}-${month1}-${year1}`;
    console.log('Converted:', convertedDate);
    console.log('Converted2:', convertedDate1);
    
    const fd2 = Math.floor(new Date(fromdate).getTime() / 1000);
    const td1 = Math.floor(new Date(todate).getTime() / 1000);
    const fd1 = Math.floor(new Date(fd2 * 1000).setDate(new Date(fd2 * 1000).getDate() - 1) / 1000);
    
    var newfd = fd1;
    var newtd = td1;
    
    // Log the received data
    console.log('Received data:');
    console.log('Product Name:', product_name);
    console.log('Line No:', line_no);
    console.log('Section:', section);
    console.log('Shift:', shift);
    console.log('From Date:', fd);
    console.log('To Date:', td);
    console.log('Converted Timestamp:', newfd);
    console.log('Converted Timestamp:', newtd);
      
    let whereConditions = [];

    if (product_name !== '') {
      whereConditions.push(`worker_timesheet.product_name = '${product_name}'`);
    }
    if (line_no !== '') {
      whereConditions.push(`worker_timesheet.line = '${line_no}'`);
    }
    if (section !== '') {
      whereConditions.push(`worker_timesheet.section = '${section}'`);
    }
    if (shift !== '') {
      whereConditions.push(`worker_timesheet.shift = '${shift}'`);
    }
    if (site !== '') {
      whereConditions.push(`worker_timesheet.site = '${site}'`);
    }
    whereConditions.push(`worker_timesheet.time_stamp BETWEEN '${newfd}' AND '${newtd}'`);
  
    const whereClause = whereConditions.join(' AND ');
  
  
    const query = `
      SELECT  worker_timesheet.*,
      item_masterr.item_description,
      section.section_name,
        HOUR1, HOUR2, HOUR3, HOUR4, HOUR5, HOUR6, HOUR7, HOUR8, HOUR9, HOUR10, HOUR11,
        HOUR1 + HOUR2 + HOUR3 + HOUR4 + HOUR5 + HOUR6 + HOUR7 + HOUR8 + HOUR9 + HOUR10 + HOUR11 AS value_sum
      FROM worker_timesheet
      LEFT JOIN item_masterr ON item_masterr.id = worker_timesheet.product_name
      LEFT JOIN section ON section.id = worker_timesheet.section
      WHERE ${whereClause}
      GROUP BY
      worker_timesheet.date_time,
      worker_timesheet.entry_id,
      worker_timesheet.product_name,
      worker_timesheet.section,
      worker_timesheet.shift,
      worker_timesheet.line
    `;

   // console.log('query:', query);
    
    const results = await new Promise((resolve, reject) => {
      db.query(query, async (error, results) => {
        if (error) {
          console.error('Error executing MySQL query: ', error);
          return reject(error);
        }

        const reggMap = {}; // Create a map to associate regg with entry IDs

        for (const row of results) {
          const entryid = row.entry_id;
          const site = row.site;
         

          let query1;
          let ss;
          if (site === 'both') {
            // Check the 'employees_ota' table first
            query1 = await new Promise((resolveQuery1, rejectQuery1) => {
              db.query(`SELECT * FROM employees_ota WHERE entryid='${entryid}'`, (error, results) => {
                if (error) {
                  console.error('MySQL Error:', error);
                  res.status(500).json({ error: 'Internal Server Error' });
                  return rejectQuery1(error);
                }

                if (results.length > 0) {
                  resolveQuery1(results[0]);
                } else {
                  // If no result is found in 'employees_ota', check 'geopos_employees' table
                  db.query(`SELECT * FROM geopos_employees WHERE entryid='${entryid}'`, (error, results2) => {
                    if (error) {
                      console.error('MySQL Error:', error);
                      res.status(500).json({ error: 'Internal Server Error' });
                      return rejectQuery1(error);
                    }

                    if (results2.length > 0) {
                      resolveQuery1(results2[0]);
                    } else {
                      resolveQuery1(null);
                    }
                  });
                }
              });
            });
          } else if (site === 'ikeja') {
            query1 = await new Promise((resolveQuery1, rejectQuery1) => {
              db.query(`SELECT * FROM geopos_employees WHERE entryid='${entryid}'`, (error, results) => {
                if (error) {
                  console.error('MySQL Error:', error);
                  res.status(500).json({ error: 'Internal Server Error' });
                  return rejectQuery1(error);
                }

                if (results.length > 0) {
                  resolveQuery1(results[0]);
                } else {
                  resolveQuery1(null);
                }
              });
            });
          } else if (site === 'ota') {
            query1 = await new Promise((resolveQuery1, rejectQuery1) => {
              db.query(`SELECT * FROM employees_ota WHERE entryid='${entryid}'`, (error, results) => {
                if (error) {
                  console.error('MySQL Error:', error);
                  res.status(500).json({ error: 'Internal Server Error' });
                  return rejectQuery1(error);
                }

                if (results.length > 0) {
                  resolveQuery1(results[0]);
                } else {
                  resolveQuery1(null);
                }
              });
            });
          } else {
            query1 = null;
          }

          if (query1) {
           
            const reg = query1.joindate;
            const regg = typeof reg === 'string' ? reg.split(' ')[0] : null;
            //const regg = reg.split(' ')[0];
            
            //console.log('Received reg:', regg);

            // Store regg in the reggMap with entryid as the key
            reggMap[entryid] = regg;
          } else {
            // Handle the case where no results were found
          }
          
        }

        // Iterate through the timesheet results and add regg to each result object
        for (const row of results) {
          const entryid = row.entry_id;
          row.regg = reggMap[entryid]; // Add regg to the timesheet result object
        }

        resolve(results);
      });
    });

    // Extract entry_ids from the first query results
    const entryIds = results.map((result) => result.entry_id);
    const query2 = `
      SELECT * FROM employees_ota WHERE entryid IN ('${entryIds.join("','")}')
    `;
    
    const results2 = await new Promise((resolve, reject) => {
      db.query(query2, (error2, results2) => {
        if (error2) {
          console.error('Error executing second MySQL query: ', error2);
          return reject(error2);
        }
        resolve(results2);
      });
    });
    
    // Extract product, line, and section from the timesheet results
    const productFromTimesheet = results.length > 0 ? results[0].item_description : null;
    const lineFromTimesheet = results.length > 0 ? results[0].line : null;
    const sectionFromTimesheet = results.length > 0 ? results[0].section_name : null;

    // Modify the data object
    const data = {
      timesheet: results,
      fdate: convertedDate,
      tdate: convertedDate1,
      operatorname: results.length > 0 ? results[0].operator_name : null
    };

    // Conditionally include product, line, and section in the response
    if (product_name) {
      data.product = productFromTimesheet;
    }
    if (line_no) {
      data.line = lineFromTimesheet;
    }
    if (section) {
      data.section = sectionFromTimesheet;
    }

    // Send the modified data object as a response
    res.json(data);
  } catch (error) {
    console.error('Error:', error);
    return res.status(500).json({ error: 'Internal Server Error' });
  }
});
 

//default data fetch
app.get('/gettodayempreportData', async (req, res) => {
  try {
    const date = new Date().toLocaleDateString('en-GB', { timeZone: 'Africa/Lagos' });
    const parts = date.split('/');
    const formattedDay = parts[0].padStart(2, '0');
    const formattedMonth = parts[1].padStart(2, '0');
    const year = parts[2];
    const date1 = `${formattedDay}-${formattedMonth}-${year}`;

    const query = `
      SELECT  worker_timesheet.*,
      item_masterr.item_description,
      section.section_name,
      HOUR1, HOUR2, HOUR3, HOUR4, HOUR5, HOUR6, HOUR7, HOUR8, HOUR9, HOUR10, HOUR11,
      HOUR1 + HOUR2 + HOUR3 + HOUR4 + HOUR5 + HOUR6 + HOUR7 + HOUR8 + HOUR9 + HOUR10 + HOUR11 AS value_sum
      FROM worker_timesheet
      LEFT JOIN item_masterr ON item_masterr.id = worker_timesheet.product_name
      LEFT JOIN section ON section.id = worker_timesheet.section
      WHERE date_time = ?
      GROUP BY
       worker_timesheet.date_time,
      worker_timesheet.entry_id,
      worker_timesheet.product_name,
      worker_timesheet.section,
      worker_timesheet.shift,
      worker_timesheet.line
    `;

    const results = await new Promise((resolve, reject) => {
      db.query(query, [date1], async (error, results) => {
        if (error) {
          console.error('Error executing MySQL query: ', error);
          return reject(error);
        }

        const reggMap = {}; // Create a map to associate regg with entry IDs

        for (const row of results) {
          const entryid = row.entry_id;
          const site = row.site;
          const date_time = row.date_time;

          // Add these console.log statements to log the values
          console.log('Entry ID:', entryid);
          console.log('Site:', site);
          console.log('Date Time:', date_time);

          let query1;
          let ss;
          if (site === 'both') {
            // Check the 'employees_ota' table first
            query1 = await new Promise((resolveQuery1, rejectQuery1) => {
              db.query(`SELECT * FROM employees_ota WHERE entryid='${entryid}'`, (error, results) => {
                if (error) {
                  console.error('MySQL Error:', error);
                  res.status(500).json({ error: 'Internal Server Error' });
                  return rejectQuery1(error);
                }

                if (results.length > 0) {
                  resolveQuery1(results[0]);
                } else {
                  // If no result is found in 'employees_ota', check 'geopos_employees' table
                  db.query(`SELECT * FROM geopos_employees WHERE entryid='${entryid}'`, (error, results2) => {
                    if (error) {
                      console.error('MySQL Error:', error);
                      res.status(500).json({ error: 'Internal Server Error' });
                      return rejectQuery1(error);
                    }

                    if (results2.length > 0) {
                      resolveQuery1(results2[0]);
                    } else {
                      resolveQuery1(null);
                    }
                  });
                }
              });
            });
          } else if (site === 'ikeja') {
            query1 = await new Promise((resolveQuery1, rejectQuery1) => {
              db.query(`SELECT * FROM geopos_employees WHERE entryid='${entryid}'`, (error, results) => {
                if (error) {
                  console.error('MySQL Error:', error);
                  res.status(500).json({ error: 'Internal Server Error' });
                  return rejectQuery1(error);
                }

                if (results.length > 0) {
                  resolveQuery1(results[0]);
                } else {
                  resolveQuery1(null);
                }
              });
            });
          } else if (site === 'ota') {
            query1 = await new Promise((resolveQuery1, rejectQuery1) => {
              db.query(`SELECT * FROM employees_ota WHERE entryid='${entryid}'`, (error, results) => {
                if (error) {
                  console.error('MySQL Error:', error);
                  res.status(500).json({ error: 'Internal Server Error' });
                  return rejectQuery1(error);
                }

                if (results.length > 0) {
                  resolveQuery1(results[0]);
                } else {
                  resolveQuery1(null);
                }
              });
            });
          } else {
            query1 = null;
          }

          if (query1) {
            const reg = query1.joindate;
            console.log('Received reg:', reg);
            const regg = (typeof reg === 'string') ? reg.split(' ')[0] : 'N/A'; // 'N/A' or any other default value you want to use
            
            

            // Store regg in the reggMap with entryid as the key
            reggMap[entryid] = regg;
          } else {
            // Handle the case where no results were found
          }
        }

        // Iterate through the timesheet results and add regg to each result object
        for (const row of results) {
          const entryid = row.entry_id;
          row.regg = reggMap[entryid]; // Add regg to the timesheet result object
        }

        resolve(results);
      });
    });

   
    
    const data = {
      timesheet: results,
      date: date1,
     
    };
    
    res.json(data);
  } catch (error) {
    console.error('Error:', error);
    return res.status(500).json({ error: 'Internal Server Error' });
  }
});


//PPP Report 

//Default data fetch
app.get('/gettodaypppreportData', (req, res) => {
  const date = new Date().toLocaleDateString('en-GB', { timeZone: 'Africa/Lagos' });
  const parts = date.split('/');
  const formattedDay = parts[0].padStart(2, '0');
  const formattedMonth = parts[1].padStart(2, '0');
  const year = parts[2];
  const date1 = `${formattedDay}-${formattedMonth}-${year}`;

  //const query = `SELECT product_name, date_time FROM worker_timesheet WHERE date_time = ? GROUP BY product_name, date_time`;
 
  const query = `
  SELECT
    worker_timesheet.*,
    item_masterr.item_description
  FROM
    worker_timesheet
    LEFT JOIN item_masterr ON item_masterr.id = worker_timesheet.product_name
  WHERE
  date_time = '${date1}'
  GROUP BY 
    worker_timesheet.product_name,
    worker_timesheet.date_time,
    worker_timesheet.shift,
    worker_timesheet.site,
    worker_timesheet.line
   
`;

  db.query(query, (err, results) => {
    if (err) {
      console.error('MySQL query error:', err);
      res.status(500).json({ error: 'Internal Server Error' });
      return;
    }

    res.json({
      timesheet: results,
      date: date1,
    });
  });
});

//get search data
app.post('/getpppreportData', (req, res) => {
 
  var fromdate = new Date(req.body.fromdate); // Convert to Date object
  var todate = new Date(req.body.todate); // Convert to Date object
  var shift = req.body.shift;
  var site = req.body.site;

  const newfromdate = `${fromdate.getFullYear()}-${(fromdate.getMonth() + 1).toString().padStart(2, '0')}-${fromdate.getDate().toString().padStart(2, '0')}`;
  const newtodate = `${todate.getFullYear()}-${(todate.getMonth() + 1).toString().padStart(2, '0')}-${todate.getDate().toString().padStart(2, '0')}`;


  const newfromdate1 = newfromdate.split('-').reverse().join('-');
  const newtodate1 = newtodate.split('-').reverse().join('-');


  const timestampfromdate = Math.floor(fromdate.getTime() / 1000);
  const timestamptodate = Math.floor(todate.getTime() / 1000);

  const timestampfromdate1 = Math.floor(new Date(timestampfromdate * 1000).setDate(new Date(timestampfromdate * 1000).getDate() - 1) / 1000);

  console.log('Received data:');
 
  console.log('From Date:', newfromdate1);
  console.log('To Date:', newtodate1);
  console.log('Timestamp From Date:', timestampfromdate);
  console.log('Timestamp To Date:', timestamptodate);

  //let whereConditions = [];

  let whereConditions = [
    `worker_timesheet.time_stamp BETWEEN '${timestampfromdate1}' AND '${timestamptodate}'`
  ];

  if (shift !== '') {
    whereConditions.push(`worker_timesheet.shift = '${shift}'`);
  }
  if (site !== '') {
    whereConditions.push(`worker_timesheet.site = '${site}'`);
  }
   
  const whereClause = whereConditions.join(' AND ');

 
const query = `
  SELECT
    worker_timesheet.*,
    item_masterr.item_description
  FROM
    worker_timesheet
    LEFT JOIN item_masterr ON item_masterr.id = worker_timesheet.product_name
  WHERE
    ${whereClause}
  GROUP BY 
    worker_timesheet.product_name,
    worker_timesheet.date_time,
    worker_timesheet.shift,
    worker_timesheet.site,
    worker_timesheet.line
   
`;

console.log('query:', query);

  db.query(query, (error, results) => {
    if (error) {
      console.error('Error executing MySQL query: ', error);
      return res.status(500).json({ error: 'Internal Server Error' });
    }
   // const resultsCount = results.length;
   // console.log('resultsCount:', resultsCount);

    const data = {
      timesheet: results,
      fromdate: fromdate,
      todate: todate,
      fromdatetimestamp: timestampfromdate,
      todatetimestamp: timestamptodate,
      fromdate1: newfromdate1,
      todate1: newtodate1,
      site:site,
      shift:shift,
    };

    res.json(data);
  });
});

// Endpoint to handle the POST request for sum
app.post('/sum', (req, res) => {
  const timestamp1 = req.body.timestamp1;
  const timestamp2 = req.body.timestamp2;
  const product_name = req.body.product_name; // Retrieve product_name value
  const date_time = req.body.date_time; // Retrieve product_name value
  const shift = req.body.shift; // Retrieve product_name value
  const site = req.body.site; // Retrieve product_name value
  const line = req.body.line; // Retrieve product_name value
 

  //console.log('Timestamp1:', timestamp1);
  //console.log('Timestamp2:', timestamp2);
  //console.log('Product Name:', product_name);
  
  
  // Perform calculations or further processing with the timestamps
  
  // Send the response
 // const query1 = `SELECT SUM(a.tar) as res FROM (SELECT SUM(fg_output) as tar FROM fg_details WHERE time_stamp BETWEEN ? AND ? AND product_name=? GROUP BY product_name, time_stamp) a`;
  //const values1 = [timestamp1, timestamp2, product_name];

  const query1 = `SELECT SUM(a.tar) as res 
  FROM (
    SELECT SUM(fg_output) as tar
    FROM fg_details
    WHERE date_time = '${date_time}' AND product_name = '${product_name}' AND site = '${site}' AND shift = '${shift}' AND line = '${line}'
    GROUP BY product_name, time_stamp, site, shift, line
  ) a`;

  // Query 2: Calculate the average of fg_output
  /* const query2 = `
  SELECT * FROM worker_timesheet AS w
  JOIN item_masterr AS f ON w.product_name = f.id
  WHERE w.time_stamp BETWEEN ? AND ?
    AND w.product_name = ?
  GROUP BY w.product_name, w.time_stamp, w.entry_id
  `;

  const values2 = [timestamp1, timestamp2, product_name]; */

  const query2 = `SELECT *
                FROM worker_timesheet
                WHERE date_time = '${date_time}' AND product_name = '${product_name}' AND site = '${site}' AND shift = '${shift}' AND line = '${line}'
                GROUP BY product_name, time_stamp, entry_id, site, shift, line`;
  
  
  db.query(query1, (error1, results1) => {
    if (error1) {
      console.error('Error executing query:', error1);
      return res.status(500).json({ error: 'An error occurred' });
    }


  
    db.query(query2, (error2, results2) => {
      if (error2) {
        console.error('Error executing query 2:', error2);
        return res.status(500).json({ error: 'An error occurred' });
      }

      const sum = results1[0].res;
      const avg = results2.length;
      //console.log(avg);

      // Use the sum and avg values as needed
      res.send({ sum: sum, avg: avg });
    });
    // Use the sum value as needed
    //res.send({ sum: sum });
  });
});


//FG Output Report

//default fgoutput data fetch
app.get('/get_fgoutput_default', (req, res) => {
  console.log("Request received for /get_fgoutput_default");

  const date = new Date().toLocaleDateString('en-GB', { timeZone: 'Africa/Lagos' });
  const parts = date.split('/');
  const formattedDay = parts[0].padStart(2, '0');
  const formattedMonth = parts[1].padStart(2, '0');
  const year = parts[2];
  const date1 = `${formattedDay}-${formattedMonth}-${year}`;

  const query = `
    SELECT fg_details.*, item_masterr.item_description, SUM(fg_details.fg_output) as tar
    FROM fg_details
    LEFT JOIN item_masterr ON fg_details.product_name = item_masterr.id
    WHERE fg_details.date_time = ?
    GROUP BY fg_details.product_name, fg_details.line, fg_details.shift, fg_details.site, fg_details.date_time
  `;

  db.query(query, [date1], (error, results) => {
    if (error) {
      console.error('Error executing MySQL query: ', error);
      return res.status(500).json({ error: 'Internal Server Error' });
    }

    // Process results if data is available
    let completedQueries = 0;
    const resultsWithWorkerCount = [];

    if (results.length === 0) {
      // If no results, send an empty timesheet array
      return res.json({ timesheet: [], date: date1 });
    }

    results.forEach((row, index) => {
      const innerQuery = `SELECT * FROM worker_timesheet 
                          WHERE product_name = '${row.product_name}' 
                          AND line = '${row.line}' 
                          AND site = '${row.site}' 
                          AND shift = '${row.shift}' 
                          AND date_time = '${row.date_time}' 
                          GROUP BY entry_id`;

      db.query(innerQuery, (error, workerResults) => {
        if (error) {
          console.error('Error executing inner MySQL query: ', error);
          return res.status(500).json({ error: 'Internal Server Error' });
        }

        const workerCount = workerResults.length;
        row.workerCount = workerCount;
        resultsWithWorkerCount.push(row);

        completedQueries++;

        if (completedQueries === results.length) {
          const data = {
            timesheet: resultsWithWorkerCount,
            date: date1,
          };

          res.json(data);
        }
      });
    });
  });
});

//filter search data fetch
app.post('/getfgoutputreport', (req, res) => {

   const shift = req.body.shift;
   const site = req.body.site;
 
   const fromdate = req.body.fromdate;
   const fdParts = fromdate.split('-');
   const fd = `${fdParts[2]}-${fdParts[1]}-${fdParts[0]}`;
   
   const todate = req.body.todate;
   const tdParts = todate.split('-');
   const td = `${tdParts[2]}-${tdParts[1]}-${tdParts[0]}`;
   
   const dateObj = new Date(fromdate);
   const day = dateObj.getDate().toString().padStart(2, '0');
   const month = (dateObj.getMonth() + 1).toString().padStart(2, '0');
   const year = dateObj.getFullYear();
   
   const convertedDate = `${day}-${month}-${year}`;
   
   const dateObj1 = new Date(todate);
   const day1 = dateObj1.getDate().toString().padStart(2, '0');
   const month1 = (dateObj1.getMonth() + 1).toString().padStart(2, '0');
   const year1 = dateObj1.getFullYear();
   
   const convertedDate1 = `${day1}-${month1}-${year1}`;
   console.log('Converted:', convertedDate);
   console.log('Converted2:', convertedDate1);
   
   const fd2 = Math.floor(new Date(fromdate).getTime() / 1000);
   const td1 = Math.floor(new Date(todate).getTime() / 1000);
   const fd1 = Math.floor(new Date(fd2 * 1000).setDate(new Date(fd2 * 1000).getDate() - 1) / 1000);
   
   var newfd = fd1;
   var newtd = td1;

   // Log the received data
   console.log('Received data:');
   console.log('Shift:', shift);
   console.log('Site:', site);
   console.log('From Date:', fd);
   console.log('To Date:', td);
   console.log('Converted Timestamp:', newfd);
   console.log('Converted Timestamp:', newtd);

   let whereConditions = [];

if (shift !== '') {
  whereConditions.push(`fg_details.shift = '${shift}'`);
}
if (site !== '') {
  whereConditions.push(`fg_details.site = '${site}'`);
}
whereConditions.push(`fg_details.time_stamp BETWEEN '${newfd}' AND '${newtd}'`);

const whereClause = whereConditions.join(' AND ');

  // Construct the SQL query
  const query = `
  SELECT 
      fg_details.*, 
      item_masterr.item_description, 
      SUM(fg_details.fg_output) AS tar
  FROM 
      fg_details
  LEFT JOIN 
      item_masterr ON fg_details.product_name = item_masterr.id
  WHERE 
      ${whereClause}
  GROUP BY 
      fg_details.product_name, 
      fg_details.line, 
      fg_details.shift, 
      fg_details.site, 
      fg_details.date_time
`;

console.log('Query:',query);
  
  // Execute the SQL query
  db.query(query, (error, results) => {
    if (error) {
      console.error('Error executing MySQL query: ', error);
      return res.status(500).json({ error: 'Internal Server Error' });
    }

    // If the main query results are empty, return a response
    if (results.length === 0) {
      const emptyResponse = {
        timesheet: [],
        shift: shift,
        site: site,
        fdate: convertedDate,
        tdate: convertedDate1,
      };

      return res.json(emptyResponse);
    }
  
    // Create an array to store the results with workerCount
    const resultsWithWorkerCount = [];
  
    // Loop through the results
    results.forEach((row) => {

      let query;

      if (fromdate !== '' && todate !== '') {
        query = `SELECT * FROM worker_timesheet 
                      WHERE product_name = '${row.product_name}' 
                      AND line = '${row.line}' 
                      AND site = '${row.site}' 
                      AND shift = '${row.shift}' 
                      AND date_time = '${row.date_time}' 
                      GROUP BY entry_id`;
      } else {
        countQuery = `SELECT * FROM worker_timesheet 
                      WHERE product_name = '${row.product_name}' 
                      AND line = '${row.line}' 
                      AND site = '${row.site}' 
                      AND shift = '${row.shift}' 
                      AND date_time = '${row.date_time}' 
                      GROUP BY entry_id`;
      }
      //const product_name = result.product_name; // Extract product_name from the result
  
      // Execute the worker_timesheet SQL query
      db.query(query, (error, workerResults) => {
        if (error) {
          console.error('Error:', error);
          res.status(500).json({ error: 'Internal server error' });
        } else {
          const workerCount = workerResults.length;
          //console.log('workerCount:', workerCount);

          // Create a new object that combines the original result and workerCount
          const resultWithWorkerCount = {
            ...row,
            workerCount,
          };
  
          // Push the result with workerCount to the array
          resultsWithWorkerCount.push(resultWithWorkerCount);
  
          // If all results have been processed, send the response
          if (resultsWithWorkerCount.length === results.length) {
            const data = {
              timesheet: resultsWithWorkerCount,
              shift: shift,
              site: site,
              fdate: convertedDate,
              tdate: convertedDate1,
            };
  
            res.json(data);
          }
        }
      });
    });
  });
});


//Productive Manpower

//Filter data search
app.post('/gethourlossreport', async (req, res) => {
  try {
    var product_name = req.body.product_id;
    var line_no = req.body.line_no;
    const fromdate = req.body.fromdate;
    const fdParts = fromdate.split('-');
    const fd = `${fdParts[2]}-${fdParts[1]}-${fdParts[0]}`;
    
    const todate = req.body.todate;
    const tdParts = todate.split('-');
    const td = `${tdParts[2]}-${tdParts[1]}-${tdParts[0]}`;
    
    const dateObj = new Date(fromdate);
    const day = dateObj.getDate().toString().padStart(2, '0');
    const month = (dateObj.getMonth() + 1).toString().padStart(2, '0');
    const year = dateObj.getFullYear();
    
    const convertedDate = `${day}-${month}-${year}`;
    
    const dateObj1 = new Date(todate);
    const day1 = dateObj1.getDate().toString().padStart(2, '0');
    const month1 = (dateObj1.getMonth() + 1).toString().padStart(2, '0');
    const year1 = dateObj1.getFullYear();
    
    const convertedDate1 = `${day1}-${month1}-${year1}`;
    console.log('Converted:', convertedDate);
    console.log('Converted2:', convertedDate1);
    
    const fd2 = Math.floor(new Date(fromdate).getTime() / 1000);
    const td1 = Math.floor(new Date(todate).getTime() / 1000);
    const fd1 = Math.floor(new Date(fd2 * 1000).setDate(new Date(fd2 * 1000).getDate() - 1) / 1000);
    
    var newfd = fd1;
    var newtd = td1;
    
    // Log the received data
    console.log('Received data:');
    console.log('Product Name:', product_name);
    console.log('Line No:', line_no);
    console.log('From Date:', fd);
    console.log('To Date:', td);
    console.log('Converted Timestamp:', newfd);
    console.log('Converted Timestamp:', newtd);
    
    let whereConditions = [];
    
    if (product_name !== '') {
      whereConditions.push(`worker_timesheet.product_name = '${product_name}'`);
    }
    if (line_no !== '') {
      whereConditions.push(`worker_timesheet.line = '${line_no}'`);
    }
    whereConditions.push(`worker_timesheet.time_stamp BETWEEN '${newfd}' AND '${newtd}'`);
    
    const whereClause = whereConditions.join(' AND ');
    
    const query = `
      SELECT worker_timesheet.*,
      item_masterr.item_description,
      section.section_name
      FROM
      worker_timesheet
      LEFT JOIN item_masterr ON item_masterr.id = worker_timesheet.product_name
      LEFT JOIN section ON section.id = worker_timesheet.section
      WHERE 
      ${whereClause}
      GROUP BY
      worker_timesheet.date_time,
      worker_timesheet.entry_id,
      worker_timesheet.product_name,
      worker_timesheet.section,
      worker_timesheet.line
    `;

    //console.log('query:', query);
    
    const results = await new Promise((resolve, reject) => {
      db.query(query, async (error, results) => {
        if (error) {
          console.error('Error executing MySQL query: ', error);
          return reject(error);
        }

        const reggMap = {}; // Create a map to associate regg with entry IDs

        for (const row of results) {
          const entryid = row.entry_id;
          const site = row.site;
          const date_time = row.date_time;

          let query1;
          let ss;
          if (site === 'both') {
            // Check the 'employees_ota' table first
            query1 = await new Promise((resolveQuery1, rejectQuery1) => {
              db.query(`SELECT * FROM employees_ota WHERE entryid='${entryid}'`, (error, results) => {
                if (error) {
                  console.error('MySQL Error:', error);
                  res.status(500).json({ error: 'Internal Server Error' });
                  return rejectQuery1(error);
                }

                if (results.length > 0) {
                  resolveQuery1(results[0]);
                } else {
                  // If no result is found in 'employees_ota', check 'geopos_employees' table
                  db.query(`SELECT * FROM geopos_employees WHERE entryid='${entryid}'`, (error, results2) => {
                    if (error) {
                      console.error('MySQL Error:', error);
                      res.status(500).json({ error: 'Internal Server Error' });
                      return rejectQuery1(error);
                    }

                    if (results2.length > 0) {
                      resolveQuery1(results2[0]);
                    } else {
                      resolveQuery1(null);
                    }
                  });
                }
              });
            });
          } else if (site === 'ikeja') {
            query1 = await new Promise((resolveQuery1, rejectQuery1) => {
              db.query(`SELECT * FROM geopos_employees WHERE entryid='${entryid}'`, (error, results) => {
                if (error) {
                  console.error('MySQL Error:', error);
                  res.status(500).json({ error: 'Internal Server Error' });
                  return rejectQuery1(error);
                }

                if (results.length > 0) {
                  resolveQuery1(results[0]);
                } else {
                  resolveQuery1(null);
                }
              });
            });
          } else if (site === 'ota') {
            query1 = await new Promise((resolveQuery1, rejectQuery1) => {
              db.query(`SELECT * FROM employees_ota WHERE entryid='${entryid}'`, (error, results) => {
                if (error) {
                  console.error('MySQL Error:', error);
                  res.status(500).json({ error: 'Internal Server Error' });
                  return rejectQuery1(error);
                }

                if (results.length > 0) {
                  resolveQuery1(results[0]);
                } else {
                  resolveQuery1(null);
                }
              });
            });
          } else {
            query1 = null;
          }

          
          if (query1) {
            // Check if the result has the expected property 'joindate'
            if ('joindate' in query1) {
              const reg = query1.joindate;
        
              // Check if reg is a string before attempting to split
              if (typeof reg === 'string') {
                const regg = reg.split(' ')[0];
                // Store regg in the reggMap with entryid as the key
                reggMap[entryid] = regg;
              } else {
                // Handle the case where reg is not a string
              }
            } else {
              // Handle the case where 'joindate' is not present in the result
            }
          } else {
            // Handle the case where no results were found
          }
          
        }

        // Iterate through the timesheet results and add regg to each result object
        for (const row of results) {
          const entryid = row.entry_id;
          //row.regg = reggMap[entryid]; // Add regg to the timesheet result object
          row.regg = reggMap[entryid] || '';
        }

        resolve(results);
      });
    });

    // Extract entry_ids from the first query results
    const entryIds = results.map((result) => result.entry_id);
    const query2 = `
      SELECT * FROM employees_ota WHERE entryid IN ('${entryIds.join("','")}')
    `;
    
    const results2 = await new Promise((resolve, reject) => {
      db.query(query2, (error2, results2) => {
        if (error2) {
          console.error('Error executing second MySQL query: ', error2);
          return reject(error2);
        }
        resolve(results2);
      });
    });
    
    const data = {
      timesheet: results,
      product: product_name,
      line: line_no,
      fdate: convertedDate,
      tdate: convertedDate1,
      operatorname: results.length > 0 ? results[0].operator_name : null,
      employees: results2,
    };
    
    res.json(data);
  } catch (error) {
    console.error('Error:', error);
    return res.status(500).json({ error: 'Internal Server Error' });
  }
});


// default data fetch
app.get('/gethourlossreportdefault', async (req, res) => {
  try {
    const date = new Date().toLocaleDateString('en-GB', { timeZone: 'Africa/Lagos' });
    const parts = date.split('/');
    const formattedDay = parts[0].padStart(2, '0');
    const formattedMonth = parts[1].padStart(2, '0');
    const year = parts[2];
    const date1 = `${formattedDay}-${formattedMonth}-${year}`;

    // Define the SQL query
    const query = `
      SELECT worker_timesheet.*, item_masterr.item_description, section.section_name,
        SUM(worker_timesheet.HOUR1+worker_timesheet.HOUR2+worker_timesheet.HOUR3+worker_timesheet.HOUR4+
          worker_timesheet.HOUR5+worker_timesheet.HOUR6+worker_timesheet.HOUR7+worker_timesheet.HOUR8+
          worker_timesheet.HOUR9+worker_timesheet.HOUR10+worker_timesheet.HOUR11) as value_sum
      FROM worker_timesheet
      LEFT JOIN item_masterr ON item_masterr.id = worker_timesheet.product_name
      LEFT JOIN section ON section.id = worker_timesheet.section
      WHERE date_time = ?
      GROUP BY worker_timesheet.entry_id, worker_timesheet.product_name, worker_timesheet.section, worker_timesheet.date_time
    `;

    // Execute the SQL query with the current date as a parameter
    const results = await new Promise((resolve, reject) => {
      db.query(query, [date1], async (err, results) => {
        if (err) {
          console.error('Error executing MySQL query:', err);
          reject(err);
        }
        resolve(results);
      });
    });

    const reggMap = {}; // Create a map to associate regg with entry IDs

    // Iterate through the timesheet results and add regg to each result object
    for (const row of results) {
      const entryid = row.entry_id;
      const site = row.site;
      const date_time = row.date_time;

      let query1;
      let ss;
      if (site === 'both') {
        // Check the 'employees_ota' table first
        query1 = await new Promise((resolveQuery1, rejectQuery1) => {
          db.query(`SELECT * FROM employees_ota WHERE entryid='${entryid}'`, (error, results) => {
            if (error) {
              console.error('MySQL Error:', error);
              res.status(500).json({ error: 'Internal Server Error' });
              return rejectQuery1(error);
            }

            if (results.length > 0) {
              resolveQuery1(results[0]);
            } else {
              // If no result is found in 'employees_ota', check 'geopos_employees' table
              db.query(`SELECT * FROM geopos_employees WHERE entryid='${entryid}'`, (error, results2) => {
                if (error) {
                  console.error('MySQL Error:', error);
                  res.status(500).json({ error: 'Internal Server Error' });
                  return rejectQuery1(error);
                }

                if (results2.length > 0) {
                  resolveQuery1(results2[0]);
                } else {
                  resolveQuery1(null);
                }
              });
            }
          });
        });
      } else if (site === 'ikeja') {
        query1 = await new Promise((resolveQuery1, rejectQuery1) => {
          db.query(`SELECT * FROM geopos_employees WHERE entryid='${entryid}'`, (error, results) => {
            if (error) {
              console.error('MySQL Error:', error);
              res.status(500).json({ error: 'Internal Server Error' });
              return rejectQuery1(error);
            }

            if (results.length > 0) {
              resolveQuery1(results[0]);
            } else {
              resolveQuery1(null);
            }
          });
        });
      } else if (site === 'ota') {
        query1 = await new Promise((resolveQuery1, rejectQuery1) => {
          db.query(`SELECT * FROM employees_ota WHERE entryid='${entryid}'`, (error, results) => {
            if (error) {
              console.error('MySQL Error:', error);
              res.status(500).json({ error: 'Internal Server Error' });
              return rejectQuery1(error);
            }

            if (results.length > 0) {
              resolveQuery1(results[0]);
            } else {
              resolveQuery1(null);
            }
          });
        });
      } else {
        query1 = null;
      }

      
      if (query1) {
        // Check if the result has the expected property 'joindate'
        if ('joindate' in query1) {
          const reg = query1.joindate;
    
          // Check if reg is a string before attempting to split
          if (typeof reg === 'string') {
            const regg = reg.split(' ')[0];
            // Store regg in the reggMap with entryid as the key
            reggMap[entryid] = regg;
          } else {
            // Handle the case where reg is not a string
          }
        } else {
          // Handle the case where 'joindate' is not present in the result
        }
      } else {
        // Handle the case where no results were found
      }
      
    }

    // Iterate through the timesheet results and add regg to each result object
    for (const row of results) {
      const entryid = row.entry_id;
      row.regg = reggMap[entryid] || '';
    }

    const data = {
      timesheet: results,
      date: date1,
    };

    // Respond with the query results
    res.json(data);
  } catch (error) {
    console.error('Error:', error);
    return res.status(500).json({ error: 'Internal Server Error' });
  }
});


//Worker Efficiency Report

//Get worker efficiency Default data
app.get('/get_workereff_default', (req, res) => {

  const date = new Date().toLocaleDateString('en-GB', { timeZone: 'Africa/Lagos' });
  const parts = date.split('/');
  const formattedDay = parts[0].padStart(2, '0');
  const formattedMonth = parts[1].padStart(2, '0');
  const year = parts[2];
  const date1 = `${formattedDay}-${formattedMonth}-${year}`;
 
const query = `
   SELECT worker_timesheet.*, item_masterr.item_description, section.section_name,
     SUM(worker_timesheet.HOUR1+worker_timesheet.HOUR2+worker_timesheet.HOUR3+worker_timesheet.HOUR4+
       worker_timesheet.HOUR5+worker_timesheet.HOUR6+worker_timesheet.HOUR7+worker_timesheet.HOUR8+
       worker_timesheet.HOUR9+worker_timesheet.HOUR10+worker_timesheet.HOUR11) as value_sum
   FROM worker_timesheet
   LEFT JOIN item_masterr ON item_masterr.id = worker_timesheet.product_name
   LEFT JOIN section ON section.id = worker_timesheet.section
   WHERE date_time = ?
   GROUP BY worker_timesheet.entry_id, worker_timesheet.product_name, worker_timesheet.section,worker_timesheet.date_time
   `; 
 
   db.query(query, [date1], (error, results) => {
     if (error) {
       console.error('Error executing MySQL query: ', error);
       return res.status(500).json({ error: 'Internal Server Error' });
     }
 
     const data = {
      timesheet: results,
      date: date1,
    };
 
     res.json(data);
    });
});


//Get worker efficiency search data
app.post('/get_workereff_search', (req, res) => {
  var product_name = req.body.product_id;
  var line_no = req.body.line_no;
  var section = req.body.section_id;
 

const fromdate = req.body.fromdate;
const fdParts = fromdate.split('-');
const fd = `${fdParts[2]}-${fdParts[1]}-${fdParts[0]}`;

const todate = req.body.todate;
const tdParts = todate.split('-');
const td = `${tdParts[2]}-${tdParts[1]}-${tdParts[0]}`;


const dateObj = new Date(fromdate);

const day = dateObj.getDate().toString().padStart(2, '0');
const month = (dateObj.getMonth() + 1).toString().padStart(2, '0');
const year = dateObj.getFullYear();

const convertedDate = `${day}-${month}-${year}`;

const dateObj1 = new Date(todate);
const day1 = dateObj1.getDate().toString().padStart(2, '0');
const month1 = (dateObj1.getMonth() + 1).toString().padStart(2, '0');
const year1 = dateObj1.getFullYear();

const convertedDate1 = `${day1}-${month1}-${year1}`;
console.log('Converted:', convertedDate);
console.log('Converted2:', convertedDate1);


const fd2 = Math.floor(new Date(fromdate).getTime() / 1000);
const td1 = Math.floor(new Date(todate).getTime() / 1000);
const fd1 = Math.floor(new Date(fd2 * 1000).setDate(new Date(fd2 * 1000).getDate() - 1) / 1000);

var newfd = fd1;
var newtd = td1;

   // Log the received data
   console.log('Received data:');
   console.log('Product Name:', product_name);
   console.log('Line No:', line_no);
   console.log('Section:', section);
   console.log('From Date:', fd);
   console.log('To Date:', td);
   console.log('Converted Timestamp:', newfd);
   console.log('Converted Timestamp:', newtd);
  
  let whereConditions = [];

  if (product_name !== '') {
    whereConditions.push(`worker_timesheet.product_name = '${product_name}'`);
  }
  if (line_no !== '') {
    whereConditions.push(`worker_timesheet.line = '${line_no}'`);
  }
  if (section !== '') {
    whereConditions.push(`worker_timesheet.section = '${section}'`);
  }
  
  whereConditions.push(`worker_timesheet.time_stamp BETWEEN '${newfd}' AND '${newtd}'`);

  const whereClause = whereConditions.join(' AND ');

 const query = `
   SELECT worker_timesheet.*, item_masterr.item_description, section.section_name,
     SUM(worker_timesheet.HOUR1+worker_timesheet.HOUR2+worker_timesheet.HOUR3+worker_timesheet.HOUR4+
       worker_timesheet.HOUR5+worker_timesheet.HOUR6+worker_timesheet.HOUR7+worker_timesheet.HOUR8+
       worker_timesheet.HOUR9+worker_timesheet.HOUR10+worker_timesheet.HOUR11) as value_sum
   FROM worker_timesheet
   LEFT JOIN item_masterr ON item_masterr.id = worker_timesheet.product_name
   LEFT JOIN section ON section.id = worker_timesheet.section
   WHERE ${whereClause}
   GROUP BY worker_timesheet.entry_id, worker_timesheet.product_name, worker_timesheet.section,worker_timesheet.date_time
   `; 
 
//console.log('query:', query);
 
   db.query(query, (error, results) => {
     if (error) {
       console.error('Error executing MySQL query: ', error);
       return res.status(500).json({ error: 'Internal Server Error' });
     }

     // Extract product, line, and section from the timesheet results
    const productFromTimesheet = results.length > 0 ? results[0].item_description : null;
    const lineFromTimesheet = results.length > 0 ? results[0].line : null;
    const sectionFromTimesheet = results.length > 0 ? results[0].section_name : null;
 

     // Modify the data object
     const data = {
      timesheet: results,
      fdate: convertedDate,
      tdate: convertedDate1,
      operatorname: results.length > 0 ? results[0].operator_name : null
    };

    // Conditionally include product, line, and section in the response
    if (product_name) {
      data.product = productFromTimesheet;
    }
    if (line_no) {
      data.line = lineFromTimesheet;
    }
    if (section) {
      data.section = sectionFromTimesheet;
    }
 
     res.json(data);
    });
}); 

//Supervisor Efficiency Report

//Get Supervisor eff default data
app.get('/get_supervisoreff_default', (req, res) => {
  const date = new Date().toLocaleDateString('en-GB', { timeZone: 'Africa/Lagos' });
  const parts = date.split('/');
  const formattedDay = parts[0].padStart(2, '0');
  const formattedMonth = parts[1].padStart(2, '0');
  const year = parts[2];
  const date1 = `${formattedDay}-${formattedMonth}-${year}`;

  // SQL query
  const query = `
      SELECT 
        worker_timesheet.*, 
        geopos_users.name AS operator_name, 
        item_masterr.item_description, 
        section.section_name, 
        COUNT(worker_timesheet.entry_id) AS num_rows,
        SUM(worker_timesheet.target) AS totalTarget1, 
        SUM(
          worker_timesheet.HOUR1 + worker_timesheet.HOUR2 + worker_timesheet.HOUR3 + 
          worker_timesheet.HOUR4 + worker_timesheet.HOUR5 + worker_timesheet.HOUR6 + 
          worker_timesheet.HOUR7 + worker_timesheet.HOUR8 + worker_timesheet.HOUR9 + 
          worker_timesheet.HOUR10 + worker_timesheet.HOUR11
        ) AS value_sum
      FROM 
        worker_timesheet
      JOIN 
        geopos_users ON geopos_users.id = worker_timesheet.operator_id
      JOIN 
        item_masterr ON item_masterr.id = worker_timesheet.product_name
      JOIN 
        section ON section.id = worker_timesheet.section
      WHERE 
        worker_timesheet.date_time = ?
      GROUP BY 
        worker_timesheet.product_name, 
        worker_timesheet.line, 
        worker_timesheet.section, 
        worker_timesheet.date_time`;

  // Execute the SQL query
  db.query(query, [date1], (error, results) => {
    if (error) {
      console.error('Error executing MySQL query: ', error);
      return res.status(500).json({ error: 'Internal Server Error' });
    }

    //console.log('Results:', results);

    const data = {
     timesheet: results,
     date: date1,
   };

    res.json(data);
   });
});

//Get supervisor search data
app.post('/get_supervisor_search', (req, res) => {
  
const fromdate = req.body.fromdate;
const fdParts = fromdate.split('-');
const fd = `${fdParts[2]}-${fdParts[1]}-${fdParts[0]}`;

const dateObj = new Date(fromdate);
const day = dateObj.getDate().toString().padStart(2, '0');
const month = (dateObj.getMonth() + 1).toString().padStart(2, '0');
const year = dateObj.getFullYear();

const convertedDate = `${day}-${month}-${year}`;
console.log('Converted:', convertedDate);

const fd2 = Math.floor(new Date(fromdate).getTime() / 1000);
const fd1 = Math.floor(new Date(fd2 * 1000).setDate(new Date(fd2 * 1000).getDate() - 1) / 1000);
var newfd = fd2;

// Log the received data
console.log('Received data:');
console.log('From Date:', fd);
console.log('Converted Timestamp:', newfd);
   
const query = `
      SELECT 
        worker_timesheet.*, 
        geopos_users.name AS operator_name, 
        item_masterr.item_description, 
        section.section_name, 
        COUNT(worker_timesheet.entry_id) AS num_rows, 
        SUM(worker_timesheet.target) AS totalTarget1,
        SUM(
          worker_timesheet.HOUR1 + worker_timesheet.HOUR2 + worker_timesheet.HOUR3 + 
          worker_timesheet.HOUR4 + worker_timesheet.HOUR5 + worker_timesheet.HOUR6 + 
          worker_timesheet.HOUR7 + worker_timesheet.HOUR8 + worker_timesheet.HOUR9 + 
          worker_timesheet.HOUR10 + worker_timesheet.HOUR11
        ) AS value_sum
      FROM 
        worker_timesheet
      JOIN 
        geopos_users ON geopos_users.id = worker_timesheet.operator_id
      JOIN 
        item_masterr ON item_masterr.id = worker_timesheet.product_name
      JOIN 
        section ON section.id = worker_timesheet.section
      WHERE 
        worker_timesheet.date_time = ?
      GROUP BY 
        worker_timesheet.product_name, 
        worker_timesheet.line, 
        worker_timesheet.section, 
        worker_timesheet.date_time`;
   // Execute the SQL query
   db.query(query, [convertedDate],  (error, results) => {
    if (error) {
      console.error('Error executing MySQL query: ', error);
      return res.status(500).json({ error: 'Internal Server Error' });
    }

    const data = {
     timesheet: results,
     date: convertedDate,
   };

    res.json(data);
   });
});

//Section Wise efficiency Report

//Get section eff default data
app.get('/get_sectioneff_default', (req, res) => {
  const date = new Date().toLocaleDateString('en-GB', { timeZone: 'Africa/Lagos' });
  const parts = date.split('/');
  const formattedDay = parts[0].padStart(2, '0');
  const formattedMonth = parts[1].padStart(2, '0');
  const year = parts[2];
  const date1 = `${formattedDay}-${formattedMonth}-${year}`;

  // SQL query
  const query = `
    SELECT worker_timesheet.*, item_masterr.item_description, section.section_name, item_category.category_name,
      SUM(worker_timesheet.HOUR1+worker_timesheet.HOUR2+worker_timesheet.HOUR3+worker_timesheet.HOUR4+
        worker_timesheet.HOUR5+worker_timesheet.HOUR6+worker_timesheet.HOUR7+worker_timesheet.HOUR8+
        worker_timesheet.HOUR9+worker_timesheet.HOUR10+worker_timesheet.HOUR11) as comp,
      COUNT(*) as tt
    FROM worker_timesheet
    LEFT JOIN item_masterr ON item_masterr.id = worker_timesheet.product_name
    LEFT JOIN section ON section.id = worker_timesheet.section
    LEFT JOIN item_category ON item_masterr.category_id = item_category.id
    WHERE worker_timesheet.date_time = ?
    GROUP BY worker_timesheet.product_name, worker_timesheet.section, worker_timesheet.date_time`;


   // Execute the SQL query
   db.query(query, [date1], (error, results) => {
    if (error) {
      console.error('Error executing MySQL query: ', error);
      return res.status(500).json({ error: 'Internal Server Error' });
    }

    const data = {
     timesheet: results,
     date: date1,
   };

    res.json(data);
   });
});

//Get sectioneff search data
app.post('/get_sectioneff_search', (req, res) => {
  var product_name = req.body.product_name;
  var section = req.body.section;
  var category = req.body.category;
  var worker = req.body.worker;
  var search = req.body.search;

  const fromdate = req.body.fromdate;
  const fdParts = fromdate.split('-');
  const fd = `${fdParts[2]}-${fdParts[1]}-${fdParts[0]}`;

  const todate = req.body.todate;
  const tdParts = todate.split('-');
  const td = `${tdParts[2]}-${tdParts[1]}-${tdParts[0]}`;


  const dateObj = new Date(fromdate);
  const day = dateObj.getDate().toString().padStart(2, '0');
  const month = (dateObj.getMonth() + 1).toString().padStart(2, '0');
  const year = dateObj.getFullYear();

  const convertedDate = `${day}-${month}-${year}`;

  const dateObj1 = new Date(todate);
  const day1 = dateObj1.getDate().toString().padStart(2, '0');
  const month1 = (dateObj1.getMonth() + 1).toString().padStart(2, '0');
  const year1 = dateObj1.getFullYear();

  const convertedDate1 = `${day1}-${month1}-${year1}`;
  console.log('Converted:', convertedDate);
  console.log('Converted2:', convertedDate1);


  const fd2 = Math.floor(new Date(fromdate).getTime() / 1000);
  const td1 = Math.floor(new Date(todate).getTime() / 1000);
  const fd1 = Math.floor(new Date(fd2 * 1000).setDate(new Date(fd2 * 1000).getDate() - 1) / 1000);

  var newfd = fd2;
  var newtd = td1;

  // Log the received data
   /* console.log('Received data:');
   console.log('Product Name:', product_name);
   console.log('Section:', section);
   console.log('Worker:', worker);
   console.log('Category:', category);
   console.log('Search:', search);
   console.log('From Date:', fd);
   console.log('To Date:', td);
   console.log('Converted Timestamp:', newfd);
   console.log('Converted Timestamp:', newtd); */


   const cdate = new Date().toLocaleDateString('en-GB', { timeZone: 'Africa/Lagos' });
   const parts = cdate.split('/');
   const formattedDay = parts[0].padStart(2, '0');
   const formattedMonth = parts[1].padStart(2, '0');
   const cyear = parts[2];
   const cdate1 = `${formattedDay}-${formattedMonth}-${year}`;
   const cmonth1 = `${formattedMonth}-${year}`;


   /* console.log('Current Date:', cdate1);
   console.log('Current Month:', cmonth1);
   console.log('Current Year:', cyear); */
  
   let whereConditions = [];

   // Handle search option 5
   if (search === '5') {
     whereConditions.push(`worker_timesheet.date_time = '${cdate1}'`);
   }
   // Handle search option 1
   else if (search === '1') {
     const currentDate = new Date().toLocaleDateString('en-GB', { timeZone: 'Africa/Lagos' });
     const firstDayOfWeek = new Date(currentDate.setDate(currentDate.getDate() - currentDate.getDay() + 1));
     const lastDayOfWeek = new Date(currentDate.setDate(currentDate.getDate() - currentDate.getDay() + 7));
   
     const firstDayOfWeek1 = `${firstDayOfWeek.getFullYear()}-${(firstDayOfWeek.getMonth() + 1).toString().padStart(2, '0')}-${firstDayOfWeek.getDate().toString().padStart(2, '0')}`;
     const lastDayOfWeek1 = `${lastDayOfWeek.getFullYear()}-${(lastDayOfWeek.getMonth() + 1).toString().padStart(2, '0')}-${lastDayOfWeek.getDate().toString().padStart(2, '0')}`;
   
     const fdate1 = firstDayOfWeek1.split('-').reverse().join('-');
     const tdate2 = lastDayOfWeek1.split('-').reverse().join('-');
   
     const fdate = Math.floor(new Date(fdate1).getTime() / 1000);
     const tdate = Math.floor(new Date(tdate2).getTime() / 1000);
   
     whereConditions.push(`worker_timesheet.time_stamp BETWEEN '${fdate}' AND '${tdate}' OR worker_timesheet.time_stamp='${fdate}'`);
   }
   // Handle search option 2
   else if (search === '2') {
     whereConditions.push(`worker_timesheet.date_time = '${cmonth1}'`);
   }
   // Handle search option 3
   else if (search === '3') {
     whereConditions.push(`worker_timesheet.mon = '${cyear}'`);
   }
   // Handle search option 4
   else if (search === '4') {
     const fromdate = new Date(req.body.fromdate);
     const todate = new Date(req.body.todate);
   
     const newfromdate = `${fromdate.getFullYear()}-${(fromdate.getMonth() + 1).toString().padStart(2, '0')}-${fromdate.getDate().toString().padStart(2, '0')}`;
     const newtodate = `${todate.getFullYear()}-${(todate.getMonth() + 1).toString().padStart(2, '0')}-${todate.getDate().toString().padStart(2, '0')}`;
   
     const newfromdate1 = newfromdate.split('-').reverse().join('-');
     const newtodate1 = newtodate.split('-').reverse().join('-');
   
     const timestampfromdate = Math.floor(fromdate.getTime() / 1000);
     const timestamptodate = Math.floor(todate.getTime() / 1000);
   
     // Update the existing whereConditions array
     whereConditions.push(`(worker_timesheet.time_stamp BETWEEN '${timestampfromdate}' AND '${timestamptodate}' OR worker_timesheet.time_stamp='${timestampfromdate}')`);
   }
   
  if (product_name !== '') {
    whereConditions.push(`worker_timesheet.product_name = '${product_name}'`);
  }
  
  if (section !== '') {
    whereConditions.push(`worker_timesheet.section = '${section}'`);
  }
  if (category !== '') {
    whereConditions.push(`item_masterr.category_id = '${category}'`);
  }
  if (worker !== '') {
    whereConditions.push(`worker_timesheet.entry_id = '${worker}'`);
  }

 // Log the whereConditions array:
//console.log('Where Conditions:', whereConditions);
  
  //whereConditions.push(`worker_timesheet.time_stamp BETWEEN '${newfd}' AND '${newtd}'`);

  const whereClause = whereConditions.join(' AND ');

  // Log the whereConditions array:
//console.log('WhereClause:', whereClause);
  const query = `
    SELECT worker_timesheet.*, item_masterr.item_description, section.section_name, item_category.category_name,
      SUM(worker_timesheet.HOUR1 + worker_timesheet.HOUR2 + worker_timesheet.HOUR3 + worker_timesheet.HOUR4
        + worker_timesheet.HOUR5 + worker_timesheet.HOUR6 + worker_timesheet.HOUR7 + worker_timesheet.HOUR8
        + worker_timesheet.HOUR9 + worker_timesheet.HOUR10 + worker_timesheet.HOUR11) AS comp,
      COUNT(*) AS tt
    FROM worker_timesheet
    LEFT JOIN item_masterr ON item_masterr.id = worker_timesheet.product_name
    LEFT JOIN section ON section.id = worker_timesheet.section
    LEFT JOIN item_category ON item_masterr.category_id = item_category.id
    WHERE ${whereClause}
    GROUP BY worker_timesheet.date_time, worker_timesheet.product_name, worker_timesheet.section
  `;
  // Execute the SQL query
  db.query(query, (error, results) => {
    if (error) {
      console.error('Error executing MySQL query: ', error);
      return res.status(500).json({ error: 'Internal Server Error' });
    }

    const data = {
     timesheet: results,
    
   };

    res.json(data);
   });
});

//Performance Overview Report

//Get Performance overview default data
app.get('/get_performance_default', (req, res) => {
  const date = new Date().toLocaleDateString('en-GB', { timeZone: 'Africa/Lagos' });
  const parts = date.split('/');
  const formattedDay = parts[0].padStart(2, '0');
  const formattedMonth = parts[1].padStart(2, '0');
  const year = parts[2];
  const date1 = `${formattedDay}-${formattedMonth}-${year}`;
  // SQL query
  const query = `
  SELECT worker_timesheet.*, item_masterr.item_description, section.section_name, employees_moz.joindate,
  SUM(worker_timesheet.HOUR1+worker_timesheet.HOUR2+worker_timesheet.HOUR3+worker_timesheet.HOUR4+
    worker_timesheet.HOUR5+worker_timesheet.HOUR6+worker_timesheet.HOUR7+worker_timesheet.HOUR8+
    worker_timesheet.HOUR9+worker_timesheet.HOUR10+worker_timesheet.HOUR11+worker_timesheet.HOUR12) as comp,
  COUNT(*) as tt
   FROM worker_timesheet
   LEFT JOIN employees_moz ON employees_moz.entryid = worker_timesheet.entry_id
    LEFT JOIN item_masterr ON item_masterr.id = worker_timesheet.product_name
    LEFT JOIN section ON section.id = worker_timesheet.section
    WHERE worker_timesheet.date_time = ?
    GROUP BY worker_timesheet.product_name, worker_timesheet.section, worker_timesheet.date_time,worker_timesheet.entry_id,worker_timesheet.line`

  // Execute the SQL query
  db.query(query, [date1], (error, results) => {
    if (error) {
      console.error('Error executing MySQL query: ', error);
      return res.status(500).json({ error: 'Internal Server Error' });
    }

    const data = {
     timesheet: results,
     date: date1,
   };

    res.json(data);
   });
});

//Get Performance overview Search data
app.post('/get_performance_searchh', (req, res) => {

  const fromdate = req.body.fromdate;
  const fdParts = fromdate.split('-');
  const fd = `${fdParts[2]}-${fdParts[1]}-${fdParts[0]}`;

  const todate = req.body.todate;
  const tdParts = todate.split('-');
  const td = `${tdParts[2]}-${tdParts[1]}-${tdParts[0]}`;


  const dateObj = new Date(fromdate);
  const day = dateObj.getDate().toString().padStart(2, '0');
  const month = (dateObj.getMonth() + 1).toString().padStart(2, '0');
  const year = dateObj.getFullYear();

  const convertedDate = `${day}-${month}-${year}`;

  const dateObj1 = new Date(todate);
  const day1 = dateObj1.getDate().toString().padStart(2, '0');
  const month1 = (dateObj1.getMonth() + 1).toString().padStart(2, '0');
  const year1 = dateObj1.getFullYear();

  const convertedDate1 = `${day1}-${month1}-${year1}`;
  console.log('Converted:', convertedDate);
  console.log('Converted2:', convertedDate1);


  const fd2 = Math.floor(new Date(fromdate).getTime() / 1000);
  const td1 = Math.floor(new Date(todate).getTime() / 1000);
  const fd1 = Math.floor(new Date(fd2 * 1000).setDate(new Date(fd2 * 1000).getDate() - 1) / 1000);

  var newfd = fd2;
  var newtd = td1;

   // Log the received data
   /* console.log('Received data:');
   console.log('From Date:', fd);
   console.log('To Date:', td);
   console.log('Converted Timestamp:', newfd);
   console.log('Converted Timestamp:', newtd); */

 // Log the whereConditions array:
//console.log('Where Conditions:', whereConditions);

let whereConditions = [];
  
  whereConditions.push(`worker_timesheet.time_stamp BETWEEN '${newfd}' AND '${newtd}'`);

  const whereClause = whereConditions.join(' AND ');

  // Log the whereConditions array:
//console.log('WhereClause:', whereClause);
  // SQL query
  const query = `
    SELECT worker_timesheet.*, item_masterr.item_description, section.section_name, employees_moz.joindate,
    SUM(worker_timesheet.HOUR1+worker_timesheet.HOUR2+worker_timesheet.HOUR3+worker_timesheet.HOUR4+
      worker_timesheet.HOUR5+worker_timesheet.HOUR6+worker_timesheet.HOUR7+worker_timesheet.HOUR8+
      worker_timesheet.HOUR9+worker_timesheet.HOUR10+worker_timesheet.HOUR11+worker_timesheet.HOUR12) as comp,
    COUNT(*) as tt
     FROM worker_timesheet
     LEFT JOIN employees_moz ON employees_moz.entryid = worker_timesheet.entry_id
    LEFT JOIN item_masterr ON item_masterr.id = worker_timesheet.product_name
    LEFT JOIN section ON section.id = worker_timesheet.section
    WHERE ${whereClause}
    GROUP BY worker_timesheet.product_name, worker_timesheet.section, worker_timesheet.date_time,worker_timesheet.entry_id,worker_timesheet.line`

  // Execute the SQL query
  db.query(query, (error, results) => {
    if (error) {
      console.error('Error executing MySQL query: ', error);
      return res.status(500).json({ error: 'Internal Server Error' });
    }

    const data = {
     timesheet: results,
     fdate: convertedDate,
     tdate: convertedDate1,
     
   };

    res.json(data);
   });
});

//nonbraid date_worker_new_excel
app.get('/date_worker_new_excel', (req, res) => {
  const fromdate = req.body.fromdate;
  const fdParts = fromdate.split('-');
  const fd = `${fdParts[2]}-${fdParts[1]}-${fdParts[0]}`;

  const todate = req.body.todate;
  const tdParts = todate.split('-');
  const td = `${tdParts[2]}-${tdParts[1]}-${tdParts[0]}`;


  const dateObj = new Date(fromdate);
  const day = dateObj.getDate().toString().padStart(2, '0');
  const month = (dateObj.getMonth() + 1).toString().padStart(2, '0');
  const year = dateObj.getFullYear();

  const convertedDate = `${day}-${month}-${year}`;

  const dateObj1 = new Date(todate);
  const day1 = dateObj1.getDate().toString().padStart(2, '0');
  const month1 = (dateObj1.getMonth() + 1).toString().padStart(2, '0');
  const year1 = dateObj1.getFullYear();

  const convertedDate1 = `${day1}-${month1}-${year1}`;
  console.log('Converted:', convertedDate);
  console.log('Converted2:', convertedDate1);


  const fd2 = Math.floor(new Date(fromdate).getTime() / 1000);
  const td1 = Math.floor(new Date(todate).getTime() / 1000);
  const fd1 = Math.floor(new Date(fd2 * 1000).setDate(new Date(fd2 * 1000).getDate() - 1) / 1000);

  var newfd = fd2;
  var newtd = td1;

  const query = `
      SELECT *, HOUR1+HOUR2+HOUR3+HOUR4+HOUR5+HOUR6+
      HOUR7+HOUR8+HOUR9+HOUR10+HOUR11 AS value_sum  
      FROM worker_timesheet 
      WHERE (time_stamp BETWEEN ? AND ?)
      GROUP BY entry_id, shift, mon
    `;

    const query2 = `
    SELECT *, HOUR1+HOUR2+HOUR3+HOUR4+HOUR5+HOUR6+
    HOUR7+HOUR8+HOUR9+HOUR10+HOUR11 AS value_sum  
    FROM worker_timesheet 
    WHERE (time_stamp BETWEEN ? AND ?)
    GROUP BY entry_id, product_name, line, section, date_time
  `;

  // Execute the first SQL query
  db.query(query1, [newfd, newtd], (error1, results1) => {
    if (error1) {
      console.error('Error executing MySQL query 1: ', error1);
      return res.status(500).json({ error: 'Internal Server Error' });
    }

    // Execute the second SQL query
    db.query(query2, [newfd, newtd], (error2, results2) => {
      if (error2) {
        console.error('Error executing MySQL query 2: ', error2);
        return res.status(500).json({ error: 'Internal Server Error' });
      }

       // Process the PHP functionality using the obtained results
       const rowCount = 2;
       const ard = [];
       const arr_tar = [];
       const arr_ach = [];
       const arr = [];

       // Process timesheetk array
      results2.forEach((itemk) => {
        const dent = `${itemk.date_time}-${itemk.entry_id}-${itemk.product_name}-${itemk.section}`;
        ard.push(dent);
        
        const e = (itemk.value_sum / itemk.target) * 100;
        const eff = parseFloat(e.toFixed(2));
        arr.push(eff);
        
        arr_tar.push(itemk.target);
        arr_ach.push(itemk.value_sum);

      });

      results1.forEach((item) => {
        const entry = item.entry_id;
      
        const querys = `SELECT * FROM employees_ota WHERE entryid='${entry}'`;
        
        // Execute the SQL query to check if the entryid exists in employees_ota
        db.query(querys, (error, rows) => {
          if (error) {
            console.error('Error executing MySQL query: ', error);
            return;
          }
      
          if (rows.length > 0) {
            // The entryid exists in employees_ota
            const query1 = `SELECT * FROM employees_ota WHERE entryid='${entry}'`;
            db.query(query1, (error1, rows1) => {
              if (error1) {
                console.error('Error executing MySQL query: ', error1);
                return;
              }
      
              const reg = rows1[0].joindate;
              const regg = formatDate(reg);
              const datek1 = formatDate(new Date());
              const earlier = new Date(reg);
              const later = new Date(datek1);
              const diff = calculateDateDifference(earlier, later);
      
              // Rest of the PHP functionality code goes here
      
              // Do whatever you want with the diff value here
              console.log('Difference:', diff);
            });
          } else {
            // The entryid does not exist in employees_ota
            const query2 = `SELECT * FROM geopos_employees WHERE entryid='${entry}'`;
            db.query(query2, (error2, rows2) => {
              if (error2) {
                console.error('Error executing MySQL query: ', error2);
                return;
              }
      
              const reg = rows2[0].joindate;
              const regg = formatDate(reg);
              const datek1 = formatDate(new Date());
              const earlier = new Date(reg);
              const later = new Date(datek1);
              const diff = calculateDateDifference(earlier, later);
      
              // Rest of the PHP functionality code goes here
      
              // Do whatever you want with the diff value here
              console.log('Difference:', diff);
            });
          }
        });
      });
      
      function formatDate(date) {
        const day = date.getDate().toString().padStart(2, '0');
        const month = (date.getMonth() + 1).toString().padStart(2, '0');
        const year = date.getFullYear();
        return `${day}-${month}-${year}`;
      }
      
      function calculateDateDifference(earlier, later) {
        const diffInMilliseconds = later.getTime() - earlier.getTime();
        const diffInDays = Math.floor(diffInMilliseconds / (1000 * 60 * 60 * 24));
        return `${diffInDays}Days`;
      }

      const data = {
        timesheet: results1,
        timesheetk: results2,
        fdate: convertedDate,
        tdate: convertedDate1,
      };

      res.json(data);
    });
  });
});


// Define your Node.js API endpoints
app.post('/date_worker_new_excel1', (req, res) => {
 
  const fromdate = new Date(req.body.fromdate)
  const fdParts = `${fromdate.getFullYear()}-${(fromdate.getMonth() + 1).toString().padStart(2, '0')}-${fromdate.getDate().toString().padStart(2, '0')}`;
  const fd = fdParts.split('-').reverse().join('-');

  const todate = new Date(req.body.todate)
  const tdParts = `${todate.getFullYear()}-${(todate.getMonth() + 1).toString().padStart(2, '0')}-${todate.getDate().toString().padStart(2, '0')}`;
  const td = tdParts.split('-').reverse().join('-');

  const fd2 = Math.floor(new Date(fromdate).getTime() / 1000);
  const td1 = Math.floor(new Date(todate).getTime() / 1000);
  const fd1 = Math.floor(new Date(fd2 * 1000).setDate(new Date(fd2 * 1000).getDate() - 1) / 1000);

  var newfd = fd2;
  var newtd = td1;

    // MySQL query to fetch timesheet data
    const query3 = `SELECT *, HOUR1+HOUR2+HOUR3+HOUR4+HOUR5+HOUR6+
      HOUR7+HOUR8+HOUR9+HOUR10+HOUR11 AS value_sum  
      FROM worker_timesheet 
      WHERE time_stamp BETWEEN ? AND ?
      GROUP BY entry_id, shift, mon`;

    db.query(query3, [newfd, newtd], (err, timesheet) => {
      if (err) {
        console.error('Error executing query:', err);
        return res.status(500).json({ error: 'Internal Server Error' });
      }

      // Additional queries and data processing here

      const data = {
        timesheet,
        // Add other data properties here
      };

      // Send response
      res.json(data);
    });
  
});

app.post('/date_worker_new_excel', (req, res) => {
  const fromdate = new Date(req.body.fromdate)
  const fdParts = `${fromdate.getFullYear()}-${(fromdate.getMonth() + 1).toString().padStart(2, '0')}-${fromdate.getDate().toString().padStart(2, '0')}`;
  const fd = fdParts.split('-').reverse().join('-');

  const todate = new Date(req.body.todate)
  const tdParts = `${todate.getFullYear()}-${(todate.getMonth() + 1).toString().padStart(2, '0')}-${todate.getDate().toString().padStart(2, '0')}`;
  const td = tdParts.split('-').reverse().join('-');

  const fd2 = Math.floor(new Date(fromdate).getTime() / 1000);
  const td1 = Math.floor(new Date(todate).getTime() / 1000);
  const fd1 = Math.floor(new Date(fd2 * 1000).setDate(new Date(fd2 * 1000).getDate() - 1) / 1000);

  var newfd = fd2;
  var newtd = td1;

    // Query to fetch timesheet data
    const query1 = `SELECT *, HOUR1+HOUR2+HOUR3+HOUR4+HOUR5+HOUR6+HOUR7+HOUR8+HOUR9+HOUR10+HOUR11 AS value_sum
                    FROM worker_timesheet
                    WHERE (time_stamp BETWEEN ? AND ?)
                    GROUP BY entry_id, shift, mon`;

    // Query to fetch timesheetk data
    const query2 = `SELECT *, HOUR1+HOUR2+HOUR3+HOUR4+HOUR5+HOUR6+HOUR7+HOUR8+HOUR9+HOUR10+HOUR11 AS value_sum
                    FROM worker_timesheet
                    WHERE (time_stamp BETWEEN ? AND ?)
                    GROUP BY entry_id, product_name, line, section, date_time`;

    // Execute the first query
    db.query(query1, [newfd, newtd], (err1, timesheet) => {
      if (err1) {
        throw err1;
      }

      // Execute the second query
      db.query(query2, [newfd, newtd], (err2, timesheetk) => {
        if (err2) {
          throw err2;
        }

        // Prepare the response data
        const responseData = {
          timesheet,
          timesheetk,
          fromdate,
          todate,
          /* td1: ed1,
          fd1,
          ffd1: fd1,
          ed1, */
        };

        // Send the response
        res.json(responseData);
      });
    });
  
});



// Machine Hour Report
//default data fetch
app.get('/machine_hour', (req, res) => {
  const sql = 'SELECT * FROM geopos_machine';
  
  let resultText = '';
  // Execute the SQL query
  db.query(sql, (err, result) => {
    if (err) {
      console.error('Error executing query:', err);
      res.status(500).json({ error: 'Internal Server Error' });
      return;
    }

    // Assuming 'result' contains the query results
    const zoneData = {
      zone: result,
      tdate: 1,
    };

    // Split the 'machine' string into an array
    zoneData.zone.forEach((zone) => {
      zone.machine = zone.machine.split(',');
    });

    // Log the 'machine' array for each 'zone'
    zoneData.zone.forEach((zone) => {
      //console.log(`Machine Array for Zone ${zone.zone}:`, zone.machine);

      // Iterate through each machine (mach) in the current zone
      zone.machine.forEach((mach) => {
        console.log(`Machine for Zone ${zone.zone}:`, mach);

         // Generate machine information text
         const machineInfoText = `${zone.zone} -> ${mach.trim()}`;

         // Append the generated text to the result string
         resultText += machineInfoText + '\n'; // Add a newline between entries
        // Add your processing logic for each machine here

        console.log('resultText:', resultText);

        const userId = 9;
        const userRole = 5;
        const date = new Date().toLocaleDateString('en-GB', { timeZone: 'Africa/Lagos' });
        const parts = date.split('/');
        const formattedDay = parts[0].padStart(2, '0');
        const formattedMonth = parts[1].padStart(2, '0');
        const year = parts[2];
        const date1 = `${formattedDay}-${formattedMonth}-${year}`;
          let whereClause = '';
          if (userRole === 5) {
            whereClause = `geopos_operator.zone = '${userId}' AND geopos_operator.machine = '${mach}' AND geopos_operator.date = '${date1}'`;
          }
          else {
            db.query(
              `SELECT geopos_employees.id FROM geopos_employees 
              JOIN geopos_users ON geopos_employees.entryid = geopos_users.entryid
              WHERE geopos_users.id = ?`,
              [userId],
              (error, results, fields) => {
                if (error) {
                  console.error('Error getting employee id:', error);
                  res.status(500).json({ error: 'Internal Server Error' });
                  return;
                }

                const empid = results[0].id;
                whereClause = `geopos_operator.zone = '${id}' AND geopos_operator.machine = '${mach}' AND geopos_operator.date = '${date1}' AND geopos_operator.emp_id = ${empid}`;
              });
            }

           // Execute the main query
          const sql = `SELECT * FROM geopos_operator
          LEFT JOIN item_masterr ON item_masterr.id = geopos_operator.item
          WHERE ${whereClause}`;

          db.query(sql, (error, results, fields) => {
          if (error) {
          console.error('Error executing SQL query:', error);
          res.status(500).json({ error: 'Internal Server Error' });
          return;
          }

          // Log all results
          //console.log(results);

          const count = results.length;

          console.log(count);

          

          // Send the count as the API response
          //res.json({ count });
          });  

       
      });
    });

    // Send the response
    res.status(200).json({ data: resultText });
  });
});




//date wise filter search
app.post('/datewise_machine_hour', (req, res) => {
  if (req.body) {
    const fromdate = req.body.fromdate;
    const fdParts = fromdate.split('-');
    const fd = `${fdParts[2]}-${fdParts[1]}-${fdParts[0]}`;
    
    const todate = req.body.todate;
    const tdParts = todate.split('-');
    const td = `${tdParts[2]}-${tdParts[1]}-${tdParts[0]}`;
    
    
    const dateObj = new Date(fromdate);
    const day = dateObj.getDate().toString().padStart(2, '0');
    const month = (dateObj.getMonth() + 1).toString().padStart(2, '0');
    const year = dateObj.getFullYear();
    
    const convertedDate = `${day}-${month}-${year}`;
    
    const dateObj1 = new Date(todate);
    const day1 = dateObj1.getDate().toString().padStart(2, '0');
    const month1 = (dateObj1.getMonth() + 1).toString().padStart(2, '0');
    const year1 = dateObj1.getFullYear();
    
    const convertedDate1 = `${day1}-${month1}-${year1}`;
    console.log('Converted:', convertedDate);
    console.log('Converted2:', convertedDate1);

    const tdate = 1;
    let resultText = '';
    
    // Query the MySQL database based on hr_start and hr_end
    const query = `SELECT * FROM geopos_machine`;
    db.query(query, (error, results, fields) => {
      if (error) {
        console.error('Error executing MySQL query:', error);
        res.status(500).json({ message: 'Internal Server Error' });
      } /* else {
        const data = results;

        res.json({ data, convertedDate, convertedDate1, tdate });
      } */

      // Assuming 'result' contains the query results
      const zoneData = {
        zone: results,
        tdate: 1,
      };

      // Split the 'machine' string into an array
      zoneData.zone.forEach((zone) => {
        zone.machine = zone.machine.split(',');
      });

      // Log zoneData after splitting 'zone.machine' strings into arrays
      console.log('Zone Data after Splitting Machines:', zoneData);

      // Log the 'machine' array for each 'zone'
      zoneData.zone.forEach((zone) => {
        //console.log(`Machine Array for Zone ${zone.zone}:`, zone.machine);

    // Iterate through each machine (mach) in the current zone
      zone.machine.forEach((mach) => {
      console.log(`Machine for Zone ${zone.zone}:`, mach);

      // Generate machine information text
      const machineInfoText = `${zone.zone} -> ${mach.trim()}`;

      // Append the generated text to the result string
      resultText += machineInfoText + '\n'; // Add a newline between entries
     // Add your processing logic for each machine here

     console.log('resultText:', resultText);

        const userId = 9;
        const userRole = 5;
        const date = new Date().toLocaleDateString('en-GB', { timeZone: 'Africa/Lagos' });
        const parts = date.split('/');
        const formattedDay = parts[0].padStart(2, '0');
        const formattedMonth = parts[1].padStart(2, '0');
        const year = parts[2];
        const date1 = `${formattedDay}-${formattedMonth}-${year}`;
        let whereClause = '';
          if (userRole === 5) {
            whereClause = `geopos_operator.zone = '${userId}' AND geopos_operator.machine = '${mach}' AND geopos_operator.date = '${date1}'`;
          }
          else {
            db.query(
              `SELECT geopos_employees.id FROM geopos_employees 
              JOIN geopos_users ON geopos_employees.entryid = geopos_users.entryid
              WHERE geopos_users.id = ?`,
              [userId],
              (error, results, fields) => {
                if (error) {
                  console.error('Error getting employee id:', error);
                  res.status(500).json({ error: 'Internal Server Error' });
                  return;
                }

                const empid = results[0].id;
                whereClause = `geopos_operator.zone = '${id}' AND geopos_operator.machine = '${mach}' AND geopos_operator.date = '${date1}' AND geopos_operator.emp_id = ${empid}`;
              });
            }

           // Execute the main query
          const sql = `SELECT * FROM geopos_operator
          LEFT JOIN item_masterr ON item_masterr.id = geopos_operator.item
          WHERE ${whereClause}`;

          db.query(sql, (error, results, fields) => {
          if (error) {
          console.error('Error executing SQL query:', error);
          res.status(500).json({ error: 'Internal Server Error' });
          return;
          }

          // Log all results
          //console.log(results);

          const count = results.length;

          console.log(count);
        }); 
        
        });
      });
      res.status(200).json({ data: resultText });
    });
  } else {
    res.status(400).json({ message: "Invalid input" });
  }
});

// Define a single API endpoint
app.get('/api/your_endpoint', (req, res) => {
  // Assuming you have user authentication and can access user role and ID
  const userId = 9;
  const userRole = 5;
  const date = new Date().toLocaleDateString('en-GB', { timeZone: 'Africa/Lagos' });
  const parts = date.split('/');
  const formattedDay = parts[0].padStart(2, '0');
  const formattedMonth = parts[1].padStart(2, '0');
  const year = parts[2];
  const date1 = `${formattedDay}-${formattedMonth}-${year}`;

  // Build the SQL query based on user role
  let whereClause = '';
  if (userRole === 5) {
    whereClause = `geopos_operator.zone = ${userId} AND geopos_operator.machine = ${mach} AND geopos_operator.date = '${date1}'`;
  }
   else {
    db.query(
      `SELECT geopos_employees.id FROM geopos_employees 
       JOIN geopos_users ON geopos_employees.entryid = geopos_users.entryid
       WHERE geopos_users.id = ?`,
      [userId],
      (error, results, fields) => {
        if (error) {
          console.error('Error getting employee id:', error);
          res.status(500).json({ error: 'Internal Server Error' });
          return;
        }

        const empid = results[0].id;
        whereClause = `geopos_operator.zone = ${id} AND geopos_operator.machine = ${mach} AND geopos_operator.date = '${date1}' AND geopos_operator.emp_id = ${empid}`;

        // Execute the main query
        const sql = `SELECT * FROM geopos_operator
                    LEFT JOIN item_masterr ON item_masterr.id = geopos_operator.item
                    WHERE ${whereClause}`;
        
        db.query(sql, (error, results, fields) => {
          if (error) {
            console.error('Error executing SQL query:', error);
            res.status(500).json({ error: 'Internal Server Error' });
            return;
          }

           // Log all results
           console.log(results);

          const count = results.length;

          // Send the count as the API response
          res.json({ count });
        });
      }
    );
  }
});


//get machine options based on zone value
app.get('/getMachineOptions/:selectedZone', (req, res) => {
  const { selectedZone } = req.params;
  console.log('selectedZone:', selectedZone);

  // Query the database to fetch machine options for the specified zone
  db.query('SELECT machine FROM geopos_machine WHERE zone = ?', [selectedZone], (error, results) => {
    if (error) {
      console.error('Error querying the database:', error);
      res.status(500).json({ error: 'Internal Server Error' });
      return;
    }

    // Check if there are any results
    if (results && results.length > 0) {
      // Extract machine names from the result
      const machines = results[0].machine.split(',');

      // Format the machine options as an array of objects
      const machineOptions = machines.map((machine) => ({ machine: machine }));

      // Log machineOptions to the console
      console.log('Machine Options:', machineOptions);
      
      // Send the machineOptions as JSON response
      res.json(machineOptions);
    } else {
      // Handle the case when no results are found
      console.log('No machine options found for the specified zone.');
      res.json([]); // or handle it as you see fit
    }
  });
});




app.post('/get_zone_machine_hour', (req, res) => {
  const requestData = req.body.data; // Access the data sent in the request

  // Handle the received data here as needed
  console.log('Received Data:', requestData);

  const userId = 9;
  const userRole = 5;
  const date = new Date().toLocaleDateString('en-GB', { timeZone: 'Africa/Lagos' });
  const parts = date.split('/');
  const formattedDay = parts[0].padStart(2, '0');
  const formattedMonth = parts[1].padStart(2, '0');
  const year = parts[2];
  const date1 = `${formattedDay}-${formattedMonth}-${year}`;

  // Initialize a string to store the result text
  let resultText = '';

  // Assuming requestData is an array of zone objects
  if (Array.isArray(requestData.zone)) {
    requestData.zone.forEach((zone) => {
      const machines = zone.machine.split(',');
      console.log('Machines:', machines);
      machines.forEach((machine) => {
        // Generate machine information text
        const machineInfoText = `${zone.zone} -> ${machine.trim()}`;

        // Append the generated text to the result string
        resultText += machineInfoText + '\n'; // Add a newline between entries

        // Handle each machine as needed
        console.log(`${zone.zone},${machine.trim()}`);
      });
    });
  } else {
    console.log('Invalid requestData format. Expected an array.');
  }

  let whereClause = '';
  if (userRole === 5) {
    whereClause = `geopos_operator.zone = ${userId} AND geopos_operator.machine = ${machine} AND geopos_operator.date = '${date1}'`;
  }
  else {
    db.query(
      `SELECT geopos_employees.id FROM geopos_employees 
       JOIN geopos_users ON geopos_employees.entryid = geopos_users.entryid
       WHERE geopos_users.id = ?`,
      [userId],
      (error, results, fields) => {
        if (error) {
          console.error('Error getting employee id:', error);
          res.status(500).json({ error: 'Internal Server Error' });
          return;
        }

        const empid = results[0].id;
        whereClause = `geopos_operator.zone = ${id} AND geopos_operator.machine = ${machine} AND geopos_operator.date = '${date1}' AND geopos_operator.emp_id = ${empid}`;

        // Execute the main query
        const sql = `SELECT * FROM geopos_operator
                    LEFT JOIN item_masterr ON item_masterr.id = geopos_operator.item
                    WHERE ${whereClause}`;
        
        db.query(sql, (error, results, fields) => {
          if (error) {
            console.error('Error executing SQL query:', error);
            res.status(500).json({ error: 'Internal Server Error' });
            return;
          }

           // Log all results
           console.log(results);

          const count = results.length;

          // Send the count as the API response
          res.json({ count });
        });
      }
    );
  }

  // Send the result text in the response
  res.send(resultText);
});



















//-------------------------REPORT ---------------------------//

//--------------------------Employee Timesheet ---------------------------//


// Get the filtered data for braid employees list
app.post('/getemployeetimesheetdata', (req, res) => {

  var product_name = req.body.product_name;
  var shift = req.body.shift;
  var site = req.body.site;
 
  
  const fromdate = new Date(req.body.fromdate)
  const fdParts = `${fromdate.getFullYear()}-${(fromdate.getMonth() + 1).toString().padStart(2, '0')}-${fromdate.getDate().toString().padStart(2, '0')}`;
  const fd = fdParts.split('-').reverse().join('-');

  const todate = new Date(req.body.todate)
  const tdParts = `${todate.getFullYear()}-${(todate.getMonth() + 1).toString().padStart(2, '0')}-${todate.getDate().toString().padStart(2, '0')}`;
  const td = tdParts.split('-').reverse().join('-');

  const fd2 = Math.floor(new Date(fromdate).getTime() / 1000);
  const td1 = Math.floor(new Date(todate).getTime() / 1000);
  const fd1 = Math.floor(new Date(fd2 * 1000).setDate(new Date(fd2 * 1000).getDate() - 1) / 1000);

  var newfd = fd1;
  var newtd = td1;




   // Log the received data
   console.log('Received data:');
   console.log('Product Name:', product_name);
   console.log('Shift:', shift);
   console.log('Site:', site);
   console.log('From Date:', fd);
   console.log('To Date:', td);
   console.log('From Date:', fromdate);
   console.log('To Date:', todate);
   console.log('Converted Timestamp:', newfd);
   console.log('Converted Timestamp:', newtd);
  
  let whereConditions = [];

  if (product_name !== '') {
    whereConditions.push(`geopos_operator.item = '${product_name}'`);
  }
 
  if (shift !== '') {
    whereConditions.push(`geopos_operator.shift = '${shift}'`);
  }
  if (site !== '') {
    whereConditions.push(`geopos_operator.site = '${site}'`);
  }
  whereConditions.push(`geopos_operator.timestamp BETWEEN '${newfd}' AND '${newtd}'`);

  const whereClause = whereConditions.join(' AND ');

   if (site === 'ikeja') {

            const query = `
            SELECT
                geopos_operator.*,
                geopos_employees.name,
                geopos_employees.entryid,
                geopos_employees.workertype,
                item_masterr.item_description,
                color_master.color_name
            FROM
                geopos_operator
            LEFT JOIN
                geopos_employees ON geopos_operator.emp_id = geopos_employees.id
            LEFT JOIN
                item_masterr ON geopos_operator.item = item_masterr.id
            LEFT JOIN
                color_master ON geopos_operator.color_id = color_master.id
            WHERE
                ${whereClause}
          `;

          console.log(query);

          db.query(query, (error, results) => {
            if (error) {
              console.error('Error executing MySQL query: ', error);
              return res.status(500).json({ error: 'Internal Server Error' });
            }

             console.log('Query results ikeja:', results); 
          console.log('Query results ikeja:', query);

            const data = {
            timesheet: results,
            
          };
          res.json(data); // Send response back to client
            
          });
  }
  else if (site === 'ota') {

          const query = `

           SELECT
                geopos_operator.*,
                employees_ota.name,
                employees_ota.entryid,
                employees_ota.workertype,
                item_masterr.item_description,
                color_master.color_name
            FROM
                geopos_operator
            LEFT JOIN
                employees_ota ON employees_ota.id = geopos_operator.emp_id
            LEFT JOIN
                item_masterr ON geopos_operator.item = item_masterr.id
            LEFT JOIN
                color_master ON geopos_operator.color_id = color_master.id
            WHERE
                ${whereClause}
        `;

        console.log(query);
        db.query(query, (error, results) => {
          if (error) {
            console.error('Error executing MySQL query: ', error);
            return res.status(500).json({ error: 'Internal Server Error' });
          }

          console.log('Query results ota:', results);

          const data = {
          timesheet: results,
          
        };
        res.json(data); // Send response back to client
          
        });

  }
  else {

             const query1 = `
            SELECT geopos_operator.*, geopos_employees.name, geopos_employees.entryid,
            geopos_employees.workertype, item_masterr.item_description,
            color_master.color_name
            FROM geopos_operator
            LEFT JOIN geopos_employees ON geopos_employees.id = geopos_operator.emp_id
            LEFT JOIN item_masterr ON geopos_operator.item = item_masterr.id
            LEFT JOIN color_master ON geopos_operator.color_id = color_master.id
            WHERE geopos_operator.site = 'ikeja' AND ${whereClause}
          `;

          const query2 = `
            SELECT geopos_operator.*, employees_ota.name, employees_ota.entryid,
            employees_ota.workertype, item_masterr.item_description,
            color_master.color_name
            FROM geopos_operator
            LEFT JOIN employees_ota ON employees_ota.id = geopos_operator.emp_id
            LEFT JOIN item_masterr ON geopos_operator.item = item_masterr.id
            LEFT JOIN color_master ON geopos_operator.color_id = color_master.id
            WHERE geopos_operator.site = 'ota' AND ${whereClause}
          `;

        // Execute the first query
        db.query(query1, (error1, results1) => {
          if (error1) {
            console.error('Error executing query 1:', error1);
            return;
          }

          // Execute the second query
          db.query(query2, (error2, results2) => {
            if (error2) {
              console.error('Error executing query 2:', error2);
              return;
            }

            // Combine the results using the UNION operator
            const combinedResults = results1.concat(results2);

            console.log('Combined query results:', combinedResults);
            // Do something with the combined results here

            // Send response back to client
              const data = {
                timesheet: combinedResults,
              };
              res.json(data);
          });
        }); 


  } 
    
  
}); 


// Get the default employee data for current date
app.get('/getdefaultemployeetimesheetdatabraid', (req, res) => {
  const roleid = 5;
  const id = 9;

  const date = new Date().toLocaleDateString('en-GB', { timeZone: 'Africa/Lagos' });
  const parts = date.split('/');
  const formattedDay = parts[0].padStart(2, '0');
  const formattedMonth = parts[1].padStart(2, '0');
  const year = parts[2];
  const date1 = `${formattedDay}-${formattedMonth}-${year}`;
  
  // Log the received data
  console.log('Received data:');
  console.log('Date:', date1);

  let query;

  if (roleid === 5) {
    // Queries for roleid = 5
    const query1 = `
        SELECT geopos_operator.*, geopos_employees.name, geopos_employees.entryid, geopos_employees.workertype, item_masterr.item_description, color_master.color_name
        FROM geopos_operator
        LEFT JOIN geopos_employees ON geopos_employees.id = geopos_operator.emp_id
        LEFT JOIN item_masterr ON geopos_operator.item = item_masterr.id
        LEFT JOIN color_master ON geopos_operator.color_id = color_master.id
        WHERE geopos_operator.date = ? AND geopos_operator.site = 'ikeja'
      `;

      const query2 = `
        SELECT geopos_operator.*, employees_ota.name, employees_ota.entryid, employees_ota.workertype, item_masterr.item_description, color_master.color_name
        FROM geopos_operator
        LEFT JOIN employees_ota ON employees_ota.id = geopos_operator.emp_id
        LEFT JOIN item_masterr ON geopos_operator.item = item_masterr.id
        LEFT JOIN color_master ON geopos_operator.color_id = color_master.id
        WHERE geopos_operator.date = ? AND geopos_operator.site = 'ota'
      `;


    query = `${query1} UNION ${query2}`;
  } 
   else {
    
        const id2 = 6;

        // Query the database for user data
        db.query('SELECT * FROM geopos_users WHERE id = ?', [id2], (err, userData) => {
          if (err) {
            console.error('Error querying the database:', err);
            res.status(500).json({ error: 'Internal Server Error' });
            return;
          }

          const site = userData[0].production_type;
          const ctype = userData[0].category_type;

          let data = {};

          if (site === 'ikeja' && ctype === 'BRAID') {
            // Perform the first database query
            db.query(
              'SELECT geopos_employees.* FROM geopos_employees ' +
                'LEFT JOIN geopos_users ON geopos_employees.entryid = geopos_users.entryid ' +
                'WHERE geopos_users.id = ?',
              [id2],
              (err, result) => {
                if (err) {
                  console.error('Error querying the database:', err);
                  res.status(500).json({ error: 'Internal Server Error' });
                  return;
                }

                const id = result[0].id;
                const date = new Date().toLocaleDateString('en-NG'); // Use 'en-NG' for Nigeria timezone

                // Define the MySQL query
                const query = `
                SELECT geopos_operator.*, geopos_employees.name, geopos_employees.entryid, geopos_employees.workertype, item_masterr.item_description, color_master.color_name
                FROM geopos_operator
                LEFT JOIN geopos_employees ON geopos_employees.id = geopos_operator.emp_id
                LEFT JOIN item_masterr ON item_masterr.id = geopos_operator.item
                LEFT JOIN color_master ON color_master.id = geopos_operator.color_id
                WHERE geopos_operator.date = ? AND geopos_operator.emp_id = ?
                ORDER BY id DESC
                LIMIT 1
              `;
              
                // Execute the SQL query
                db.query(query, [date, id], (err, results) => {
                  if (err) {
                    console.error('Error executing SQL query:', err);
                    res.status(500).json({ error: 'Internal server error' });
                  } else {
                    res.json(results);
                  }
                });
              }
            );
          }

          if (site === 'ota' && ctype === 'BRAID') {
            // Perform the second database query
            db.query(
              'SELECT employees_ota.* FROM employees_ota ' +
                'LEFT JOIN geopos_users ON employees_ota.entryid = geopos_users.entryid ' +
                'WHERE geopos_users.id = ?',
              [id2],
              (err, result) => {
                if (err) {
                  console.error('Error querying the database:', err);
                  res.status(500).json({ error: 'Internal Server Error' });
                  return;
                }

                const id = result[0].id;
                const date = new Date().toLocaleDateString('en-NG'); // Use 'en-NG' for Nigeria timezone

                // Your SQL query
                const query = `
                  SELECT geopos_operator.*, employees_ota.name, employees_ota.entryid, employees_ota.workertype, item_masterr.item_description, color_master.color_name
                  FROM geopos_operator
                  LEFT JOIN employees_ota ON employees_ota.id = geopos_operator.emp_id
                  LEFT JOIN item_masterr ON item_masterr.id = geopos_operator.item
                  LEFT JOIN color_master ON color_master.id = geopos_operator.color_id
                  WHERE geopos_operator.date = ? AND geopos_operator.emp_id = ?
                  ORDER BY id DESC
                  LIMIT 1
                `;
              
                // Execute the SQL query
                db.query(query, [date, id], (err, results) => {
                  if (err) {
                    console.error('Error executing SQL query:', err);
                    res.status(500).json({ error: 'Internal server error' });
                  } else {
                    res.json(results);
                  }
                });
              }
            );
          }
        });
  } 

  db.query(query, [date1, date1], (error, results, fields) => {

    if (error) {
      console.error('Error executing query:', error);
      res.status(500).json({ error: 'Query error' });
      return;
    }

    const data = {
      timesheet: results,
    };

    res.json(data);
  });
});




// view comparision
app.get('/getviewcomparisonbraid/:itemId', (req, res) => {
  const itemId = req.params.itemId;
  console.log('Recieved ID:', itemId);
  const query = `
    SELECT geopos_operator.*, item_masterr.item_description, item_masterr.net_weight, 
           item_masterr.targeted_waste, color_master.color_name as color
    FROM geopos_operator
    LEFT JOIN item_masterr ON geopos_operator.item = item_masterr.id
    LEFT JOIN color_master ON geopos_operator.color_id = color_master.id
    WHERE geopos_operator.id = ?
  `;

  db.query(query, [itemId], (err, results) => {
    if (err) {
      console.error('Error executing SQL query: ', err);
      res.status(500).json({ error: 'Internal Server Error' });
      return;
    }

    const comparison = results[0]; // Assuming you expect only one row
    console.log(comparison);
    const data = {
      comparison,
    };

    res.json(data);
  });
});


//get employee productivity
app.get('/getemployeeproductivity/:id', (req, res) => {
    const firstResponseId = req.params.id;
  
    // Query the database to retrieve data
    const sql = `
      SELECT * FROM operator_section
      WHERE opmanual_id LIKE '%${firstResponseId}%'
    `;
    db.query(sql, (err, results) => {
      if (err) {
        res.status(500).json({ error: 'Internal Server Error' });
        return;
      }
  
      console.log(results); // Corrected console.log statement
  
      // Create an array to store the response data
      const responseData = [];
  
      // Process the results and populate responseData
      results.forEach((row) => {
        const opid = row.opmanual_id.split(',');
        const k = opid.indexOf(firstResponseId);
        const complete = row.complete.split(',');
        const cmp = complete[k];
        const cnt = k + 1;
        const sectionId = row.section_id;
  
        // Log the relevant information to the console for debugging
        console.log('opid:', opid);
        console.log('k:', k);
        console.log('complete:', complete);
        console.log('cmp:', cmp);
        console.log('cnt:', cnt);
        console.log('sectionId:', sectionId);
  
        // Query the 'section' table to get the 'section_name'
        const sectionSql = `SELECT * FROM section WHERE id = ${sectionId}`;
        db.query(sectionSql, (sectionErr, sectionResults) => {
          if (sectionErr) {
            res.status(500).json({ error: 'Internal Server Error' });
            return;
          }
  
          const sec = sectionResults[0].section_name;
          console.log('sec:', sec);
  
          const employeeData = {
            id: row.id,
            opmanual_id: row.opmanual_id,
            empid: row.empid,
            section_id: row.section_id,
            emp: row.emp,
            target: row.target,
            complete: row.complete,
            date: row.date,
            timestamp: row.timestamp,
            sectionName: sec, // Include section_name
          };
  
          // Add employeeData to responseData
          responseData.push(employeeData);
  
          // Check if all data has been processed before sending the response
          if (responseData.length === results.length) {

            const responseObj = {
              results: responseData,
              
            };
            
            // Send the response with responseData
            res.json(responseObj);
          }
        });
      });
    });
  });


 
// Edit EmployeeTimesheet Braid Ikeja
app.get('/operator_edit/:id', (req, res) => {
  const id = req.params.id;
  const roleid = 5;
  console.log(`Requested operator_edit for ID: ${id}`);
  
  if (roleid === 5) {
    const catid = id;
    const query = 'SELECT * FROM geopos_operator WHERE id = ?';

    // Execute the database query
    db.query(query, [catid], (err, results) => {
      if (err) {
        console.error('Error executing MySQL query:', err);
        res.status(500).send('Internal Server Error');
        return;
      }

      const comparison = results[0] || {}; // Assuming you expect one row or an empty object
      console.log('Database query results:', comparison);

      // Wrap the comparison object inside an object with the 'comparison' key
      const response = {
        comparison: comparison
      };

      res.json(response); // Send the response object as JSON
    });
  } 
});



 // get operator
 app.get('/getOperator1/:empid/:site', (req, res) => {
  const empid = req.params.empid;
  const site = req.params.site;
  console.log(`Requested operator_edit for emp_id: ${empid}`);
  console.log(`Requested operator_edit for site: ${site}`);
  
  // Define the query to select operators
  const query = `
    SELECT geopos_employees.*
    FROM geopos_employees
    LEFT JOIN geopos_users ON geopos_employees.entryid = geopos_users.entryid
    WHERE geopos_users.roleid = 3
      AND geopos_users.production_type = 'ikeja'
      AND geopos_users.banned = 0
  `;

  // Create an object to store name and id
  const responseObj = {
    name: '',
    id: ''
  };

  // Execute the database query
  db.query(query, (err, results) => {
    if (err) {
      console.error('Error executing MySQL query:', err);
      res.status(500).send('Internal Server Error');
      return;
    }

    const operators = results;

    // Check conditions
    if (empid === '1') {
      responseObj.name = 'Admin';
      responseObj.id = '50000';
    } else if (site === 'ikeja') {
      // Query for 'ikeja' site
      db.query(
        'SELECT name, entryid FROM geopos_employees WHERE id = ?',
        [empid],
        (err, results) => {
          if (err) {
            console.error('Error executing MySQL query for ikeja site:', err);
            res.status(500).send('Internal Server Error');
            return;
          }

          if (results.length > 0) {
            responseObj.name = results[0].name;
            responseObj.id = results[0].entryid;
          }

          // Send the response
          console.log('Response for ikeja site:', responseObj);
          res.json(responseObj);
        }
      );
    } else if (site === 'ota') {
      // Query for 'ota' site
      db.query(
        'SELECT name, entryid FROM employees_ota WHERE id = ?',
        [empid],
        (err, results) => {
          if (err) {
            console.error('Error executing MySQL query for ota site:', err);
            res.status(500).send('Internal Server Error');
            return;
          }

          if (results.length > 0) {
            responseObj.name = results[0].name;
            responseObj.id = results[0].entryid;
          }

          // Send the response
          console.log('Response for ota site:', responseObj);
          res.json(responseObj);
        }
      );
    } else {
      // Handle other cases or send an appropriate response
      console.log('Site not found:', site);
      res.status(404).send('Site not found');
    }
  });
});
app.get('/getOperator/:empid/:site', (req, res) => {
  const empid = req.params.empid;
  const site = req.params.site;
  console.log(`Requested operator_edit forr emp_id: ${empid}`);
  console.log(`Requested operator_edit forr site: ${site}`);

  // Create an object to store name and id
  const responseObj = {
    name: '',
    id: ''
  };

  // Check conditions
  if (empid === '1') {
    responseObj.name = 'Admin';
    responseObj.id = '50000';
    res.json(responseObj);
  } else if (site === 'ikeja' || site === 'ota') {
    const tableName = (site === 'ikeja') ? 'geopos_employees' : 'employees_ota';

    // Query for the specified site
    db.query(
      `SELECT name, entryid FROM ${tableName} WHERE id = ?`,
      [empid],
      (err, results) => {
        if (err) {
          console.error(`Error executing MySQL query for ${site} site:`, err);
          res.status(500).send('Internal Server Error');
          return;
        }

        if (results.length > 0) {
          responseObj.name = results[0].name;
          responseObj.id = results[0].entryid;
        }

        // Send the response
        console.log(`Response for ${site} site:`, responseObj);
        res.json(responseObj);
      }
    );
  } else {
    // Handle other cases or send an appropriate response
    console.log('Site not found:', site);
    res.status(404).send('Site not found');
  }
});



// get operator section
app.get('/operatorsection/:id', (req, res) => {
  const comparisonId = req.params.id;
  console.log('comparisonId:', comparisonId);
  // SQL query to retrieve data
  const sql = `
    SELECT os.*, s.section_name
    FROM operator_section os
    LEFT JOIN section s ON os.section_id = s.id
    WHERE os.opmanual_id LIKE '%${comparisonId}%'
  `;

  // Execute the SQL query
  db.query(sql, (err, rows) => {
    if (err) {
      console.error('Error executing SQL query:', err);
      res.status(500).json({ error: 'Internal server error' });
      return;
    }

    const results = [];

    for (const row of rows) {
      const opid = row.opmanual_id.split(',');

      if (opid.includes(comparisonId)) {
        const k = opid.indexOf(comparisonId);
        const complete = row.complete.split(',');
        const cmp = complete[k];

        console.log('k:', k);
        console.log('complete:', complete);
        console.log('cmp:', cmp);

        const cnt = k + 1;

        // Determine if 'read' should be 'disabled'
        const read = [24, 23, 7].includes(row.section_id) ? 'disabled' : '';

        // Include the 'section_name' directly in the 'rows' response
        row.sec = row.section_name;

        // Remove the 'section_name' property from the row if desired
        delete row.section_name;

        // Include 'cmp' value in the record
        row.cmp = cmp;

        results.push(row);
      }
    }

    // Send the response
    const responseObj = {
      rows: results,
    };
    res.json(responseObj);
  });
});




//nbraid ota list

//search data
app.post('/getemployeetimesheetdatanbraidota', (req, res) => {

  var product_name = req.body.product_name;
  var shift = req.body.shift;
  var line = req.body.line_no;
  var section = req.body.section;
 
  
  const fromdate = new Date(req.body.fromdate)
  const fdParts = `${fromdate.getFullYear()}-${(fromdate.getMonth() + 1).toString().padStart(2, '0')}-${fromdate.getDate().toString().padStart(2, '0')}`;
  const fd = fdParts.split('-').reverse().join('-');

  const todate = new Date(req.body.todate)
  const tdParts = `${todate.getFullYear()}-${(todate.getMonth() + 1).toString().padStart(2, '0')}-${todate.getDate().toString().padStart(2, '0')}`;
  const td = tdParts.split('-').reverse().join('-');

  const fd2 = Math.floor(new Date(fromdate).getTime() / 1000);
  const td1 = Math.floor(new Date(todate).getTime() / 1000);
  const fd1 = Math.floor(new Date(fd2 * 1000).setDate(new Date(fd2 * 1000).getDate() - 1) / 1000);

  var newfd = fd1;
  var newtd = td1;




   // Log the received data
   console.log('Received data:');
   console.log('Product Name:', product_name);
   console.log('Shift:', shift);
   console.log('Line:', line);
   console.log('Section:', section);
   console.log('From Date:', fd);
   console.log('To Date:', td);
   console.log('From Date:', fromdate);
   console.log('To Date:', todate);
   console.log('Converted Timestamp:', newfd);
   console.log('Converted Timestamp:', newtd);
  
  let whereConditions = [];

  if (product_name !== '') {
    whereConditions.push(`worker_timesheet.product_name = '${product_name}'`);
  }
 
  if (shift !== '') {
    whereConditions.push(`worker_timesheet.shift = '${shift}'`);
  }

  if (line !== '') {
    whereConditions.push(`worker_timesheet.line = '${line}'`);
  }

  if (section !== '') {
    whereConditions.push(`worker_timesheet.section = '${section}'`);
  }
  whereConditions.push(`worker_timesheet.time_stamp BETWEEN '${newfd}' AND '${newtd}'`);

  const whereClause = whereConditions.join(' AND ');

  const query = `
  SELECT
    worker_timesheet.*, section.section_name, item_masterr.item_description,
    SUM(
      worker_timesheet.HOUR1 + worker_timesheet.HOUR2 + worker_timesheet.HOUR3 +
      worker_timesheet.HOUR4 + worker_timesheet.HOUR5 + worker_timesheet.HOUR6 +
      worker_timesheet.HOUR7 + worker_timesheet.HOUR8 + worker_timesheet.HOUR9 +
      worker_timesheet.HOUR10 + worker_timesheet.HOUR11
    ) AS value_sum
  FROM worker_timesheet
  LEFT JOIN item_masterr ON worker_timesheet.product_name = item_masterr.id
  LEFT JOIN section ON worker_timesheet.section = section.id
  WHERE
    ${whereClause}
  GROUP BY
    worker_timesheet.entry_id,
    worker_timesheet.product_name,
    worker_timesheet.section,
    worker_timesheet.shift,
    worker_timesheet.date_time
  ORDER BY worker_timesheet.worker ASC
`;

     

db.query(query, (error, results) => {
  if (error) {
    console.error('Error executing MySQL query: ', error);
    return res.status(500).json({ error: 'Internal Server Error' });
  }

   console.log('Query results ota:', results); 
// console.log('Query results ikeja:', query);

  const data = {
  timesheet: results,
  
};
res.json(data); // Send response back to client 


});
}); 



//default data
app.get('/getdefaultemployeetimesheetdatanbraidota/:roleId/:userid', (req, res) => {

  const { roleId, userid } = req.params;
  //console.log('roleid:', roleId);
  //console.log('userid:', userid);

  const date = new Date().toLocaleDateString('en-GB', { timeZone: 'Africa/Lagos' });
  const parts = date.split('/');
  const formattedDay = parts[0].padStart(2, '0');
  const formattedMonth = parts[1].padStart(2, '0');
  const year = parts[2];
  const date1 = `${formattedDay}-${formattedMonth}-${year}`;

  let query = `
  SELECT
  worker_timesheet.*, section.section_name, item_masterr.item_description,
  SUM(
    worker_timesheet.HOUR1 + worker_timesheet.HOUR2 + worker_timesheet.HOUR3 +
    worker_timesheet.HOUR4 + worker_timesheet.HOUR5 + worker_timesheet.HOUR6 +
    worker_timesheet.HOUR7 + worker_timesheet.HOUR8 + worker_timesheet.HOUR9 +
    worker_timesheet.HOUR10 + worker_timesheet.HOUR11
  ) AS value_sum
FROM worker_timesheet
LEFT JOIN item_masterr ON worker_timesheet.product_name = item_masterr.id
LEFT JOIN section ON worker_timesheet.section = section.id
WHERE worker_timesheet.date_time = ?
  `;

  if (roleId === 3) {
    query += ' AND worker_timesheet.operator_id = ?';
  }
  

  query += `
    GROUP BY worker_timesheet.entry_id, worker_timesheet.product_name,
      worker_timesheet.section, worker_timesheet.shift, worker_timesheet.date_time
    ORDER BY worker_timesheet.worker ASC
  `;

  //console.log('query:',query);

  const queryParams = roleId === 3 ? [date1, userid] : [date1];

  db.query(query, queryParams, (err, results) => {
    if (err) {
      console.error('Error executing query:', err);
      return res.status(500).json({ error: 'Internal Server Error' });
    }

    const data = {
      timesheet: results,
      
    };
    res.json(data); // Send response back to client 
  });
});

//default data for operator login
app.get('/getdefaultemployeetimesheetdatanbraidotaop/:roleId/:userid', (req, res) => {

  const { roleId, userid } = req.params;
  //console.log('roleid:', roleId);
  //console.log('userid:', userid);

  const date = new Date().toLocaleDateString('en-GB', { timeZone: 'Africa/Lagos' });
  const parts = date.split('/');
  const formattedDay = parts[0].padStart(2, '0');
  const formattedMonth = parts[1].padStart(2, '0');
  const year = parts[2];
  const date1 = `${formattedDay}-${formattedMonth}-${year}`;
  
  let query = `
  SELECT
  worker_timesheet.*, section.section_name, item_masterr.item_description,
  SUM(
    worker_timesheet.HOUR1 + worker_timesheet.HOUR2 + worker_timesheet.HOUR3 +
    worker_timesheet.HOUR4 + worker_timesheet.HOUR5 + worker_timesheet.HOUR6 +
    worker_timesheet.HOUR7 + worker_timesheet.HOUR8 + worker_timesheet.HOUR9 +
    worker_timesheet.HOUR10 + worker_timesheet.HOUR11
  ) AS value_sum
  FROM worker_timesheet
  LEFT JOIN item_masterr ON worker_timesheet.product_name = item_masterr.id
  LEFT JOIN section ON worker_timesheet.section = section.id
  WHERE worker_timesheet.date_time = ? 
  AND worker_timesheet.operator_id = ?
    `;

  query += `
    GROUP BY worker_timesheet.entry_id, worker_timesheet.product_name,
      worker_timesheet.section, worker_timesheet.shift, worker_timesheet.date_time
    ORDER BY worker_timesheet.worker ASC
  `;

  if (roleId === 3) {
    query += ' AND worker_timesheet.operator_id = ?';
  }

  console.log('query:',query);

  const queryParams = roleId === 3 ? [date1, userid] : [date1, ];

  db.query(query, [date1, userid], (err, results) => {
    if (err) {
      console.error('Error executing query:', err);
      return res.status(500).json({ error: 'Internal Server Error' });
    }

    const data = {
      timesheet: results,
      
    };
    res.json(data); // Send response back to client 
  });
});

//edit employee timesheet nbraid ota data
app.get('/getnbraidotadata/:id', (req, res) => {
  const id = req.params.id;

  const query = `
    SELECT worker_timesheet.*, section.section_name, item_masterr.item_description
    FROM worker_timesheet
    LEFT JOIN item_masterr ON worker_timesheet.product_name = item_masterr.id
    LEFT JOIN section ON worker_timesheet.section = section.id
    WHERE worker_timesheet.id = ?
  `;

  db.query(query, [id], (err, rows) => {
    if (err) {
      console.error('Error executing MySQL query:', err);
      res.status(500).json({ error: 'Internal server error' });
      return;
    }

    if (rows.length === 0) {
      res.status(404).json({ error: 'Timesheet not found' });
      return;
    }

    console.log('Query results ota:', rows); 
    res.json(rows); // Send response back to client 
  });
});

// API Endpoint to handle edit requests
app.post('/updatenbraidotadata', (req, res) => {

  const eid = req.body.id;
  const product_name = req.body.product_name;
  const section = req.body.section;
  const line = req.body.line_no;

  console.log('eid:', eid);
  console.log('product_name:', product_name);
  console.log('section:', section);
  console.log('line:', line);

  // Update the record in the 'worker_timesheet' table
  const sql = `UPDATE worker_timesheet SET product_name=?, section=?, line=? WHERE id=?`;

  db.query(sql, [product_name, section, line, eid], (err, result) => {
    if (err) {
      console.error('Error updating employee timesheet:', err);
      return res.status(500).json({ status: 'Error', message: 'Internal server error' });
    }

    if (result.affectedRows === 0) {
      return res.status(404).json({ status: 'Error', message: 'Record not found' });
    }

    return res.json({ status: 'Success', message: 'Record updated successfully' });
  });
});

//get employees for non braid employeetimesheet add
app.post('/getaddemployeetimesheetfilterdatanbraidota', (req, res) => {
  // Extract data from the request body
  const shift = req.body.shift;
  const hour = req.body.hour;
  const line = req.body.line_no;
  const section = req.body.section;
  const sites = req.body.site;

  console.log('Received data:');
  console.log('Line No:', line);
  console.log('Section:', section);
  console.log('Shift:', shift);
  console.log('Hour:', hour);
  console.log('Site:', sites);

  let date1 = '';
  let sectionName = ''; // Initialize sectionName

  // Check if the site is 'ota'
  if (sites === 'ota') {
    // Query to fetch data from 'employees_ota' table
    const query1 = 'SELECT * FROM employees_ota ORDER BY id ASC LIMIT 1';
    
    // Execute query1 to get the date value
    db.query(query1, (error1, results1, fields) => {
      if (error1) {
        console.error('Error executing query1:', error1);
        res.status(500).json({ error: 'Internal Server Error' });
      } else {
        // Set the date1 variable with the fetched date value
        date1 = results1[0].date;
        //console.log('date for ota:', date1);

        // Check if data already exists for the specified parameters
        const checkQuery = `
          SELECT *
          FROM worker_timesheet
          WHERE line = '${line}' 
          AND section = '${section}' 
          AND shift = '${shift}' 
          AND date_time = '${date1}' 
          AND ${hour} > 0
          AND site = '${sites}';
        `;

        //console.log('Check Query:', checkQuery);
        //console.log('Values:', [line, section, shift, date1, sites]);

        // Execute checkQuery to see if data exists
        db.query(checkQuery,  (checkError, checkResults) => {
          if (checkError) {
            console.error('Error executing checkQuery:', checkError);
            res.status(500).json({ error: 'Internal Server Error' });
          } else {
           
            // Check if data exists
            const dataExists = checkResults.length > 0;
            //console.log('dataExists:', dataExists);
            //console.log('Check Results:', checkResults);
            
            if (dataExists) {
              // Fetch section name based on sectionId
              const querySectionName = `
                SELECT section_name
                FROM section
                WHERE id = ?;
              `;
            
              db.query(querySectionName, [section], (errorSection, resultsSection) => {
                if (errorSection) {
                  console.error('Error fetching section name:', errorSection);
                  res.status(500).json({ error: 'Internal Server Error' });
                } else {
                  // Extract sectionName from the query results
                  const sectionName = resultsSection.length > 0 ? resultsSection[0].section_name : '';
            
                  // Continue with constructing the response
                 // const message = `You have already inserted data for product, line ${line}, section ${sectionName}, and hour ${hour}. For editing, click on `;
                  const message = `You have already inserted data for product, ${line}, line, ${sectionName}, section and, ${hour}, hour. For editing, click on `;
                  const additionalData = {
                    sectionname: sectionName,
                    tdate: 0,
                    sites,
                    hour,
                    line,
                    section,
                    shiftt: shift,
                  };
            
                  res.status(200).json({ message, ...additionalData });
                }
              });
            } else {
              // Continue with the main logic

              // Query to fetch data from 'operator_assign' table
              const query2 = `
                SELECT operator_assign.*, geopos_users.name, operator_assign.name_id as opid
                FROM operator_assign
                LEFT JOIN geopos_users ON operator_assign.name_id = geopos_users.id
                WHERE operator_assign.line = ? 
                AND operator_assign.section = ? 
                AND operator_assign.shift = ? 
                AND operator_assign.category_type = 'NBRAID';
              `;
              db.query(query2, [line, section, shift], (error2, results2, fields) => {
                if (error2) {
                  console.error('Error executing query2:', error2);
                  res.status(500).json({ error: 'Internal Server Error' });
                } else {
                  // Execute query4 to fetch the section name
                  const sectionId = section; // Assuming 'section' holds the section_id
                  const query4 = `
                    SELECT section_name
                    FROM section
                    WHERE id = ?;
                  `;
                  db.query(query4, [sectionId], (error4, results4, fields) => {
                    if (error4) {
                      console.error('Error fetching section name:', error4);
                      res.status(500).json({ error: 'Internal Server Error' });
                    } else {
                      if (results4.length > 0) {
                        sectionName = results4[0].section_name;
                        //console.log('Section Name:', sectionName);
                      }
      
                      // Query to check if data exists in 'worker_timesheet'
                      const query3 = `
                        SELECT *
                        FROM worker_timesheet
                        WHERE line = ? 
                        AND section = ? 
                        AND shift = ? 
                        AND date_time = ? 
                        AND ? > 0 
                        AND site = ?;
                      `;

                      db.query(query3, [line, section, shift, date1, hour, sites], (error3, results3, fields) => {
                        if (error3) {
                          console.error('Error executing query3:', error3);
                          res.status(500).json({ error: 'Internal Server Error' });
                        } else {
                          // Log the results of query3 to the console
                          //console.log('Query3 Results:', results3);

                          // If no data exists in 'worker_timesheet', execute additional query
                          if (results3.length === 0) {
                            // Query to fetch data from 'employees_ota' based on specific conditions
                            const query9 = `
                                SELECT *
                                FROM employees_ota
                                WHERE section_id = ? 
                                AND line = ? 
                                AND roleid = '1' 
                                AND passive_type = 'ACT' 
                                AND workertype = 'DIRECT' 
                                AND shift = ? 
                                AND category_type = 'NBRAID'
                                ORDER BY name;
                              `;

db.query(query9, [section, line, shift], (error9, results9) => {
  if (error9) {
    console.error('Error executing query9:', error9);
    res.status(500).json({ error: 'Internal Server Error' });
  } else {
    // Log the results of query9 to the console
    console.log('Query9 Results:', results9);

    // Initialize the data object outside the loop
    const data = {
      op: results2,
      filteredResults: [], // Initialize filteredResults as an empty array
      abs: [], // Initialize abs as an empty array for absent entryid values
      additionalResults: [], // Initialize additionalResults as an empty array for 'P' case
      sectionname: sectionName, // Set sectionName here
      tdate: 0,
      sites,
      hour,
      line,
      section,
      shiftt: shift,
    };

    // Function to execute the inner query and handle the result
    const executeInnerQuery = (row) => {
      return new Promise((resolve, reject) => {
        const queryInner = `
          SELECT * 
          FROM worker_timesheet 
          WHERE entry_id = ? 
          AND ${hour} > 0 
          AND date_time = ?;
        `;
    
        console.log('Inner Query:', queryInner); // Log the SQL query
    
        db.query(queryInner, [row.entryid, date1], (errorInner, wrk) => {
          if (errorInner) {
            console.error('Error executing worker_timesheet query:', errorInner);
            reject(errorInner);
          } else {
            const row1 = wrk.length; // Use the length property for the number of rows
            console.log('row1:', row1);
    
            if (row1 === 0) {
              // Include the entire 'row' object in filteredResults for 'P' case
              data.filteredResults.push(row);
            } else {
              // Handle the case when rows are found in the inner query
              // Add your logic here for the 'else' condition
    
              // Extract relevant information from the query 9 results for 'non-P' case
              const { name } = row;
    
              // Include the relevant information in additionalResults for 'non-P' case
              data.additionalResults.push({ name });
            }
    
            resolve();
          }
        });
      });
    };

    // Array to store promises for inner queries
    const innerQueryPromises = [];

    results9.forEach((row) => {
      const entryId = row.entryid;
      if (row.status === 'P') {
        // Execute the inner query and push the promise to the array
        innerQueryPromises.push(executeInnerQuery(row));
      } else {
        // Include the entryid in abs for 'non-P' case
        data.abs.push(entryId);
      }
    });

    // Wait for all inner queries to complete before sending the response
    Promise.all(innerQueryPromises)
      .then(() => {
        // Send the modified 'data' object as a response
        res.status(200).json(data);
      })
      .catch((error) => {
        console.error('Error in inner queries:', error);
        res.status(500).json({ error: 'Internal Server Error' });
      });
  }
});
                          } else {
                            // Data already exists in 'worker_timesheet'
                            const data = {
                              op: results2,
                              filteredResults: results3, // Include results from query3
                              sectionname: sectionName, // Set sectionName here
                              tdate: 0,
                              sites,
                              hour,
                              line,
                              section,
                              shiftt: shift,
                            };

                            // Send the 'data' object as a response with the results of query3
                            res.status(200).json(data);
                          }
                        }
                      });
                    }
                  });
                }
              });
            }
          }
        });
      }
    });
  } else if (sites === 'ikeja') {
    // Query to fetch data from 'geopos_employees' table
    const query5 = 'SELECT * FROM geopos_employees ORDER BY id ASC LIMIT 1';
    
    // Execute query5 to get the date value
    db.query(query5, (error5, results5, fields) => {
      if (error5) {
        console.error('Error executing query5:', error5);
        res.status(500).json({ error: 'Internal Server Error' });
      } else {
        // Set the date1 variable with the fetched date value
        date1 = results5[0].date;
        console.log('date for ikeja:', date1);

       // Check if data already exists for the specified parameters
       const checkQuery = `
       SELECT *
       FROM worker_timesheet
       WHERE line = '${line}' 
       AND section = '${section}' 
       AND shift = '${shift}' 
       AND date_time = '${date1}' 
       AND ${hour} > 0
       AND site = '${sites}';
     `;
     
             console.log('Check Query:', checkQuery);
             //console.log('Values:', [line, section, shift, date1, sites]);
     
             // Execute checkQuery to see if data exists
             db.query(checkQuery,  (checkError, checkResults) => {
               if (checkError) {
                 console.error('Error executing checkQuery:', checkError);
                 res.status(500).json({ error: 'Internal Server Error' });
               } else {
                
                 // Check if data exists
                 const dataExists = checkResults.length > 0;
                 console.log('dataExists:', dataExists);
                 console.log('Check Results:', checkResults);
                 if (dataExists) {
                  // Fetch section name based on sectionId
                  const querySectionName = `
                    SELECT section_name
                    FROM section
                    WHERE id = ?;
                  `;
                
                  db.query(querySectionName, [section], (errorSection, resultsSection) => {
                    if (errorSection) {
                      console.error('Error fetching section name:', errorSection);
                      res.status(500).json({ error: 'Internal Server Error' });
                    } else {
                      // Extract sectionName from the query results
                      const sectionName = resultsSection.length > 0 ? resultsSection[0].section_name : '';
                
                      // Continue with constructing the response
                      //const message = `You have already inserted data for product, line ${line}, section ${sectionName}, and hour ${hour}. For editing, click on `;
                      const message = `You have already inserted data for product, ${line}, line, ${sectionName}, section and, ${hour}, hour. For editing, click on `;
                      const additionalData = {
                        sectionname: sectionName,
                        tdate: 0,
                        sites,
                        hour,
                        line,
                        section,
                        shiftt: shift,
                      };
                
                      res.status(200).json({ message, ...additionalData });
                    }
                  });
                }  else {
              // Continue with the main logic

              // Query to fetch data from 'operator_assign_ikeja' table
              const query6 = `
                SELECT operator_assign_ikeja.*, geopos_users.name, operator_assign_ikeja.operator_id as opid
                FROM operator_assign_ikeja
                LEFT JOIN geopos_users ON operator_assign_ikeja.operator_id = geopos_users.id
                WHERE operator_assign_ikeja.line = ? 
                AND operator_assign_ikeja.section = ? 
                AND operator_assign_ikeja.shift = ? 
                AND operator_assign_ikeja.category_type = 'NBRAID';
              `;
              db.query(query6, [line, section, shift], (error6, results6, fields) => {
                if (error6) {
                  console.error('Error executing query6:', error6);
                  res.status(500).json({ error: 'Internal Server Error' });
                } else {
                  // Execute query4 to fetch the section name
                  const sectionId = section; // Assuming 'section' holds the section_id
                  const query7 = `
                    SELECT section_name
                    FROM section
                    WHERE id = ?;
                  `;
                  db.query(query7, [sectionId], (error7, results7, fields) => {
                    if (error7) {
                      console.error('Error fetching section name:', error7);
                      res.status(500).json({ error: 'Internal Server Error' });
                    } else {
                      if (results7.length > 0) {
                        sectionName = results7[0].section_name;
                        console.log('Section Name:', sectionName);
                      }
      
                      // Query to check if data exists in 'worker_timesheet'
                      const query3 = `
                        SELECT *
                        FROM worker_timesheet
                        WHERE line = ? 
                        AND section = ? 
                        AND shift = ? 
                        AND date_time = ? 
                        AND ? > 0 
                        AND site = ?;
                      `;

                      db.query(query3, [line, section, shift, date1, hour, sites], (error3, results3, fields) => {
                        if (error3) {
                          console.error('Error executing query3:', error3);
                          res.status(500).json({ error: 'Internal Server Error' });
                        } else {
                          // Log the results of query3 to the console
                          console.log('Query3 Results:', results3);

                          // If no data exists in 'worker_timesheet', execute additional query
                          if (results3.length === 0) {
                            // Query to fetch data from 'geopos_employees' based on specific conditions
                            /* const query10 = `
                              SELECT *
                              FROM geopos_employees
                              WHERE section_id = ? 
                              AND line = ? 
                              AND roleid = '1' 
                              AND passive_type = 'ACT' 
                              AND workertype = 'DIRECT' 
                              AND shift = ? 
                              AND category_type = 'NBRAID'
                              ORDER BY name;
                            `;

                            db.query(query10, [section, line, shift], (error10, results10) => {
                              if (error10) {
                                console.error('Error executing query10:', error10);
                                res.status(500).json({ error: 'Internal Server Error' });
                              } else {
                                // Log the results of query10 to the console
                                console.log('Query10 Results:', results10);

                                // Include the results of query10 as filteredResults
                                const data = {
                                  op: results6,
                                  filteredResults: results10, // Include results from query10
                                  sectionname: sectionName, // Set sectionName here
                                  tdate: 0,
                                  sites,
                                  hour,
                                  line,
                                  section,
                                  shiftt: shift,
                                };

                                // Send the 'data' object as a response with the results of query10
                                res.status(200).json(data);
                              }
                            }); */
                            const query10 = `
                              SELECT *
                              FROM geopos_employees
                              WHERE section_id = ? 
                              AND line = ? 
                              AND roleid = '1' 
                              AND passive_type = 'ACT' 
                              AND workertype = 'DIRECT' 
                              AND shift = ? 
                              AND category_type = 'NBRAID'
                              ORDER BY name;
                            `;

                            db.query(query10, [section, line, shift], (error10, results10) => {
                              if (error10) {
                                console.error('Error executing query10:', error10);
                                res.status(500).json({ error: 'Internal Server Error' });
                              } else {
                                // Log the results of query10 to the console
                                console.log('Query10 Results:', results10);

    // Initialize the data object outside the loop
    const data = {
      op: results6,
      filteredResults: [], // Initialize filteredResults as an empty array
      abs: [], // Initialize abs as an empty array for absent entryid values
      additionalResults: [], // Initialize additionalResults as an empty array for 'P' case
      sectionname: sectionName, // Set sectionName here
      tdate: 0,
      sites,
      hour,
      line,
      section,
      shiftt: shift,
    };

    // Function to execute the inner query and handle the result
    const executeInnerQuery = (row) => {
      return new Promise((resolve, reject) => {
        const queryInner = `
          SELECT * 
          FROM worker_timesheet 
          WHERE entry_id = ? 
          AND ${hour} > 0 
          AND date_time = ?;
        `;

        console.log('Inner Query:', queryInner); // Log the SQL query

        db.query(queryInner, [row.entryid, date1], (errorInner, wrk) => {
          if (errorInner) {
            console.error('Error executing worker_timesheet query:', errorInner);
            reject(errorInner);
          } else {
            const row1 = wrk.length; // Use the length property for the number of rows
            console.log('row1:', row1);

            if (row1 === 0) {
              // Include the entire 'row' object in filteredResults for 'P' case
              data.filteredResults.push(row);
            } else {
              // Handle the case when rows are found in the inner query
              // Add your logic here for the 'else' condition
    
              // Extract relevant information from the query 9 results for 'non-P' case
              const { name } = row;
    
              // Include the relevant information in additionalResults for 'non-P' case
              data.additionalResults.push({ name });
            }
            resolve();
          }
        });
      });
    };

    // Array to store promises for inner queries
    const innerQueryPromises = [];

    results10.forEach((row) => {
      const entryId = row.entryid;
      if (row.status === 'P') {
        // Execute the inner query and push the promise to the array
        innerQueryPromises.push(executeInnerQuery(row));
      } else {
        // Include the entryid in abs for 'non-P' case
        data.abs.push(entryId);
      }
    });

    // Wait for all inner queries to complete before sending the response
    Promise.all(innerQueryPromises)
      .then(() => {
        // Send the modified 'data' object as a response
        res.status(200).json(data);
      })
      .catch((error) => {
        console.error('Error in inner queries:', error);
        res.status(500).json({ error: 'Internal Server Error' });
      });
  }
});


                          } else {
                            // Data already exists in 'worker_timesheet'
                            const data = {
                              op: results6,
                              filteredResults: results3, // Include results from query3
                              sectionname: sectionName, // Set sectionName here
                              tdate: 0,
                              sites,
                              hour,
                              line,
                              section,
                              shiftt: shift,
                            };

                            // Send the 'data' object as a response with the results of query3
                            res.status(200).json(data);
                          }
                        }
                      });
                    }
                  });
                }
              });
            }
          }
        });
      }
    });
  }
});

//get employees for non braid employeetimesheet add op login
app.post('/getaddemployeetimesheetfilterdatanbraidotaoplogin/:userid', (req, res) => {
  // Extract data from the request body
  const shift = req.body.shift;
  const hour = req.body.hour;
  const line = req.body.line_no;
  const section = req.body.section;
  const { userid } = req.params;
  
  console.log('Received data:');
  console.log('Line No:', line);
  console.log('Section:', section);
  console.log('Shift:', shift);
  console.log('Hour:', hour);
  console.log('userid:', userid);

  const date = new Date().toLocaleDateString('en-GB', { timeZone: 'Africa/Lagos' });
  const parts = date.split('/');
  const day = parts[0].padStart(2, '0');
  const month = parts[1].padStart(2, '0');
  const year = parts[2];
  const currentMonth = `${month}-${year}`;
  const currentdate = `${day}-${month}-${year}`;

  let date1 = '';
  let sectionName = ''; // Initialize sectionName
 

  // Execute the MySQL query
  db.query(`SELECT * FROM geopos_users WHERE id='${userid}'`, (error, results, fields) => {
    if (error) {
      console.error('Error executing MySQL query:', error);
      res.status(500).send('Internal Server Error');
    } else {
      // Retrieve the necessary data from the MySQL results
      const site = results[0].production_type;
      const ctype = results[0].category_type;
      console.log('site:', site);
      console.log('ctype:', ctype);

     
        if (site === 'ota' && ctype ==='NBRAID') {
          // Query to fetch data from 'employees_ota' table
          const query1 = 'SELECT * FROM employees_ota ORDER BY id ASC LIMIT 1';
          
          // Execute query1 to get the date value
          db.query(query1, (error1, results1, fields) => {
            if (error1) {
              console.error('Error executing query1:', error1);
              res.status(500).json({ error: 'Internal Server Error' });
            } else {
              // Set the date1 variable with the fetched date value
              date1 = results1[0].date;
              //console.log('date for ota:', date1);

              // Check if data already exists for the specified parameters
              const checkQuery = `
              SELECT *
              FROM worker_timesheet
              WHERE line = '${line}' 
              AND section = '${section}' 
              AND shift = '${shift}' 
              AND date_time = '${date1}' 
              AND ${hour} > 0
              AND site = '${site}';
            `;

              //console.log('Check Query:', checkQuery);
              //console.log('Values:', [line, section, shift, date1, site]);

              // Execute checkQuery to see if data exists
              db.query(checkQuery,  (checkError, checkResults) => {
                if (checkError) {
                  console.error('Error executing checkQuery:', checkError);
                  res.status(500).json({ error: 'Internal Server Error' });
                } else {
                
                  // Check if data exists
                  const dataExists = checkResults.length > 0;
                  
                  if (dataExists) {
                    // Fetch section name based on sectionId
                    const querySectionName = `
                      SELECT section_name
                      FROM section
                      WHERE id = ?;
                    `;
                  
                    db.query(querySectionName, [section], (errorSection, resultsSection) => {
                      if (errorSection) {
                        console.error('Error fetching section name:', errorSection);
                        res.status(500).json({ error: 'Internal Server Error' });
                      } else {
                        // Extract sectionName from the query results
                        const sectionName = resultsSection.length > 0 ? resultsSection[0].section_name : '';
                  
                        // Continue with constructing the response
                        const message = `You have already inserted data for product, ${line}, line, ${sectionName}, section and, ${hour}, hour. For editing, click on `;
                        const additionalData = {
                          sectionname: sectionName,
                          tdate: 0,
                          site,
                          hour,
                          line,
                          section,
                          shiftt: shift,
                        };
                  
                        res.status(200).json({ message, ...additionalData });
                      }
                    });
                  } else {

                    // Query to fetch data from 'operator_assign' table
                    const query2 = `
                      SELECT operator_assign.*, geopos_users.name, operator_assign.name_id as opid
                      FROM operator_assign
                      LEFT JOIN geopos_users ON operator_assign.name_id = geopos_users.id
                      WHERE operator_assign.line = ? 
                      AND operator_assign.section = ? 
                      AND operator_assign.shift = ? 
                      AND operator_assign.category_type = 'NBRAID';
                    `;
                    db.query(query2, [line, section, shift], (error2, results2, fields) => {
                      if (error2) {
                        console.error('Error executing query2:', error2);
                        res.status(500).json({ error: 'Internal Server Error' });
                      } else {
                        // Execute query4 to fetch the section name
                        const sectionId = section; // Assuming 'section' holds the section_id
                        const query4 = `
                          SELECT section_name
                          FROM section
                          WHERE id = ?;
                        `;
                        db.query(query4, [sectionId], (error4, results4, fields) => {
                          if (error4) {
                            console.error('Error fetching section name:', error4);
                            res.status(500).json({ error: 'Internal Server Error' });
                          } else {
                            if (results4.length > 0) {
                              sectionName = results4[0].section_name;
                              //console.log('Section Name:', sectionName);
                            }
            
                            // Query to check if data exists in 'worker_timesheet'
                            const query3 = `
                              SELECT *
                              FROM worker_timesheet
                              WHERE line = ? 
                              AND section = ? 
                              AND shift = ? 
                              AND date_time = ? 
                              AND ? > 0 
                              AND site = ?;
                            `;

                            db.query(query3, [line, section, shift, date1, hour, site], (error3, results3, fields) => {
                              if (error3) {
                                console.error('Error executing query3:', error3);
                                res.status(500).json({ error: 'Internal Server Error' });
                              } else {
                                // Log the results of query3 to the console
                                //console.log('Query3 Results:', results3);

                                // If no data exists in 'worker_timesheet', execute additional query
                                if (results3.length === 0) {
                                  // Query to fetch data from 'employees_ota' based on specific conditions
                                  const query9 = `
                                  SELECT *
                                  FROM employees_ota
                                  WHERE section_id = ? 
                                  AND line = ? 
                                  AND roleid = '1' 
                                  AND passive_type = 'ACT' 
                                  AND workertype = 'DIRECT' 
                                  AND shift = ? 
                                  AND category_type = 'NBRAID'
                                  ORDER BY name;
                                `;

                                db.query(query9, [section, line, shift], (error9, results9) => {
                                  if (error9) {
                                    console.error('Error executing query9:', error9);
                                    res.status(500).json({ error: 'Internal Server Error' });
                                  } else {
                                    // Log the results of query9 to the console
                                    console.log('Query9 Results:', results9);

                                    // Initialize the data object outside the loop
                                    const data = {
                                      op: results2,
                                      filteredResults: [], // Initialize filteredResults as an empty array
                                      abs: [], // Initialize abs as an empty array for absent entryid values
                                      additionalResults: [], // Initialize additionalResults as an empty array for 'P' case
                                      sectionname: sectionName, // Set sectionName here
                                      tdate: 0,
                                      site,
                                      hour,
                                      line,
                                      section,
                                      shiftt: shift,
                                    };

                                    // Function to execute the inner query and handle the result
                                    const executeInnerQuery = (row) => {
                                      return new Promise((resolve, reject) => {
                                        const queryInner = `
                                          SELECT * 
                                          FROM worker_timesheet 
                                          WHERE entry_id = ? 
                                          AND ${hour} > 0 
                                          AND date_time = ?;
                                        `;
                                    
                                        console.log('Inner Query:', queryInner); // Log the SQL query
                                    
                                        db.query(queryInner, [row.entryid, date1], (errorInner, wrk) => {
                                          if (errorInner) {
                                            console.error('Error executing worker_timesheet query:', errorInner);
                                            reject(errorInner);
                                          } else {
                                            const row1 = wrk.length; // Use the length property for the number of rows
                                            console.log('row1:', row1);
                                    
                                            if (row1 === 0) {
                                              // Include the entire 'row' object in filteredResults for 'P' case
                                              data.filteredResults.push(row);
                                            } else {
                                              // Handle the case when rows are found in the inner query
                                              // Add your logic here for the 'else' condition
                                    
                                              // Extract relevant information from the query 9 results for 'non-P' case
                                              const { name } = row;
                                    
                                              // Include the relevant information in additionalResults for 'non-P' case
                                              data.additionalResults.push({ name });
                                            }
                                    
                                            resolve();
                                          }
                                        });
                                      });
                                    };

                                    // Array to store promises for inner queries
                                    const innerQueryPromises = [];

                                    results9.forEach((row) => {
                                      const entryId = row.entryid;
                                      if (row.status === 'P') {
                                        // Execute the inner query and push the promise to the array
                                        innerQueryPromises.push(executeInnerQuery(row));
                                      } else {
                                        // Include the entryid in abs for 'non-P' case
                                        data.abs.push(entryId);
                                      }
                                    });

                                    // Wait for all inner queries to complete before sending the response
                                    Promise.all(innerQueryPromises)
                                      .then(() => {
                                        // Send the modified 'data' object as a response
                                        res.status(200).json(data);
                                      })
                                      .catch((error) => {
                                        console.error('Error in inner queries:', error);
                                        res.status(500).json({ error: 'Internal Server Error' });
                                      });
                                  }
                                });
                                } else {
                                  // Data already exists in 'worker_timesheet'
                                  const data = {
                                    op: results2,
                                    filteredResults: results3, // Include results from query3
                                    sectionname: sectionName, // Set sectionName here
                                    tdate: 0,
                                    site,
                                    hour,
                                    line,
                                    section,
                                    shiftt: shift,
                                  };

                                  // Send the 'data' object as a response with the results of query3
                                  res.status(200).json(data);
                                }
                              }
                            });
                          }
                        });
                      }
                    });
                  }
                }
              });
            }
          });
        } 
        else if (site === 'ikeja' && ctype ==='NBRAID') {
          // Query to fetch data from 'geopos_employees' table
          const query5 = 'SELECT * FROM geopos_employees ORDER BY id ASC LIMIT 1';
          
          // Execute query5 to get the date value
          db.query(query5, (error5, results5, fields) => {
            if (error5) {
              console.error('Error executing query5:', error5);
              res.status(500).json({ error: 'Internal Server Error' });
            } else {
              // Set the date1 variable with the fetched date value
              date1 = results5[0].date;
              console.log('date for ikeja:', date1);

            // Check if data already exists for the specified parameters
            const checkQuery = `
            SELECT *
            FROM worker_timesheet
            WHERE line = '${line}' 
            AND section = '${section}' 
            AND shift = '${shift}' 
            AND date_time = '${date1}' 
            AND ${hour} > 0
            AND site = '${site}';
          `;
          
                  console.log('Check Query:', checkQuery);
                  //console.log('Values:', [line, section, shift, date1, site]);
          
                  // Execute checkQuery to see if data exists
                  db.query(checkQuery,  (checkError, checkResults) => {
                    if (checkError) {
                      console.error('Error executing checkQuery:', checkError);
                      res.status(500).json({ error: 'Internal Server Error' });
                    } else {
                      
                      // Check if data exists
                      const dataExists = checkResults.length > 0;
                      console.log('dataExists:', dataExists);
                      console.log('Check Results:', checkResults);
                      if (dataExists) {
                        // Fetch section name based on sectionId
                        const querySectionName = `
                          SELECT section_name
                          FROM section
                          WHERE id = ?;
                        `;
                      
                        db.query(querySectionName, [section], (errorSection, resultsSection) => {
                          if (errorSection) {
                            console.error('Error fetching section name:', errorSection);
                            res.status(500).json({ error: 'Internal Server Error' });
                          } else {
                            // Extract sectionName from the query results
                            const sectionName = resultsSection.length > 0 ? resultsSection[0].section_name : '';
                      
                            // Continue with constructing the response
                            //const message = `You have already inserted data for product, line ${line}, section ${sectionName}, and hour ${hour}. For editing, click on `;
                            const message = `You have already inserted data for product, ${line}, line, ${sectionName}, section and, ${hour}, hour. For editing, click on `;
                            const additionalData = {
                              sectionname: sectionName,
                              tdate: 0,
                              site,
                              hour,
                              line,
                              section,
                              shiftt: shift,
                            };
                      
                            res.status(200).json({ message, ...additionalData });
                          }
                        });
                      }  else {
                    // Continue with the main logic

                    // Query to fetch data from 'operator_assign_ikeja' table
                    const query6 = `
                      SELECT operator_assign_ikeja.*, geopos_users.name, operator_assign_ikeja.operator_id as opid
                      FROM operator_assign_ikeja
                      LEFT JOIN geopos_users ON operator_assign_ikeja.operator_id = geopos_users.id
                      WHERE operator_assign_ikeja.line = ? 
                      AND operator_assign_ikeja.section = ? 
                      AND operator_assign_ikeja.shift = ? 
                      AND operator_assign_ikeja.category_type = 'NBRAID';
                    `;
                    db.query(query6, [line, section, shift], (error6, results6, fields) => {
                      if (error6) {
                        console.error('Error executing query6:', error6);
                        res.status(500).json({ error: 'Internal Server Error' });
                      } else {
                        // Execute query4 to fetch the section name
                        const sectionId = section; // Assuming 'section' holds the section_id
                        const query7 = `
                          SELECT section_name
                          FROM section
                          WHERE id = ?;
                        `;
                        db.query(query7, [sectionId], (error7, results7, fields) => {
                          if (error7) {
                            console.error('Error fetching section name:', error7);
                            res.status(500).json({ error: 'Internal Server Error' });
                          } else {
                            if (results7.length > 0) {
                              sectionName = results7[0].section_name;
                              console.log('Section Name:', sectionName);
                            }
            
                            // Query to check if data exists in 'worker_timesheet'
                            const query3 = `
                              SELECT *
                              FROM worker_timesheet
                              WHERE line = ? 
                              AND section = ? 
                              AND shift = ? 
                              AND date_time = ? 
                              AND ? > 0 
                              AND site = ?;
                            `;

                            db.query(query3, [line, section, shift, date1, hour, site], (error3, results3, fields) => {
                              if (error3) {
                                console.error('Error executing query3:', error3);
                                res.status(500).json({ error: 'Internal Server Error' });
                              } else {
                                // Log the results of query3 to the console
                                console.log('Query3 Results:', results3);

                                // If no data exists in 'worker_timesheet', execute additional query
                                if (results3.length === 0) {
                                  // Query to fetch data from 'geopos_employees' based on specific conditions
                                 
                                  const query10 = `
                                    SELECT *
                                    FROM geopos_employees
                                    WHERE section_id = ? 
                                    AND line = ? 
                                    AND roleid = '1' 
                                    AND passive_type = 'ACT' 
                                    AND workertype = 'DIRECT' 
                                    AND shift = ? 
                                    AND category_type = 'NBRAID'
                                    ORDER BY name;
                                  `;

                                  db.query(query10, [section, line, shift], (error10, results10) => {
                                    if (error10) {
                                      console.error('Error executing query10:', error10);
                                      res.status(500).json({ error: 'Internal Server Error' });
                                    } else {
                                      // Log the results of query10 to the console
                                      console.log('Query10 Results:', results10);

                                    // Initialize the data object outside the loop
                                    const data = {
                                      op: results6,
                                      filteredResults: [], // Initialize filteredResults as an empty array
                                      abs: [], // Initialize abs as an empty array for absent entryid values
                                      additionalResults: [], // Initialize additionalResults as an empty array for 'P' case
                                      sectionname: sectionName, // Set sectionName here
                                      tdate: 0,
                                      site,
                                      hour,
                                      line,
                                      section,
                                      shiftt: shift,
                                    };

                                    // Function to execute the inner query and handle the result
                                    const executeInnerQuery = (row) => {
                                      return new Promise((resolve, reject) => {
                                        const queryInner = `
                                          SELECT * 
                                          FROM worker_timesheet 
                                          WHERE entry_id = ? 
                                          AND ${hour} > 0 
                                          AND date_time = ?;
                                        `;

                                        console.log('Inner Query:', queryInner); // Log the SQL query

                                        db.query(queryInner, [row.entryid, date1], (errorInner, wrk) => {
                                          if (errorInner) {
                                            console.error('Error executing worker_timesheet query:', errorInner);
                                            reject(errorInner);
                                          } else {
                                            const row1 = wrk.length; // Use the length property for the number of rows
                                            console.log('row1:', row1);

                                            if (row1 === 0) {
                                              // Include the entire 'row' object in filteredResults for 'P' case
                                              data.filteredResults.push(row);
                                            } else {
                                              // Handle the case when rows are found in the inner query
                                              // Add your logic here for the 'else' condition
                                    
                                              // Extract relevant information from the query 9 results for 'non-P' case
                                              const { name } = row;
                                    
                                              // Include the relevant information in additionalResults for 'non-P' case
                                              data.additionalResults.push({ name });
                                            }
                                            resolve();
                                          }
                                        });
                                      });
                                    };

                                    // Array to store promises for inner queries
                                    const innerQueryPromises = [];

                                    results10.forEach((row) => {
                                      const entryId = row.entryid;
                                      if (row.status === 'P') {
                                        // Execute the inner query and push the promise to the array
                                        innerQueryPromises.push(executeInnerQuery(row));
                                      } else {
                                        // Include the entryid in abs for 'non-P' case
                                        data.abs.push(entryId);
                                      }
                                    });

                                    // Wait for all inner queries to complete before sending the response
                                    Promise.all(innerQueryPromises)
                                      .then(() => {
                                        // Send the modified 'data' object as a response
                                        res.status(200).json(data);
                                      })
                                      .catch((error) => {
                                        console.error('Error in inner queries:', error);
                                        res.status(500).json({ error: 'Internal Server Error' });
                                      });
                                  }
                                });
                                } else {
                                  // Data already exists in 'worker_timesheet'
                                  const data = {
                                    op: results6,
                                    filteredResults: results3, // Include results from query3
                                    sectionname: sectionName, // Set sectionName here
                                    tdate: 0,
                                    site,
                                    hour,
                                    line,
                                    section,
                                    shiftt: shift,
                                  };

                                  // Send the 'data' object as a response with the results of query3
                                  res.status(200).json(data);
                                }
                              }
                            });
                          }
                        });
                      }
                    });
                  }
                }
              });
            }
          });
        }
        else if (site === 'both' && ctype ==='both') {
          date1 = currentdate;
        }

    }
  }); 
});


// Fetch target based on product 
app.get('/gettargetnbraid/:selectedProduct', (req, res) => {
  const { selectedProduct } = req.params;
  const selectedSection = req.query.section; // Retrieve the section from the query parameters
  // Execute the database query
  const query = `
    SELECT target
    FROM item_section_ota
    WHERE section_id = ? AND item_id = ?;
  `;

  db.query(query, [selectedSection, selectedProduct], (error, results, fields) => {
    if (error) {
      console.error('Error executing database query:', error);
      res.status(500).json({ error: 'Internal Server Error' });
    } else {
      if (results.length > 0) {
        const target = results[0].target;
        res.json({ target });
      } else {
        res.status(404).json({ error: 'Data not found' });
      }
    }
  });
});




//insert employeetimesheet new data
app.post('/insertemployeetimesheetnbraidotadata', async (req, res) => {
  console.log("connected");
  const tableData = req.body;
  let date1;
  let joindate;
  let success = true; // Flag to track if any error occurs
  const errors = [];

  try {
    await Promise.all(tableData.map(async (data) => {
      const worker_names = data.worker_names;
      const emp_ids = data.emp_ids;
      const shifts = data.shifts;
      const user_id = data.op_id;
      const section = data.section;
      const product_name = data.product_name;
      const line = data.line;
      const sectionname = data.sectionname;
      const hour = data.hour;
      const target = data.target;
      const fg = data.fg;
      const completes = data.completes;
      const color = data.color;
      const sites = data.sites;
      const joindate = data.joindate;

      // Add console logs for debugging or tracing
      //console.log('Processing data:', data);
      /* console.log('completes:', completes);
      console.log('target:', target);
      console.log('user_id:', user_id); */

      if (sites === 'ota') {
        const query = `SELECT * FROM employees_ota ORDER BY id ASC LIMIT 1`;
        try {
          const employeeResults = await executeQuery(query);
          //console.log('Employee Results:', employeeResults);
          if (employeeResults.length > 0) {
            date1 = employeeResults[0].date;
            //joindate = employeeResults[0].joindate;

            /* console.log('Date1:', date1);
            console.log('Join Date:', joindate); */

            // Split the date string into day, month, and year
            const [day, month, year] = date1.split('-');

            // Create a new Date using the components
            const dayy1 = new Date(`${year}-${month}-${day}`);
            //console.log('dayy1:', dayy1);

            const formattedMonth = (dayy1.getMonth() + 1).toString().padStart(2, '0');
            const formattedYear = dayy1.getFullYear();
            const formattedDate = `${formattedMonth}-${formattedYear}`;

            //console.log('Formatted Month-Year:', formattedDate);

            const currentDate = new Date().toISOString();
            //console.log('currentDate:', currentDate);

            const milliseconds = dayy1.getTime();
            const timestamp = Math.floor(milliseconds / 1000);
            //console.log('timestamp:', timestamp);

            const query = `SELECT * FROM worker_timesheet
              WHERE product_name IN (?) AND line IN (?) AND section IN (?) AND shift IN (?) AND entry_id IN (?) AND date_time = ? AND site = ?`;

            const timesheetResults = await executeQuery(query, [product_name, line, section, shifts, emp_ids, date1, sites]);

            //console.log('Timesheet Results:', timesheetResults);

            if (timesheetResults.length > 0) {
              const existingEntry = timesheetResults;
              const hr = hour[4];
              //console.log('hr:', hr);

              const postedTarget = target;
              //console.log('Posted target:', postedTarget);

              const resultTarget = existingEntry[0].target;
              //console.log('target:', resultTarget);

              const tar = parseFloat(target) + parseFloat(resultTarget);
              //console.log('tar:', tar);

              const updateQuery = `UPDATE worker_timesheet SET ${hour} = ?, target = ?
                WHERE product_name = ? AND line = ? AND section = ? AND shift = ?
                AND date_time = ? AND worker = ? AND entry_id = ?`;

              try {
                await executeQuery(updateQuery, [completes, tar, product_name, line, section, shifts, date1, worker_names, emp_ids]);
              } catch (err) {
                console.error('Error updating entry: ' + err.stack);
                errors.push('Error updating entry: ' + err.message);
                success = false;
              }
            } else {
              const hr = hour[4];
              //console.log('hr:', hr);
              const insertQuery = `INSERT INTO worker_timesheet (product_name, line, section, shift, worker, entry_id, joindate, ${hour}, target, actual_target, date_time, time_stamp, mon, color_id, date, operator_id, site)
                VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`;

             
              console.log('Insert Query:', insertQuery);
              console.log('Insert Values:', [product_name, line, section, shifts, worker_names, emp_ids, joindate, completes, target, target, date1, timestamp, month, color, currentDate, user_id, sites]);


              try {
                await executeQuery(insertQuery, [product_name, line, section, shifts, worker_names, emp_ids, joindate, completes, target, target, date1, timestamp, formattedDate, color, currentDate, user_id, sites]);
              } catch (err) {
                console.error('Error inserting new entry: ' + err.stack);
                errors.push('Error inserting new entry: ' + err.message);
                success = false;
              }
            }
          } else {
            console.error('No data found in employees_ota');
            errors.push('No data found in employees_ota');
            success = false;
          }
        } catch (err) {
          console.error('Error querying employees_ota: ' + err.stack);
          errors.push('Error querying employees_ota: ' + err.message);
          success = false;
        }
      } else if (sites === 'ikeja') {
        const query = `SELECT * FROM geopos_employees ORDER BY id ASC LIMIT 1`;
        try {
          const employeeResults = await executeQuery(query);
          if (employeeResults.length > 0) {
            date1 = employeeResults[0].date;
            //joindate = employeeResults[0].joindate;

            // Split the date string into day, month, and year
            const [day, month, year] = date1.split('-');

            // Create a new Date using the components
            const dayy1 = new Date(`${year}-${month}-${day}`);
            //console.log('dayy1:', dayy1);

            const formattedMonth = (dayy1.getMonth() + 1).toString().padStart(2, '0');
            const formattedYear = dayy1.getFullYear();
            const formattedDate = `${formattedMonth}-${formattedYear}`;

            //console.log('Formatted Month-Year:', formattedDate);

            const currentDate = new Date().toISOString();
            //console.log('currentDate:', currentDate);

            const milliseconds = dayy1.getTime();
            const timestamp = Math.floor(milliseconds / 1000);
            //console.log('timestamp:', timestamp);

            const query = `SELECT * FROM worker_timesheet
              WHERE product_name IN (?) AND line IN (?) AND section IN (?) AND shift IN (?) AND entry_id IN (?) AND date_time = ? AND site = ?`;

            const timesheetResults = await executeQuery(query, [product_name, line, section, shifts, emp_ids, date1, sites]);

            if (timesheetResults.length > 0) {
              const existingEntry = timesheetResults[0];
              const hr = hour[4];
              const tar = existingEntry.target + target;

              const updateQuery = `UPDATE worker_timesheet SET ${hour} = ?, target = ?
                WHERE product_name = ? AND line = ? AND section = ? AND shift = ?
                AND date_time = ? AND worker = ? AND entry_id = ?`;

              try {
                await executeQuery(updateQuery, [completes, tar, product_name, line, section, shifts, date1, worker_names, emp_ids]);
              } catch (err) {
                console.error('Error updating entry: ' + err.stack);
                errors.push('Error updating entry: ' + err.message);
                success = false;
              }
            } else {
              const hr = hour[4];

              const insertQuery = `INSERT INTO worker_timesheet (product_name, line, section, shift, worker, entry_id, joindate, ${hour}, target, actual_target, date_time, time_stamp, mon, color_id, date, operator_id, site)
                VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`;

              //console.log('Insert Query:', insertQuery);

              try {
                await executeQuery(insertQuery, [product_name, line, section, shifts, worker_names, emp_ids, joindate, completes, target, target, date1, timestamp, formattedDate, color, currentDate, user_id, sites]);
              } catch (err) {
                console.error('Error inserting new entry: ' + err.stack);
                errors.push('Error inserting new entry: ' + err.message);
                success = false;
              }
            }
          } else {
            console.error('No data found in geopos_employees');
            errors.push('No data found in geopos_employees');
            success = false;
          }
        } catch (err) {
          console.error('Error querying geopos_employees: ' + err.stack);
          errors.push('Error querying geopos_employees: ' + err.message);
          success = false;
        }
      } else {
        console.error('Invalid site value');
        errors.push('Invalid site value');
        success = false;
      }
    }));

    if (success) {
      return res.json({ status: 1, message: 'Details added successfully' });
    } else {
      // If there are errors, send a response with the collected error messages.
      return res.json({ status: 0, errors });
    }
  } catch (error) {
    console.error('Error processing data: ' + error.stack);
    errors.push('Error processing data: ' + error.message);
    return res.json({ status: 0, errors });
  }
});


// Function to execute a database query and return a Promise
function executeQuery(query, values) {
  return new Promise((resolve, reject) => {
    db.query(query, values, (err, results) => {
      if (err) {
        reject(err);
      } else {
        resolve(results);
      }
    });
  });
}


//insert employeetimesheet new data operator login
app.post('/insertemployeetimesheetnbraidotadataoplogin/:userid', async (req, res) => {
  const tableData = req.body;
  let date1;
  let joindate;
  let success = true; // Flag to track if any error occurs
  const errors = [];
  const { userid } = req.params;

  const date = new Date().toLocaleDateString('en-GB', { timeZone: 'Africa/Lagos' });
  const parts = date.split('/');
  const day = parts[0].padStart(2, '0');
  const month = parts[1].padStart(2, '0');
  const year = parts[2];
  const currentMonth = `${month}-${year}`;
  const currentDate = `${day}-${month}-${year}`;

  try {
    await Promise.all(tableData.map(async (data) => {
      const worker_names = data.worker_names;
      const emp_ids = data.emp_ids;
      const shifts = data.shifts;
      const section = data.section;
      const product_name = data.product_name;
      const line = data.line;
      const sectionname = data.sectionname;
      const hour = data.hour;
      const target = data.target;
      const fg = data.fg;
      const completes = data.completes;
      const color = data.color;

       console.log('Processing data:', data);

      const queryResult = await new Promise((resolve, reject) => {
        db.query(`SELECT * FROM geopos_users WHERE id='${userid}'`, (error, results, fields) => {
          if (error) {
            console.error('Error executing MySQL query:', error);
            reject(error);
          } else {
            resolve(results);
          }
        });
      });

      const site = queryResult[0].production_type;
      const ctype = queryResult[0].category_type;
      console.log('site:', site);
      console.log('ctype:', ctype);

      if (site === 'ota' && ctype === 'NBRAID') {
        const query = `SELECT * FROM employees_ota ORDER BY id ASC LIMIT 1`;
        try {
          const employeeResults = await executeQueryop(query);
          //console.log('Employee Results:', employeeResults);
          if (employeeResults.length > 0) {
            date1 = employeeResults[0].date;
            joindate = employeeResults[0].joindate;

            /* console.log('Date1:', date1);
            console.log('Join Date:', joindate); */

            // Split the date string into day, month, and year
            const [day, month, year] = date1.split('-');

            // Create a new Date using the components
            const dayy1 = new Date(`${year}-${month}-${day}`);
            //console.log('dayy1:', dayy1);

            const formattedMonth = (dayy1.getMonth() + 1).toString().padStart(2, '0');
            const formattedYear = dayy1.getFullYear();
            const formattedDate = `${formattedMonth}-${formattedYear}`;

            //console.log('Formatted Month-Year:', formattedDate);

            const currentDate = new Date().toISOString();
            //console.log('currentDate:', currentDate);

            const milliseconds = dayy1.getTime();
            const timestamp = Math.floor(milliseconds / 1000);
            //console.log('timestamp:', timestamp);

            const query = `SELECT * FROM worker_timesheet
              WHERE product_name IN (?) AND line IN (?) AND section IN (?) AND shift IN (?) AND entry_id IN (?) AND date_time = ? AND site = ?`;

            const timesheetResults = await executeQueryop(query, [product_name, line, section, shifts, emp_ids, date1, site]);

            //console.log('Timesheet Results:', timesheetResults);

            if (timesheetResults.length > 0) {
              const existingEntry = timesheetResults;
              const hr = hour[4];
              //console.log('hr:', hr);

              const postedTarget = target;
              //console.log('Posted target:', postedTarget);

              const resultTarget = existingEntry[0].target;
              //console.log('target:', resultTarget);

              const tar = parseFloat(target) + parseFloat(resultTarget);
              //console.log('tar:', tar);

              const updateQuery = `UPDATE worker_timesheet SET ${hour} = ?, target = ?
                WHERE product_name = ? AND line = ? AND section = ? AND shift = ?
                AND date_time = ? AND worker = ? AND entry_id = ?`;

              try {
                await executeQueryop(updateQuery, [completes, tar, product_name, line, section, shifts, date1, worker_names, emp_ids]);
              } catch (err) {
                console.error('Error updating entry: ' + err.stack);
                errors.push('Error updating entry: ' + err.message);
                success = false;
              }
            } else {
              const hr = hour[4];
              //console.log('hr:', hr);
              const insertQuery = `INSERT INTO worker_timesheet (product_name, line, section, shift, worker, entry_id, joindate, ${hour}, target, actual_target, date_time, time_stamp, mon, color_id, date, operator_id, site)
                VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`;

             
              console.log('Insert Query:', insertQuery);
              console.log('Insert Values:', [product_name, line, section, shifts, worker_names, emp_ids, joindate, completes, target, target, date1, timestamp, month, color, currentDate, userid, site]);


              try {
                await executeQueryop(insertQuery, [product_name, line, section, shifts, worker_names, emp_ids, joindate, completes, target, target, date1, timestamp, formattedDate, color, currentDate, userid, site]);
              } catch (err) {
                console.error('Error inserting new entry: ' + err.stack);
                errors.push('Error inserting new entry: ' + err.message);
                success = false;
              }
            }
          } else {
            console.error('No data found in employees_ota');
            errors.push('No data found in employees_ota');
            success = false;
          }
        } catch (err) {
          console.error('Error querying employees_ota: ' + err.stack);
          errors.push('Error querying employees_ota: ' + err.message);
          success = false;
        }
      } else if (site === 'ikeja' && ctype === 'NBRAID') {
        const query = `SELECT * FROM geopos_employees ORDER BY id ASC LIMIT 1`;
        try {
          const employeeResults = await executeQueryop(query);
          if (employeeResults.length > 0) {
            date1 = employeeResults[0].date;
            joindate = employeeResults[0].joindate;

            // Split the date string into day, month, and year
            const [day, month, year] = date1.split('-');

            // Create a new Date using the components
            const dayy1 = new Date(`${year}-${month}-${day}`);
            //console.log('dayy1:', dayy1);

            const formattedMonth = (dayy1.getMonth() + 1).toString().padStart(2, '0');
            const formattedYear = dayy1.getFullYear();
            const formattedDate = `${formattedMonth}-${formattedYear}`;

            //console.log('Formatted Month-Year:', formattedDate);

            const currentDate = new Date().toISOString();
            //console.log('currentDate:', currentDate);

            const milliseconds = dayy1.getTime();
            const timestamp = Math.floor(milliseconds / 1000);
            //console.log('timestamp:', timestamp);

            const query = `SELECT * FROM worker_timesheet
              WHERE product_name IN (?) AND line IN (?) AND section IN (?) AND shift IN (?) AND entry_id IN (?) AND date_time = ? AND site = ?`;

            const timesheetResults = await executeQueryop(query, [product_name, line, section, shifts, emp_ids, date1, site]);

            if (timesheetResults.length > 0) {
              const existingEntry = timesheetResults[0];
              const hr = hour[4];
              const tar = existingEntry.target + target;

              const updateQuery = `UPDATE worker_timesheet SET ${hour} = ?, target = ?
                WHERE product_name = ? AND line = ? AND section = ? AND shift = ?
                AND date_time = ? AND worker = ? AND entry_id = ?`;

              try {
                await executeQueryop(updateQuery, [completes, tar, product_name, line, section, shifts, date1, worker_names, emp_ids]);
              } catch (err) {
                console.error('Error updating entry: ' + err.stack);
                errors.push('Error updating entry: ' + err.message);
                success = false;
              }
            } else {
              const hr = hour[4];

              const insertQuery = `INSERT INTO worker_timesheet (product_name, line, section, shift, worker, entry_id, joindate, ${hour}, target, actual_target, date_time, time_stamp, mon, color_id, date, operator_id, site)
                VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)`;

              //console.log('Insert Query:', insertQuery);

              try {
                await executeQueryop(insertQuery, [product_name, line, section, shifts, worker_names, emp_ids, joindate, completes, target, target, date1, timestamp, formattedDate, color, currentDate, userid, site]);
              } catch (err) {
                console.error('Error inserting new entry: ' + err.stack);
                errors.push('Error inserting new entry: ' + err.message);
                success = false;
              }
            }
          } else {
            console.error('No data found in geopos_employees');
            errors.push('No data found in geopos_employees');
            success = false;
          }
        } catch (err) {
          console.error('Error querying geopos_employees: ' + err.stack);
          errors.push('Error querying geopos_employees: ' + err.message);
          success = false;
        }
      } else if (site === 'both' && ctype === 'both') {
        date1 = currentDate;
      }

    }));

    if (success) {
      return res.json({ status: 1, message: 'Details added successfully' });
    } else {
      return res.json({ status: 0, errors });
    }
  } catch (error) {
    console.error('Error processing data: ' + error.stack);
    errors.push('Error processing data: ' + error.message);
    return res.json({ status: 0, errors });
  }
});


// Function to execute a database query and return a Promise
function executeQueryop(query, values) {
  return new Promise((resolve, reject) => {
    db.query(query, values, (err, results) => {
      if (err) {
        reject(err);
      } else {
        resolve(results);
      }
    });
  });
}



// Get the default employee data for current date
app.get('/getinitialemployeetimesheetdatabraid', (req, res) => {

  const date = new Date().toLocaleDateString('en-GB', { timeZone: 'Africa/Lagos' });
  const parts = date.split('/');
  const formattedDay = parts[0].padStart(2, '0');
  const formattedMonth = parts[1].padStart(2, '0');
  const year = parts[2];
  const date1 = `${formattedDay}-${formattedMonth}-${year}`;

  

   // Log the received data
   console.log('Received data:');
   console.log('Date:', date1);
  
  
  // Query for the first site 'ikeja'
const query1 = `
SELECT geopos_operator.*, geopos_employees.name, geopos_employees.entryid,
  geopos_employees.workertype, item_masterr.item_description, color_master.color_name
FROM geopos_operator
LEFT JOIN geopos_employees ON geopos_employees.id = geopos_operator.emp_id
LEFT JOIN item_masterr ON geopos_operator.item = item_masterr.id
LEFT JOIN color_master ON geopos_operator.color_id = color_master.id
WHERE geopos_operator.date = '${date1}'
  AND geopos_operator.site = 'ikeja';
`;

// Query for the second site 'ota'
const query2 = `
SELECT geopos_operator.*, employees_ota.name, employees_ota.entryid,
  employees_ota.workertype, item_masterr.item_description, color_master.color_name
FROM geopos_operator
LEFT JOIN employees_ota ON employees_ota.id = geopos_operator.emp_id
LEFT JOIN item_masterr ON geopos_operator.item = item_masterr.id
LEFT JOIN color_master ON geopos_operator.color_id = color_master.id
WHERE geopos_operator.date = '${date1}'
  AND geopos_operator.site = 'ota';
`;

const combinedQuery = `${query1}; ${query2}`;

  db.query(combinedQuery, (error, results, fields) => {
    if (error) {
      console.error(error);
      res.status(500).json({ error: 'Internal server error' });
    } else {
      const combinedResults = [...results[0], ...results[1]];
      res.json(combinedResults);
    }
  });
});

//fetch section
app.post('/getsectionsforaddemployee', (req, res) => {
  let site, zone, shift, machine, cat, color;
  if (req.body) {
    cat = req.body.product_name;
    color = req.body.color_description;
    site = req.body.site;
    zone = req.body.zone;
    shift = req.body.shift;
    machine = req.body.machine1 + ',';
  }
  
  /*****************Note - Product and color are not required for getting sections*********************/

  // Logging the extracted values
  /* console.log('Product Name:', cat);
  console.log('Color Description:', color);
  console.log('Site:', site);
  console.log('Zone:', zone);
  console.log('Shift:', shift);
  console.log('Machine:', machine); */

  const date = new Date().toLocaleDateString('en-GB', { timeZone: 'Africa/Lagos' });
  const parts = date.split('/');
  const formattedDay = parts[0].padStart(2, '0');
  const formattedMonth = parts[1].padStart(2, '0');
  const year = parts[2];
  const date1 = `${formattedDay}-${formattedMonth}-${year}`;

  const query = 'SELECT * FROM item_section_ota WHERE item_id = ?';

  db.query(query, [cat], (error, results) => {
    if (error) {
      console.error('Error in initial query:', error);
      return res.status(500).json({ error: 'Internal Server Error' });
    }

    let output = '';
    let absent = '';
    let resolvedPromises = [];

    const processResults = (row, querya, querye) => {
      return new Promise((resolve, reject) => {
        db.query(querya, (errora, resultsa) => {
          if (errora) return reject(errora);

          resultsa.forEach(rowa => {
            absent += rowa.entryid + ',';
          });

          db.query(querye, (errore, resultse) => {
            if (errore) return reject(errore);

            //console.log('Result of querye:', resultse);

            const sectionQuery = `SELECT * FROM section WHERE id = ${row.section_id}`;
            db.query(sectionQuery, (errorSection, resultSection) => {
              if (errorSection) return reject(errorSection);

              const section = resultSection[0].section_name;
              const target = row.target;

              resultse.forEach(roww => {
              // Add section_name and target to the current row
              roww.section_name = resultSection[0].section_name;
              roww.target = row.target;

              // Add the modified row to the output array
              output += JSON.stringify(roww, null, 2);
              });

              resolve();
            });
          });
        });
      });
    };

    const sendResponseIfDone = () => {
      if (resolvedPromises.length === results.length) {
        const dataArray = {
          pr: output.replace(/\n/g, ''),
          ab: absent
        };
        //console.log('Sending response:', dataArray);
        res.json(dataArray);
      }
    };

    const promises = results.map(row => {
      let wherea, where, querya, querye;

      if (site === 'ota') {
        wherea = `roleid != 3 AND zone='${zone}' AND shift='${shift}' AND machine LIKE '%${machine}%' AND status='A' AND workertype='DIRECT'`;
        where = `roleid != 3 AND zone='${zone}' AND shift='${shift}' AND machine LIKE '%${machine}%' AND status='P' AND workertype='DIRECT'`;
        querya = `SELECT * FROM employees_ota WHERE ${wherea} AND section_id = ${row.section_id}`;
        querye = `SELECT * FROM employees_ota WHERE ${where} AND section_id = ${row.section_id}`;
      } else if (site === 'ikeja') {
        wherea = `roleid != 3 AND zone='${zone}' AND shift='${shift}' AND machine LIKE '%${machine}%' AND status='A' AND workertype='DIRECT'`;
        where = `roleid != 3 AND zone='${zone}' AND shift='${shift}' AND machine LIKE '%${machine}%' AND status='P' AND workertype='DIRECT'`;
        querya = `SELECT * FROM geopos_employees WHERE ${wherea} AND section_id = ${row.section_id}`;
        querye = `SELECT * FROM geopos_employees WHERE ${where} AND section_id = ${row.section_id}`;
      }

      return processResults(row, querya, querye)
        .then(() => {
          resolvedPromises.push(row); // Assuming each promise represents a row
        })
        .catch(error => {
          //console.error('Error processing results:', error);
          res.status(500).json({ error: 'Internal Server Error' });
        });
    });

    Promise.all(promises)
      .then(() => sendResponseIfDone())
      .catch(error => {
        //console.error('Error in Promise.all:', error);
        res.status(500).json({ error: 'Internal Server Error' });
      });
  });
});


//insert employee timesheet data
app.post('/insertemployeetimesheetfilterdata', (req, res) => {
  const receivedData = req.body;
 // console.log('Received Form Data:', receivedData);

  const formDataToSend = receivedData[0];
  const { zone, machinec, shift, fdate } = formDataToSend;
  
  const date1 = fdate;
  const fdParts = date1.split('-');
  const fd = `${fdParts[2]}-${fdParts[1]}-${fdParts[0]}`;

  const dateObj = new Date(date1);
  const day = dateObj.getDate().toString().padStart(2, '0');
  const month = (dateObj.getMonth() + 1).toString().padStart(2, '0');
  const year = dateObj.getFullYear();

  const date = `${day}-${month}-${year}`;
  const date2 = `${month}-${year}`;

  const fd2 = Math.floor(new Date(date1).getTime() / 1000);


var dayy1 = fd2;

const originalDate = new Date(fdate);

const year1 = originalDate.getFullYear();
const month1 = String(originalDate.getMonth() + 1).padStart(2, '0');
const day1 = String(originalDate.getDate()).padStart(2, '0');
const hour = '12';
const minute = '00';
const second = '00';

const date3 = `${year1}-${month1}-${day1} ${hour}:${minute}:${second}`;


console.log('Date:', date);
console.log('date2:', date2);
console.log('dayy1:', dayy1);
console.log('date3:', date3);

 /* const dayy1 = '1700524800';
  const date2 = '11-2023';
  const date3 = '2023-11-21 12:00:00';*/

  const tableRowsData = receivedData.slice(1);

  //const machineCondition = `machine LIKE '%${machinec}%'`;
  //const machineCondition = `machine = '${machinec}'`;
  const machineCondition = `FIND_IN_SET('${machinec}', machine) > 0`;
  const whereConditionIndirect = `zone='${zone}' AND shift='${shift}' AND ${machineCondition} AND workertype='INDIRECT' AND status='P'`;
  const whereConditionDirect = `zone='${zone}' AND shift='${shift}' AND ${machineCondition} AND workertype='DIRECT' AND status='P'`;

  const queryIndirect = `SELECT * FROM geopos_employees WHERE ${whereConditionIndirect}`;
  const queryDirect = `SELECT * FROM geopos_employees WHERE ${whereConditionDirect}`;

  console.log('queryIndirect:', queryIndirect); // Log the value of ire here
  console.log('queryDirect:', queryDirect); // Log the value of ire here


  db.query(queryIndirect, (err, resultIndirect) => {
    if (err) throw err;

    let ire = 0;
    resultIndirect.forEach((ws) => {
      //ire += parseInt(ws.emp_count, 10);
      ire += parseFloat(ws.emp_count);

    });

    const roundedIre = parseFloat(ire.toFixed(4));
    console.log('roundedIre:', roundedIre); // Log the value of ire here

    db.query(queryDirect, (err, resultDirect) => {
      if (err) throw err;

      let dre = 0;
      resultDirect.forEach((ws1) => {
        //dre += parseInt(ws1.emp_count, 10);
        dre += parseFloat(ws1.emp_count);
      });

      const roundeddre = parseFloat(dre.toFixed(4));
    console.log('roundeddre:', roundeddre); // Log the value of ire here

      const combinedData = {
        dataArray: [
          {
            ...formDataToSend,
            indirectCount: roundedIre,
            directCount: roundeddre,
            date,
            dayy1,
            date2,
            date3,
          },
          ...tableRowsData,
        ],
        dataArray1: tableRowsData,
      };

      // Call the function to perform MySQL operations
      performMySQLOperations(combinedData, (mysqlErr, mysqlResult) => {
        if (mysqlErr) {
          console.error('MySQL operation failed:', mysqlErr);
      
          res.status(500).json({
            error: 'MySQL operation failed.',
            errorMessage: mysqlErr.message // Include the error message from mysqlErr
          });
        } else {
          res.json({ success: 'MySQL operation successful.', successMessage: mysqlResult });
        }
      });
    });
  });
});


function performMySQLOperations(combinedData, callback) {
  // Log dataArray to the console
 // console.log('Received combinedData:', combinedData);

  const { emp_id, shift, item, color_id, zone, machine, machinec, hr_start, hr_end, fiber, fg_output, waste1, waste2, waste3, waste_weight, date, temp0, temp1, temp2, temp3, temp4, temp5, site, indirectCount, directCount, dayy1, date2, date3 } = combinedData.dataArray[0];

  const data = {
    emp_id: emp_id,
    shift: shift,
    item: item,
    color_id: color_id,
    zone: zone,
    machine: machine,
    hr_start: hr_start,
    hr_end: hr_end,
    fiber: fiber,
    fg_output: fg_output,
    waste1: waste1,
    waste2: waste2,
    waste3: waste3,
    waste_weight: waste_weight,
    date: date,
    timestamp: dayy1,
    datetime: date3,
    month: date2,
    iemp_count: indirectCount,
    demp_count: directCount,
    upper: temp0,
    lower: temp1,
    perheating: temp2,
    machine_speed: temp3,
    tension: temp4,
    spreading: temp5,
    site: site,
  };


  
  /* const { emp_ids, worker_names, section, target, section_id, completes } = combinedData.dataArray1;
  const empIdsArray = emp_ids.split(',').map(id => id.trim()); */

  const selectQuery = `SELECT * FROM geopos_operator WHERE hr_start = '${hr_start}' AND zone = '${zone}' AND machine = '${machine}' AND date = '${date}'`;

  console.log('selectQuery:', selectQuery);

  db.query(selectQuery, (selectError, selectResults) => {
    if (selectError) {
      res.json({ status: 'Error', message: 'Database error' });
    } else {
      const numRows = selectResults.length;
      console.log('selectResults:', selectResults);
      console.log('numRows:', numRows);

      if (numRows > 0) {
        const errorMessage = `Sorry, you have already entered ${hr_start} start hour for ${zone} and ${machine} on ${date}`;
        console.log('Error Message:', errorMessage);
        const errorResponse = {
          status: 'Error',
          message: errorMessage,
        };
       // Sending the error response to the client
         return callback(errorResponse);
      } else {
        const insertQuery = 'INSERT INTO geopos_operator SET ?';

        db.query(insertQuery, data, (insertError, insertResults) => {
          if (insertError) {
            res.json({ status: 'Error', message: 'Failed to insert data' });
          }
          else {
            const opid = insertResults.insertId;
            console.log('opid:', opid);
            const dataArray = combinedData.dataArray1;

              for (let i = 0; i < dataArray.length; i++) {
                const { emp_ids, worker_names, section, target, section_id, completes } = dataArray[i];
                const empIdsArray = emp_ids.split(',').map(id => id.trim());
                
                console.log('Emp IDs:', emp_ids);
                console.log('Worker Names:', worker_names);
                console.log('Section:', section);
                console.log('Target:', target);
                console.log('Section ID:', section_id);
                console.log('Completes:', completes);
              

                
            
              if (section) {
                const selectSectionQuery = 'SELECT * FROM geopos_operator ORDER BY id DESC LIMIT 1';

                db.query(selectSectionQuery, (selectSectionError, selectSectionResults) => {
                  const lastOperatorId = selectSectionResults[0].id;
                  console.log('lastOperatorId:', lastOperatorId);

                  //console.log('empIdsArray:', empIdsArray);

                  empIdsArray.forEach((emid, index) => {
                    const comp = completes;
                    console.log(`Before data1 construction (Index ${index}):`, worker_names, section_id, target);


                    const data1 = {
                      empid: emid,
                      opmanual_id: `${lastOperatorId},`,
                      section_id: section_id,
                      emp: worker_names,
                      target: target,
                      complete: `${comp},`,
                      date,
                      timestamp: dayy1,
                    };

                    console.log(`data1 (Index ${index}):`, data1);

                    const selectOperatorSectionQuery = 'SELECT * FROM operator_section WHERE empid = ? AND date = ?';
                    const selectOperatorSectionValues = [emid, date];

                    db.query(
                      selectOperatorSectionQuery,
                      selectOperatorSectionValues,
                      (selectOSQueryError, selectOSQueryResults) => {
                        const numOSRows = selectOSQueryResults.length;

                        if (numOSRows > 0) {
                          const cid = selectOSQueryResults[0].id;
                          const op = `${selectOSQueryResults[0].opmanual_id}${opid},`;
                          const cm = `${selectOSQueryResults[0].complete}${comp},`;

                          const updateOperatorSectionQuery =
                            'UPDATE operator_section SET opmanual_id = ?, complete = ? WHERE id = ?';
                          const updateOperatorSectionValues = [op, cm, cid];

                          db.query(
                            updateOperatorSectionQuery,
                            updateOperatorSectionValues,
                            (updateOSError) => {
                              if (updateOSError) {
                                console.error(updateOSError);
                              }
                            }
                          );
                        } else {
                          const insertOperatorSectionQuery = 'INSERT INTO operator_section SET ?';

                          db.query(
                            insertOperatorSectionQuery,
                            data1,
                            (insertOSQueryError) => {
                              if (insertOSQueryError) {
                                console.error(insertOSQueryError);
                              }
                            }
                          );
                        }
                      }
                    );
                  });
                });
              }
            } 
            // Send success message to the client
            const successMessage = 'Details added successfully!';
            return callback(null, successMessage);
          }
        });
      }
    }
  });
}




//Add employee timesheet filter values and click enter
app.post('/getaddemployeetimesheetfilterdata', (req, res) => {
  const shift = parseFloat(req.body.shift);
  const shf = Math.round(shift * 100) / 100;
  const shf1 = shift + 'HRS';
  const hour = req.body.hour;
  const product = req.body.product_name;
  const line = req.body.line_no;
  const section = req.body.section;
  const dayNight = req.body.day_night;
  const op_id = 9;

  // Log the received data
  console.log('Received data:');
  console.log('Product Name:', product);
  console.log('Line No:', line);
  console.log('Section:', section);
  console.log('Shift:', shf);
  console.log('Hour:', hour);
  console.log('Day/Night:', dayNight);

  const date = new Date().toLocaleDateString('en-GB', { timeZone: 'Africa/Lagos' });
  const parts = date.split('/');
  const formattedDay = parts[0].padStart(2, '0');
  const formattedMonth = parts[1].padStart(2, '0');
  const year = parts[2];
  const date1 = `${formattedDay}-${formattedMonth}-${year}`;

  console.log('Date:', date1);

  const query1 = `SELECT im.item_description as item_description, s.section_name as section_name, ism.utarget 
    FROM item_section_moz ism
    INNER JOIN item_masterr im ON ism.item_id = im.id
    INNER JOIN section s ON ism.section_id = s.id
    WHERE im.id = "${product}" AND s.id = "${section}"`;

  // Execute the first query to fetch utarget
  db.query(query1, (error1, results1) => {
    if (error1) {
      console.error('Error executing query:', error1);
      res.status(500).json({ error: 'Internal Server Error' });
    } else {
      if (results1.length > 0) {
        const utarget = results1[0].utarget;
        const target = results1[0].utarget;
        const productName = results1[0].item_description;
        const sectionName = results1[0].section_name;
        

        // Log the retrieved data
        console.log('utarget:', utarget);
        console.log('target:', target);
        console.log('Product Name:', product);
        console.log('Line No:', line);
        console.log('Section:', section);
        console.log('Shift:', shf);
        console.log('Shift1:', shf1);
        console.log('Hour:', hour);
        console.log('Day/Night:', dayNight);
        console.log('Date:', date1);
        console.log('Product Name:', productName);
        console.log('Section Name:', sectionName);

        const data = {
          r: 0,
          target: target,
          hour: hour,
          product: productName,
          line: line,
          section: sectionName,
          day_night: dayNight,
          date: date1,
          op_id: op_id,
          shiftt: shift,
          tdate: 0,
          productid: product,
          sectionid: section,
          query3Results: [] // Initialize an empty array for query3 results
        };

        // Use the data as needed or send it in the response
        console.log(data);

        //new added lines 10-07-2023

        if (product !== '') {
          const array = {
            product: product,
            section_id: section,
            line: line,
            shift: shf1,
            roleid: '1',
            passive_type: 'ACT'
          };

          const query3 = 'SELECT * FROM employees_moz WHERE product = ? AND section_id = ? AND line = ? AND shift = ? AND roleid = ? AND passive_type = ? AND status = ? ORDER BY name ASC';
          db.query(query3, [array.product, array.section_id, array.line, array.shift, array.roleid, array.passive_type, 'P'], (error3, ret) => {
            if (error3) {
              console.error('Error:', error3);
              res.status(500).json({ error: 'Internal Server Error' });
              return;
            }

            // Log Query 3 results
            console.log('Query 3 Results:', ret);

            // Add the query3 results to the data object
            data.query3Results = ret;

            // Perform the query to fetch absent entry IDs
            const queryAbsent =
            'SELECT entryid FROM employees_moz WHERE product = ? AND section_id = ? AND line = ? AND shift = ? AND roleid = ? AND passive_type = ? AND status = ? ORDER BY name ASC';

          db.query(
            queryAbsent,
            [array.product, array.section_id, array.line, array.shift, array.roleid, array.passive_type, 'A'], // Using 'A' to indicate 'absent'
            (errorAbsent, retAbsent) => {
              if (errorAbsent) {
                console.error('Error executing queryAbsent:', errorAbsent);
                res.status(500).json({ error: 'Internal Server Error' });
              } else {
                // Log QueryAbsent results
                console.log('QueryAbsent Results:', retAbsent);

                // Add absent entry IDs to the data object
                data.absentEntryIds = retAbsent.map((entry) => entry.entryid);

                res.json(data);
              }
            }
          );

           //res.json(data);
          });
        } else {
          // No product provided
          console.log('No product provided.');
          res.status(400).json({ error: 'No product provided.' });
        }

        //new added lines 10-07-2023

      } else {
        // No matching rows found
        console.log('No rows found.');
        res.status(404).json({ error: 'No rows found.' });
      }
    }
  });
});



//edit and update braid employeetimesheet
app.post('/updateemployeetimesheetfilterdata', (req, res) => {
  const receivedData = req.body;
  console.log('Received Form Data:', receivedData);

  const formDataToSend = receivedData[0];
  const { zone, machinec, shift, fdate } = formDataToSend;

  /*const date = '21-11-2023';
  const dayy1 = '1700524800';
  const date2 = '11-2023';
  const date3 = '2023-11-21 12:00:00';*/

  const date1 = fdate;
  const fdParts = date1.split('-');
  const fd = `${fdParts[2]}-${fdParts[1]}-${fdParts[0]}`;

  const dateObj = new Date(date1);
  const day = dateObj.getDate().toString().padStart(2, '0');
  const month = (dateObj.getMonth() + 1).toString().padStart(2, '0');
  const year = dateObj.getFullYear();

  const date = `${day}-${month}-${year}`;
  const date2 = `${month}-${year}`;

  const fd2 = Math.floor(new Date(date1).getTime() / 1000);


var dayy1 = fd2;

const originalDate = new Date(fdate);

const year1 = originalDate.getFullYear();
const month1 = String(originalDate.getMonth() + 1).padStart(2, '0');
const day1 = String(originalDate.getDate()).padStart(2, '0');
const hour = '12';
const minute = '00';
const second = '00';

const date3 = `${year1}-${month1}-${day1} ${hour}:${minute}:${second}`;


console.log('Date:', date);
console.log('date2:', date2);
console.log('dayy1:', dayy1);
console.log('date3:', date3);

  const tableRowsData = receivedData.slice(1);

  const machineCondition = `machine LIKE '%${machinec}%'`;
  const whereConditionIndirect = `zone='${zone}'  AND ${machineCondition} AND workertype='INDIRECT' AND status='P'`;
  const whereConditionDirect = `zone='${zone}'  AND ${machineCondition} AND workertype='DIRECT' AND status='P'`;

  const queryIndirect = `SELECT * FROM geopos_employees WHERE ${whereConditionIndirect}`;
  const queryDirect = `SELECT * FROM geopos_employees WHERE ${whereConditionDirect}`;

  db.query(queryIndirect, (err, resultIndirect) => {
    /* if (err) throw err;

    let ire = 0;
    resultIndirect.forEach((ws) => {
      ire += parseInt(ws.emp_count, 10);
    });

    db.query(queryDirect, (err, resultDirect) => {
      if (err) throw err;

      let dre = 0;
      resultDirect.forEach((ws1) => {
        dre += parseInt(ws1.emp_count, 10);
      }); */

      if (err) throw err;

    let ire = 0;
    resultIndirect.forEach((ws) => {
      //ire += parseInt(ws.emp_count, 10);
      ire += parseFloat(ws.emp_count);

    });

    const roundedIre = parseFloat(ire.toFixed(4));
    console.log('roundedIre:', roundedIre); // Log the value of ire here

    db.query(queryDirect, (err, resultDirect) => {
      if (err) throw err;

      let dre = 0;
      resultDirect.forEach((ws1) => {
        //dre += parseInt(ws1.emp_count, 10);
        dre += parseFloat(ws1.emp_count);
      });

      const roundeddre = parseFloat(dre.toFixed(4));
    console.log('roundeddre:', roundeddre); // Log the value of ire here

      const combinedData = {
        dataArray: [
          {
            ...formDataToSend,
            indirectCount: roundedIre,
            directCount: roundeddre,
            date,
            dayy1,
            date2,
            date3,
          },
          ...tableRowsData,
        ],
      };

      // Call the function to perform MySQL operations
      performMySQLOperations1(combinedData, (mysqlErr, mysqlResult) => {
        if (mysqlErr) {
          console.error('MySQL operation failed:', mysqlErr);
      
          res.status(500).json({
            error: 'MySQL operation failed.',
            errorMessage: mysqlErr.message // Include the error message from mysqlErr
          });
        } else {
          res.json({ success: 'MySQL operation successful.', successMessage: mysqlResult });
        }
      });
    });
  });
});

function performMySQLOperations1(combinedData, callback) {
  // Log dataArray to the console
  console.log('Received combinedData:', combinedData);

  const {catid,shift,product_name,color_description,zone,machine,machinec,hr_start,hr_end,fiber,fg_output,waste1,waste2,waste3,waste_weight,date,temp0,temp1,temp2,temp3,temp4,temp5,site,indirectCount,directCount,dayy1,date2,date3} = combinedData.dataArray[0];
  /* console.log('Zone:', zone);
  console.log('Machine:', machine);
  console.log('hr_start:', hr_start);
  console.log('date:', date); */

  const data = {
		color_id: color_description,
    hr_start: hr_start,
    hr_end: hr_end,
    item: product_name,
    fiber: fiber,
    fg_output: fg_output,
    waste1: waste1,
    waste2: waste2,
	  waste3:waste3,
    waste_weight: waste_weight,
    date: date,
    timestamp: dayy1,
    datetime: date3,
    month: date2,
	  iemp_count: indirectCount,
		demp_count: directCount,
		upper: temp0,
	  lower: temp1,
		perheating: temp2,
		machine_speed: temp3,
		tension: temp4,
		spreading: temp5,
  };
 console.log(data);
const cat_id = catid;
console.log(cat_id);
 

  db.query('UPDATE geopos_operator SET ? WHERE id = ?', [data, cat_id], (error, results) => {
    if (error) {
      console.error('Error updating data in MySQL:', error);
      res.status(500).json({ status: 'Error', message: 'Internal server error.' });
      return;
    }
             

      
      const dataArray = combinedData.dataArray;

        for (let i = 1; i < dataArray.length; i++) {
          const { emp_ids, worker_names, section, target, section_id, secid,  completes } = dataArray[i];
          const sec_idArray = secid.split(',').map(id => id.trim());
          
          console.log('Emp IDs:', emp_ids);
          console.log('Worker Names:', worker_names);
          console.log('Section:', section);
          console.log('Target:', target);
          console.log('Section ID:', section_id);
          console.log('Completes:', completes);
          console.log('Secid:', secid);
        

          
      
        if (section_id) {
          

          sec_idArray.forEach((secid, index) => {
              
              console.log(`Before data1 construction (Index ${index}):`, secid);

              const selectOperatorSectionQuery = 'SELECT * FROM operator_section WHERE id = ? ';
              const selectOperatorSectionValues = [secid];

              db.query(
                selectOperatorSectionQuery,
                selectOperatorSectionValues,
                (selectOSQueryError, selectOSQueryResults) => {
                  const numOSRows = selectOSQueryResults.length;
                  console.log('numOSRows:', numOSRows);
                  if (numOSRows > 0) {
                    
                    const op = `${selectOSQueryResults[0].opmanual_id}`;
                    const cm = `${selectOSQueryResults[0].complete}`.trim();
                    const opi = op.split(',').map(Number);
                    console.log('op ID:', op);
                    console.log('cm:', cm);
                    console.log('opi:', opi);

                     

                    if (opi.includes(+cat_id)) {
                      /* const ky = opi.indexOf(+cat_id);
                      const com = cm.split(',').map(item => item.trim()).filter(Boolean);

                      com[ky] = cm[index];
                      const cmn = com.join(','); */

                      const ky = opi.indexOf(+cat_id);
                      const com = cm.split(',').map(item => item.trim());
                  

                      // Replace the value at ky with the new value (completes)
                      if (ky >= 0 && ky < com.length) {
                        com[ky] = String(completes); // Convert to string before replacing
                      }
                  
                      const cmn = com.join(',');
                  
                      console.log('ky:', ky);
                      console.log('com:', com);
                      console.log('newcom:', cmn); // Log the joined array with commas
                      console.log('cmn:', cmn);
                    
                      const updateOperatorSectionQuery = 'UPDATE operator_section SET complete = ? WHERE id = ?';
                      const updateOperatorSectionValues = [cmn, secid];
                    
                      db.query(updateOperatorSectionQuery, updateOperatorSectionValues, (updateOSError) => {
                        if (updateOSError) {
                          console.error(updateOSError);
                        }
                      });
                    }

                   /*  const updateOperatorSectionQuery =
                      'UPDATE operator_section SET complete = ? WHERE id = ?';
                    const updateOperatorSectionValues = [ cm, secid];

                    db.query(
                      updateOperatorSectionQuery,
                      updateOperatorSectionValues,
                      (updateOSError) => {
                        if (updateOSError) {
                          console.error(updateOSError);
                        }
                      }
                    ); */
                  } 

                 
                  
                }
              );
            });
        
        }
      } 
     // Send success message to the client
     const successMessage = 'Details added successfully!';
     return callback(null, successMessage);
  });
} 




// Function to delete operator section data
function deleteOperatorSectionData1(deletedManualId, callback) {
  console.log(`Deleting operator section data for manual ID: ${deletedManualId}`);
  
  const query = `SELECT * FROM operator_section WHERE opmanual_id LIKE '%${deletedManualId}%'`;

  db.query(query, (error, result) => {
    if (error) {
      console.error('Error executing MySQL query:', error);
      callback(error, null);
      return;
    }

    result.forEach(value => {
      const opSecId = value.id;
      const opmanualIds = value.opmanual_id;

      // Log the values
      console.log(`opSecId: ${opSecId}`);
      console.log(`opmanualIds: ${opmanualIds}`);

      const opidArray = opmanualIds.split(',');

      // Check if the array contains only one element and it matches the deletedManualId
      if (opidArray.length === 1 && opidArray[0] === deletedManualId) {
        // If it matches, delete the entire row
        const deleteQuery = `DELETE FROM operator_section WHERE id = ${opSecId}`;
        db.query(deleteQuery, (deleteError) => {
          if (deleteError) {
            console.error('Error deleting MySQL row:', deleteError);
            callback(deleteError, null);
            return;
          }
          console.log(`Deleted operator section data with ID ${opSecId}`);
          console.log('Operator section data deletion process completed');
          callback(null, 'Operator section data deleted successfully');
        });
      } else if (opidArray.includes(deletedManualId)) {
        // If the array has multiple elements, remove the deletedManualId and update the row
        const index = opidArray.indexOf(deletedManualId);
        opidArray.splice(index, 1);

        const newOpidStr = opidArray.join(',');

        // Update opmanual_id in the MySQL database
        const updateQuery = `UPDATE operator_section SET opmanual_id = '${newOpidStr}' WHERE id = ${opSecId}`;
        db.query(updateQuery, (updateError) => {
          if (updateError) {
            console.error('Error updating MySQL row:', updateError);
            callback(updateError, null);
            return;
          }
          console.log(`Updated operator section data with ID ${opSecId}`);
          
          // Check if the updated opmanualIds still include the deletedManualId
          if (newOpidStr.includes(deletedManualId)) {
            console.log('Operator section data deletion process completed');
            callback(null, 'Operator section data not found for deletion');
          } else {
            console.log('Operator section data deletion process completed');
            callback(null, 'Operator section data deleted successfully');
          }
        });
      }
    });
  });
}

// Function to delete operator section data
function deleteOperatorSectionData(deletedManualId, callback) {
  console.log(`Deleting operator section data for manual ID: ${deletedManualId}`);
  
  // Delete directly from the operator_section table based on the opmanual_id condition
  const deleteQuery = `DELETE FROM operator_section WHERE opmanual_id LIKE '%${deletedManualId}%'`;

  db.query(deleteQuery, (deleteError, deleteResults) => {
    if (deleteError) {
      console.error('Error deleting MySQL rows:', deleteError);
      callback(deleteError, null);
      return;
    }

    // Log the deleted rows
    console.log(`Deleted operator section data for manual ID ${deletedManualId}: ${JSON.stringify(deleteResults)}`);

    console.log('Operator section data deletion process completed');
    callback(null, 'Operator section data deleted successfully');
  });
}

// API endpoint for deleting employee timesheet data
app.post('/emptimesheet_delete', (req, res) => {
  const id = req.body.deleteid;
  console.log('Received id:', id); // Log the value of id

  if (!id) {
    console.error('Invalid request: Missing deleteid parameter');
    return res.status(400).json({ status: 'Error', message: 'Invalid request' });
  }

  // Delete data from the operator_section table
  deleteOperatorSectionData(id, (deleteError, deleteResult) => {
    if (deleteError) {
      console.error('Error deleting operator section data:', deleteError);
      return res.status(500).json({ status: 'Error', message: 'Internal server error' });
    }

    console.log(deleteResult);

    // Delete data from the geopos_operator table
    const deleteOperatorQuery = `DELETE FROM geopos_operator WHERE id = ${id}`;
    db.query(deleteOperatorQuery, (error, results) => {
      if (error) {
        console.error('Error deleting geopos_operator data:', error);
        return res.status(500).json({ status: 'Error', message: 'Internal server error' });
      }

      // Check if any rows were affected (successful delete)
      if (results.affectedRows > 0) {
        console.log(`Successfully deleted geopos_operator data with ID ${id}`);
        return res.json({ status: 'Success', message: 'Successfully Deleted' });
      } else {
        console.warn(`Record not found for ID ${id}`);
        return res.status(404).json({ status: 'Error', message: 'Record not found' });
      }
    });
  });
});

// delete worker from workertimesheet by ID
app.delete("/workerdelete/:id", (req, res) => {
  const id = req.params.id;
  console.log('id:',id);
  db.query("DELETE FROM worker_timesheet WHERE id = ?", [id], (err, result) => {
    if (err) {
      console.log(err);
      res.status(500).json({ error: 'An error occurred while deleting the item.' });
    } else {
      console.log(result);
      res.json({ message: 'Employee deleted successfully.' });
    }
  });
});




// API Endpoint to handle edit requests
app.post('/updateHourValue', (req, res) => {
  const { id, field, value } = req.body;
  const data = { [field]: value };

  const updateQuery = 'UPDATE worker_timesheet SET ? WHERE id = ?';
  db.query(updateQuery, [data, id], (error, results) => {
    if (error) {
      console.error('Error executing query:', error);
      return res.status(500).json({ status: 'Error', message: 'Database error' });
    }

    if (results.affectedRows > 0) {
      return res.json({ status: 'Success', message: 'UPDATED' });
    } else {
      return res.json({ status: 'Error', message: 'ERROR' });
    }
  });
});




//--------------------------Employee Timesheet ---------------------------//




//--------------------------Fg Output--------------------------------------//

//search data fetch
app.post('/fg_output', (req, res) => {
  const date = req.body.date;
  console.log(date);
  if (!date) {
    return res.status(400).json({ error: 'Date value is missing' });
  }

  const formattedDate = date.split('-').reverse().join('-');
  console.log(formattedDate);
  // Execute the MySQL query to fetch fg_details
  db.query(
    'SELECT fg_details.*, item_masterr.item_description, item_code.product_code, color_master.color_name, geopos_users.name AS user_name ' +
      'FROM fg_details ' +
      'LEFT JOIN item_masterr ON fg_details.product_name = item_masterr.id ' +
      'LEFT JOIN item_code ON fg_details.product_code = item_code.id ' +
      'LEFT JOIN color_master ON item_code.color_id = color_master.id ' +
      'LEFT JOIN geopos_users ON fg_details.user = geopos_users.id ' +
      'WHERE fg_details.date_time = ?',
    [formattedDate],
    (error, results) => {
      if (error) {
        console.error('Error executing MySQL query:', error);
        return res.status(500).json({ error: 'An error occurred' });
      }

      // Process the query results
      const fgDetails = results.map((row) => ({
        id: row.id,
        product_name: row.item_description,
        product_code: row.product_code,
        line: row.line,
        hour: row.hour,
        shift: row.shift,
        fg_output: row.fg_output,
        user: row.user_name,
        date_time: row.date_time,
        color_name: row.color_name, // Include color_name in the response
      }));

      //console.log(fgDetails);

      // Return the response
      res.json(fgDetails);
    }
  );
});


//FgOutput Ikeja Braid

// default data fetch for ikeja braid fgoutput
app.get('/get_fg_output_default_ikeja', (req, res) => {
  const date = new Date().toLocaleDateString('en-GB', { timeZone: 'Africa/Lagos' });
  const parts = date.split('/');
  const day = parts[0].padStart(2, '0');
  const month = parts[1].padStart(2, '0');
  const year = parts[2];
  const newcurrentDate1 = `${day}-${month}-${year}`;

  const query = `
  SELECT geopos_operator.*, color_master.color_name, item_masterr.item_description, geopos_employees.name,
         SUM(fg_output) AS tar
  FROM geopos_operator
  LEFT JOIN geopos_employees ON geopos_operator.emp_id = geopos_employees.id
  LEFT JOIN item_masterr ON geopos_operator.item = item_masterr.id
  LEFT JOIN color_master ON geopos_operator.color_id = color_master.id
  WHERE geopos_operator.date = '${newcurrentDate1}' AND geopos_operator.site = 'ikeja'
  GROUP BY geopos_operator.item, geopos_operator.color_id`;

  db.query(query, (err, results) => {
    if (err) {
      console.error('Error querying database:', err);
      res.status(500).json({ error: 'Internal Server Error' });
    } else {
      res.json(results);
    }
  });
});

// date wise data fetch for ikeja braid fgoutput
app.post('/get_fg_output_search_ikeja', (req, res) => {

  const date = req.body.date;
  console.log(date);
  if (!date) {
    return res.status(400).json({ error: 'Date value is missing' });
  }

  const formattedDate = date.split('-').reverse().join('-');
  console.log('formattedDate', formattedDate);
  

  const query = `
      SELECT
        geopos_operator.*,
        color_master.color_name,
        item_masterr.item_description,
        geopos_employees.name,
        SUM(fg_output) as tar
      FROM
        geopos_operator
      LEFT JOIN
        geopos_employees ON geopos_operator.emp_id = geopos_employees.id
      LEFT JOIN
        item_masterr ON geopos_operator.item = item_masterr.id
      LEFT JOIN
        color_master ON geopos_operator.color_id = color_master.id
      WHERE
        geopos_operator.date = '${formattedDate}' AND
        geopos_operator.site = 'ikeja'
      GROUP BY
        geopos_operator.item, geopos_operator.color_id`;

  db.query(query, (err, results) => {
    if (err) {
      console.error('Error querying database:', err);
      res.status(500).json({ error: 'Internal Server Error' });
    } else {
      res.json(results);
    }
  });
});



//FgOutput Ikeja Non Braid

// default data fetch for ikeja nbraid fgoutput
app.get('/get_fg_output_default_ikeja_nbraid', (req, res) => {
  const date = new Date().toLocaleDateString('en-GB', { timeZone: 'Africa/Lagos' });
  const parts = date.split('/');
  const day = parts[0].padStart(2, '0');
  const month = parts[1].padStart(2, '0');
  const year = parts[2];
  const newcurrentDate1 = `${day}-${month}-${year}`;

  const query = `
      SELECT
        fg_details.*,
        geopos_users.name,
        item_masterr.item_description,
        color_master.color_name,
        item_code.product_code,
        item_code.product_des
      FROM
        fg_details
      LEFT JOIN
        geopos_users ON fg_details.user = geopos_users.id
      LEFT JOIN
        item_masterr ON fg_details.product_name = item_masterr.id
      LEFT JOIN
        item_code ON fg_details.product_code = item_code.id
      LEFT JOIN
        color_master ON item_code.color_id = color_master.id
      WHERE
        fg_details.date_time = '${newcurrentDate1}' AND
        fg_details.site = 'ikeja' AND
        fg_details.category_type = 'NBRAID'`;

  db.query(query, (err, results) => {
    if (err) {
      console.error('Error querying database:', err);
      res.status(500).json({ error: 'Internal Server Error' });
    } else {
      res.json(results);
    }
  });
});

//date wise search data fetch for ikeja nbraid fgoutput
app.post('/get_fg_output_search_ikeja_nbraid', (req, res) => {
  const date = req.body.date;
  console.log(date);
  if (!date) {
    return res.status(400).json({ error: 'Date value is missing' });
  }

  const formattedDate = date.split('-').reverse().join('-');
  console.log('formattedDate', formattedDate);

  const query = `
      SELECT
        fg_details.*,
        geopos_users.name,
        item_masterr.item_description,
        color_master.color_name,
        item_code.product_code,
        item_code.product_des
      FROM
        fg_details
      LEFT JOIN
        geopos_users ON fg_details.user = geopos_users.id
      LEFT JOIN
        item_masterr ON fg_details.product_name = item_masterr.id
      LEFT JOIN
        item_code ON fg_details.product_code = item_code.id
      LEFT JOIN
        color_master ON item_code.color_id = color_master.id
      WHERE
        fg_details.date_time = '${formattedDate}' AND
        fg_details.site = 'ikeja' AND
        fg_details.category_type = 'NBRAID'`;

  db.query(query, (err, results) => {
    if (err) {
      console.error('Error querying database:', err);
      res.status(500).json({ error: 'Internal Server Error' });
    } else {
      res.json(results);
    }
  });
}); 


// delete fg output
app.delete("/fgoutputdelete/:id", (req, res) => {
  const id = req.params.id;
 // console.log(id);
  db.query("DELETE FROM fg_details WHERE id = ?", [id], (err, result) => {
    if (err) {
      console.log(err);
      res.status(500).json({ error: 'An error occurred while deleting the item.' });
    } else {
      console.log(result);
      res.json({ message: 'FG Details deleted successfully.' });
    }
  });
});


// Define a route for fetching color options
app.get('/getcolordescription/:selectedProduct', (req, res) => {
  const { selectedProduct } = req.params;

  const query = `SELECT id, product_des, color_id FROM item_code WHERE product_id = ?`;

  db.query(query, [selectedProduct], (error, results) => {
    if (error) {
      console.error('Error fetching color descriptions:', error);
      res.status(500).json({ error: 'An error occurred' });
    } else {
      const colorDescriptions = results.map((row) => ({
        id: row.id,
        product_des: row.product_des,
        color_id: row.color_id,
      }));

      res.json(colorDescriptions);
    }
  });
});

// Define a route for fetching color options
app.get('/getcolordescriptionss/:item', (req, res) => {
  const { item } = req.params;

  // Perform a database query to fetch the line options for the specified product
  // Replace 'your_db_connection' with your actual database connection object

  // Example using MySQL as the database
  const query = `SELECT id, product_des FROM item_code WHERE product_id = ?`;

  db.query(query, [item], (error, results) => {
    if (error) {
      console.error('Error fetching color descriptions:', error);
      res.status(500).json({ error: 'An error occurred' });
    } else {
      const colorDescriptions = results.map((row) => ({
        id: row.id,
        product_des: row.product_des,
      }));

      res.json(colorDescriptions);
    }
  });
});

// Define a route for fetching product_code options
app.get('/getproductcode/:selectedColor', (req, res) => {
  const { selectedColor } = req.params;
  console.log(selectedColor);

  // Perform a database query to fetch the product_code options for the specified product
  // Replace 'your_db_connection' with your actual database connection object

  // Example using MySQL as the database
  const query = `SELECT product_code FROM item_code WHERE id = ?`;

  db.query(query, [selectedColor], (error, results) => {
    if (error) {
      console.error('Error fetching color code:', error);
      res.status(500).json({ error: 'An error occurred' });
    } else {
      const colorCodes = results.map((row) => ({
       
        product_code: row.product_code,
      }));

      res.json(colorCodes);
      console.log(colorCodes);
    }
  });
});

// add fgoutput ikeja nbraid
app.post('/addfgoutput', (req, res) => {
  const product = req.body.product_name;
  const code = req.body.color_description;
  const line = req.body.line_no;
  const fg_output = req.body.fgoutput;
  const hour = req.body.hour;
  const shift = req.body.shift;
  const date = new Date(req.body.fromdate);
/* const day = String(date.getDate()).padStart(2, '0');
const month = String(date.getMonth() + 1).padStart(2, '0');
const year = date.getFullYear();
const formattedDate = `${day}-${month}-${year}`; */

//const formattedDate = `${date.getDate()}-${date.getMonth() + 1}-${date.getFullYear()}`;
const formattedDate = `${date.getDate().toString().padStart(2, '0')}-${(date.getMonth() + 1).toString().padStart(2, '0')}-${date.getFullYear()}`;
//const timestamp = new Date(date).getTime();
const timestampInSeconds = Math.floor(new Date(date).getTime() / 1000);

  /* console.log(product);
  console.log(code);
  console.log(line);
  console.log(fg_output);
  console.log(hour);
  console.log(shift);
  console.log(formattedDate);
  console.log(timestampInSeconds); */

   const userid = 9; // Replace with the actual way to get the user ID
   const site = 'ikeja';
   const cat = 'NBRAID';

  const array = {
    product_name: product,
    product_code: code,
    line: line,
    hour: hour,
    shift: shift,
    date_time: formattedDate,
    site: site,
  };

  const selectQuery = `SELECT * FROM fg_details WHERE product_name = ? AND product_code = ? AND line = ? AND shift = ? AND hour = ? AND date_time = ? AND site = ?`;
const values = [product, code, line, shift, hour, formattedDate, site];


db.query(selectQuery, values, (selectError, selectResult) => {
  if (selectError) {
    console.error('Database error:', selectError);
    return res.status(500).json({ status: 'Error', message: 'Database error' });
  }

  if (selectResult.length > 0) {
    return res.status(400).json({
      status: 'Error',
      message: 'Sorry, for today you have already added the FG OUTPUT for this Product Name and Line!!!',
    });
  }

  const insertData = {
    product_name: product,
    line: line,
    product_code: code,
    hour: hour,
    shift: shift,
    fg_output: fg_output,
    user: userid,
    date_time: formattedDate,
    time_stamp: timestampInSeconds,
    site: site,
    category_type: cat,
  };

  const insertQuery = 'INSERT INTO fg_details SET ?';
  db.query(insertQuery, insertData, (insertError, insertResult) => {
    if (insertError) {
      console.error('Database error:', insertError);
      return res.status(500).json({ status: 'Error', message: 'Database error' });
    }

    // Check if any rows were affected by the insert operation
    if (insertResult.affectedRows > 0) {
      // Insert operation successful
      const successResponse = { status: 'Success', message: 'FG Details added successfully' };
      return res.status(200).json(successResponse);
    } else {
      // No rows were affected (record already exists)
      const failureResponse = { status: 'Error', message: 'Record already exists' };
      return res.status(400).json(failureResponse);
    }
  });
});
});

// API endpoint to fetch data from fg_details table
app.get('/getfgoutputData/:id', (req, res) => {
  const id = req.params.id;
  console.log(id);

  // Query the fg_details table with the provided ID
 //const query = `SELECT * FROM fg_details WHERE id = ${id}`;
  // Query the fg_details table with the provided ID and join with the item_code table
  /* const query = `
    SELECT fg_details.*, item_code.product_code, item_code.product_des
    FROM fg_details
    JOIN item_code ON fg_details.product_code = item_code.id
    WHERE fg_details.id = ${id}
  `; */

   const query = `
  SELECT fg_details.*, item_code.product_code as pcode
  FROM fg_details
  JOIN item_code ON fg_details.product_code = item_code.id
  WHERE fg_details.id = ${id}
`; 

  // Execute the query
  db.query(query, (err, rows) => {
    if (err) {
      console.error('Error fetching FG data:', err);
      res.status(500).json({ error: 'Internal server error' });
    } else if (rows.length === 0) {
      res.status(404).json({ error: 'FG data not found' });
    } else {
      // Send the retrieved data as the response
      res.json(rows[0]);
    }
  });
});



// PUT endpoint to edit FG output
app.post('/fg_output_update/', (req, res) => {
 // const cid = req.params.id;
  const {
    id,
    product_name,
    color_description,
    line_no,
    code,
    hour,
    shift,
    fgoutput,
  } = req.body;


  

  const product_code = color_description;

  console.log('Received Request Body:', req.body);
  console.log('Extracted Values:');
  console.log('id:', id);
  console.log('product_name:', product_name);
  console.log('line_no:', line_no);
  console.log('code:', code);
  console.log('hour:', hour);
  console.log('shift:', shift);
  console.log('fgoutput:', fgoutput);
  console.log('product_code:', product_code);

  // Check if FG output already exists for the given parameters
  const query = `
    SELECT * 
    FROM fg_details 
    WHERE product_name = ? 
      AND product_code = ? 
      AND line = ? 
      AND hour = ? 
      AND shift = ? 
      AND date_time = CURDATE()
  `;
  const values = [product_name, product_code, line_no, hour, shift];

   db.query(query, values, (err, rows) => {
    if (err) {
      console.error('Error fetching FG data:', err);
      res.status(500).json({ error: 'Internal server error' });
    } else if (rows.length > 0) {
      res.status(400).json({ error: 'FG data already exists for this hour' });
    } else {
      // Update FG output
      const updateQuery = `
        UPDATE fg_details 
        SET product_name = ?, line = ?, product_code = ?, hour = ?, shift = ?, fg_output = ? 
        WHERE id = ?
      `;
      const updateValues = [product_name, line_no, product_code, hour, shift, fgoutput, id];

      db.query(updateQuery, updateValues, (err, result) => {
        if (err) {
          console.error('Error updating FG data:', err);
          res.status(500).json({ error: 'Internal server error' });
        } else {
          // Handle success response
          res.json({ status: 'Success', message: 'FG output updated successfully' });
        }
      });
    }
  }); 
});

//get product name 
app.get('/getColorOptions', (req, res) => {
  const itemId = req.params.itemId;

  // Assuming you have a database connection and a table named 'item_code'
  // Perform a database query to fetch the data based on the itemId
  // Example query using MySQL:
  const query = `SELECT * FROM item_code`;

  // Execute the query and handle the result
  db.query(query, (error, results) => {
    if (error) {
      console.error('Error fetching shift data:', error);
      res.status(500).json({ error: 'Failed to fetch item data' });
    } else {
      res.json(results);
    }
  });
});

//get product name 
app.get('/getColorOptionsedit/:product_code', (req, res) => {
  const itemId = req.params.product_code;
  console.log('Recieved ID:', itemId);

  // Assuming you have a database connection and a table named 'item_code'
  // Perform a database query to fetch the data based on the itemId
  // Example query using MySQL:
  const query = `SELECT * FROM item_code WHERE id = ?`;

  // Execute the query and handle the result
  db.query(query, [itemId], (error, results) => {
    if (error) {
      console.error('Error fetching shift data:', error);
      res.status(500).json({ error: 'Failed to fetch item data' });
    } else {
      res.json(results);
    }
  });
});


//Fg Output Ota Braid

// default data fetch for ota braid fgoutput
app.get('/get_fg_output_default_ota', (req, res) => {
  const date = new Date().toLocaleDateString('en-GB', { timeZone: 'Africa/Lagos' });
  const parts = date.split('/');
  const day = parts[0].padStart(2, '0');
  const month = parts[1].padStart(2, '0');
  const year = parts[2];
  const newcurrentDate1 = `${day}-${month}-${year}`;

  const query = `
  SELECT geopos_operator.*, color_master.color_name, item_masterr.item_description, employees_ota.name,
         SUM(fg_output) AS tar
  FROM geopos_operator
  LEFT JOIN employees_ota ON geopos_operator.emp_id = employees_ota.id
  LEFT JOIN item_masterr ON geopos_operator.item = item_masterr.id
  LEFT JOIN color_master ON geopos_operator.color_id = color_master.id
  WHERE geopos_operator.date = '${newcurrentDate1}' AND geopos_operator.site = 'ota'
  GROUP BY geopos_operator.item, geopos_operator.color_id`;

  db.query(query, (err, results) => {
    if (err) {
      console.error('Error querying database:', err);
      res.status(500).json({ error: 'Internal Server Error' });
    } else {
      res.json(results);
    }
  });
});

// date wise data fetch for ota braid fgoutput
app.post('/get_fg_output_search_ota', (req, res) => {

  const date = req.body.date;
  console.log(date);
  if (!date) {
    return res.status(400).json({ error: 'Date value is missing' });
  }

  const formattedDate = date.split('-').reverse().join('-');
  console.log('formattedDate', formattedDate);
  

  const query = `
      SELECT
        geopos_operator.*,
        color_master.color_name,
        item_masterr.item_description,
        employees_ota.name,
        SUM(fg_output) as tar
      FROM
        geopos_operator
      LEFT JOIN
      employees_ota ON geopos_operator.emp_id = employees_ota.id
      LEFT JOIN
        item_masterr ON geopos_operator.item = item_masterr.id
      LEFT JOIN
        color_master ON geopos_operator.color_id = color_master.id
      WHERE
        geopos_operator.date = '${formattedDate}' AND
        geopos_operator.site = 'ota'
      GROUP BY
        geopos_operator.item, geopos_operator.color_id`;

  db.query(query, (err, results) => {
    if (err) {
      console.error('Error querying database:', err);
      res.status(500).json({ error: 'Internal Server Error' });
    } else {
      res.json(results);
    }
  });
});

// default data fetch for ota nbraid fgoutput
app.get('/get_fg_output_default_ota_nbraid', (req, res) => {
  const date = new Date().toLocaleDateString('en-GB', { timeZone: 'Africa/Lagos' });
  const parts = date.split('/');
  const day = parts[0].padStart(2, '0');
  const month = parts[1].padStart(2, '0');
  const year = parts[2];
  const newcurrentDate1 = `${day}-${month}-${year}`;

  const query = `
  SELECT fg_details.*, geopos_users.name AS user_name, item_masterr.item_description,
         color_master.color_name, item_code.product_code, item_code.product_des
  FROM fg_details
  LEFT JOIN geopos_users ON fg_details.user = geopos_users.id
  LEFT JOIN item_masterr ON fg_details.product_name = item_masterr.id
  LEFT JOIN item_code ON fg_details.product_code = item_code.id
  LEFT JOIN color_master ON item_code.color_id = color_master.id
  WHERE fg_details.date_time = '${newcurrentDate1}' AND fg_details.site = 'ota'
        AND fg_details.category_type = 'NBRAID';
`;

  db.query(query, (err, results) => {
    if (err) {
      console.error('Error querying database:', err);
      res.status(500).json({ error: 'Internal Server Error' });
    } else {
      res.json(results);
    }
  });
}); 

//date wise search data fetch for ota nbraid fgoutput
app.post('/get_fg_output_search_ota_nbraid', (req, res) => {
 

  const fromdate = req.body.fromdate;
  const fdParts = fromdate.split('-');
  const fd = `${fdParts[2]}-${fdParts[1]}-${fdParts[0]}`;

  const todate = req.body.todate;
  const tdParts = todate.split('-');
  const td = `${tdParts[2]}-${tdParts[1]}-${tdParts[0]}`;


  const dateObj = new Date(fromdate);
  const day = dateObj.getDate().toString().padStart(2, '0');
  const month = (dateObj.getMonth() + 1).toString().padStart(2, '0');
  const year = dateObj.getFullYear();

  const convertedDate = `${day}-${month}-${year}`;

  const dateObj1 = new Date(todate);
  const day1 = dateObj1.getDate().toString().padStart(2, '0');
  const month1 = (dateObj1.getMonth() + 1).toString().padStart(2, '0');
  const year1 = dateObj1.getFullYear();

  const convertedDate1 = `${day1}-${month1}-${year1}`;
  console.log('Converted:', convertedDate);
  console.log('Converted2:', convertedDate1);


  // Calculate fd2 by getting the timestamp in seconds and subtracting one day's worth of seconds
  const fd2 = Math.floor(new Date(fromdate).getTime() / 1000) - (2 * 24 * 60 * 60);

  const td1 = Math.floor(new Date(todate).getTime() / 1000);
  const fd1 = Math.floor(new Date(fd2 * 1000).setDate(new Date(fd2 * 1000).getDate() - 1) / 1000);

  var timestampFDate = fd2;
  var timestampTDate = td1;

 

  const query = `
  SELECT fg_details.*, geopos_users.name AS user_name, item_masterr.item_description,
         color_master.color_name, item_code.product_code, item_code.product_des
  FROM fg_details
  LEFT JOIN geopos_users ON fg_details.user = geopos_users.id
  LEFT JOIN item_masterr ON fg_details.product_name = item_masterr.id
  LEFT JOIN item_code ON fg_details.product_code = item_code.id
  LEFT JOIN color_master ON item_code.color_id = color_master.id
  WHERE fg_details.time_stamp BETWEEN ? AND ? 
  AND fg_details.site = 'ota'
        AND fg_details.category_type = 'NBRAID';
`;

  db.query(query, [timestampFDate, timestampTDate], (err, results) => {
    if (err) {
      console.error('Error querying database:', err);
      res.status(500).json({ error: 'Internal Server Error' });
    } else {
      res.json(results);
    }
  });
}); 


// add fgoutput ota nonbraid
app.post('/addfgoutputotanbraid', (req, res) => {
  if (req.body) {
    const product = req.body.product_name;
    const line = req.body.line_no;
    const code = req.body.color_description;
    const shifts = req.body.shift;
    const fg_output = req.body.fgoutput;
    const hour = req.body.hour;
    const date = new Date(req.body.fromdate);
    const formattedDate = `${date.getDate().toString().padStart(2, '0')}-${(date.getMonth() + 1).toString().padStart(2, '0')}-${date.getFullYear()}`;
    const timestampInSeconds = Math.floor(new Date(date).getTime() / 1000);

    console.log('Product:', product);
    console.log('Line:', line);
    console.log('Code:', code);
    console.log('Shifts:', shifts);
    console.log('FG Output:', fg_output);
    console.log('Hour:', hour);
    console.log('Date:', date);
    console.log('formattedDate:', formattedDate);
    console.log('timestampInSeconds:', timestampInSeconds);

    //const userid = req.user.id; 
    //const userid = 9; 
    const userid = req.query.userid;
    console.log('userid:', userid);
    const site = 'ota';
    const cat = 'NBRAID';

    const ppQuery = `SELECT item_description FROM item_masterr WHERE id = ${product}`;
    db.query(ppQuery, (ppErr, ppResult) => {
      if (ppErr) {
        console.error('Error fetching product description: ', ppErr);
        return res.json({ status: 'Error', message: 'Internal Server Error' });
      }

      const pp = ppResult[0].item_description;

      const workerTimesheetQuery = 'SELECT * FROM worker_timesheet WHERE product_name = ? AND line = ? AND shift = ? AND date_time = ? AND site = ?';
      const workerTimesheetValues = [product, line, shifts, formattedDate, site];

      db.query(workerTimesheetQuery, workerTimesheetValues, (wtErr, wtResult) => {
        if (wtErr) {
          console.error('Error checking worker timesheet: ', wtErr);
          return res.json({ status: 'Error', message: 'Internal Server Error' });
        }

        const num1 = wtResult.length;

        if (num1 > 0) {
          const data = {
            product_name: product,
            product_code: code,
            line,
            hour,
            shift: shifts,
            fg_output,
            user: userid,
            date_time: formattedDate,
            time_stamp: timestampInSeconds,
            site,
            category_type: cat,
          };

          

          console.log('data:', data);
          

          const isDuplicateQuery = 'SELECT * FROM fg_details WHERE product_name = ? AND line = ? AND shift = ? AND date_time = ? AND hour = ?';
          const isDuplicateValues = [product, line, shifts, formattedDate, hour];

          db.query(isDuplicateQuery, isDuplicateValues, (duErr, duResult) => {
            if (duErr) {
              console.error('Error checking duplicate: ', duErr);
              return res.json({ status: 'Error', message: 'Internal Server Error' });
            }

            const isDuplicate = duResult.length > 0;

            if (isDuplicate) {
              return res.json({
                status: 'Error',
                message: `Sorry, for today or the selected date, you have already added the FG OUTPUT for ${pp} - Line: ${line} - Shift: ${shifts} - Site: ${site}`,
              });
            } else {
              const insertFgOutputQuery = 'INSERT INTO fg_details SET ?';
              db.query(insertFgOutputQuery, data, (insertErr, insertResult) => {
                if (insertErr) {
                  console.error('Error inserting FG output: ', insertErr);
                  return res.json({ status: 'Error', message: 'Internal Server Error' });
                }

                const fgoutput_id = insertResult.insertId;

                // Return success response or other actions
                return res.json({ status: 'Success', message: 'FG OUTPUT added successfully!' });
              });
            }
          });
        } else {
          return res.json({
            status: 'Error',
            message: `Sorry, for today or the selected date production of ${pp} - Line: ${line} - Shift: ${shifts} - Site: ${site} has not started yet!`,
          });
        }
      });
    });
  } else {
    res.json({ status: 'Error', message: 'Invalid request' });
  }
});




// API endpoint to fetch data from fg_details table
app.get('/getfgoutputDataOtanbraid/:id', (req, res) => {
  const id = req.params.id;
  console.log(id);

  // Query the fg_details table with the provided ID
 //const query = `SELECT * FROM fg_details WHERE id = ${id}`;
  // Query the fg_details table with the provided ID and join with the item_code table
  /* const query = `
    SELECT fg_details.*, item_code.product_code, item_code.product_des
    FROM fg_details
    JOIN item_code ON fg_details.product_code = item_code.id
    WHERE fg_details.id = ${id}
  `; */

   const query = `
  SELECT fg_details.*, item_code.product_code as pcode
  FROM fg_details
  JOIN item_code ON fg_details.product_code = item_code.id
  WHERE fg_details.id = ${id}
`; 

  // Execute the query
  db.query(query, (err, rows) => {
    if (err) {
      console.error('Error fetching FG data:', err);
      res.status(500).json({ error: 'Internal server error' });
    } else if (rows.length === 0) {
      res.status(404).json({ error: 'FG data not found' });
    } else {
      // Send the retrieved data as the response
      console.log('rows:',rows);
      res.json(rows[0]);
    }
  });
});



// PUT endpoint to edit FG output
app.post('/fg_output_update_ota_nbraid/', (req, res) => {
 // const cid = req.params.id;
  const {
    id,
    product_name,
    color_description,
    line_no,
    code,
    hour,
    shift,
    fgoutput
  } = req.body;

  const product_code = color_description;

console.log('Received Request Body:', req.body);
console.log('Extracted Values:');
console.log('id:', id);
console.log('product_name:', product_name);
console.log('line_no:', line_no);
console.log('code:', code);
console.log('hour:', hour);
console.log('shift:', shift);
console.log('fgoutput:', fgoutput);
console.log('product_code:', product_code);



  // Check if FG output already exists for the given parameters
  const query = `
    SELECT * 
    FROM fg_details 
    WHERE product_name = ? 
      AND product_code = ? 
      AND line = ? 
      AND hour = ? 
      AND shift = ? 
      AND date_time = CURDATE()
  `;
  const values = [product_name, product_code, line_no, hour, shift];

   db.query(query, values, (err, rows) => {
    if (err) {
      console.error('Error fetching FG data:', err);
      res.status(500).json({ error: 'Internal server error' });
    } else if (rows.length > 0) {
      res.status(400).json({ error: 'FG data already exists for this hour' });
    } else {
      // Update FG output
      const updateQuery = `
        UPDATE fg_details 
        SET product_name = ?, line = ?, product_code = ?, hour = ?, shift = ?, fg_output = ? 
        WHERE id = ?
      `;
      const updateValues = [product_name, line_no, product_code, hour, shift, fgoutput, id];

      db.query(updateQuery, updateValues, (err, result) => {
        if (err) {
          console.error('Error updating FG data:', err);
          res.status(500).json({ error: 'Internal server error' });
        } else {
          // Handle success response
          res.json({ status: 'Success', message: 'FG output updated successfully' });
        }
      });
    }
  }); 
});

//--------------------------Fg Output--------------------------------------//

//-------------------------Import Module-----------------------------------//

//Import Color
app.post('/uploadcolor', upload.single('userfile'), (req, res) => {
  try {
    if (!req.file) {
      return res.status(400).json({ message: 'No file uploaded' });
    }

    const file = req.file;

    const filePath = file.path;
    const parser = csv({ delimiter: ',' });

    const colorEntries = [];

    parser.on('readable', () => {
      let record;
      while ((record = parser.read())) {
        console.log('Records:', record); // Log the record to the console

        const colorEntry = {
          name: record.colorname
        };
        console.log('Color Entry:', colorEntry);
    
        if (record) {
          colorEntries.push(colorEntry);
        } else {
          console.log('Skipping invalid record:', record);
        }
      }
    });

    parser.on('end', () => {
      fs.unlinkSync(filePath); // Delete the uploaded file

      const colorNames = colorEntries.map(entry => entry.name);

      const selectQuery = `SELECT color_name FROM color_master WHERE color_name IN (?)`;

      db.query(selectQuery, [colorNames], (selectError, selectResults) => {
        if (selectError) {
          console.error(selectError);
          res.status(500).json({ status: 'Error', message: 'Database Import Error! Please try again later.' });
          return;
        }

        const existingColors = selectResults.map(row => row.color_name);
        const newColors = colorNames.filter(name => !existingColors.includes(name));

        if (newColors.length === 0) {
          res.status(400).json({ status: 'Error', message: 'No new colors to import' });
          return;
        }

        const insertQuery = `INSERT INTO color_master (color_name) VALUES ?`;

        db.query(insertQuery, [newColors.map(name => [name])], (insertError, insertResult) => {
          if (insertError) {
            console.error(insertError);
            res.status(500).json({ status: 'Error', message: 'Database Import Error! Please check your file and its content.' });
            return;
          }

          res.json({ status: 'Success', message: 'Data Imported Successfully!' });
        });
      });
    });

    fs.createReadStream(filePath).pipe(parser);
  } catch (error) {
    console.error(error);
    res.status(500).json({ status: 'Error', message: 'Database Import Error! Please check your file and its content.' });
  }
});


//Import Line
app.post('/uploadline', upload.single('userfile'), (req, res) => {
  try {
    if (!req.file) {
      return res.status(400).json({ message: 'No file uploaded' });
    }

    const file = req.file;

    const filePath = file.path;
    const parser = csv({ delimiter: ',' });

    const lineNames = [];

    parser.on('readable', () => {
      let record;
      while ((record = parser.read())) {
        console.log('Records:', record); // Log the record to the console

        const lineName = record.linename; 
        console.log('Line Name:', lineName);
        console.log('Record Length:', Object.keys(record).length);
    
        if (record) {
          lineNames.push(lineName);
        } else {
          console.log('Skipping invalid record:', record);
        }
      }
    });

    parser.on('end', () => {
      fs.unlinkSync(filePath); // Delete the uploaded file

      const values = lineNames.map((lineName) => [lineName]);
      const flattenedValues = values.flat();
      console.log('flattenedValues:', flattenedValues);

      const selectQuery = `SELECT line_name FROM line_master WHERE line_name IN (?)`;

      db.query(selectQuery, [flattenedValues], (selectError, selectResults) => {
        if (selectError) {
          console.error(selectError);
          res.status(500).json({ status: 'Error', message: 'Database Import Error! Please try again later.' });
          return;
        }

        const existingLines = selectResults.map(row => row.line_name);
        const newLines = lineNames.filter(name => !existingLines.includes(name));

        if (newLines.length === 0) {
          res.status(400).json({ status: 'Error', message: 'No new lines to import' });
          return;
        }

        const insertQuery = `INSERT INTO line_master (line_name) VALUES ?`;

        db.query(insertQuery, [newLines.map(name => [name])], (insertError, insertResult) => {
          if (insertError) {
            console.error(insertError);
            res.status(500).json({ status: 'Error', message: 'Database Import Error! Please check your file and its content.' });
            return;
          }

          res.json({ status: 'Success', message: 'Data Imported Successfully!' });
        });
      });
    });

    fs.createReadStream(filePath).pipe(parser);
  } catch (error) {
    console.error(error);
    res.status(500).json({ status: 'Error', message: 'Database Import Error! Please check your file and its content.' });
  }
});



//Import Section
app.post('/uploadsection', upload.single('userfile'), (req, res) => {
  try {
    if (!req.file) {
      return res.status(400).json({ message: 'No file uploaded' });
    }

    const file = req.file;
    const filePath = file.path;
    const parser = csv({ delimiter: ',' });

    const sectionData = [];

    parser.on('readable', () => {
      let record;
      while ((record = parser.read())) {
        console.log('Records:', record); // Log the record to the console

        const sectionName = record.sectionname; 
        console.log('Section Name:', sectionName);
        console.log('Record Length:', Object.keys(record).length);
    
        if (record) {
          const newSection = {
            section_name: record.sectionname,
            target_unit: record.targetunit,
            section_type: record.itemcategory,
          };
          sectionData.push(newSection);
        } else {
          console.log('Skipping invalid record:', record);
        }
      }
    });

    parser.on('end', () => {
      fs.unlinkSync(filePath); // Delete the uploaded file

      const sectionNames = sectionData.map(section => section.section_name);

      const selectQuery = `SELECT section_name FROM section WHERE section_name IN (?)`;

      db.query(selectQuery, [sectionNames], (selectError, selectResults) => {
        if (selectError) {
          console.error(selectError);
          res.status(500).json({ status: 'Error', message: 'Database Import Error! Please try again later.' });
          return;
        }

        const existingSections = selectResults.map(row => row.section_name);
        const newSections = sectionData.filter(section => !existingSections.includes(section.section_name));

        if (newSections.length === 0) {
          res.status(400).json({ status: 'Error', message: 'No new sections to import' });
          return;
        }

        const values = newSections.map(section => [section.section_name, section.target_unit, section.section_type]);
        const placeholders = values.map(() => '(?, ?, ?)').join(', ');
        const insertQuery = `INSERT INTO section (section_name, target_unit, section_type) VALUES ${placeholders}`;

        const flattenedValues = values.flat();
        db.query(insertQuery, flattenedValues, (insertError, insertResult) => {
          if (insertError) {
            console.error(insertError);
            res.status(500).json({ status: 'Error', message: 'Database Import Error! Please check your file and its content.' });
            return;
          }

          res.json({ status: 'Success', message: 'Data Imported Successfully!' });
        });
      });
    });

    fs.createReadStream(filePath).pipe(parser);
  } catch (error) {
    console.error(error);
    res.status(500).json({ status: 'Error', message: 'Database Import Error! Please check your file and its content.' });
  }
});


//Import Item
app.post('/uploaditem', upload.single('userfile'), (req, res) => {
  try {
    if (!req.file) {
      return res.status(400).json({ message: 'No file uploaded' });
    }

    const file = req.file;
    const filePath = file.path;
    const parser = csv({ delimiter: ',' });

    const itemNames = [];
    let totalRecords = 0;
    let processedRecords = 0;

    parser.on('readable', () => {
      let record;
      while ((record = parser.read())) {
        console.log('Records:', record); // Log the record to the console
        totalRecords++;
        const itemGroup = record.etacode;
        const itemCategory = record['itemcategory(BRAIDS/NON-BRAIDS/ALL)']; // Accessing 'category type(BRAID/NBRAID)' column
        const itemDescription = record.itemdescription;
        const tppp = record.targetppp;
        const netWeight = record.netweight;
        const targetedWaste = record.targetedwaste;

        // Adding console logs
        console.log("Item Group:", itemGroup);
        console.log("Item Category:", itemCategory);
        console.log("Item Description:", itemDescription);
        console.log("Target PPP:", tppp);
        console.log("Net Weight:", netWeight);
        console.log("Targeted Waste:", targetedWaste);

        const catQuery = `SELECT id FROM item_category WHERE category_name='${itemCategory}'`;
        console.log("catQuery:", catQuery); // Check the query being executed

        db.query(catQuery, (error, results) => {
          if (error) throw error;

          if (results.length === 0) {
            console.log('No category found for:', itemCategory);
            // Handle the case where no category is found
            // You may want to insert a default category or handle it in another appropriate way
          } else {
            const cat = results[0].id;

            const duplicateCheckQuery = `SELECT id FROM item_masterr WHERE item_description='${itemDescription}'`;
            db.query(duplicateCheckQuery, (error, results) => {
              if (error) throw error;

              processedRecords++; // Increment processed records

              if (results.length === 0) {
                itemNames.push({
                  item_group: itemGroup,
                  item_description: itemDescription,
                  category_id: cat,
                  tppp: tppp,
                  net_weight: netWeight,
                  targeted_waste: targetedWaste,
                });
              } else {
                console.log('Record already exists:', itemDescription);
              }

              if (processedRecords === totalRecords) {
                // Process item names after all records are processed
                processItemNames();
              }
            });
          }
        });
      }
    });

    parser.on('end', () => {
      fs.unlinkSync(filePath); // Delete the uploaded file
    });

    fs.createReadStream(filePath).pipe(parser);

    function processItemNames() {
      if (itemNames.length === 0) {
        console.log('No items to process.');
        res.json({ status: 'Success', message: 'No new data to import.' });
        return;
      }

      const values = itemNames.map(Object.values);
      console.log('Values:', values);

      const flattenedValues = values.flat();
      console.log('flattenedValues:', flattenedValues);

      const duplicateCheckQuery = `SELECT item_description FROM item_masterr WHERE item_description IN (?)`;

      db.query(duplicateCheckQuery, [itemNames.map(item => item.item_description)], (error, results) => {
        if (error) {
          console.error(error);
          res.status(500).json({ status: 'Error', message: 'Database Import Error! Please check your file and its content.' });
          return;
        }

        const duplicateItems = results.map((row) => row.item_description);

        if (duplicateItems.length > 0) {
          res.status(400).json({ status: 'Error', message: `Duplicate item descriptions found: ${duplicateItems.join(', ')}` });
          return;
        }

        const placeholders = values.map(() => '(?, ?, ?, ?, ?, ?)').join(', ');

        const insertQuery = `INSERT INTO item_masterr (item_group, item_description, category_id, tppp, net_weight, targeted_waste) VALUES ${placeholders}`;

        db.query(insertQuery, flattenedValues, (insertError, insertResult) => {
          if (insertError) {
            console.error(insertError);
            res.status(500).json({ status: 'Error', message: 'Database Import Error! Please check your file and its content.' });
            return;
          }

          res.json({ status: 'Success', message: 'Data Imported Successfully!' });
        });
      });
    }
  } catch (error) {
    console.error(error);
    res.status(500).json({ status: 'Error', message: 'Database Import Error! Please check your file and its content.' });
  }
});


//Import Plan vs Target

// Define the dbQuery function
function dbQuery(query, values) {
  return new Promise((resolve, reject) => {
    db.query(query, values, (error, results) => {
      if (error) {
        reject(error);
      } else {
        resolve(results);
      }
    });
  });
}

app.post('/uploadplanvstarget', upload.single('userfile'), async (req, res) => {
  try {
    if (!req.file) {
      return res.status(400).json({ message: 'No file uploaded' });
    }

    const file = req.file;
    const filePath = file.path;
    const parser = csv({ delimiter: ',' });

    const targetNames = [];

    await new Promise((resolve, reject) => {
      parser.on('readable', () => {
        let record;
        while ((record = parser.read())) {
          console.log('Records:', record); // Log the record to the console
          const productcode = record.productcode;
          const productdescription = record.productdescription;

          // Print date keys and values
          const dateKeys = Object.keys(record).filter(key => key !== 'productcode' && key !== 'productdescription');

          dateKeys.forEach(async (key, index) => {
            const modifiedKey = key; // Modify the key
            const [day, month, year] = modifiedKey.split('-');
            const isoDate = new Date(`${year}-${month}-${day}`).toISOString();
            const timestamp = Math.floor(new Date(isoDate).getTime() / 1000);
            const dateValue = record[key]; // Store the value in a variable

            try {
              // Query to fetch the ID based on the product code
              const results = await dbQuery('SELECT * FROM item_code WHERE product_code = ?', [productcode]);
              if (results.length > 0) {
                const product = results[0].id;
                const product_id = results[0].product_id;

                // Second query using the retrieved product_id
                const results2 = await dbQuery('SELECT * FROM item_masterr WHERE id = ?', [product_id]);
                if (results2.length > 0) {
                  const categoryid = results2[0].category_id;

                  // Third query using the retrieved categoryid
                  const results3 = await dbQuery('SELECT id FROM target_plan_ota WHERE item_code_id = ? AND date = ?', [product, modifiedKey]);
                  if (results3.length === 0) {
                    targetNames.push({
                      item_code_id: product,
                      category: categoryid,
                      target_plan: dateValue,
                      date: modifiedKey,
                      timestamp: timestamp,
                    });
                  }
                } else {
                  console.log('Category Id not found for product ID:', product_id);
                }
              } else {
                console.log('Product code not found:', productcode);
              }

              if (index === dateKeys.length - 1) {
                console.log('targetNames:', targetNames);
                resolve(); // Resolve the promise when all dates are processed
              }
            } catch (error) {
              console.error('Error:', error);
              reject(error); // Reject the promise if there's an error
            }
          });

          console.log('Record Length:', Object.keys(record).length);
        }
      });

      parser.on('end', () => {
        fs.unlinkSync(filePath); // Delete the uploaded file
      });

      fs.createReadStream(filePath).pipe(parser);
    });

    if (targetNames.length === 0) {
      console.log('No targets to process.');
      return;
    }

    // Process targetNames
    for (const entry of targetNames) {
      try {
        const insertResult = await dbQuery('INSERT INTO target_plan_ota (item_code_id, category, target_plan, date, timestamp) VALUES (?, ?, ?, ?, ?)', [
          entry.item_code_id,
          entry.category,
          entry.target_plan,
          entry.date,
          entry.timestamp,
        ]);
        console.log('Row inserted:', entry);
      } catch (insertError) {
        console.error('Error inserting data:', insertError);
        // Handle the error as needed
      }
    }
    // Send success response after successful insert
    res.json({ status: 'Success', message: 'Data Imported Successfully!' });
    
  } catch (error) {
    console.error('Error:', error);
    res.status(500).json({ status: 'Error', message: 'Database Import Error! Please check your file and its content.' });
  }
});

//Import Item Color Code
app.post('/uploaditemcolorcode', upload.single('userfile'), (req, res) => {
  try {
    if (!req.file) {
      return res.status(400).json({ message: 'No file uploaded' });
    }

    const file = req.file;

    const filePath = file.path;
    const parser = csv({ delimiter: ',' });

    const itemcolorNames = [];

    parser.on('readable', () => {
      let record;
      while ((record = parser.read())) {
        console.log('Records:', record); // Log the record to the console
        const itemcode = record.itemcode;
        const productname = record.productname;
        const productdescription = record.productdescription;
        const colorcode = record.colorcode;
        console.log('Item Code:', itemcode);
        console.log('Product Name:', productname);
        console.log('Product Description:', productdescription);
        console.log('Color Code:', colorcode);
        console.log('Record Length:', Object.keys(record).length);

        // Execute MySQL queries to fetch IDs
        db.query('SELECT * FROM item_masterr WHERE item_description = ?', [productname], (productError, productResults) => {
          if (productError) {
            console.error('Error fetching product ID:', productError);
            return;
          }
          const productId = productResults.length > 0 ? productResults[0].id : null;

          db.query('SELECT * FROM color_master WHERE color_name = ?', [colorcode], (colorError, colorResults) => {
            if (colorError) {
              console.error('Error fetching color ID:', colorError);
              return;
            }
            const colorId = colorResults.length > 0 ? colorResults[0].id : null;

            console.log('Product ID:', productId);
            console.log('Color ID:', colorId);

            if (colorResults.length > 0) {
              console.log('Color information not found, pushing item to itemcolorNames:', itemcode);
              itemcolorNames.push({
                itemcode: itemcode,
                product_id: productId,
                product_des: productdescription,
                color_id: colorId,
              });
              console.log('Pushed Item:', itemcode);
              console.log('Updated itemcolorNames:', itemcolorNames);
              processItemColorNames(); // Call the function to process itemcolorNames
            }
            else {
              console.log('Color found, skipping item:', itemcode, productname, colorcode);
            }
          });
        });
      }
    });

    
    parser.on('end', () => {
      fs.unlinkSync(filePath); // Delete the uploaded file
      // Call processItemColorNames here only if there are items to process
      if (itemcolorNames.length > 0) {
        processItemColorNames();
      }
    });

    fs.createReadStream(filePath).pipe(parser);

    function processItemColorNames() {
      if (itemcolorNames.length === 0) {
        console.log('No items to process.');
        return;
      }

      const values = itemcolorNames.map(Object.values);
      console.log('Values:', values);

      // Generate placeholders for each row
      const placeholders = values.map(() => '(?, ?, ?, ?)').join(', ');

      // Flatten the values array to pass as parameters to the query
      const flattenedValues = values.flat();
      console.log('flattenedValues:', flattenedValues);

      const insertQuery = `INSERT INTO item_code(product_code, product_id, product_des, color_id) VALUES ${placeholders}`;

      db.query(insertQuery, flattenedValues, (insertError, insertResult) => {
        if (insertError) {
          console.error(insertError);
          res.status(500).json({ status: 'Error', message: 'Database Import Error! Please check your file and its content.' });
          return;
        }

        res.json({ status: 'Success', message: 'Data Imported Successfully!' });
      });
    }
  } catch (error) {
    console.error(error);
    res.status(500).json({ status: 'Error', message: 'Database Import Error! Please check your file and its content.' });
  }
});

//Import Employee
const { promisify } = require('util');
const writeFileAsync = promisify(fs.writeFile);
const unlinkAsync = promisify(fs.unlink);

// Use an array to store accumulated CSV responses
let accumulatedCsvData = [];

app.get('/downloademployeebackup', async (req, res) => {
  try {
    const query = `
      SELECT entryid as EntryId, status as Status, staff as Site
      FROM employees_ota
      WHERE passive_type='ACT' AND roleid='1'
    `;

    console.log('Query:', query);

    const results = await new Promise((resolve, reject) => {
      db.query(query, (error, results) => {
        if (error) {
          console.error('Error executing query:', error);
          reject(error);
        } else {
          resolve(results);
        }
      });
    });

    console.log('Query Results:', results);

    const data = results.map((row) => ({
      Entryid: row.Entryid,
      Status: row.Status,
      Site: row.Site,
    }));

    const csvData = [
      ['Entryid', 'Status', 'Site'],
      ...data.map((row) => Object.values(row)),
    ];

    accumulatedCsvData.push(...csvData);

    res.status(200).json({ status: 'Success', message: 'CSV data accumulated successfully' });
  } catch (error) {
    console.error('Error:', error);
    res.status(500).json({ status: 'Error', message: 'Internal Server Error' });
  }
});

app.get('/saveaccumulatedcsv', async (req, res) => {
  try {
    if (accumulatedCsvData.length === 0) {
      res.status(400).json({ status: 'Error', message: 'No accumulated CSV data' });
      return;
    }

    const fileName = 'Employee-Master.csv';
    const csvFolderPath = path.join(__dirname, 'csv_files');
    const filePath = path.join(csvFolderPath, fileName);

    const csvContent = accumulatedCsvData.map((row) => row.join(',')).join('\n');

    // Write CSV content to file
    await writeFileAsync(filePath, csvContent);

    // Set the response headers for file download
    res.setHeader('Content-Type', 'text/csv');
    res.setHeader('Content-Disposition', `attachment; filename="${fileName}"`);
    res.setHeader('Content-Length', Buffer.byteLength(csvContent, 'utf-8'));

    // Pipe the file to the response
    const readStream = fs.createReadStream(filePath);
    readStream.pipe(res);

    readStream.on('end', async () => {
      // Delete the file after it has been sent
      await unlinkAsync(filePath);
      console.log('File downloaded and deleted successfully');

      // Clear accumulated responses for the next download
      accumulatedCsvData = [];
    });
  } catch (error) {
    console.error('Error:', error);
    res.status(500).json({ status: 'Error', message: 'Internal Server Error' });
  }
});


//Import Fg Details Nbraid
app.post('/uploadfgdetails2', upload.single('userfile'), (req, res) => {
  try {
    if (!req.file) {
      return res.status(400).json({ message: 'No file uploaded' });
    }

    const file = req.file;

    const filePath = file.path;
    const parser = csv({ delimiter: ',' });

    const itemfgDetails = [];

    parser.on('readable', () => {
      let record;
      while ((record = parser.read())) {
        console.log('Records:', record); // Log the record to the console
        
        const productname = record.productname;
        const productcode = record.productcode;
        const line = record.line;
        const hour = record.hour;
        const fgoutput = record.fgoutput;
        const datetime = record.datetime;
        const userid = 9;
    
        // Read additional columns
        const shift = record['shift(DAY/NIGHT)']; // Accessing 'shift(DAY/NIGHT)' column
        const site = record['site(ikeja/ota)']; // Accessing 'site(ikeja/ota)' column
        const categoryType = record['category type(BRAID/NBRAID)']; // Accessing 'category type(BRAID/NBRAID)' column
        //const timestamp = 9;
    
        // Convert datetime to timestamp
        const [day, month, year] = datetime.split('-');
        const timestamp = new Date(`${year}-${month}-${day}`).getTime() / 1000; // Convert to Unix timestamp
        
        console.log('Product Name:', productname);
        console.log('Product Code:', productcode);
        console.log('Line:', line);
        console.log('Hour:', hour);
        console.log('FgOutput:', fgoutput);
        console.log('Date Time:', datetime);
        console.log('UserId:', userid);
        console.log('categoryType:', categoryType);
        console.log('shift:', shift);
        console.log('site:', site);
        console.log('Record Length:', Object.keys(record).length);
    
        // Execute MySQL queries to fetch IDs
        db.query('SELECT id FROM item_masterr WHERE item_description = ?', [productname], (productError, productResults) => {
          if (productError) {
            console.error('Error fetching product ID:', productError);
            return;
          }
          const productId = productResults.length > 0 ? productResults[0].id : null;
    
          db.query('SELECT id FROM item_code WHERE product_code = ?', [productcode], (codeError, codeResults) => {
            if (codeError) {
              console.error('Error fetching product code:', codeError);
              return;
            }
            const code = codeResults.length > 0 ? codeResults[0].id : null;
    
            console.log('Product ID:', productId);
            console.log('Code Id:', code);
    
            if (codeResults.length > 0) {
              console.log('Code information found, pushing item to itemfgDetails:', productcode);
              itemfgDetails.push({
                product_name: productId,
                product_code: code,
                line: line,
                hour: hour,
                fg_output: fgoutput,
                date_time: datetime,
                time_stamp: timestamp,
                user: userid,
                shift: shift,
                site: site,
                category_type: categoryType
              });
              console.log('Pushed Item:', productcode);
              console.log('Updated itemfgDetails:', itemfgDetails);
              processItemCodeNames(); // Call the function to process itemcolorNames
            }
            else {
              console.log('Code not found, skipping item:', productcode, productname, code);
            }
          });
        });
      }
    });
    

    
    parser.on('end', () => {
      fs.unlinkSync(filePath); // Delete the uploaded file
      processItemCodeNames(); // Call the function to process itemfgDetails
    });

    fs.createReadStream(filePath).pipe(parser);

    function processItemCodeNames() {
      if (itemfgDetails.length === 0) {
        console.log('No items to process.');
        return;
      }

      const values = itemfgDetails.map(item => [item.product_name, item.product_code, item.line, item.hour, item.fg_output, item.date_time, item.time_stamp, item.user, item.shift, item.site, item.category_type]);
      console.log('Values:', values);
      
      const insertQuery = `INSERT INTO fg_details (product_name, product_code, line, hour, fg_output, date_time, time_stamp, user, shift, site, category_type) VALUES ?`;

      db.query(insertQuery, [values], (insertError, insertResult) => {
        if (insertError) {
          console.error(insertError);
          res.status(500).json({ status: 'Error', message: 'Database Import Error! Please check your file and its content.' });
          return;
        }

        res.json({ status: 'Success', message: 'Data Imported Successfully!' });
      });
    }
  } catch (error) {
    console.error(error);
    res.status(500).json({ status: 'Error', message: 'Database Import Error! Please check your file and its content.' });
  }
});

app.post('/uploadfgdetails', upload.single('userfile'), (req, res) => {
  try {
      if (!req.file) {
          return res.status(400).json({ message: 'No file uploaded' });
      }

      const file = req.file;
      const filePath = file.path;
      const parser = csv({ delimiter: ',' });

      const itemfgDetails = [];

      parser.on('readable', () => {
          let record;
          while ((record = parser.read())) {
              console.log('Records:', record); // Log the record to the console

              const productname = record.productname;
              const productcode = record.productcode;
              const line = record.line;
              const hour = record.hour;
              const fgoutput = record.fgoutput;
              const datetime = record.datetime;
              const userid = 9;

              // Read additional columns
              const shift = record['shift(DAY/NIGHT)']; // Accessing 'shift(DAY/NIGHT)' column
              const site = record['site(ikeja/ota)']; // Accessing 'site(ikeja/ota)' column
              const categoryType = record['category type(BRAID/NBRAID)']; // Accessing 'category type(BRAID/NBRAID)' column

              // Convert datetime to timestamp
              const [day, month, year] = datetime.split('-');
              const timestamp = new Date(`${year}-${month}-${day}`).getTime() / 1000; // Convert to Unix timestamp

              console.log('Product Name:', productname);
              console.log('Product Code:', productcode);
              console.log('Line:', line);
              console.log('Hour:', hour);
              console.log('FgOutput:', fgoutput);
              console.log('Date Time:', datetime);
              console.log('UserId:', userid);
              console.log('Category Type:', categoryType);
              console.log('Shift:', shift);
              console.log('Site:', site);
              console.log('Record Length:', Object.keys(record).length);

              itemfgDetails.push({
                  productname: productname,
                  productcode: productcode,
                  line: line,
                  hour: hour,
                  fgoutput: fgoutput,
                  datetime: datetime,
                  userid: userid,
                  shift: shift,
                  site: site,
                  categoryType: categoryType,
                  timestamp: timestamp
              });
          }
      });

      parser.on('end', () => {
          fs.unlinkSync(filePath); // Delete the uploaded file
          processItemCodeNames(); // Call the function to process itemfgDetails
      });

      // Define a function to handle database queries asynchronously
      function queryDatabase(query, values) {
          return new Promise((resolve, reject) => {
              db.query(query, values, (error, results) => {
                  if (error) {
                      reject(error);
                  } else {
                      resolve(results);
                  }
              });
          });
      }

      // Process itemfgDetails using promises
      async function processItemCodeNames() {
          if (itemfgDetails.length === 0) {
              console.log('No items to process.');
              return;
          }

          const promises = itemfgDetails.map(async (item) => {
              try {
                  const productResults = await queryDatabase('SELECT * FROM item_masterr WHERE item_description = ?', [item.productname]);
                  const productId = productResults.length > 0 ? productResults[0].id : null;

                  const codeResults = await queryDatabase('SELECT * FROM item_code WHERE product_code = ?', [item.productcode]);
                  const code = codeResults.length > 0 ? codeResults[0].id : null;

                  console.log('Product ID:', productId);
                  console.log('Code Id:', code);

                  if (codeResults.length > 0) {
                      console.log('Code information found, pushing item to itemfgDetails:', item.productcode);
                      return {
                          productId: productId,
                          codeId: code,
                          line: item.line,
                          hour: item.hour,
                          fgoutput: item.fgoutput,
                          datetime: item.datetime,
                          userid: item.userid,
                          shift: item.shift,
                          site: item.site,
                          categoryType: item.categoryType,
                          timestamp: item.timestamp
                      };
                  } else {
                      console.log('Code not found, skipping item:', item.productcode, item.productname, code);
                      return null;
                  }
              } catch (error) {
                  console.error('Error:', error);
                  throw error;
              }
          });

          try {
              const resolvedItems = await Promise.all(promises);
              const validItems = resolvedItems.filter(item => item !== null);
              console.log('Valid Items:', validItems);

              const values = validItems.map(item => [item.productId, item.codeId, item.line, item.hour, item.fgoutput, item.datetime, item.timestamp, item.userid, item.shift, item.site, item.categoryType]);
              console.log('Values:', values);

              const insertQuery = `INSERT INTO fg_details (product_name, product_code, line, hour, fg_output, date_time, time_stamp, user, shift, site, category_type) VALUES ?`;
              await queryDatabase(insertQuery, [values]);

              res.json({ status: 'Success', message: 'Data Imported Successfully!' });
          } catch (error) {
              console.error(error);
              res.status(500).json({ status: 'Error', message: 'Database Import Error! Please check your file and its content.' });
          }
      }

      fs.createReadStream(filePath).pipe(parser);
  } catch (error) {
      console.error(error);
      res.status(500).json({ status: 'Error', message: 'An error occurred while processing the file.' });
  }
});



//Import Update Attendance Nbraid
app.post('/updateattendancenbraid', upload.single('userfile'), (req, res) => {
  try {
    if (!req.file) {
      return res.status(400).json({ message: 'No file uploaded' });
    }

    const file = req.file;

    const filePath = file.path;
    const parser = csv({ delimiter: ',' });

    parser.on('readable', () => {
      let record;
      while ((record = parser.read())) {
        console.log('Records:', record);

        const entryid = record.Entryid;
        const status = record.Status;

        console.log('entryid:', entryid);
        console.log('status:', status);

        //const currentDate = new Date().toLocaleDateString('en-GB', { timeZone: 'Africa/Lagos' });
        const date = new Date().toLocaleDateString('en-GB', { timeZone: 'Africa/Lagos' });
        const parts = date.split('/');
        const formattedDay = parts[0].padStart(2, '0');
        const formattedMonth = parts[1].padStart(2, '0');
        const year = parts[2];
        const currentDate = `${formattedDay}-${formattedMonth}-${year}`;
        console.log('currentDate:', currentDate);

        const updateQuery = `UPDATE employees_ota SET status=?, passive_type='ACT', date=? WHERE entryid=?`;

        db.query(updateQuery, [status, currentDate, entryid], (error, results) => {
          if (error) {
            console.error('Error updating attendance status:', error);
            return;
          }

          console.log('Attendance status updated successfully.');

          const secondQuery = `UPDATE employees_ota SET status=?, passive_type='ACT', date=? WHERE entryid=?`;

          db.query(secondQuery, [status, currentDate, entryid], (secondError, secondResults) => {
            if (secondError) {
              console.error('Error executing second query:', secondError);
              return;
            }

            console.log('Second query executed successfully.');
          });
        });
      }
    });

    parser.on('end', () => {
      console.log('CSV parsing ended');
      // Respond when everything is complete
      return res.status(200).json({ message: 'CSV processing completed' });
    });

    // Pipe the file stream to the parser
    fs.createReadStream(filePath).pipe(parser);
  } catch (error) {
    console.error('An error occurred:', error);
    return res.status(500).json({ message: 'An error occurred' });
  }
});


//Import Update Attendance Braid
app.post('/updateattendancebraid', upload.single('userfile'), (req, res) => {
  try {
    if (!req.file) {
      return res.status(400).json({ message: 'No file uploaded' });
    }

    const file = req.file;

    const filePath = file.path;
    const parser = csv({ delimiter: ',' });

    parser.on('readable', () => {
      let record;
      while ((record = parser.read())) {
        console.log('Records:', record);

        const entryid = record.Entryid;
        const status = record.Status;

        console.log('entryid:', entryid);
        console.log('status:', status);

        //const currentDate = new Date().toLocaleDateString('en-GB', { timeZone: 'Africa/Lagos' });
        const date = new Date().toLocaleDateString('en-GB', { timeZone: 'Africa/Lagos' });
        const parts = date.split('/');
        const formattedDay = parts[0].padStart(2, '0');
        const formattedMonth = parts[1].padStart(2, '0');
        const year = parts[2];
        const currentDate = `${formattedDay}-${formattedMonth}-${year}`;
        console.log('currentDate:', currentDate);

        const updateQuery = `UPDATE geopos_employees SET status=?, passive_type='ACT', date=? WHERE entryid=?`;

        db.query(updateQuery, [status, currentDate, entryid], (error, results) => {
          if (error) {
            console.error('Error updating attendance status:', error);
            return;
          }

          //console.log('Attendance status updated successfully.');

          const secondQuery = `UPDATE geopos_employees SET status=?, passive_type='ACT', date=? WHERE entryid=?`;

          db.query(secondQuery, [status, currentDate, entryid], (secondError, secondResults) => {
            if (secondError) {
              console.error('Error executing second query:', secondError);
              return;
            }

            //console.log('Second query executed successfully.');
          });
        });
      }
    });

    parser.on('end', () => {
      console.log('CSV parsing ended');
      // Respond when everything is complete
      return res.status(200).json({ message: 'CSV processing completed' });
    });

    // Pipe the file stream to the parser
    fs.createReadStream(filePath).pipe(parser);
  } catch (error) {
    console.error('An error occurred:', error);
    return res.status(500).json({ message: 'An error occurred' });
  }
});

//Export File braid
// Function to execute a query and return a promise
function queryAsync(sql) {
  return new Promise((resolve, reject) => {
    db.query(sql, (error, results) => {
      if (error) {
        reject(error);
      } else {
        resolve(results);
      }
    });
  });
}

//get download backup Braid
app.get('/downloademployeebackupBraid', async (req, res) => {
  try {
    const query = `
      SELECT entryid as EntryId, status as Status FROM geopos_employees WHERE passive_type='ACT' and roleid='1'
    `;

    console.log('Query:', query);

    // Use the custom promise-based query method
    const results = await queryAsync(query);
   console.log(results)
    // Extract the relevant data from the database query results
    const data = results.map((row) => ({
      Entryid: row.EntryId,
      Status: row.Status,
    }));

    // Prepare CSV data
    const csvData = [
      ['Entryid', 'Status'],
      ...data.map((row) => Object.values(row)),
    ];

    // Create CSV file
    const fileName = 'Employee-Master.csv';
    const csvFolderPath = path.join(__dirname, 'csv_files');
    const filePath = path.join(csvFolderPath, fileName);
    const csvContent = csvData.map((row) => row.join(',')).join('\n');

    // Use fs.promises.writeFile for asynchronous file writing
    await fs.promises.writeFile(filePath, csvContent);

    // Check if the file is created successfully
    const fileExists = await fs.promises.access(filePath).then(() => true).catch(() => false);

    if (!fileExists) {
      console.error('Error creating the CSV file.');
      res.status(500).json({ status: 'Error', message: 'Server error' });
      return;
    }

    // Set response headers and send the file as an attachment
    res.download(filePath, fileName, (err) => {
      if (err) {
        console.error('Error sending file:', err);
        res.status(500).json({ status: 'Error', message: 'Server error' });
      } else {
        console.log('File sent successfully');
        // Delete the file after it has been sent
        fs.promises.unlink(filePath).then(() => console.log('File deleted successfully'));
      }
    });
  } catch (error) {
    console.error('Error executing query or processing data:', error);
    res.status(500).json({ status: 'Error', message: 'Server error' });
  }
});

//Export File Non-braid
// Function to execute a query and return a promise
function queryAsync1(sql) {
  return new Promise((resolve, reject) => {
    db.query(sql, (error, results) => {
      if (error) {
        reject(error);
      } else {
        resolve(results);
      }
    });
  });
}

//get download backup NBraid
app.get('/downloademployeebackupNbraid', async (req, res) => {
  try {
    const query = `
      SELECT entryid as EntryId, status as Status,staff as Site FROM employees_ota WHERE passive_type='ACT' and roleid='1'
    `;

    console.log('Query:', query);

    // Use the custom promise-based query method
    const results = await queryAsync1(query);
    console.log(results)
    // Extract the relevant data from the database query results
    const data = results.map((row) => ({
      Entryid: row.EntryId,
      Status: row.Status,
      Site: row.Site,
    }));

    // Prepare CSV data
    const csvData = [
      ['Entryid', 'Status', 'Site'],
      ...data.map((row) => Object.values(row)),
    ];

    // Create CSV file
    const fileName = 'Employee-Master.csv';
    const csvFolderPath = path.join(__dirname, 'csv_files');
    const filePath = path.join(csvFolderPath, fileName);
    const csvContent = csvData.map((row) => row.join(',')).join('\n');

    // Use fs.promises.writeFile for asynchronous file writing
    await fs.promises.writeFile(filePath, csvContent);

    // Check if the file is created successfully
    const fileExists = await fs.promises.access(filePath).then(() => true).catch(() => false);

    if (!fileExists) {
      console.error('Error creating the CSV file.');
      res.status(500).json({ status: 'Error', message: 'Server error' });
      return;
    }

    // Set response headers and send the file as an attachment
    res.download(filePath, fileName, (err) => {
      if (err) {
        console.error('Error sending file:', err);
        res.status(500).json({ status: 'Error', message: 'Server error' });
      } else {
        console.log('File sent successfully');
        // Delete the file after it has been sent
        fs.promises.unlink(filePath).then(() => console.log('File deleted successfully'));
      }
    });
  } catch (error) {
    console.error('Error executing query or processing data:', error);
    res.status(500).json({ status: 'Error', message: 'Server error' });
  }
});


//-------------------------Import Module-----------------------------------//
//-------------------------Tv Display NBraid-----------------------------------//
//total employees
app.get('/fetchtotalemployees', (req, res) => {

  const date = new Date().toLocaleDateString('en-GB', { timeZone: 'Africa/Lagos' });
  const parts = date.split('/');
  const day = parts[0].padStart(2, '0');
  const month = parts[1].padStart(2, '0');
  const year = parts[2];
  const currentMonth = `${month}-${year}`;
  const currentDate = `${day}-${month}-${year}`;

  const query = `SELECT COUNT(id) AS total_emp FROM employees_ota WHERE passive_type='ACT' AND date='${currentDate}'`;

  db.query(query, (err, result) => {
    if (err) {
      console.log(err);
      res.status(500).send('Error fetching total items');
    } else {
      const total_emp = result[0].total_emp;
      const response = {
        total_emp: total_emp, // Use "totalItem" as the key instead of "rowCount"
      };
      res.send(response);
     
    }
  });
});

//total present employees
app.get('/fetchtotalpresentemployees', (req, res) => {

  const date = new Date().toLocaleDateString('en-GB', { timeZone: 'Africa/Lagos' });
  const parts = date.split('/');
  const day = parts[0].padStart(2, '0');
  const month = parts[1].padStart(2, '0');
  const year = parts[2];
  const currentMonth = `${month}-${year}`;
  const currentDate = `${day}-${month}-${year}`;

  const query = `SELECT COUNT(id) AS total_emp FROM employees_ota WHERE passive_type='ACT' AND status='P' AND date='${currentDate}'`;

  db.query(query, (err, result) => {
    if (err) {
      console.log(err);
      res.status(500).send('Error fetching total items');
    } else {
      const total_emp = result[0].total_emp;
      const response = {
        p_emp: total_emp, // Use "totalItem" as the key instead of "rowCount"
      };
      res.send(response);
     
    }
  });
});

//total absent employees
app.get('/fetchtotalabsentemployees', (req, res) => {

  const date = new Date().toLocaleDateString('en-GB', { timeZone: 'Africa/Lagos' });
  const parts = date.split('/');
  const day = parts[0].padStart(2, '0');
  const month = parts[1].padStart(2, '0');
  const year = parts[2];
  const currentMonth = `${month}-${year}`;
  const currentDate = `${day}-${month}-${year}`;

  const query = `SELECT COUNT(id) AS total_emp FROM employees_ota WHERE passive_type='ACT' AND status='A' AND date='${currentDate}'`;

  db.query(query, (err, result) => {
    if (err) {
      console.log(err);
      res.status(500).send('Error fetching total items');
    } else {
      const total_emp = result[0].total_emp;
      const response = {
        a_emp: total_emp, // Use "totalItem" as the key instead of "rowCount"
      };
      res.send(response);
     
    }
  });
});

//total active employees
app.get('/fetchtotalactiveemployees', (req, res) => {

  const date = new Date().toLocaleDateString('en-GB', { timeZone: 'Africa/Lagos' });
  const parts = date.split('/');
  const day = parts[0].padStart(2, '0');
  const month = parts[1].padStart(2, '0');
  const year = parts[2];
  const currentMonth = `${month}-${year}`;
  const currentDate = `${day}-${month}-${year}`;

  const query = `SELECT COUNT(*) AS noOfEmp FROM worker_timesheet WHERE date_time = '${currentDate}' group by date_time,entry_id`;

  db.query(query, (err, result) => {
    if (err) {
      console.log(err);
      res.status(500).send('Error fetching total items');
    } else {
      const actemp = result.length; // Use the length of results to get the count
      const response = {
        actemp: actemp,
      };
      res.send(response);
     
    }
  });
});

//mtd fg output
app.get('/fetchmtdavgoutput', (req, res) => {
  const date = new Date().toLocaleDateString('en-GB', { timeZone: 'Africa/Lagos' });
  const parts = date.split('/');
  const day = parts[0].padStart(2, '0');
  const month = parts[1].padStart(2, '0');
  const year = parts[2];
  const currentMonth = `${month}-${year}`;
  const currentDate = `${day}-${month}-${year}`;

  const query = `SELECT SUM(fg_output) AS tar FROM fg_details WHERE SUBSTRING(date_time, 4) = '${currentMonth}'`;
  //console.log('query:',query);

  db.query(query, (err, results) => {
    if (err) {
      console.log(err);
      res.status(500).send('Error fetching total FG output');
    } else {
      const total_fg_outputK = results[0].tar || 0; // Use results[0].tar or provide a default value (0) if tar is undefined
      const response = {
        total_fg_outputK: total_fg_outputK,
      };
      res.send(response);
    }
  });
});

//total fg output
app.get('/fetchtotalfgoutput', (req, res) => {
  const date = new Date().toLocaleDateString('en-GB', { timeZone: 'Africa/Lagos' });
  const parts = date.split('/');
  const day = parts[0].padStart(2, '0');
  const month = parts[1].padStart(2, '0');
  const year = parts[2];
  const currentDate = `${day}-${month}-${year}`;

  let total_fg_outputf = 0;

  const query = `SELECT * FROM worker_timesheet AS w JOIN item_masterr AS f ON w.product_name = f.id WHERE w.date_time = '${currentDate}' GROUP BY w.product_name, w.date_time`;

  db.query(query, (err, results) => {
    if (err) {
      console.log(err);
      res.status(500).send('Error fetching data');
    } else {
      // Iterate over the results and calculate the total_fg_outputf
      const promises = results.map((row) => {
        return new Promise((resolve) => {
          const subQuery = `SELECT *, SUM(fg_output) AS tar FROM fg_details WHERE date_time = '${currentDate}' AND product_name = '${row.product_name}' GROUP BY product_name, date_time`;
          db.query(subQuery, (err, result) => {
            if (!err) {
              const sum = result.length > 0 ? result[0].tar : 0;
              total_fg_outputf += sum;
            }
            resolve();
          });
        });
      });

      // Wait for all the promises to complete
      Promise.all(promises).then(() => {
        const response = {
          total_fg_outputf: total_fg_outputf,
        };
        res.send(response);
      });
    }
  });
});

//mtd ppp
app.get('/fetchmtdppp', (req, res) => {
  const date = new Date().toLocaleDateString('en-GB', { timeZone: 'Africa/Lagos' });
  const parts = date.split('/');
  const day = parts[0].padStart(2, '0');
  const month = parts[1].padStart(2, '0');
  const year = parts[2];
  const currentDate = `${day}-${month}-${year}`;
  const currentMonth = `${month}-${year}`;

  // Query to calculate the sum of noOfEmp for the given monthK
  const query = `
    SELECT SUM(a.noOfEmp) as res
    FROM (SELECT COUNT(*) AS noOfEmp
          FROM worker_timesheet
          WHERE mon = '${currentMonth}'
          GROUP BY entry_id, date_time) a
  `;

  db.query(query, (err, result) => {
    if (err) {
      console.error('Error calculating total PPP:', err);
      res.status(500).send('Error calculating total PPP');
      return;
    }

    const ros1K = result[0]; // Assuming you have a single result row
    const resk = ros1K.res; // Assuming you have a single result row
    console.log(resk);
    //const total_fg_outputK = 12345; // Replace with your actual total_fg_outputK value
    //const ppK = total_fg_outputK / ros1K.res;
    //const total_pppK = ppK.toFixed(2); // Format the result to two decimal places
    res.json({ resk });
  });
});




// FG OUTPUT Slide
app.get('/fetchfgoutputslide', (req, res) => {
  const date = new Date().toLocaleDateString('en-GB', { timeZone: 'Africa/Lagos' });
  const parts = date.split('/');
  const day = parts[0].padStart(2, '0');
  const month = parts[1].padStart(2, '0');
  const year = parts[2];
  const currentDate = `${day}-${month}-${year}`;
  const currentMonth = `${month}-${year}`;

  //const dt = `06-10-2023`;


  const query = `
  SELECT fg_details.*, item_code.product_des, color_master.color_name, SUM(fg_details.fg_output) as tar
  FROM fg_details
  JOIN item_code ON fg_details.product_code = item_code.id
  JOIN color_master ON item_code.color_id = color_master.id
  WHERE fg_details.date_time = ?
  GROUP BY fg_details.product_code
`;

db.query(query, [currentDate], (err, results) => {
  if (err) {
    console.error('Error executing the SQL query:', err);
    res.status(500).json({ error: 'Internal server error' });
  } else {
    const data = results.map((row) => ({
      product_desc: row.product_des,
      color_name: row.color_name,
      tar: row.tar,
    }));

    res.json({ data: data }); // Wrap the response in a data object
    //console.log(data,'================')
  }
});
});

// plan vs target slide
app.get('/fetchplanvstargetslide', (req, res) => {
  const date = new Date().toLocaleDateString('en-GB', { timeZone: 'Africa/Lagos' });
  const parts = date.split('/');
  const day = parts[0].padStart(2, '0');
  const month = parts[1].padStart(2, '0');
  const year = parts[2];
  const currentDate = `${day}-${month}-${year}`;
  const currentMonth = `${month}-${year}`;

  const dt = `06-10-2023`;

  const query1 = `
    SELECT * FROM target_plan_ota
    WHERE date = ? AND target_plan > 0 AND (category = '2' OR category = '3')
  `;

  db.query(query1, [currentDate], (err, result) => {
    if (err) {
      console.error('Error executing SQL query:', err);
      res.status(500).json({ error: 'An error occurred' });
      return;
    }

    const responseArray = [];

    const processNextRow = (index) => {
      if (index >= result.length) {
        // All data processed, send the response
        res.json(responseArray);
        //console.log(responseArray, '--------------');
        return;
      }

      const row = result[index];
      const itemCodeId = row.item_code_id;

      const query2 = `
        SELECT *, SUM(fg_output) as tar FROM fg_details
        WHERE date_time = ? AND product_code = ?
        ORDER BY fg_output DESC
      `;

      db.query(query2, [currentDate, itemCodeId], (err, result2) => {
        if (err) {
          console.error('Error executing SQL query:', err);
          res.status(500).json({ error: 'An error occurred' });
        } else {
          const row2 = result2[0];
          const sump = row2 ? row2.tar : '';

          const query3 = `
            SELECT * FROM item_code
            WHERE id = ?
          `;

          db.query(query3, [itemCodeId], (err, result3) => {
            if (err) {
              console.error('Error executing SQL query:', err);
              res.status(500).json({ error: 'An error occurred' });
            } else {
              const row3 = result3[0];
              const productDes = row3 ? row3.product_des : '';

              const t = row.target_plan;
              const c = sump;

              const responseObject = {
                itemCode: productDes,
                targetPlan: t,
                c: (c === '') ? '<span style="color:red">-</span>' : c,
                b: t - c,
              };

              responseArray.push(responseObject);
              

              // Process the next row
              processNextRow(index + 1);
            }
          });
        }
      });
    };

    // Start processing the first row
    processNextRow(0);
  });
});


//itemwise ppp slide
app.get('/fetchitemwisepppslide', (req, res) => {
  const date = new Date().toLocaleDateString('en-GB', { timeZone: 'Africa/Lagos' });
  const parts = date.split('/');
  const day = parts[0].padStart(2, '0');
  const month = parts[1].padStart(2, '0');
  const year = parts[2];
  const currentDate = `${day}-${month}-${year}`;
  const currentMonth = `${month}-${year}`;

  const dt = `06-10-2023`;

  const query1 = `
    SELECT w.*, f.item_description,f.tppp
    FROM worker_timesheet w
    JOIN item_masterr f ON w.product_name = f.id
    WHERE w.date_time = ?
    GROUP BY w.product_name, w.date_time
  `;

  let totalFgOutput = 0;
  let totalPpp = 0;

  db.query(query1, [currentDate], (err, result) => {
    if (err) {
      console.error('Error executing SQL query:', err);
      res.status(500).json({ error: 'An error occurred' });
      return; // Return early to avoid further execution
    }

    const responseData = [];

    const processNextRow = (index) => {
      if (index >= result.length) {
        // All data processed, send the response
        res.json(responseData);
        return;
      }

      const row = result[index];
      const productName = row.product_name;
      const tppp = row.tppp;
      const query2 = `
        SELECT *, SUM(fg_output) as tar
        FROM fg_details
        WHERE date_time = ? AND product_name = ?
        GROUP BY product_name, date_time
      `;

      db.query(query2, [dt, productName], (err, result2) => {
        if (err) {
          console.error('Error executing SQL query:', err);
          res.status(500).json({ error: 'An error occurred' });
        } else {
          const row2 = result2[0];
          const sum = row2 ? row2.tar : 0;
          

          const query3 = `
            SELECT COUNT(*) AS res
            FROM worker_timesheet
            WHERE date_time = ? AND product_name = ?
          `;

          db.query(query3, [dt, productName], (err, result3) => {
            if (err) {
              console.error('Error executing SQL query:', err);
              res.status(500).json({ error: 'An error occurred' });
            } else {
              const res1 = result3[0];
              const resCount = res1.res;
         
              let rew = resCount !== 0 ? sum / resCount : 0;

              if (isNaN(rew)) {
                rew = 0.00;
              }

              totalFgOutput += sum;
              totalPpp += rew;

              const itemData = {
                itemDescription: row.item_description,
                fgOutput: sum,
                tppp:tppp,
                rew: rew.toFixed(2),
              };

              responseData.push(itemData);
             // console.log(responseData,'---')
              processNextRow(index + 1);
            }
          });
        }
      });
    };

    // Start processing the first row
    processNextRow(0);
  });
});

//MTD PPP slide
app.get('/fetchmtdpppslide', (req, res) => {
  const date = new Date().toLocaleDateString('en-GB', { timeZone: 'Africa/Lagos' });
  const parts = date.split('/');
  const day = parts[0].padStart(2, '0');
  const month = parts[1].padStart(2, '0');
  const year = parts[2];
  const currentDate = `${day}-${month}-${year}`;
  const currentMonth = `${month}-${year}`;

  const monthK = '10-2023';

  const query1 = `
    SELECT w.*, f.item_description,f.tppp
    FROM worker_timesheet w
    JOIN item_masterr f ON w.product_name = f.id
    WHERE w.mon = ?
    GROUP BY w.product_name, w.mon
  `;

  db.query(query1, [currentMonth], (err, result) => {
    if (err) {
      console.error('Error executing SQL query:', err);
      res.status(500).json({ error: 'An error occurred' });
      return; // Return early to avoid further execution
    }

    const responseData = [];

    const processNextRow = (index) => {
      if (index >= result.length) {
        // All data processed, send the response
        res.json(responseData);
        return;
      }

      const row = result[index];
      const productName = row.product_name;

      const query2 = `
        SELECT *, SUM(fg_output) as tar
        FROM fg_details
        WHERE substr(date_time, 4) = ? AND product_name = ?
        GROUP BY product_name
      `;

      db.query(query2, [currentMonth, productName], (err, result2) => {
        if (err) {
          console.error('Error executing SQL query:', err);
          res.status(500).json({ error: 'An error occurred' });
        } else {
          const row2 = result2[0];
          const sumk = row2 ? row2.tar : 0;
          const tppp = row.tppp;

          const query3 = `
            SELECT COUNT(*) AS res
            FROM worker_timesheet
            WHERE mon = ? AND product_name = ?
          `;

          db.query(query3, [currentMonth, productName], (err, result3) => {
            if (err) {
              console.error('Error executing SQL query:', err);
              res.status(500).json({ error: 'An error occurred' });
            } else {
              const res1 = result3[0];
              const resCount = res1.res;

              let rew = sumk / resCount;
              if (rew === Infinity) {
                rew = 0;
              }

              const itemData = {
                itemDescription: row.item_description,
                tppp,
                sumk,
                rew: rew.toFixed(2),
              };

              responseData.push(itemData);
              //console.log(responseData,'------')
              processNextRow(index + 1);
            }
          });
        }
      });
    };

    // Start processing the first row
    processNextRow(0);
  });
});

//Top 10 Best worker based on efficiency slide
app.get('/fetchTop10Workersslide', (req, res) => {
  const date = new Date().toLocaleDateString('en-GB', { timeZone: 'Africa/Lagos' });
  const parts = date.split('/');
  const day = parts[0].padStart(2, '0');
  const month = parts[1].padStart(2, '0');
  const year = parts[2];
  const currentDate = `${day}-${month}-${year}`;
  const currentMonth = `${month}-${year}`;

  const dt = '06-10-2023';

  const query = `
    SELECT *, (HOUR1 + HOUR2 + HOUR3 + HOUR4 + HOUR5 + HOUR6 + HOUR7 + HOUR8 + HOUR9 + HOUR10 + HOUR11) / target AS value_sum
    FROM worker_timesheet
    WHERE date_time = ? AND target > 0 AND actual_target > 0
    GROUP BY entry_id, product_name, line, section, date_time
    ORDER BY value_sum DESC
    LIMIT 10
  `;

  db.query(query, [currentDate], (err, result) => {
    if (err) {
      console.error('Error executing SQL query:', err);
      res.status(500).json({ error: 'An error occurred' });
    } else {
      const responseData = [];

      for (const row of result) {
        const entryId = row.entry_id;
        const worker = row.worker;
        const sectionId = row.section;
        const valueSum = (row.value_sum * 100).toFixed(2);

        const sectionQuery = `
          SELECT section_name
          FROM section
          WHERE id = ?
        `;

        db.query(sectionQuery, [sectionId], (err, sectionResult) => {
          if (err) {
            console.error('Error executing SQL query:', err);
            res.status(500).json({ error: 'An error occurred' });
          } else {
            const sectionName = sectionResult[0].section_name;

            const itemData = {
              entryId,
              worker,
              sectionName,
              valueSum: `${valueSum}%`,
            };

            responseData.push(itemData);

            if (responseData.length === result.length) {
              // Send the response when all data is processed
              res.json(responseData);
             // console.log(responseData,'----')
            }
          }
        });
      }
    }
  });
});

//Top 10 Best worker MTD slide
app.get('/fetchTop10Workersmtdslide', (req, res) => {
  const date = new Date().toLocaleDateString('en-GB', { timeZone: 'Africa/Lagos' });
  const parts = date.split('/');
  const day = parts[0].padStart(2, '0');
  const month = parts[1].padStart(2, '0');
  const year = parts[2];
  const currentDate = `${day}-${month}-${year}`;
  const currentMonth = `${month}-${year}`;

  const monthK = '10-2023';
  const query = `
    SELECT *, (a.value_sum / a.cnt) as avv
    FROM (
      SELECT *, SUM((HOUR1 + HOUR2 + HOUR3 + HOUR4 + HOUR5 + HOUR6 + HOUR7 + HOUR8 + HOUR9 + HOUR10 + HOUR11) / target) AS value_sum, count(entry_id) as cnt
      FROM worker_timesheet
      WHERE mon = ? AND target > 0 AND actual_target > 0
      GROUP BY entry_id, product_name, line, section, mon
      ORDER BY value_sum DESC
    ) a
    GROUP BY a.entry_id
    ORDER BY avv DESC
    LIMIT 10
  `;

  db.query(query, [currentMonth], (err, result) => {
    if (err) {
      console.error('Error executing SQL query:', err);
      res.status(500).json({ error: 'An error occurred' });
    } else {
      const responseData = [];

      for (const row of result) {
        const entryId = row.entry_id;
        const worker = row.worker;
        const sectionId = row.section;
        const avv = (row.avv * 100).toFixed(2);

        const sectionQuery = `
          SELECT section_name
          FROM section
          WHERE id = ?
        `;

        db.query(sectionQuery, [sectionId], (err, sectionResult) => {
          if (err) {
            console.error('Error executing SQL query:', err);
            res.status(500).json({ error: 'An error occurred' });
          } else {
            const sectionName = sectionResult[0].section_name;

            const itemData = {
              entryId,
              worker,
              sectionName,
              avv: `${avv}%`,
            };

            responseData.push(itemData);

            if (responseData.length === result.length) {
              // Send the response when all data is processed
              res.json(responseData);
              //console.log(responseData,'----')
            }
          }
        });
      }
    }
  });
});


//-------------------------Tv Display Nbraid-----------------------------------//

//-------------------------Tv Display BRAID-------------------------------//
//total employees
app.get('/fetchtotalemployees1', (req, res) => {

  const date = new Date().toLocaleDateString('en-GB', { timeZone: 'Africa/Lagos' });
  const parts = date.split('/');
  const day = parts[0].padStart(2, '0');
  const month = parts[1].padStart(2, '0');
  const year = parts[2];
  const currentMonth = `${month}-${year}`;
  const currentDate = `${day}-${month}-${year}`;

  const query = `SELECT COUNT(id) AS total_emp FROM geopos_employees WHERE roleid !='5' AND passive_type='ACT' AND date='${currentDate}'`;

  db.query(query, (err, result) => {
    if (err) {
      console.log(err);
      res.status(500).send('Error fetching total items');
    } else {
      const total_emp = result[0].total_emp;
      const response = {
        total_emp: total_emp, // Use "totalItem" as the key instead of "rowCount"
      };
      res.send(response);
     
    }
  });
});

//total present employees
app.get('/fetchtotalpresentemployees1', (req, res) => {

  const date = new Date().toLocaleDateString('en-GB', { timeZone: 'Africa/Lagos' });
  const parts = date.split('/');
  const day = parts[0].padStart(2, '0');
  const month = parts[1].padStart(2, '0');
  const year = parts[2];
  const currentMonth = `${month}-${year}`;
  const currentDate = `${day}-${month}-${year}`;

  const query = `SELECT COUNT(id) AS total_emp FROM geopos_employees WHERE roleid !='5' AND passive_type='ACT' AND status='P' AND date='${currentDate}'`;

  db.query(query, (err, result) => {
    if (err) {
      console.log(err);
      res.status(500).send('Error fetching total items');
    } else {
      const total_emp = result[0].total_emp;
      const response = {
        p_emp: total_emp, // Use "totalItem" as the key instead of "rowCount"
      };
      res.send(response);
     
    }
  });
});

//total absent employees
app.get('/fetchtotalabsentemployees1', (req, res) => {

  const date = new Date().toLocaleDateString('en-GB', { timeZone: 'Africa/Lagos' });
  const parts = date.split('/');
  const day = parts[0].padStart(2, '0');
  const month = parts[1].padStart(2, '0');
  const year = parts[2];
  const currentMonth = `${month}-${year}`;
  const currentDate = `${day}-${month}-${year}`;

  const query = `SELECT COUNT(id) AS total_emp FROM geopos_employees WHERE roleid !='5' AND passive_type='ACT' AND status='A' AND date='${currentDate}'`;

  db.query(query, (err, result) => {
    if (err) {
      console.log(err);
      res.status(500).send('Error fetching total items');
    } else {
      const total_emp = result[0].total_emp;
      const response = {
        a_emp: total_emp, // Use "totalItem" as the key instead of "rowCount"
      };
      res.send(response);
     
    }
  });
});

//total active employees
app.get('/fetchtotalactiveemployees1', (req, res) => {

  const date = new Date().toLocaleDateString('en-GB', { timeZone: 'Africa/Lagos' });
  const parts = date.split('/');
  const day = parts[0].padStart(2, '0');
  const month = parts[1].padStart(2, '0');
  const year = parts[2];
  const currentMonth = `${month}-${year}`;
  const currentDate = `${day}-${month}-${year}`;

  const query = `SELECT COUNT(*) AS noOfEmp FROM operator_section WHERE date = '${currentDate}' group by empid`;

  db.query(query, (err, result) => {
    if (err) {
      console.log(err);
      res.status(500).send('Error fetching total items');
    } else {
      const actemp = result.length; // Use the length of results to get the count
      const response = {
        actemp: actemp,
      };
      res.send(response);
     
    }
  });
});

//mtd fg output
app.get('/fetchmtdavgoutput1', (req, res) => {
  const date = new Date().toLocaleDateString('en-GB', { timeZone: 'Africa/Lagos' });
  const parts = date.split('/');
  const day = parts[0].padStart(2, '0');
  const month = parts[1].padStart(2, '0');
  const year = parts[2];
  const currentMonth = `${month}-${year}`;
  const currentDate = `${day}-${month}-${year}`;

  const query = `SELECT SUM(fg_output) AS tar FROM geopos_operator WHERE month='${currentMonth}'`;

  db.query(query, (err, results) => {
    if (err) {
      console.log(err);
      res.status(500).send('Error fetching total FG output');
    } else {
      const total_fg_outputK = results[0].tar || 0; // Use results[0].tar or provide a default value (0) if tar is undefined
      const response = {
        total_fg_outputK: total_fg_outputK,
      };
      res.send(response);
    }
  });
});

//total fg output
app.get('/fetchtotalfgoutput1', (req, res) => {
  const date = new Date().toLocaleDateString('en-GB', { timeZone: 'Africa/Lagos' });
  const parts = date.split('/');
  const day = parts[0].padStart(2, '0');
  const month = parts[1].padStart(2, '0');
  const year = parts[2];
  const currentDate = `${day}-${month}-${year}`;

  let total_fg_outputf = 0;

  const query = `SELECT * FROM geopos_operator  WHERE date = '${currentDate}' GROUP BY item,date`;

  db.query(query, (err, results) => {
    if (err) {
      console.log(err);
      res.status(500).send('Error fetching data');
    } else {
      // Iterate over the results and calculate the total_fg_outputf
      const promises = results.map((row) => {
        return new Promise((resolve) => {
          const subQuery = `SELECT *, SUM(fg_output) AS tar FROM geopos_operator WHERE date = '${currentDate}' AND item = '${row.item}'`;
          db.query(subQuery, (err, result) => {
            if (!err) {
              const sum = result.length > 0 ? result[0].tar : 0;
              total_fg_outputf += sum;
            }
            resolve();
          });
        });
      });

      // Wait for all the promises to complete
      Promise.all(promises).then(() => {
        const response = {
          total_fg_outputf: total_fg_outputf,
        };
        res.send(response);
      });
    }
  });
});
//mtd ppp
app.get('/fetchmtdppp1', (req, res) => {
  const date = new Date().toLocaleDateString('en-GB', { timeZone: 'Africa/Lagos' });
  const parts = date.split('/');
  const day = parts[0].padStart(2, '0');
  const month = parts[1].padStart(2, '0');
  const year = parts[2];
  const currentDate = `${day}-${month}-${year}`;
  const currentMonth = `${month}-${year}`;

  // Query to calculate the sum of noOfEmp for the given monthK
  const query = `
    SELECT SUM(a.noOfEmp) as res
    FROM (SELECT COUNT(*) AS noOfEmp
          FROM geopos_operator
          WHERE month = '${currentMonth}'
          GROUP BY emp_id,date) a
  `;

  db.query(query, (err, result) => {
    if (err) {
      console.error('Error calculating total PPP:', err);
      res.status(500).send('Error calculating total PPP');
      return;
    }

    const ros1K = result[0]; // Assuming you have a single result row
    const resk = ros1K.res; // Assuming you have a single result row
  
    //const total_fg_outputK = 12345; // Replace with your actual total_fg_outputK value
    //const ppK = total_fg_outputK / ros1K.res;
    //const total_pppK = ppK.toFixed(2); // Format the result to two decimal places
    res.json({ resk });
  });
});


// FG OUTPUT Slide
app.get('/fetchfgoutputslide1', (req, res) => {
  const date = new Date().toLocaleDateString('en-GB', { timeZone: 'Africa/Lagos' });
  const parts = date.split('/');
  const day = parts[0].padStart(2, '0');
  const month = parts[1].padStart(2, '0');
  const year = parts[2];
  const currentDate = `${day}-${month}-${year}`;
  const currentMonth = `${month}-${year}`;

  const dt = `06-10-2023`;


  const query = `
  SELECT geopos_operator.*, color_master.color_name, item_masterr.item_description, SUM(geopos_operator.fg_output) as tar
  FROM geopos_operator
  JOIN color_master ON geopos_operator.color_id = color_master.id
  JOIN item_masterr ON geopos_operator.item = item_masterr.id
  WHERE geopos_operator.date = ?
  GROUP BY geopos_operator.item,geopos_operator.color_id
`;

db.query(query, [currentDate], (err, results) => {
  if (err) {
    console.error('Error executing the SQL query:', err);
    res.status(500).json({ error: 'Internal server error' });
  } else {
    const data = results.map((row) => ({
      item_description: row.item_description,
      color_name: row.color_name,
      tar: row.tar,
    }));

    res.json({ data: data }); // Wrap the response in a data object
    //console.log(data,'================')
  }
});
});
// plan vs target slide
app.get('/fetchplanvstargetslide1', (req, res) => {
  const date = new Date().toLocaleDateString('en-GB', { timeZone: 'Africa/Lagos' });
  const parts = date.split('/');
  const day = parts[0].padStart(2, '0');
  const month = parts[1].padStart(2, '0');
  const year = parts[2];
  const currentDate = `${day}-${month}-${year}`;
  const currentMonth = `${month}-${year}`;

  const dt = `06-10-2023`;

  const query1 = `
    SELECT * FROM target_plan_ota
    WHERE date = ? AND target_plan > 0 AND (category = '1' OR category = '3')
  `;

  db.query(query1, [currentDate], (err, result) => {
    if (err) {
      console.error('Error executing SQL query:', err);
      res.status(500).json({ error: 'An error occurred' });
      return;
    }

    const responseArray = [];

    const processNextRow = (index) => {
      if (index >= result.length) {
        // All data processed, send the response
        res.json(responseArray);
        //console.log(responseArray, '--------------');
        return;
      }

      const row = result[index];
      const itemCodeId = row.item_code_id;
    
      const query2 = ` SELECT * FROM item_code WHERE id = ? `;

      db.query(query2, [itemCodeId], (err, result2) => {
        if (err) {
          console.error('Error executing SQL query:', err);
          res.status(500).json({ error: 'An error occurred' });
        } else {
          const row2 = result2[0];
          const productDes = row2 ? row2.product_des : '';
          const product_id= row.product_id;
          const color_id=row.color_id;

          const query3 = `
          SELECT *, SUM(fg_output) as tar FROM geopos_operator
          WHERE date= ? AND item = ? AND color_id = ?
          ORDER BY item,date
  
          `;

          db.query(query3, [currentDate,product_id,color_id], (err, result3) => {
            if (err) {
              console.error('Error executing SQL query:', err);
              res.status(500).json({ error: 'An error occurred' });
            } else {
              const row3 = result3[0];
              const sump = row3 ? row3.tar : '';

              const t = row.target_plan;
              const c = sump;

              const responseObject = {
                itemCode: productDes,
                targetPlan: t,
                c: (c === '') ? '<span style="color:red">-</span>' : c,
                b: t - c,
              };

              responseArray.push(responseObject);
              console.log(responseObject,'-------')

              // Process the next row
              processNextRow(index + 1);
            }
          });
        }
      });
    };

    // Start processing the first row
    processNextRow(0);
  });
});

//itemwise ppp slide
app.get('/fetchitemwisepppslide1', (req, res) => {
  const date = new Date().toLocaleDateString('en-GB', { timeZone: 'Africa/Lagos' });
  const parts = date.split('/');
  const day = parts[0].padStart(2, '0');
  const month = parts[1].padStart(2, '0');
  const year = parts[2];
  const currentDate = `${day}-${month}-${year}`;
  const currentMonth = `${month}-${year}`;

  const dt = `06-10-2023`;

  const query1 = `
    SELECT w.*, f.item_description,f.tppp
    FROM geopos_operator w
    JOIN item_masterr f ON w.item = f.id
    WHERE w.date = ?
    GROUP BY w.item,w.date
  `;

  let totalFgOutput = 0;
  let totalPpp = 0;

  db.query(query1, [currentDate], (err, result) => {
    if (err) {
      console.error('Error executing SQL query:', err);
      res.status(500).json({ error: 'An error occurred' });
      return; // Return early to avoid further execution
    }

    const responseData = [];

    const processNextRow = (index) => {
      if (index >= result.length) {
        // All data processed, send the response
        res.json(responseData);
        return;
      }

      const row = result[index];
      const productName = row.item;
      const tppp = row.tppp;
      const query2 = `
        SELECT *, SUM(fg_output) as tar
        FROM geopos_operator
        WHERE date = ? AND item = ?
      `;

      db.query(query2, [currentDate, productName], (err, result2) => {
        if (err) {
          console.error('Error executing SQL query:', err);
          res.status(500).json({ error: 'An error occurred' });
        } else {
          const row2 = result2[0];
          const sum = row2 ? row2.fg_output : 0;
          

          const query3 = `
            SELECT COUNT(*) AS res
            FROM geopos_operator
            WHERE date = ? AND item = ?
          `;

          db.query(query3, [currentDate, productName], (err, result3) => {
            if (err) {
              console.error('Error executing SQL query:', err);
              res.status(500).json({ error: 'An error occurred' });
            } else {
              const res1 = result3[0];
              const resCount = res1.res;
         
              let rew = resCount !== 0 ? sum / resCount : 0;

              if (isNaN(rew)) {
                rew = 0.00;
              }

              totalFgOutput += sum;
              totalPpp += rew;

              const itemData = {
                itemDescription: row.item_description,
                fgOutput: sum,
                tppp:tppp,
                rew: rew.toFixed(2),
              };

              responseData.push(itemData);
             // console.log(responseData,'---')
              processNextRow(index + 1);
            }
          });
        }
      });
    };

    // Start processing the first row
    processNextRow(0);
  });
});

//MTD PPP slide
app.get('/fetchmtdpppslide1', (req, res) => {
  const date = new Date().toLocaleDateString('en-GB', { timeZone: 'Africa/Lagos' });
  const parts = date.split('/');
  const day = parts[0].padStart(2, '0');
  const month = parts[1].padStart(2, '0');
  const year = parts[2];
  const currentDate = `${day}-${month}-${year}`;
  const currentMonth = `${month}-${year}`;

  const monthK = '10-2023';

  const query1 = `
    SELECT w.*, f.item_description,f.tppp
    FROM geopos_operator w
    JOIN item_masterr f ON w.item = f.id
    WHERE w.month = ?
    GROUP BY w.item, w.month
  `;

  db.query(query1, [currentMonth], (err, result) => {
    if (err) {
      console.error('Error executing SQL query:', err);
      res.status(500).json({ error: 'An error occurred' });
      return; // Return early to avoid further execution
    }

    const responseData = [];

    const processNextRow = (index) => {
      if (index >= result.length) {
        // All data processed, send the response
        res.json(responseData);
        return;
      }

      const row = result[index];
      const productName = row.item;

      const query2 = `
        SELECT *, SUM(fg_output) as tar
        FROM geopos_operator
        WHERE month = ? AND item = ?
      `;

      db.query(query2, [currentMonth, productName], (err, result2) => {
        if (err) {
          console.error('Error executing SQL query:', err);
          res.status(500).json({ error: 'An error occurred' });
        } else {
          const row2 = result2[0];
          const sumk = row2 ? row2.tar : 0;
          const tppp = row.tppp;

          const query3 = `
            SELECT COUNT(*) AS res
            FROM geopos_operator
            WHERE month = ? AND item = ?
          `;

          db.query(query3, [currentMonth, productName], (err, result3) => {
            if (err) {
              console.error('Error executing SQL query:', err);
              res.status(500).json({ error: 'An error occurred' });
            } else {
              const res1 = result3[0];
              const resCount = res1.res;

              let rew = sumk / resCount;
              if (rew === Infinity) {
                rew = 0;
              }

              const itemData = {
                itemDescription: row.item_description,
                tppp,
                sumk,
                rew: rew.toFixed(2),
              };

              responseData.push(itemData);
              //console.log(responseData,'------')
              processNextRow(index + 1);
            }
          });
        }
      });
    };

    // Start processing the first row
    processNextRow(0);
  });
});

//Waste Management slide
app.get('/fetchWastageManagementslide1', (req, res) => {
  const date = new Date().toLocaleDateString('en-GB', { timeZone: 'Africa/Lagos' });
  const parts = date.split('/');
  const day = parts[0].padStart(2, '0');
  const month = parts[1].padStart(2, '0');
  const year = parts[2];
  const currentDate = `${day}-${month}-${year}`;
  const currentMonth = `${month}-${year}`;

  const dt = `06-10-2023`;

  const query1 = `
  SELECT w.*, f.item_description,f.targeted_waste,f.net_weight
  FROM geopos_operator w
  JOIN item_masterr f ON w.item = f.id
  WHERE w.date = ?
  GROUP BY w.item,w.date
`;


  db.query(query1, [currentDate], (err, result) => {
      if (err) {
          console.error('Error executing SQL query:', err);
          res.status(500).json({ error: 'An error occurred' });
          return; // Return early to avoid further execution
      }

      const responseData = [];

      const processNextRow = (index) => {
          if (index >= result.length) {
              // All data processed, send the response
              res.json(responseData);
              return;
          }

          const row = result[index];
          const item_description = row.item_description;
          const waste = row.targeted_waste;
          const net = row.net_weight;
         // console.log(waste, '-------', net)
          const bom = ((waste / net) * 100).toFixed(2);
          const item = row.item;


          let fiberTotal = 0;
          let wasteWeightTotal = 0;

          const query2 = `
      SELECT * FROM geopos_operator
      WHERE date = ? AND item = ?
    `;

          db.query(query2, [currentDate, item], (err, result2) => {
              if (err) {
                  console.error('Error executing SQL query:', err);
                  res.status(500).json({ error: 'An error occurred' });
              } else {
                  result2.forEach((res2) => {
                      //console.log(res2);

                      const fiber = res2.fiber;
                      const waste_weight = res2.waste_weight;

                      fiberTotal += fiber;
                      wasteWeightTotal += waste_weight;
                  });

                  let cp = '-';
                  if (fiberTotal !== 0) {
                      cp = ((wasteWeightTotal / (fiberTotal * 1000)) * 100).toFixed(2) + ' %';
                  }

                  const itemData = {
                      itemDescription: item_description,
                      bom: bom,
                      cp: cp,
                  };

                  responseData.push(itemData);
                  //console.log(responseData, '---');
                  processNextRow(index + 1);
              }
          });

      };

      // Start processing the first row
      processNextRow(0);
  });
});

//Waste Management MTD slide
app.get('/fetchWastageManagementmtdslide1', (req, res) => {
  const date = new Date().toLocaleDateString('en-GB', { timeZone: 'Africa/Lagos' });
  const parts = date.split('/');
  const day = parts[0].padStart(2, '0');
  const month = parts[1].padStart(2, '0');
  const year = parts[2];
  const currentDate = `${day}-${month}-${year}`;
  const currentMonth = `${month}-${year}`;

  const query1 = `
  SELECT w.*, f.item_description,f.targeted_waste,f.net_weight
  FROM geopos_operator w
  JOIN item_masterr f ON w.item = f.id
  WHERE w.month = ?
  GROUP BY w.item,w.month
`;


  db.query(query1, [currentMonth], (err, result) => {
      if (err) {
          console.error('Error executing SQL query:', err);
          res.status(500).json({ error: 'An error occurred' });
          return; // Return early to avoid further execution
      }

      const responseData = [];

      const processNextRow = (index) => {
          if (index >= result.length) {
              // All data processed, send the response
              res.json(responseData);
              return;
          }

          const row = result[index];
          const item_description = row.item_description;
          const waste = row.targeted_waste;
          const net = row.net_weight;
         // console.log(waste, '-------', net)
          const bom = ((waste / net) * 100).toFixed(2);
          const item = row.item;


          let fiberTotal =0;
          let wasteWeightTotal = 0;

          const query2 = `
      SELECT * FROM geopos_operator
      WHERE month = ? AND item = ?
    `;

          db.query(query2, [currentMonth, item], (err, result2) => {
              if (err) {
                  console.error('Error executing SQL query:', err);
                  res.status(500).json({ error: 'An error occurred' });
              } else {
                  result2.forEach((res2) => {
                      

                    const fiber = parseFloat(res2.fiber);
                    const waste_weight = parseFloat(res2.waste_weight);

                      fiberTotal +=fiber;
                      wasteWeightTotal +=waste_weight;
                  });

                  let cp = '-';
                  if (fiberTotal !== 0) {
                      cp = ((wasteWeightTotal / (fiberTotal * 1000)) * 100).toFixed(2) + ' %';
                  }

                  const itemData = {
                      itemDescription: item_description,
                      bom: bom,
                      cp: cp,
                  };
                  //console.log(wasteWeightTotal,'---------',fiberTotal);
                  responseData.push(itemData);
                  //console.log(responseData, '---');
                  processNextRow(index + 1);
              }
          });

      };

      // Start processing the first row
      processNextRow(0);
  });
});
//-------------------------Tv Display BRAID-------------------------------//

//---------------------------Import Timesheet-------------------------------//
// Filter Timesheet
app.post('/getimporttimesheetfiltertimesheetdata', (req, res) => {
  // Extract data from the request body
  const shift = req.body.shift;
  const hour = req.body.hour;
  const line = req.body.line_no;
  const section = req.body.section;
  const id = 9;
  const sites = req.body.site;

  console.log('Received data:');
  console.log('Line No:', line);
  console.log('Section:', section);
  console.log('Shift:', shift);
  console.log('Hour:', hour);
  console.log('Site:', sites);

  let date1 = '';
  let sectionName = ''; // Initialize sectionName

  // Check if the site is 'ota'
  if (sites === 'ota') {
    // Query to fetch data from 'employees_ota' table
    const query1 = 'SELECT * FROM employees_ota ORDER BY id ASC LIMIT 1';
    
    // Execute query1 to get the date value
    db.query(query1, (error1, results1, fields) => {
      if (error1) {
        console.error('Error executing query1:', error1);
        res.status(500).json({ error: 'Internal Server Error' });
      } else {
        // Set the date1 variable with the fetched date value
        date1 = results1[0].date;
        //console.log('date for ota:', date1);

        // Check if data already exists for the specified parameters
        const checkQuery = `
          SELECT *
          FROM timesheet
          WHERE line = '${line}' 
          AND section = '${section}' 
          AND shift = '${shift}' 
          AND date_time = '${date1}' 
          AND ${hour} > 0
          AND site = '${sites}';
        `;

        //console.log('Check Query:', checkQuery);
        //console.log('Values:', [line, section, shift, date1, sites]);

        // Execute checkQuery to see if data exists
        db.query(checkQuery,  (checkError, checkResults) => {
          if (checkError) {
            console.error('Error executing checkQuery:', checkError);
            res.status(500).json({ error: 'Internal Server Error' });
          } else {
           
            // Check if data exists
            const dataExists = checkResults.length > 0;
            //console.log('dataExists:', dataExists);
            //console.log('Check Results:', checkResults);
            
            if (dataExists) {
              // Fetch section name based on sectionId
              const querySectionName = `
                SELECT section_name
                FROM section
                WHERE id = ?;
              `;
            
              db.query(querySectionName, [section], (errorSection, resultsSection) => {
                if (errorSection) {
                  console.error('Error fetching section name:', errorSection);
                  res.status(500).json({ error: 'Internal Server Error' });
                } else {
                  // Extract sectionName from the query results
                  const sectionName = resultsSection.length > 0 ? resultsSection[0].section_name : '';
            
                  // Continue with constructing the response
                  //const message = `You have already inserted data for product, line ${line}, section ${sectionName}, and hour ${hour}. For editing, click on `;
                  const message = `You have already inserted data for, ${shift}, shift, ${line}, line, ${sectionName}, section and, ${hour}, hour. For editing, click on `;
                  const additionalData = {
                    sectionname: sectionName,
                    tdate: 0,
                    sites,
                    hour,
                    line,
                    section,
                    shiftt: shift,
                  };
            
                  res.status(200).json({ message, ...additionalData });
                }
              });
            } else {
              // Continue with the main logic

              // Query to fetch data from 'operator_assign' table
              const query2 = `
                SELECT operator_assign.*, geopos_users.name, operator_assign.name_id as opid
                FROM operator_assign
                LEFT JOIN geopos_users ON operator_assign.name_id = geopos_users.id
                WHERE operator_assign.line = ? 
                AND operator_assign.section = ? 
                AND operator_assign.shift = ? 
                AND operator_assign.category_type = 'NBRAID';
              `;
              db.query(query2, [line, section, shift], (error2, results2, fields) => {
                if (error2) {
                  console.error('Error executing query2:', error2);
                  res.status(500).json({ error: 'Internal Server Error' });
                } else {
                  // Execute query4 to fetch the section name
                  const sectionId = section; // Assuming 'section' holds the section_id
                  const query4 = `
                    SELECT section_name
                    FROM section
                    WHERE id = ?;
                  `;
                  db.query(query4, [sectionId], (error4, results4, fields) => {
                    if (error4) {
                      console.error('Error fetching section name:', error4);
                      res.status(500).json({ error: 'Internal Server Error' });
                    } else {
                      if (results4.length > 0) {
                        sectionName = results4[0].section_name;
                        //console.log('Section Name:', sectionName);
                      }
      
                      // Query to check if data exists in 'timesheet'
                      const query3 = `
                        SELECT *
                        FROM timesheet
                        WHERE line = ? 
                        AND section = ? 
                        AND shift = ? 
                        AND date_time = ? 
                        AND ? > 0 
                        AND site = ?;
                      `;

                      db.query(query3, [line, section, shift, date1, hour, sites], (error3, results3, fields) => {
                        if (error3) {
                          console.error('Error executing query3:', error3);
                          res.status(500).json({ error: 'Internal Server Error' });
                        } else {
                          // Log the results of query3 to the console
                          //console.log('Query3 Results:', results3);

                          // If no data exists in 'timesheet', execute additional query
                          if (results3.length === 0) {
                            // Query to fetch data from 'employees_ota' based on specific conditions
                            const query9 = `
                                SELECT *
                                FROM employees_ota
                                WHERE section_id = '${section}'
                                AND line = '${line}' 
                                AND roleid = '1' 
                                AND passive_type = 'ACT' 
                                AND workertype = 'DIRECT' 
                                AND shift = '${shift}' 
                                AND category_type = 'NBRAID'
                                ORDER BY name;
                              `;

                              console.log('Query9:', query9);

                              db.query(query9, (error9, results9) => {
                                if (error9) {
                                  console.error('Error executing query9:', error9);
                                  res.status(500).json({ error: 'Internal Server Error' });
                                } else {
                                  // Log the results of query9 to the console
                                  console.log('Query9 Results:', results9);

                                  // Initialize the data object outside the loop
                                  const data = {
                                    op: results2,
                                    filteredResults: [], // Initialize filteredResults as an empty array
                                    abs: [], // Initialize abs as an empty array for absent entryid values
                                    additionalResults: [], // Initialize additionalResults as an empty array for 'P' case
                                    sectionname: sectionName, // Set sectionName here
                                    tdate: 0,
                                    sites,
                                    hour,
                                    line,
                                    section,
                                    shiftt: shift,
                                  };

                                  // Function to execute the inner query and handle the result
                                  const executeInnerQuery = (row) => {
                                    return new Promise((resolve, reject) => {
                                      const queryInner = `
                                        SELECT * 
                                        FROM timesheet 
                                        WHERE entry_id = ? 
                                        AND ${hour} > 0 
                                        AND date_time = ?;
                                      `;
                                  
                                      console.log('Inner Query:', queryInner); // Log the SQL query
                                  
                                      db.query(queryInner, [row.entryid, date1], (errorInner, wrk) => {
                                        if (errorInner) {
                                          console.error('Error executing timesheet query:', errorInner);
                                          reject(errorInner);
                                        } else {
                                          const row1 = wrk.length; // Use the length property for the number of rows
                                          console.log('row1:', row1);
                                  
                                          if (row1 === 0) {
                                            // Include the entire 'row' object in filteredResults for 'P' case
                                            data.filteredResults.push(row);
                                          } else {
                                            // Handle the case when rows are found in the inner query
                                            // Add your logic here for the 'else' condition
                                  
                                            // Extract relevant information from the query 9 results for 'non-P' case
                                            const { name } = row;
                                  
                                            // Include the relevant information in additionalResults for 'non-P' case
                                            data.additionalResults.push({ name });
                                          }
                                  
                                          resolve();
                                        }
                                      });
                                    });
                                  };

                                  // Array to store promises for inner queries
                                  const innerQueryPromises = [];

                                  results9.forEach((row) => {
                                    const entryId = row.entryid;
                                    if (row.status === 'P') {
                                      // Execute the inner query and push the promise to the array
                                      innerQueryPromises.push(executeInnerQuery(row));
                                    } else {
                                      // Include the entryid in abs for 'non-P' case
                                      data.abs.push(entryId);
                                    }
                                  });

                                  // Wait for all inner queries to complete before sending the response
                                  Promise.all(innerQueryPromises)
                                    .then(() => {
                                      // Send the modified 'data' object as a response
                                      res.status(200).json(data);
                                    })
                                    .catch((error) => {
                                      console.error('Error in inner queries:', error);
                                      res.status(500).json({ error: 'Internal Server Error' });
                                    });
                                }
                              });
                          } else {
                            // Data already exists in 'timesheet'
                            const data = {
                              op: results2,
                              filteredResults: results3, // Include results from query3
                              sectionname: sectionName, // Set sectionName here
                              tdate: 0,
                              sites,
                              hour,
                              line,
                              section,
                              shiftt: shift,
                            };

                            // Send the 'data' object as a response with the results of query3
                            res.status(200).json(data);
                          }
                        }
                      });
                    }
                  });
                }
              });
            }
          }
        });
      }
    });
  }
  else if (sites === 'ikeja') {
    // Query to fetch data from 'geopos_employees' table
    const query5 = 'SELECT * FROM geopos_employees ORDER BY id ASC LIMIT 1';
    
    // Execute query5 to get the date value
    db.query(query5, (error5, results5, fields) => {
      if (error5) {
        console.error('Error executing query5:', error5);
        res.status(500).json({ error: 'Internal Server Error' });
      } else {
        // Set the date1 variable with the fetched date value
        date1 = results5[0].date;
        console.log('date for ikeja:', date1);

       // Check if data already exists for the specified parameters
       const checkQuery = `
       SELECT *
       FROM timesheet
       WHERE line = '${line}' 
       AND section = '${section}' 
       AND shift = '${shift}' 
       AND date_time = '${date1}' 
       AND ${hour} > 0
       AND site = '${sites}';
     `;
     
             console.log('Check Query:', checkQuery);
             //console.log('Values:', [line, section, shift, date1, sites]);
     
             // Execute checkQuery to see if data exists
             db.query(checkQuery,  (checkError, checkResults) => {
               if (checkError) {
                 console.error('Error executing checkQuery:', checkError);
                 res.status(500).json({ error: 'Internal Server Error' });
               } else {
                
                 // Check if data exists
                 const dataExists = checkResults.length > 0;
                 console.log('dataExists:', dataExists);
                 console.log('Check Results:', checkResults);
                 if (dataExists) {
                  // Fetch section name based on sectionId
                  const querySectionName = `
                    SELECT section_name
                    FROM section
                    WHERE id = ?;
                  `;
                
                  db.query(querySectionName, [section], (errorSection, resultsSection) => {
                    if (errorSection) {
                      console.error('Error fetching section name:', errorSection);
                      res.status(500).json({ error: 'Internal Server Error' });
                    } else {
                      // Extract sectionName from the query results
                      const sectionName = resultsSection.length > 0 ? resultsSection[0].section_name : '';
                
                      // Continue with constructing the response
                      //const message = `You have already inserted data for product, line ${line}, section ${sectionName}, and hour ${hour}. For editing, click on `;
                      const message = `You have already inserted data for, ${shift}, shift, ${line}, line, ${sectionName}, section and, ${hour}, hour. For editing, click on `;
                      const additionalData = {
                        sectionname: sectionName,
                        tdate: 0,
                        sites,
                        hour,
                        line,
                        section,
                        shiftt: shift,
                      };
                
                      res.status(200).json({ message, ...additionalData });
                    }
                  });
                }  else {
              // Continue with the main logic

              // Query to fetch data from 'operator_assign_ikeja' table
              const query6 = `
                SELECT operator_assign_ikeja.*, geopos_users.name, operator_assign_ikeja.operator_id as opid
                FROM operator_assign_ikeja
                LEFT JOIN geopos_users ON operator_assign_ikeja.operator_id = geopos_users.id
                WHERE operator_assign_ikeja.line = ? 
                AND operator_assign_ikeja.section = ? 
                AND operator_assign_ikeja.shift = ? 
                AND operator_assign_ikeja.category_type = 'NBRAID';
              `;
              db.query(query6, [line, section, shift], (error6, results6, fields) => {
                if (error6) {
                  console.error('Error executing query6:', error6);
                  res.status(500).json({ error: 'Internal Server Error' });
                } else {
                  // Execute query4 to fetch the section name
                  const sectionId = section; // Assuming 'section' holds the section_id
                  const query7 = `
                    SELECT section_name
                    FROM section
                    WHERE id = ?;
                  `;
                  db.query(query7, [sectionId], (error7, results7, fields) => {
                    if (error7) {
                      console.error('Error fetching section name:', error7);
                      res.status(500).json({ error: 'Internal Server Error' });
                    } else {
                      if (results7.length > 0) {
                        sectionName = results7[0].section_name;
                        console.log('Section Name:', sectionName);
                      }
      
                      // Query to check if data exists in 'timesheet'
                      const query3 = `
                        SELECT *
                        FROM timesheet
                        WHERE line = ? 
                        AND section = ? 
                        AND shift = ? 
                        AND date_time = ? 
                        AND ? > 0 
                        AND site = ?;
                      `;

                      db.query(query3, [line, section, shift, date1, hour, sites], (error3, results3, fields) => {
                        if (error3) {
                          console.error('Error executing query3:', error3);
                          res.status(500).json({ error: 'Internal Server Error' });
                        } else {
                          // Log the results of query3 to the console
                          console.log('Query3 Results:', results3);

                          // If no data exists in 'timesheet', execute additional query
                          if (results3.length === 0) {
                            // Query to fetch data from 'geopos_employees' based on specific conditions
                           
                            const query10 = `
                            SELECT *
                            FROM geopos_employees
                            WHERE section_id = '${section}'
                            AND line = '${line}' 
                            AND roleid = '1' 
                            AND passive_type = 'ACT' 
                            AND workertype = 'DIRECT' 
                            AND shift = '${shift}' 
                            AND category_type = 'NBRAID'
                            ORDER BY name;
                          `;
                          
                          console.log('query10:', query10);
                          
                          db.query(query10, (error10, results10) => {
                              if (error10) {
                                console.error('Error executing query10:', error10);
                                res.status(500).json({ error: 'Internal Server Error' });
                              } else {
                                // Log the results of query10 to the console
                                console.log('Query10 Results:', results10);

                                  // Initialize the data object outside the loop
                                  const data = {
                                    op: results6,
                                    filteredResults: [], // Initialize filteredResults as an empty array
                                    abs: [], // Initialize abs as an empty array for absent entryid values
                                    additionalResults: [], // Initialize additionalResults as an empty array for 'P' case
                                    sectionname: sectionName, // Set sectionName here
                                    tdate: 0,
                                    sites,
                                    hour,
                                    line,
                                    section,
                                    shiftt: shift,
                                  };

                                  // Function to execute the inner query and handle the result
                                  const executeInnerQuery = (row) => {
                                    return new Promise((resolve, reject) => {
                                      const queryInner = `
                                        SELECT * 
                                        FROM timesheet 
                                        WHERE entry_id = ? 
                                        AND ${hour} > 0 
                                        AND date_time = ?;
                                      `;

                                      console.log('Inner Query:', queryInner); // Log the SQL query

                                      db.query(queryInner, [row.entryid, date1], (errorInner, wrk) => {
                                        if (errorInner) {
                                          console.error('Error executing timesheet query:', errorInner);
                                          reject(errorInner);
                                        } else {
                                          const row1 = wrk.length; // Use the length property for the number of rows
                                          console.log('row1:', row1);

                                          if (row1 === 0) {
                                            // Include the entire 'row' object in filteredResults for 'P' case
                                            data.filteredResults.push(row);
                                          } else {
                                            // Handle the case when rows are found in the inner query
                                            // Add your logic here for the 'else' condition
                                  
                                            // Extract relevant information from the query 9 results for 'non-P' case
                                            const { name } = row;
                                  
                                            // Include the relevant information in additionalResults for 'non-P' case
                                            data.additionalResults.push({ name });
                                          }
                                          resolve();
                                        }
                                      });
                                    });
                                  };

                                  // Array to store promises for inner queries
                                  const innerQueryPromises = [];

                                  results10.forEach((row) => {
                                    const entryId = row.entryid;
                                    if (row.status === 'P') {
                                      // Execute the inner query and push the promise to the array
                                      innerQueryPromises.push(executeInnerQuery(row));
                                    } else {
                                      // Include the entryid in abs for 'non-P' case
                                      data.abs.push(entryId);
                                    }
                                  });

                                  // Wait for all inner queries to complete before sending the response
                                  Promise.all(innerQueryPromises)
                                    .then(() => {
                                      // Send the modified 'data' object as a response
                                      res.status(200).json(data);
                                    })
                                    .catch((error) => {
                                      console.error('Error in inner queries:', error);
                                      res.status(500).json({ error: 'Internal Server Error' });
                                    });
                                }
                              });


                          } else {
                            // Data already exists in 'timesheet'
                            const data = {
                              op: results6,
                              filteredResults: results3, // Include results from query3
                              sectionname: sectionName, // Set sectionName here
                              tdate: 0,
                              sites,
                              hour,
                              line,
                              section,
                              shiftt: shift,
                            };

                            // Send the 'data' object as a response with the results of query3
                            res.status(200).json(data);
                          }
                        }
                      });
                    }
                  });
                }
              });
            }
          }
        });
      }
    });
  }
});

// fetch product name
app.get('/getproductname/:selectedProduct', (req, res) => {
  const { selectedProduct } = req.params;
  const query = `SELECT * FROM item_masterr WHERE id = '${selectedProduct}'`;

  db.query(query, (error, results) => {
    if (error) {
      console.error('Error executing MySQL query:', error);
      res.status(500).json({ error: 'An error occurred while fetching product details.' });
    } else {
      if (results.length === 0) {
        res.status(404).json({ error: 'Product not found.' });
      } else {
        const productDescription = results[0].item_description;
        res.json({ productDescription });
      }
    }
  });
});

//import timesheet 
app.post('/uploadtimesheet', upload.single('userfile'), async (req, res) => {
  try {
    if (!req.file) {
      return res.status(400).json({ message: 'No file uploaded' });
    }

    const file = req.file;
    const filePath = file.path;
    const parser = csv({ delimiter: ',' });
    const itemNames = [];
    let headerColumns;
    let recordCount = 0;
    const recordPromises = []; // Define recordPromises array

    parser.on('headers', (headers) => {
      headerColumns = headers;
    });

    parser.on('readable', () => {
      let record;
      

      while ((record = parser.read())) {
        console.log('Record Count (Inside while loop):', recordCount);
        const recordCountIncremented = ++recordCount;
        console.log('Record Count (Incremented):', recordCountIncremented);

        const hourColumnIndex = 8;
        const hourColumnName = headerColumns[hourColumnIndex];

        const name = record.Name;
        const entryid = record.Entryid;
        const shift = record.Shift;
        const product = record.Product;
        const color = record.Color;
        const line = record.Line;
        const section = record.Section;
        const target = record.Target;
        //const hour = record.HOUR1;
        const hour = record[hourColumnName]; // Access the column value dynamically
        const site = record.Site;
        const operator = record.Operator;
        const date = record.Date;
        const parts = date.split('-');
        const monthYear = parts[1] + '-' + parts[2];
        const formattedDate = parts[2] + '-' + parts[1] + '-' + parts[0]; // Reformat to 'YYYY-MM-DD'
        const timestamp = Date.parse(formattedDate);
        const timestampInSeconds = timestamp / 1000;

        console.log('date:', date);
        console.log('timestamp:', timestamp);
        console.log('timestampInSeconds:', timestampInSeconds);

        

        const itemQuery = `SELECT * FROM item_masterr WHERE item_description='${product}'`;
        const colorQuery = `SELECT * FROM item_code WHERE product_des='${color}'`;
        const query1 = `SELECT * FROM section WHERE section_name='${section}'`;
        const query2 = `SELECT * FROM geopos_users WHERE name='${operator}'`;

        // Push promises to the array
        recordPromises.push(
          (async () => {
            try {
              const [itemResults, colorResults, sectionResults, operatorResults] = await Promise.all([
                dbQueryPromise(itemQuery),
                dbQueryPromise(colorQuery),
                dbQueryPromise(query1),
                dbQueryPromise(query2),
              ]);

              const item = itemResults[0].id;
              const colorcode = colorResults[0].id;
              const sectioncode = sectionResults[0].id;
              const operatorcode = operatorResults[0].id;

              let op = operatorcode || '9';

              // Calculate join date based on the site
              let joindate;
              if (site === 'ota') {
                const joindateQuery = `SELECT joindate FROM employees_ota WHERE entryid='${entryid}'`;
                const joindateResults = await dbQueryPromise(joindateQuery);
                joindate = joindateResults[0].joindate;
              } else if (site === 'ikeja') {
                const joindateQuery = `SELECT joindate FROM geopos_employees WHERE entryid='${entryid}'`;
                const joindateResults = await dbQueryPromise(joindateQuery);
                joindate = joindateResults[0].joindate;
              }

              const recordObject = {
                product_name: item,
                line: line,
                section: sectioncode,
                worker: name,
                entry_id: entryid,
                shift: shift,
                hour: hour,
                target: target,
                actual_target: target,
                date_time: date,
                site: site,
                color_id: colorcode,
                time_stamp: timestampInSeconds,
                mon: monthYear,
                operator_id: op,
                joindate: joindate,
              };

              itemNames.push(recordObject);
            } catch (error) {
              console.error('Error processing record:', error);
              console.error('Record Data:', record);
            }
          })()
        );
      }

      // Wait for all promises to resolve before moving on
      Promise.all(recordPromises).then(() => {
        // Do anything else you need to do after processing all records
      });
    });

    parser.on('end', async () => {
      try {
        await Promise.all(recordPromises); // Wait for all promises to resolve
        fs.unlinkSync(filePath);
       console.log('Total records processed (After try catch block):', recordCount);
        console.log('itemNames:', itemNames);
       processItemNames(headerColumns, itemNames); // Pass headerColumns and itemNames to the function
      } catch (error) {
        console.error('Error processing records:', error);
        res.status(500).json({ status: 'Error', message: 'Database Import Error! Please check your file and its content.' });
      }
    });

    fs.createReadStream(filePath).pipe(parser);

    function processItemNames(headerColumns, itemNames) {
      if (itemNames.length === 0) {
        console.log('No items to process.');
        return;
      }
    
      // Access hourColumnName in this function
      const hourColumnIndex = 8;
      const hourColumnName = headerColumns[hourColumnIndex];
      console.log('Hour Column Name:', hourColumnName);

      const values = itemNames.map(Object.values);
      //console.log('Values:', values);

      const entryIds = values.map(subArray => subArray[4]);
      const products = values.map(subArray => subArray[0]);
      const sections = values.map(subArray => subArray[2]);
      const shifts = values.map(subArray => subArray[5]);
      const sites = values.map(subArray => subArray[10]);
      const lines = values.map(subArray => subArray[1]);
      const dates = values.map(subArray => subArray[9]);
      const targets = values.map(subArray => subArray[7]);
      const hours = values.map(subArray => subArray[6]);
      /*  console.log('entryIds:', entryIds);
      console.log('products:', products);
      console.log('sections:', sections);
      console.log('shifts:', shifts);
      console.log('sites:', sites);
      console.log('lines:', lines);
      console.log('dates:', dates);
      console.log('targets:', targets); */ 

      // Generate placeholders for each row
      const placeholders = values.map(() => '(?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)').join(', ');

      // Flatten the values array to pass as parameters to the query
      const flattenedValues = values.flat();

      //console.log('flattenedValues:', flattenedValues);

      // Specify the indices of the fields you want to extract
      const desiredIndices = [0, 1, 2, 4, 5, 9, 10];

      // Extract desired fields from each subArray
      const uflattenedValues = values.map(subArray => desiredIndices.map(index => subArray[index])).flat();
      

      //console.log('uflattenedValues:', uflattenedValues);

     

      const duplicateCheckQuery = `SELECT id
      FROM timesheet
    WHERE
    entry_id IN (${entryIds.join(',')}) AND
    product_name IN (${products.join(',')}) AND
    section IN (${sections.join(',')}) AND
    shift IN ('${shifts.join("','")}') AND
    site IN ('${sites.join("','")}') AND
    line IN (${lines.join(',')}) AND
    date_time IN ('${dates.join("','")}')`;


      console.log('duplicateCheckQuery:', duplicateCheckQuery);  

      db.query(duplicateCheckQuery, uflattenedValues, (error, results) => {
        if (error) {
          console.error(error);
          res.status(500).json({ status: 'Error', message: 'Database Import Error! Please check your file and its content.' });
          return;
        }

        console.log('results:', results);  

        

       // Check if there are duplicates based on the query results
if (results.length > 0) {
  let target = [];
  let tar;
  let tarValue;

  const tarQueries = entryIds.map((id, index) => {
    return `
      SELECT * FROM timesheet
      WHERE
      entry_id = '${id}' AND
      product_name = ${products[index]} AND
      section = ${sections[index]} AND
      shift = '${shifts[index]}' AND
      site = '${sites[index]}' AND
      line = '${lines[index]}' AND
      date_time = '${dates[index]}'
    `;
  });

  // Log or use the generated tarQueries as needed
  tarQueries.forEach(tarQuery => {
    console.log('tarQuery:');
    console.log(tarQuery);

    const executeQuery = async (tarQuery, index) => {
      return new Promise((resolve, reject) => {
        db.query(tarQuery, (err, result) => {
          if (err) reject(err);

          let totalTarget = 0;

          if (result.length > 0) {
            result.forEach(row => {
              tarValue = row.target;
              target.push(Number(tarValue) + Number(targets[index]));
            });

            console.log('target:', target);
          } else {
            console.log('tar:', tarValue);
          }

          const updateQuery = `UPDATE timesheet
            SET ${hourColumnName}='${hours[index]}', target='${target[index]}'
            WHERE
            entry_id = '${entryIds[index]}' AND
            product_name = ${products[index]} AND
            section = ${sections[index]} AND
            shift = '${shifts[index]}' AND
            site = '${sites[index]}' AND
            line = '${lines[index]}' AND
            date_time = '${dates[index]}'`;

          console.log(`updateQuery ${index + 1}:`);
          console.log(updateQuery);

          db.query(updateQuery, (err, result) => {
            if (err) reject(err);
            resolve();
          });
        });
      });
    };

    // Execute queries sequentially using async/await
    const executeQueries = async () => {
      for (let i = 0; i < tarQueries.length; i++) {
        const tarQuery = tarQueries[i];
        await executeQuery(tarQuery, i);
      }
    };

    executeQueries()
      .then(() => {
        // All queries and updates are completed
        res.json({ status: 'Success', message: 'Data Updated Successfully!' });
      })
      .catch(err => {
        console.error(err);
        res.status(500).json({ status: 'Error', message: 'Error updating existing record.' });
      });
      });
    } else {
          // No duplicates found, proceed with inserting the new record
          const insertQuery = `INSERT INTO timesheet (product_name, line, section, worker, entry_id, shift, ${hourColumnName}, target, actual_target, date_time, site, color_id, time_stamp, mon, operator_id, joindate) VALUES ${placeholders}`;

          //console.log('insertQuery:', insertQuery);

          db.query(insertQuery, flattenedValues, (insertError, insertResult) => {
            if (insertError) {
              console.error(insertError);
              res.status(500).json({ status: 'Error', message: 'Database Import Error! Please check your file and its content.' });
            } else {
              res.json({ status: 'Success', message: 'Data Imported Successfully!' });
            }
          });
        }
      });
    }

    function processRecord(record) {
      // ... (your existing code for processing individual records)
    }

    function dbQueryPromise(query) {
      return new Promise((resolve, reject) => {
        db.query(query, (error, results) => {
          if (error) {
            reject(error);
          } else {
            resolve(results);
          }
        });
      });
    }
  } catch (error) {
    console.error('Upload Timesheet Error:', error);
    res.status(500).json({ status: 'Error', message: 'Database Import Error! Please check your file and its content.' });
  }
});

//view timesheet
app.get('/viewtimesheet', (req, res) => {

  const date = new Date().toLocaleDateString('en-GB', { timeZone: 'Africa/Lagos' });
  const parts = date.split('/');
  const formattedDay = parts[0].padStart(2, '0');
  const formattedMonth = parts[1].padStart(2, '0');
  const year = parts[2];
  const date1 = `${formattedDay}-${formattedMonth}-${year}`;
 
  console.log('Date:', date1);
  
  // Define the SQL query based on the user's role
  const sqlQuery = `
    SELECT
      timesheet.*, section.section_name, item_masterr.item_description,
      SUM(
       timesheet.HOUR1 + timesheet.HOUR2 + timesheet.HOUR3 +
        timesheet.HOUR4 + timesheet.HOUR5 + timesheet.HOUR6 +
       timesheet.HOUR7 + timesheet.HOUR8 + timesheet.HOUR9 +
       timesheet.HOUR10 + timesheet.HOUR11
      ) AS value_sum
    FROM timesheet
    LEFT JOIN item_masterr ON timesheet.product_name = item_masterr.id
    LEFT JOIN section ON timesheet.section = section.id
    WHERE timesheet.date_time = ?
    GROUP BY
      timesheet.entry_id,
      timesheet.product_name,
      timesheet.section,
      timesheet.shift,
      timesheet.date_time
    ORDER BY timesheet.worker ASC
  `;


  // Execute the SQL query
  db.query(sqlQuery, [date1], (error, results) => {
    if (error) {
      return res.status(500).json({ error: 'Database error' });
    }

    console.log('Query results ota:', results); 

    const data = {
      timesheet: results,
      
    };
    res.json(data); // Send response back to client 
  });
});

//---------------------------Import Timesheet-------------------------------//

//--------------------Attendance And Attrition Dashboard--------------------//

//Get ota(braid) total worker 
app.get("/fetchtotalotabraid", (req, res) => {

  const query = `
  SELECT * FROM employees_ota
  ORDER BY id ASC
  LIMIT 1;
`;

db.query(query, (error, results) => {
  if (error) {
    console.error('Error executing the query:', error);
   
    return;
  }

  if (results.length === 0) {
    //console.log('No records found');
   
    return;
  }

  const dt = results[0].date;

  const whereClause = `passive_type = 'ACT' AND workertype = 'DIRECT' AND category_type = 'BRAID' AND date = '${dt}' `;
  const countQuery = `
    SELECT COUNT(*) AS totalWorkerCount
    FROM employees_ota
    WHERE ${whereClause};
  `;

  db.query(countQuery, (error, countResults) => {
    if (error) {
      console.error('Error executing the count query:', error);
     
      return;
    }

    const totalCount = countResults[0].totalWorkerCount;
    console.log('Total Worker Count:', totalCount);
    res.send(countResults);
   
  });
});
}); 

//Get ota(braid) present worker 
app.get("/fetchpresentotabraid", (req, res) => {
  const query = `
  SELECT * FROM employees_ota
  ORDER BY id ASC
  LIMIT 1;
`;

db.query(query, (error, results) => {
  if (error) {
    console.error('Error executing the query:', error);
   
    return;
  }

  if (results.length === 0) {
    //console.log('No records found');
   
    return;
  }

  const dt = results[0].date;

  const whereClause = `passive_type = 'ACT' AND workertype = 'DIRECT' AND category_type = 'BRAID' AND date = '${dt}' AND status = 'P'`;
  const countQuery = `
    SELECT COUNT(*) AS totalPresentCount
    FROM employees_ota
    WHERE ${whereClause};
  `;

  db.query(countQuery, (error, countResults) => {
    if (error) {
      console.error('Error executing the count query:', error);
     
      return;
    }

    const totalCount = countResults[0].totalPresentCount;
    console.log('Total Present  Worker Count:', totalCount);
    res.send(countResults);
   
  });
});
}); 

//Get ota(braid) absent worker 
app.get("/fetchabsentotabraid", (req, res) => {
  const query = `
  SELECT * FROM employees_ota
  ORDER BY id ASC
  LIMIT 1;
`;

db.query(query, (error, results) => {
  if (error) {
    console.error('Error executing the query:', error);
   
    return;
  }

  if (results.length === 0) {
    //console.log('No records found');
   
    return;
  }

  const dt = results[0].date;

  const whereClause = `passive_type = 'ACT' AND workertype = 'DIRECT' AND category_type = 'BRAID' AND date = '${dt}' AND status = 'A'`;
  const countQuery = `
    SELECT COUNT(*) AS totalAbsentCount
    FROM employees_ota
    WHERE ${whereClause};
  `;

  db.query(countQuery, (error, countResults) => {
    if (error) {
      console.error('Error executing the count query:', error);
     
      return;
    }

    const totalCount = countResults[0].totalAbsentCount;
    console.log('Total Absent Worker Count:', totalCount);
    res.send(countResults);
   
  });
});
}); 


//Get ota(nbraid) total worker 
app.get("/fetchtotalotanbraid", (req, res) => {

  const query = `
  SELECT * FROM employees_ota
  ORDER BY id ASC
  LIMIT 1;
`;

db.query(query, (error, results) => {
  if (error) {
    console.error('Error executing the query:', error);
   
    return;
  }

  if (results.length === 0) {
    //console.log('No records found');
   
    return;
  }

  const dt = results[0].date;

  const whereClause = `passive_type = 'ACT' AND workertype = 'DIRECT' AND category_type = 'NBRAID' AND date = '${dt}' `;
  const countQuery = `
    SELECT COUNT(*) AS totalWorkerCount
    FROM employees_ota
    WHERE ${whereClause};
  `;

  db.query(countQuery, (error, countResults) => {
    if (error) {
      console.error('Error executing the count query:', error);
     
      return;
    }

    const totalCount = countResults[0].totalWorkerCount;
    //console.log('Total Worker Count:', totalCount);
    res.send(countResults);
   
  });
});
}); 

//Get ota(nbraid) present worker 
app.get("/fetchpresentotanbraid", (req, res) => {
  const query = `
  SELECT * FROM employees_ota
  ORDER BY id ASC
  LIMIT 1;
`;

db.query(query, (error, results) => {
  if (error) {
    console.error('Error executing the query:', error);
    return;
  }

  if (results.length === 0) {
    //console.log('No records found');
   
    return;
  }

  const dt = results[0].date;

  const whereClause = `passive_type = 'ACT' AND workertype = 'DIRECT' AND category_type = 'NBRAID' AND date = '${dt}' AND status = 'P'`;
  const countQuery = `
    SELECT COUNT(*) AS totalPresentCount
    FROM employees_ota
    WHERE ${whereClause};
  `;

  db.query(countQuery, (error, countResults) => {
    if (error) {
      console.error('Error executing the count query:', error);
     
      return;
    }

    const totalCount = countResults[0].totalPresentCount;
    console.log('Total Present  Worker Count:', totalCount);
    res.send(countResults);
   
  });
});
}); 

//Get ota(nbraid) absent worker 
app.get("/fetchabsentotanbraid", (req, res) => {
  const query = `
  SELECT * FROM employees_ota
  ORDER BY id ASC
  LIMIT 1;
`;

db.query(query, (error, results) => {
  if (error) {
    console.error('Error executing the query:', error);
   
    return;
  }

  if (results.length === 0) {
    //console.log('No records found');
   
    return;
  }

  const dt = results[0].date;

  const whereClause = `passive_type = 'ACT' AND workertype = 'DIRECT' AND category_type = 'NBRAID' AND date = '${dt}' AND status = 'A'`;
  const countQuery = `
    SELECT COUNT(*) AS totalAbsentCount
    FROM employees_ota
    WHERE ${whereClause};
  `;

  db.query(countQuery, (error, countResults) => {
    if (error) {
      console.error('Error executing the count query:', error);
     
      return;
    }

    const totalCount = countResults[0].totalAbsentCount;
    console.log('Total Absent Worker Count:', totalCount);
    res.send(countResults);
   
  });
});
}); 

//Get ikeja(braid) total worker 
app.get("/fetchtotalikejabraid", (req, res) => {

  const query = `
  SELECT * FROM geopos_employees
  ORDER BY id ASC
  LIMIT 1;
`;

db.query(query, (error, results) => {
  if (error) {
    console.error('Error executing the query:', error);
   
    return;
  }

  if (results.length === 0) {
    //console.log('No records found');
   
    return;
  }

  const dt = results[0].date;

  const whereClause = `passive_type = 'ACT' AND workertype = 'DIRECT' AND category_type = 'BRAID' AND date = '${dt}' `;
  const countQuery = `
    SELECT COUNT(*) AS totalWorkerCount
    FROM geopos_employees
    WHERE ${whereClause};
  `;

  db.query(countQuery, (error, countResults) => {
    if (error) {
      console.error('Error executing the count query:', error);
     
      return;
    }

    const totalCount = countResults[0].totalWorkerCount;
    //console.log('Total Worker Count:', totalCount);
    res.send(countResults);
   
  });
});
}); 

//Get ikeja(braid) present worker 
app.get("/fetchpresentikejabraid", (req, res) => {
  const query = `
  SELECT * FROM geopos_employees
  ORDER BY id ASC
  LIMIT 1;
`;

db.query(query, (error, results) => {
  if (error) {
    console.error('Error executing the query:', error);
   
    return;
  }

  if (results.length === 0) {
    //console.log('No records found');
   
    return;
  }

  const dt = results[0].date;

  const whereClause = `passive_type = 'ACT' AND workertype = 'DIRECT' AND category_type = 'BRAID' AND date = '${dt}' AND status = 'P'`;
  const countQuery = `
    SELECT COUNT(*) AS totalPresentCount
    FROM geopos_employees
    WHERE ${whereClause};
  `;

  db.query(countQuery, (error, countResults) => {
    if (error) {
      console.error('Error executing the count query:', error);
     
      return;
    }

    const totalCount = countResults[0].totalPresentCount;
    console.log('Total Present  Worker Count:', totalCount);
    res.send(countResults);
   
  });
});
}); 

//Get ikeja(braid) absent worker 
app.get("/fetchabsentikejabraid", (req, res) => {
  const query = `
  SELECT * FROM geopos_employees
  ORDER BY id ASC
  LIMIT 1;
`;

db.query(query, (error, results) => {
  if (error) {
    console.error('Error executing the query:', error);
   
    return;
  }

  if (results.length === 0) {
    //console.log('No records found');
   
    return;
  }

  const dt = results[0].date;

  const whereClause = `passive_type = 'ACT' AND workertype = 'DIRECT' AND category_type = 'BRAID' AND date = '${dt}' AND status = 'A'`;
  const countQuery = `
    SELECT COUNT(*) AS totalAbsentCount
    FROM geopos_employees
    WHERE ${whereClause};
  `;

  db.query(countQuery, (error, countResults) => {
    if (error) {
      console.error('Error executing the count query:', error);
     
      return;
    }

    const totalCount = countResults[0].totalAbsentCount;
    console.log('Total Absent Worker Count:', totalCount);
    res.send(countResults);
   
  });
});
}); 


//Get ikeja(nbraid) total worker 
app.get("/fetchtotalikejanbraid", (req, res) => {

  const query = `
  SELECT * FROM geopos_employees
  ORDER BY id ASC
  LIMIT 1;
`;

db.query(query, (error, results) => {
  if (error) {
    console.error('Error executing the query:', error);
   
    return;
  }

  if (results.length === 0) {
    //console.log('No records found');
   
    return;
  }

  const dt = results[0].date;

  const whereClause = `passive_type = 'ACT' AND workertype = 'DIRECT' AND category_type = 'NBRAID' AND date = '${dt}' `;
  const countQuery = `
    SELECT COUNT(*) AS totalWorkerCount
    FROM geopos_employees
    WHERE ${whereClause};
  `;

  db.query(countQuery, (error, countResults) => {
    if (error) {
      console.error('Error executing the count query:', error);
     
      return;
    }

    const totalCount = countResults[0].totalWorkerCount;
    //console.log('Total Worker Count:', totalCount);
    res.send(countResults);
   
  });
});
}); 

//Get ikeja(nbraid) present worker 
app.get("/fetchpresentikejanbraid", (req, res) => {
  const query = `
  SELECT * FROM geopos_employees
  ORDER BY id ASC
  LIMIT 1;
`;

db.query(query, (error, results) => {
  if (error) {
    console.error('Error executing the query:', error);
   
    return;
  }

  if (results.length === 0) {
    //console.log('No records found');
   
    return;
  }

  const dt = results[0].date;

  const whereClause = `passive_type = 'ACT' AND workertype = 'DIRECT' AND category_type = 'NBRAID' AND date = '${dt}' AND status = 'P'`;
  const countQuery = `
    SELECT COUNT(*) AS totalPresentCount
    FROM geopos_employees
    WHERE ${whereClause};
  `;

  db.query(countQuery, (error, countResults) => {
    if (error) {
      console.error('Error executing the count query:', error);
     
      return;
    }

    const totalCount = countResults[0].totalPresentCount;
    console.log('Total Present  Worker Count:', totalCount);
    res.send(countResults);
   
  });
});
}); 

//Get ikeja(nbraid) absent worker 
app.get("/fetchabsentikejanbraid", (req, res) => {
  const query = `
  SELECT * FROM geopos_employees
  ORDER BY id ASC
  LIMIT 1;
`;

db.query(query, (error, results) => {
  if (error) {
    console.error('Error executing the query:', error);
   
    return;
  }

  if (results.length === 0) {
    //console.log('No records found');
   
    return;
  }

  const dt = results[0].date;

  const whereClause = `passive_type = 'ACT' AND workertype = 'DIRECT' AND category_type = 'NBRAID' AND date = '${dt}' AND status = 'A'`;
  const countQuery = `
    SELECT COUNT(*) AS totalAbsentCount
    FROM geopos_employees
    WHERE ${whereClause};
  `;

  db.query(countQuery, (error, countResults) => {
    if (error) {
      console.error('Error executing the count query:', error);
     
      return;
    }

    const totalCount = countResults[0].totalAbsentCount;
    console.log('Total Absent Worker Count:', totalCount);
    res.send(countResults);
   
  });
});
}); 


// API endpoint for ota_braid_total_day
app.get('/ota_braid_total_day', (req, res) => {
  // Get the latest date from the employees_ota table
  const latestDateQuery = 'SELECT * FROM employees_ota ORDER BY id ASC LIMIT 1';
  db.query(latestDateQuery, (latestDateError, latestDateResults) => {
    if (latestDateError) {
      console.error(latestDateError);
      return res.status(500).json({ error: 'Internal Server Error' });
    }

    const latestDate = latestDateResults[0].date;

    // Query to count the total employees for the specified date and conditions
    const employeeCountQuery = `
      SELECT COUNT(*) AS totalEmployees
      FROM employees_ota
      WHERE passive_type = 'ACT'
        AND workertype = 'DIRECT'
        AND shift = 'DAY'
        AND category_type = 'BRAID'
        AND date = ?
    `;

    // Execute the query with the latest date
    db.query(employeeCountQuery, [latestDate], (employeeCountError, employeeCountResults) => {
      if (employeeCountError) {
        console.error(employeeCountError);
        return res.status(500).json({ error: 'Internal Server Error' });
      }

      const totalEmployees = employeeCountResults[0].totalEmployees;

      // Send the total employee count as the API response
      res.json({ totalEmployees });
    });
  });
});

// API endpoint for ota_braid_total_present_day
app.get('/ota_braid_total_present_day', (req, res) => {
  // Get the latest date from the employees_ota table
  const latestDateQuery = 'SELECT * FROM employees_ota ORDER BY id ASC LIMIT 1';
  db.query(latestDateQuery, (latestDateError, latestDateResults) => {
    if (latestDateError) {
      console.error(latestDateError);
      return res.status(500).json({ error: 'Internal Server Error' });
    }

    const latestDate = latestDateResults[0].date;

    // Query to count the total present employees for the specified date and conditions (day shift, BRAID category, status: P)
    const presentEmployeeCountQuery = `
      SELECT COUNT(*) AS presentEmployees
      FROM employees_ota
      WHERE passive_type = 'ACT'
        AND workertype = 'DIRECT'
        AND category_type = 'BRAID'
        AND status = 'P'
        AND shift = 'DAY'
        AND date = ?
    `;

    // Execute the query with the latest date
    db.query(presentEmployeeCountQuery, [latestDate], (presentEmployeeCountError, presentEmployeeCountResults) => {
      if (presentEmployeeCountError) {
        console.error(presentEmployeeCountError);
        return res.status(500).json({ error: 'Internal Server Error' });
      }

      const presentEmployees = presentEmployeeCountResults[0].presentEmployees;

      // Send the total present employee count as the API response
      res.json({ presentEmployees });
    });
  });
});

// API endpoint for ota_braid_total_absent_day
app.get('/ota_braid_total_absent_day', (req, res) => {
  // Get the latest date from the employees_ota table
  const latestDateQuery = 'SELECT * FROM employees_ota ORDER BY id ASC LIMIT 1';
  db.query(latestDateQuery, (latestDateError, latestDateResults) => {
    if (latestDateError) {
      console.error(latestDateError);
      return res.status(500).json({ error: 'Internal Server Error' });
    }

    const latestDate = latestDateResults[0].date;

    // Query to count the total absent employees for the specified date and conditions (day shift, BRAID category, status: A)
    const absentEmployeeCountQuery = `
      SELECT COUNT(*) AS absentEmployees
      FROM employees_ota
      WHERE passive_type = 'ACT'
        AND workertype = 'DIRECT'
        AND category_type = 'BRAID'
        AND status = 'A'
        AND shift = 'DAY'
        AND date = ?
    `;

    // Execute the query with the latest date
    db.query(absentEmployeeCountQuery, [latestDate], (absentEmployeeCountError, absentEmployeeCountResults) => {
      if (absentEmployeeCountError) {
        console.error(absentEmployeeCountError);
        return res.status(500).json({ error: 'Internal Server Error' });
      }

      const absentEmployees = absentEmployeeCountResults[0].absentEmployees;

      // Send the total absent employee count as the API response
      res.json({ absentEmployees });
    });
  });
});

// API endpoint for ota_braid_total_night
app.get('/ota_braid_total_night', (req, res) => {
  // Get the latest date from the employees_ota table
  const latestDateQuery = 'SELECT * FROM employees_ota ORDER BY id ASC LIMIT 1';
  db.query(latestDateQuery, (latestDateError, latestDateResults) => {
    if (latestDateError) {
      console.error(latestDateError);
      return res.status(500).json({ error: 'Internal Server Error' });
    }

    const latestDate = latestDateResults[0].date;

    // Query to count the total employees for the specified date and conditions (night shift)
    const employeeCountQuery = `
      SELECT COUNT(*) AS totalEmployees
      FROM employees_ota
      WHERE passive_type = 'ACT'
        AND workertype = 'DIRECT'
        AND shift = 'NIGHT'
        AND category_type = 'BRAID'
        AND date = ?
    `;

    // Execute the query with the latest date
    db.query(employeeCountQuery, [latestDate], (employeeCountError, employeeCountResults) => {
      if (employeeCountError) {
        console.error(employeeCountError);
        return res.status(500).json({ error: 'Internal Server Error' });
      }

      const totalEmployees = employeeCountResults[0].totalEmployees;

      // Send the total employee count as the API response
      res.json({ totalEmployees });
    });
  });
});

// API endpoint for ota_braid_total_present_night
app.get('/ota_braid_total_present_night', (req, res) => {
  // Get the latest date from the employees_ota table
  const latestDateQuery = 'SELECT * FROM employees_ota ORDER BY id ASC LIMIT 1';
  db.query(latestDateQuery, (latestDateError, latestDateResults) => {
    if (latestDateError) {
      console.error(latestDateError);
      return res.status(500).json({ error: 'Internal Server Error' });
    }

    const latestDate = latestDateResults[0].date;

    // Query to count the total present employees for the specified date and conditions (night shift, BRAID category, status: P)
    const presentEmployeeCountQuery = `
      SELECT COUNT(*) AS presentEmployees
      FROM employees_ota
      WHERE passive_type = 'ACT'
        AND workertype = 'DIRECT'
        AND category_type = 'BRAID'
        AND status = 'P'
        AND shift = 'NIGHT'
        AND date = ?
    `;

    // Execute the query with the latest date
    db.query(presentEmployeeCountQuery, [latestDate], (presentEmployeeCountError, presentEmployeeCountResults) => {
      if (presentEmployeeCountError) {
        console.error(presentEmployeeCountError);
        return res.status(500).json({ error: 'Internal Server Error' });
      }

      const presentEmployees = presentEmployeeCountResults[0].presentEmployees;

      // Send the total present employee count as the API response
      res.json({ presentEmployees });
    });
  });
});

// API endpoint for ota_braid_total_absent_night
app.get('/ota_braid_total_absent_night', (req, res) => {
  // Get the latest date from the employees_ota table
  const latestDateQuery = 'SELECT * FROM employees_ota ORDER BY id ASC LIMIT 1';
  db.query(latestDateQuery, (latestDateError, latestDateResults) => {
    if (latestDateError) {
      console.error(latestDateError);
      return res.status(500).json({ error: 'Internal Server Error' });
    }

    const latestDate = latestDateResults[0].date;

    // Query to count the total absent employees for the specified date and conditions (night shift, BRAID category, status: A)
    const absentEmployeeCountQuery = `
      SELECT COUNT(*) AS absentEmployees
      FROM employees_ota
      WHERE passive_type = 'ACT'
        AND workertype = 'DIRECT'
        AND category_type = 'BRAID'
        AND status = 'A'
        AND shift = 'NIGHT'
        AND date = ?
    `;

    // Execute the query with the latest date
    db.query(absentEmployeeCountQuery, [latestDate], (absentEmployeeCountError, absentEmployeeCountResults) => {
      if (absentEmployeeCountError) {
        console.error(absentEmployeeCountError);
        return res.status(500).json({ error: 'Internal Server Error' });
      }

      const absentEmployees = absentEmployeeCountResults[0].absentEmployees;

      // Send the total absent employee count as the API response
      res.json({ absentEmployees });
    });
  });
});

// API endpoint for ota_nbraid_total_day
app.get('/ota_nbraid_total_day', (req, res) => {
  // Get the latest date from the employees_ota table
  const latestDateQuery = 'SELECT * FROM employees_ota ORDER BY id ASC LIMIT 1';
  db.query(latestDateQuery, (latestDateError, latestDateResults) => {
    if (latestDateError) {
      console.error(latestDateError);
      return res.status(500).json({ error: 'Internal Server Error' });
    }

    const latestDate = latestDateResults[0].date;

    // Query to count the total employees for the specified date and conditions (day shift, NBRAID category)
    const employeeCountQuery = `
      SELECT COUNT(*) AS totalEmployees
      FROM employees_ota
      WHERE passive_type = 'ACT'
        AND workertype = 'DIRECT'
        AND shift = 'DAY'
        AND category_type = 'NBRAID'
        AND date = ?
    `;

    // Execute the query with the latest date
    db.query(employeeCountQuery, [latestDate], (employeeCountError, employeeCountResults) => {
      if (employeeCountError) {
        console.error(employeeCountError);
        return res.status(500).json({ error: 'Internal Server Error' });
      }

      const totalEmployees = employeeCountResults[0].totalEmployees;

      // Send the total employee count as the API response
      res.json({ totalEmployees });
    });
  });
});

// API endpoint for ota_nbraid_total_present_day
app.get('/ota_nbraid_total_present_day', (req, res) => {
  // Get the latest date from the employees_ota table
  const latestDateQuery = 'SELECT * FROM employees_ota ORDER BY id ASC LIMIT 1';
  db.query(latestDateQuery, (latestDateError, latestDateResults) => {
    if (latestDateError) {
      console.error(latestDateError);
      return res.status(500).json({ error: 'Internal Server Error' });
    }

    const latestDate = latestDateResults[0].date;

    // Query to count the total present employees for the specified date and conditions (day shift, NBRAID category, status: P)
    const presentEmployeeCountQuery = `
      SELECT COUNT(*) AS presentEmployees
      FROM employees_ota
      WHERE passive_type = 'ACT'
        AND workertype = 'DIRECT'
        AND category_type = 'NBRAID'
        AND status = 'P'
        AND shift = 'DAY'
        AND date = ?
    `;

    // Execute the query with the latest date
    db.query(presentEmployeeCountQuery, [latestDate], (presentEmployeeCountError, presentEmployeeCountResults) => {
      if (presentEmployeeCountError) {
        console.error(presentEmployeeCountError);
        return res.status(500).json({ error: 'Internal Server Error' });
      }

      const presentEmployees = presentEmployeeCountResults[0].presentEmployees;

      // Send the total present employee count as the API response
      res.json({ presentEmployees });
    });
  });
});

// API endpoint for ota_nbraid_total_absent_day
app.get('/ota_nbraid_total_absent_day', (req, res) => {
  // Get the latest date from the employees_ota table
  const latestDateQuery = 'SELECT * FROM employees_ota ORDER BY id ASC LIMIT 1';
  db.query(latestDateQuery, (latestDateError, latestDateResults) => {
    if (latestDateError) {
      console.error(latestDateError);
      return res.status(500).json({ error: 'Internal Server Error' });
    }

    const latestDate = latestDateResults[0].date;

    // Query to count the total absent employees for the specified date and conditions (day shift, NBRAID category, status: A)
    const absentEmployeeCountQuery = `
      SELECT COUNT(*) AS absentEmployees
      FROM employees_ota
      WHERE passive_type = 'ACT'
        AND workertype = 'DIRECT'
        AND category_type = 'NBRAID'
        AND status = 'A'
        AND shift = 'DAY'
        AND date = ?
    `;

    // Execute the query with the latest date
    db.query(absentEmployeeCountQuery, [latestDate], (absentEmployeeCountError, absentEmployeeCountResults) => {
      if (absentEmployeeCountError) {
        console.error(absentEmployeeCountError);
        return res.status(500).json({ error: 'Internal Server Error' });
      }

      const absentEmployees = absentEmployeeCountResults[0].absentEmployees;

      // Send the total absent employee count as the API response
      res.json({ absentEmployees });
    });
  });
});

// API endpoint for ota_nbraid_total_night
app.get('/ota_nbraid_total_night', (req, res) => {
  // Get the latest date from the employees_ota table
  const latestDateQuery = 'SELECT * FROM employees_ota ORDER BY id ASC LIMIT 1';
  db.query(latestDateQuery, (latestDateError, latestDateResults) => {
    if (latestDateError) {
      console.error(latestDateError);
      return res.status(500).json({ error: 'Internal Server Error' });
    }

    const latestDate = latestDateResults[0].date;

    // Query to count the total employees for the specified date and conditions (night shift, NBRAID category)
    const employeeCountQuery = `
      SELECT COUNT(*) AS totalEmployees
      FROM employees_ota
      WHERE passive_type = 'ACT'
        AND workertype = 'DIRECT'
        AND shift = 'NIGHT'
        AND category_type = 'NBRAID'
        AND date = ?
    `;

    // Execute the query with the latest date
    db.query(employeeCountQuery, [latestDate], (employeeCountError, employeeCountResults) => {
      if (employeeCountError) {
        console.error(employeeCountError);
        return res.status(500).json({ error: 'Internal Server Error' });
      }

      const totalEmployees = employeeCountResults[0].totalEmployees;

      // Send the total employee count as the API response
      res.json({ totalEmployees });
    });
  });
});

// API endpoint for ota_nbraid_total_present_night
app.get('/ota_nbraid_total_present_night', (req, res) => {
  // Get the latest date from the employees_ota table
  const latestDateQuery = 'SELECT * FROM employees_ota ORDER BY id ASC LIMIT 1';
  db.query(latestDateQuery, (latestDateError, latestDateResults) => {
    if (latestDateError) {
      console.error(latestDateError);
      return res.status(500).json({ error: 'Internal Server Error' });
    }

    const latestDate = latestDateResults[0].date;

    // Query to count the total present employees for the specified date and conditions (night shift, NBRAID category, status: P)
    const presentEmployeeCountQuery = `
      SELECT COUNT(*) AS presentEmployees
      FROM employees_ota
      WHERE passive_type = 'ACT'
        AND workertype = 'DIRECT'
        AND category_type = 'NBRAID'
        AND status = 'P'
        AND shift = 'NIGHT'
        AND date = ?
    `;

    // Execute the query with the latest date
    db.query(presentEmployeeCountQuery, [latestDate], (presentEmployeeCountError, presentEmployeeCountResults) => {
      if (presentEmployeeCountError) {
        console.error(presentEmployeeCountError);
        return res.status(500).json({ error: 'Internal Server Error' });
      }

      const presentEmployees = presentEmployeeCountResults[0].presentEmployees;

      // Send the total present employee count as the API response
      res.json({ presentEmployees });
    });
  });
});

// API endpoint for ota_nbraid_total_absent_night
app.get('/ota_nbraid_total_absent_night', (req, res) => {
  // Get the latest date from the employees_ota table
  const latestDateQuery = 'SELECT * FROM employees_ota ORDER BY id ASC LIMIT 1';
  db.query(latestDateQuery, (latestDateError, latestDateResults) => {
    if (latestDateError) {
      console.error(latestDateError);
      return res.status(500).json({ error: 'Internal Server Error' });
    }

    const latestDate = latestDateResults[0].date;

    // Query to count the total absent employees for the specified date and conditions (night shift, NBRAID category, status: A)
    const absentEmployeeCountQuery = `
      SELECT COUNT(*) AS absentEmployees
      FROM employees_ota
      WHERE passive_type = 'ACT'
        AND workertype = 'DIRECT'
        AND category_type = 'NBRAID'
        AND status = 'A'
        AND shift = 'NIGHT'
        AND date = ?
    `;

    // Execute the query with the latest date
    db.query(absentEmployeeCountQuery, [latestDate], (absentEmployeeCountError, absentEmployeeCountResults) => {
      if (absentEmployeeCountError) {
        console.error(absentEmployeeCountError);
        return res.status(500).json({ error: 'Internal Server Error' });
      }

      const absentEmployees = absentEmployeeCountResults[0].absentEmployees;

      // Send the total absent employee count as the API response
      res.json({ absentEmployees });
    });
  });
});

  // API endpoint for ikeja_braid_total_day
  app.get('/ikeja_braid_total_day', (req, res) => {
    // Get the latest date from the geopos_employees table
    const latestDateQuery = 'SELECT * FROM geopos_employees ORDER BY id ASC LIMIT 1';
    db.query(latestDateQuery, (latestDateError, latestDateResults) => {
      if (latestDateError) {
        console.error(latestDateError);
        return res.status(500).json({ error: 'Internal Server Error' });
      }
  
      const latestDate = latestDateResults[0].date;
  
      // Query to count the total employees for the specified date and conditions
      const employeeCountQuery = `
        SELECT COUNT(*) AS totalEmployees
        FROM geopos_employees
        WHERE passive_type = 'ACT'
          AND workertype = 'DIRECT'
          AND shift = 'DAY'
          AND category_type = 'BRAID'
          AND date = ?
      `;
  
      // Execute the query with the latest date
      db.query(employeeCountQuery, [latestDate], (employeeCountError, employeeCountResults) => {
        if (employeeCountError) {
          console.error(employeeCountError);
          return res.status(500).json({ error: 'Internal Server Error' });
        }
  
        const totalEmployees = employeeCountResults[0].totalEmployees;
  
        // Send the total employee count as the API response
        res.json({ totalEmployees });
      });
    });
  });
  
  // API endpoint for ikeja_braid_total_present_day
  app.get('/ikeja_braid_total_present_day', (req, res) => {
    // Get the latest date from the geopos_employees table
    const latestDateQuery = 'SELECT * FROM geopos_employees ORDER BY id ASC LIMIT 1';
    db.query(latestDateQuery, (latestDateError, latestDateResults) => {
      if (latestDateError) {
        console.error(latestDateError);
        return res.status(500).json({ error: 'Internal Server Error' });
      }
  
      const latestDate = latestDateResults[0].date;
  
      // Query to count the total present employees for the specified date and conditions (day shift, BRAID category, status: P)
      const presentEmployeeCountQuery = `
        SELECT COUNT(*) AS presentEmployees
        FROM geopos_employees
        WHERE passive_type = 'ACT'
          AND workertype = 'DIRECT'
          AND category_type = 'BRAID'
          AND status = 'P'
          AND shift = 'DAY'
          AND date = ?
      `;
  
      // Execute the query with the latest date
      db.query(presentEmployeeCountQuery, [latestDate], (presentEmployeeCountError, presentEmployeeCountResults) => {
        if (presentEmployeeCountError) {
          console.error(presentEmployeeCountError);
          return res.status(500).json({ error: 'Internal Server Error' });
        }
  
        const presentEmployees = presentEmployeeCountResults[0].presentEmployees;
  
        // Send the total present employee count as the API response
        res.json({ presentEmployees });
      });
    });
  });
  
  // API endpoint for ikeja_braid_total_absent_day
  app.get('/ikeja_braid_total_absent_day', (req, res) => {
    // Get the latest date from the geopos_employees table
    const latestDateQuery = 'SELECT * FROM geopos_employees ORDER BY id ASC LIMIT 1';
    db.query(latestDateQuery, (latestDateError, latestDateResults) => {
      if (latestDateError) {
        console.error(latestDateError);
        return res.status(500).json({ error: 'Internal Server Error' });
      }
  
      const latestDate = latestDateResults[0].date;
  
      // Query to count the total absent employees for the specified date and conditions (day shift, BRAID category, status: A)
      const absentEmployeeCountQuery = `
        SELECT COUNT(*) AS absentEmployees
        FROM geopos_employees
        WHERE passive_type = 'ACT'
          AND workertype = 'DIRECT'
          AND category_type = 'BRAID'
          AND status = 'A'
          AND shift = 'DAY'
          AND date = ?
      `;
  
      // Execute the query with the latest date
      db.query(absentEmployeeCountQuery, [latestDate], (absentEmployeeCountError, absentEmployeeCountResults) => {
        if (absentEmployeeCountError) {
          console.error(absentEmployeeCountError);
          return res.status(500).json({ error: 'Internal Server Error' });
        }
  
        const absentEmployees = absentEmployeeCountResults[0].absentEmployees;
  
        // Send the total absent employee count as the API response
        res.json({ absentEmployees });
      });
    });
  });
  
  // API endpoint for ikeja_braid_total_night
  app.get('/ikeja_braid_total_night', (req, res) => {
    // Get the latest date from the geopos_employees table
    const latestDateQuery = 'SELECT * FROM geopos_employees ORDER BY id ASC LIMIT 1';
    db.query(latestDateQuery, (latestDateError, latestDateResults) => {
      if (latestDateError) {
        console.error(latestDateError);
        return res.status(500).json({ error: 'Internal Server Error' });
      }
  
      const latestDate = latestDateResults[0].date;
  
      // Query to count the total employees for the specified date and conditions (night shift)
      const employeeCountQuery = `
        SELECT COUNT(*) AS totalEmployees
        FROM geopos_employees
        WHERE passive_type = 'ACT'
          AND workertype = 'DIRECT'
          AND shift = 'NIGHT'
          AND category_type = 'BRAID'
          AND date = ?
      `;
  
      // Execute the query with the latest date
      db.query(employeeCountQuery, [latestDate], (employeeCountError, employeeCountResults) => {
        if (employeeCountError) {
          console.error(employeeCountError);
          return res.status(500).json({ error: 'Internal Server Error' });
        }
  
        const totalEmployees = employeeCountResults[0].totalEmployees;
  
        // Send the total employee count as the API response
        res.json({ totalEmployees });
      });
    });
  });
  
  // API endpoint for ikeja_braid_total_present_night
  app.get('/ikeja_braid_total_present_night', (req, res) => {
    // Get the latest date from the geopos_employees table
    const latestDateQuery = 'SELECT * FROM geopos_employees ORDER BY id ASC LIMIT 1';
    db.query(latestDateQuery, (latestDateError, latestDateResults) => {
      if (latestDateError) {
        console.error(latestDateError);
        return res.status(500).json({ error: 'Internal Server Error' });
      }
  
      const latestDate = latestDateResults[0].date;
  
      // Query to count the total present employees for the specified date and conditions (night shift, BRAID category, status: P)
      const presentEmployeeCountQuery = `
        SELECT COUNT(*) AS presentEmployees
        FROM geopos_employees
        WHERE passive_type = 'ACT'
          AND workertype = 'DIRECT'
          AND category_type = 'BRAID'
          AND status = 'P'
          AND shift = 'NIGHT'
          AND date = ?
      `;
  
      // Execute the query with the latest date
      db.query(presentEmployeeCountQuery, [latestDate], (presentEmployeeCountError, presentEmployeeCountResults) => {
        if (presentEmployeeCountError) {
          console.error(presentEmployeeCountError);
          return res.status(500).json({ error: 'Internal Server Error' });
        }
  
        const presentEmployees = presentEmployeeCountResults[0].presentEmployees;
  
        // Send the total present employee count as the API response
        res.json({ presentEmployees });
      });
    });
  });
  
  // API endpoint for ikeja_braid_total_absent_night
  app.get('/ikeja_braid_total_absent_night', (req, res) => {
    // Get the latest date from the geopos_employees table
    const latestDateQuery = 'SELECT * FROM geopos_employees ORDER BY id ASC LIMIT 1';
    db.query(latestDateQuery, (latestDateError, latestDateResults) => {
      if (latestDateError) {
        console.error(latestDateError);
        return res.status(500).json({ error: 'Internal Server Error' });
      }
  
      const latestDate = latestDateResults[0].date;
  
      // Query to count the total absent employees for the specified date and conditions (night shift, BRAID category, status: A)
      const absentEmployeeCountQuery = `
        SELECT COUNT(*) AS absentEmployees
        FROM geopos_employees
        WHERE passive_type = 'ACT'
          AND workertype = 'DIRECT'
          AND category_type = 'BRAID'
          AND status = 'A'
          AND shift = 'NIGHT'
          AND date = ?
      `;
  
      // Execute the query with the latest date
      db.query(absentEmployeeCountQuery, [latestDate], (absentEmployeeCountError, absentEmployeeCountResults) => {
        if (absentEmployeeCountError) {
          console.error(absentEmployeeCountError);
          return res.status(500).json({ error: 'Internal Server Error' });
        }
  
        const absentEmployees = absentEmployeeCountResults[0].absentEmployees;
  
        // Send the total absent employee count as the API response
        res.json({ absentEmployees });
      });
    });
  });
  
  // API endpoint for ikeja_nbraid_total_day
  app.get('/ikeja_nbraid_total_day', (req, res) => {
    // Get the latest date from the geopos_employees table
    const latestDateQuery = 'SELECT * FROM geopos_employees ORDER BY id ASC LIMIT 1';
    db.query(latestDateQuery, (latestDateError, latestDateResults) => {
      if (latestDateError) {
        console.error(latestDateError);
        return res.status(500).json({ error: 'Internal Server Error' });
      }
  
      const latestDate = latestDateResults[0].date;
  
      // Query to count the total employees for the specified date and conditions (day shift, NBRAID category)
      const employeeCountQuery = `
        SELECT COUNT(*) AS totalEmployees
        FROM geopos_employees
        WHERE passive_type = 'ACT'
          AND workertype = 'DIRECT'
          AND shift = 'DAY'
          AND category_type = 'NBRAID'
          AND date = ?
      `;
  
      // Execute the query with the latest date
      db.query(employeeCountQuery, [latestDate], (employeeCountError, employeeCountResults) => {
        if (employeeCountError) {
          console.error(employeeCountError);
          return res.status(500).json({ error: 'Internal Server Error' });
        }
  
        const totalEmployees = employeeCountResults[0].totalEmployees;
  
        // Send the total employee count as the API response
        res.json({ totalEmployees });
      });
    });
  });
  
  // API endpoint for ikeja_nbraid_total_present_day
  app.get('/ikeja_nbraid_total_present_day', (req, res) => {
    // Get the latest date from the geopos_employees table
    const latestDateQuery = 'SELECT * FROM geopos_employees ORDER BY id ASC LIMIT 1';
    db.query(latestDateQuery, (latestDateError, latestDateResults) => {
      if (latestDateError) {
        console.error(latestDateError);
        return res.status(500).json({ error: 'Internal Server Error' });
      }
  
      const latestDate = latestDateResults[0].date;
  
      // Query to count the total present employees for the specified date and conditions (day shift, NBRAID category, status: P)
      const presentEmployeeCountQuery = `
        SELECT COUNT(*) AS presentEmployees
        FROM geopos_employees
        WHERE passive_type = 'ACT'
          AND workertype = 'DIRECT'
          AND category_type = 'NBRAID'
          AND status = 'P'
          AND shift = 'DAY'
          AND date = ?
      `;
  
      // Execute the query with the latest date
      db.query(presentEmployeeCountQuery, [latestDate], (presentEmployeeCountError, presentEmployeeCountResults) => {
        if (presentEmployeeCountError) {
          console.error(presentEmployeeCountError);
          return res.status(500).json({ error: 'Internal Server Error' });
        }
  
        const presentEmployees = presentEmployeeCountResults[0].presentEmployees;
  
        // Send the total present employee count as the API response
        res.json({ presentEmployees });
      });
    });
  });
  
  // API endpoint for ikeja_nbraid_total_absent_day
  app.get('/ikeja_nbraid_total_absent_day', (req, res) => {
    // Get the latest date from the geopos_employees table
    const latestDateQuery = 'SELECT * FROM geopos_employees ORDER BY id ASC LIMIT 1';
    db.query(latestDateQuery, (latestDateError, latestDateResults) => {
      if (latestDateError) {
        console.error(latestDateError);
        return res.status(500).json({ error: 'Internal Server Error' });
      }
  
      const latestDate = latestDateResults[0].date;
  
      // Query to count the total absent employees for the specified date and conditions (day shift, NBRAID category, status: A)
      const absentEmployeeCountQuery = `
        SELECT COUNT(*) AS absentEmployees
        FROM geopos_employees
        WHERE passive_type = 'ACT'
          AND workertype = 'DIRECT'
          AND category_type = 'NBRAID'
          AND status = 'A'
          AND shift = 'DAY'
          AND date = ?
      `;
  
      // Execute the query with the latest date
      db.query(absentEmployeeCountQuery, [latestDate], (absentEmployeeCountError, absentEmployeeCountResults) => {
        if (absentEmployeeCountError) {
          console.error(absentEmployeeCountError);
          return res.status(500).json({ error: 'Internal Server Error' });
        }
  
        const absentEmployees = absentEmployeeCountResults[0].absentEmployees;
  
        // Send the total absent employee count as the API response
        res.json({ absentEmployees });
      });
    });
  });
  
  // API endpoint for ikeja_nbraid_total_night
  app.get('/ikeja_nbraid_total_night', (req, res) => {
    // Get the latest date from the geopos_employees table
    const latestDateQuery = 'SELECT * FROM geopos_employees ORDER BY id ASC LIMIT 1';
    db.query(latestDateQuery, (latestDateError, latestDateResults) => {
      if (latestDateError) {
        console.error(latestDateError);
        return res.status(500).json({ error: 'Internal Server Error' });
      }
  
      const latestDate = latestDateResults[0].date;
  
      // Query to count the total employees for the specified date and conditions (night shift, NBRAID category)
      const employeeCountQuery = `
        SELECT COUNT(*) AS totalEmployees
        FROM geopos_employees
        WHERE passive_type = 'ACT'
          AND workertype = 'DIRECT'
          AND shift = 'NIGHT'
          AND category_type = 'NBRAID'
          AND date = ?
      `;
  
      // Execute the query with the latest date
      db.query(employeeCountQuery, [latestDate], (employeeCountError, employeeCountResults) => {
        if (employeeCountError) {
          console.error(employeeCountError);
          return res.status(500).json({ error: 'Internal Server Error' });
        }
  
        const totalEmployees = employeeCountResults[0].totalEmployees;
  
        // Send the total employee count as the API response
        res.json({ totalEmployees });
      });
    });
  });
  
  // API endpoint for ikeja_nbraid_total_present_night
  app.get('/ikeja_nbraid_total_present_night', (req, res) => {
    // Get the latest date from the geopos_employees table
    const latestDateQuery = 'SELECT * FROM geopos_employees ORDER BY id ASC LIMIT 1';
    db.query(latestDateQuery, (latestDateError, latestDateResults) => {
      if (latestDateError) {
        console.error(latestDateError);
        return res.status(500).json({ error: 'Internal Server Error' });
      }
  
      const latestDate = latestDateResults[0].date;
  
      // Query to count the total present employees for the specified date and conditions (night shift, NBRAID category, status: P)
      const presentEmployeeCountQuery = `
        SELECT COUNT(*) AS presentEmployees
        FROM geopos_employees
        WHERE passive_type = 'ACT'
          AND workertype = 'DIRECT'
          AND category_type = 'NBRAID'
          AND status = 'P'
          AND shift = 'NIGHT'
          AND date = ?
      `;
  
      // Execute the query with the latest date
      db.query(presentEmployeeCountQuery, [latestDate], (presentEmployeeCountError, presentEmployeeCountResults) => {
        if (presentEmployeeCountError) {
          console.error(presentEmployeeCountError);
          return res.status(500).json({ error: 'Internal Server Error' });
        }
  
        const presentEmployees = presentEmployeeCountResults[0].presentEmployees;
  
        // Send the total present employee count as the API response
        res.json({ presentEmployees });
      });
    });
  });
  
  // API endpoint for ikeja_nbraid_total_absent_night
  app.get('/ikeja_nbraid_total_absent_night', (req, res) => {
    // Get the latest date from the geopos_employees table
    const latestDateQuery = 'SELECT * FROM geopos_employees ORDER BY id ASC LIMIT 1';
    db.query(latestDateQuery, (latestDateError, latestDateResults) => {
      if (latestDateError) {
        console.error(latestDateError);
        return res.status(500).json({ error: 'Internal Server Error' });
      }
  
      const latestDate = latestDateResults[0].date;
  
      // Query to count the total absent employees for the specified date and conditions (night shift, NBRAID category, status: A)
      const absentEmployeeCountQuery = `
        SELECT COUNT(*) AS absentEmployees
        FROM geopos_employees
        WHERE passive_type = 'ACT'
          AND workertype = 'DIRECT'
          AND category_type = 'NBRAID'
          AND status = 'A'
          AND shift = 'NIGHT'
          AND date = ?
      `;
  
      // Execute the query with the latest date
      db.query(absentEmployeeCountQuery, [latestDate], (absentEmployeeCountError, absentEmployeeCountResults) => {
        if (absentEmployeeCountError) {
          console.error(absentEmployeeCountError);
          return res.status(500).json({ error: 'Internal Server Error' });
        }
  
        const absentEmployees = absentEmployeeCountResults[0].absentEmployees;
  
        // Send the total absent employee count as the API response
        res.json({ absentEmployees });
      });
    });
  });


// API endpoint for braid_daywise_active_employees_staff
app.get('/braid_daywise_active_employees_staff', (req, res) => {
  // Use a parameterized query to avoid SQL injection
  const query1 = `
    SELECT COUNT(*) AS employee_count
    FROM geopos_employees
    WHERE passive_type = 'ACT'
      AND workertype = 'DIRECT'
      AND employee_type = 'Staff'
      AND category_type = 'BRAID'
  `;

  const query2 = `
    SELECT COUNT(*) AS employee_count
    FROM employees_ota
    WHERE passive_type = 'ACT'
      AND workertype = 'DIRECT'
      AND employee_type = 'Staff'
      AND category_type = 'BRAID'
  `;

  // Execute the queries using the connection pool
  db.query(query1, (error, results1) => {
    if (error) {
      console.error(error);
      res.status(500).json({ error: 'Internal Server Error' });
      return;
    }

    db.query(query2, (err, results2) => {
      if (err) {
        console.error(err);
        res.status(500).json({ error: 'Internal Server Error' });
        return;
      }

      // Extract the counts from the results
      const employeeCount1 = results1[0].employee_count;
      const employeeCount2 = results2[0].employee_count;

      // Calculate the total employee count and send it as the API response
      const totalEmployeeCount = employeeCount1 + employeeCount2;
      res.json({ totalEmployeeCount });
    });
  });
});

// API endpoint for braid_daywise_active_employees_staff_present
app.get('/braid_daywise_active_employees_staff_present', (req, res) => {
  // Use a parameterized query to avoid SQL injection
  const query1 = `
    SELECT COUNT(*) AS employee_count
    FROM geopos_employees
    WHERE passive_type = 'ACT'
      AND workertype = 'DIRECT'
      AND status = 'P'
      AND employee_type = 'Staff'
      AND category_type = 'BRAID'
  `;

  const query2 = `
    SELECT COUNT(*) AS employee_count
    FROM employees_ota
    WHERE passive_type = 'ACT'
      AND workertype = 'DIRECT'
      AND status = 'P'
      AND employee_type = 'Staff'
      AND category_type = 'BRAID'
  `;

  // Execute the queries using the connection pool
  db.query(query1, (error, results1) => {
    if (error) {
      console.error(error);
      res.status(500).json({ error: 'Internal Server Error' });
      return;
    }

    db.query(query2, (err, results2) => {
      if (err) {
        console.error(err);
        res.status(500).json({ error: 'Internal Server Error' });
        return;
      }

      // Extract the counts from the results
      const employeeCount1 = results1[0].employee_count;
      const employeeCount2 = results2[0].employee_count;

      // Calculate the total employee count and send it as the API response
      const totalEmployeeCount = employeeCount1 + employeeCount2;
      res.json({ totalEmployeeCount });
    });
  });
});


// API endpoint for braid_daywise_active_employees_staff_absent
app.get('/braid_daywise_active_employees_staff_absent', (req, res) => {
  // Use a parameterized query to avoid SQL injection
  const query1 = `
    SELECT COUNT(*) AS employee_count
    FROM geopos_employees
    WHERE passive_type = 'ACT'
      AND workertype = 'DIRECT'
      AND status = 'A'
      AND employee_type = 'Staff'
      AND category_type = 'BRAID'
  `;

  const query2 = `
    SELECT COUNT(*) AS employee_count
    FROM employees_ota
    WHERE passive_type = 'ACT'
      AND workertype = 'DIRECT'
      AND status = 'A'
      AND employee_type = 'Staff'
      AND category_type = 'BRAID'
  `;

  // Execute the queries using the connection pool
  db.query(query1, (error, results1) => {
    if (error) {
      console.error(error);
      res.status(500).json({ error: 'Internal Server Error' });
      return;
    }

    db.query(query2, (err, results2) => {
      if (err) {
        console.error(err);
        res.status(500).json({ error: 'Internal Server Error' });
        return;
      }

      // Extract the counts from the results
      const employeeCount1 = results1[0].employee_count;
      const employeeCount2 = results2[0].employee_count;

      // Calculate the total employee count and send it as the API response
      const totalEmployeeCount = employeeCount1 + employeeCount2;
      res.json({ totalEmployeeCount });
    });
  });
});

// API endpoint for braid_daywise_active_employees_contract
app.get('/braid_daywise_active_employees_contract', (req, res) => {
  const query1 = `
    SELECT COUNT(*) AS employee_count
    FROM geopos_employees
    WHERE passive_type = 'ACT'
      AND workertype = 'DIRECT'
      AND employee_type = 'Contract'
      AND category_type = 'BRAID'
  `;

  const query2 = `
    SELECT COUNT(*) AS employee_count
    FROM employees_ota
    WHERE passive_type = 'ACT'
      AND workertype = 'DIRECT'
      AND employee_type = 'Contract'
      AND category_type = 'BRAID'
  `;

  db.query(query1, (error, results1) => {
    if (error) {
      console.error(error);
      res.status(500).json({ error: 'Internal Server Error' });
      return;
    }

    db.query(query2, (err, results2) => {
      if (err) {
        console.error(err);
        res.status(500).json({ error: 'Internal Server Error' });
        return;
      }

      const employeeCount1 = results1[0].employee_count;
      const employeeCount2 = results2[0].employee_count;
      const totalEmployeeCount = employeeCount1 + employeeCount2;

      res.json({ totalEmployeeCount });
    });
  });
});

// API endpoint for braid_daywise_active_employees_contract_present
app.get('/braid_daywise_active_employees_contract_present', (req, res) => {
  const query1 = `
    SELECT COUNT(*) AS employee_count
    FROM geopos_employees
    WHERE passive_type = 'ACT'
      AND workertype = 'DIRECT'
      AND status = 'P'
      AND employee_type = 'Contract'
      AND category_type = 'BRAID'
  `;

  const query2 = `
    SELECT COUNT(*) AS employee_count
    FROM employees_ota
    WHERE passive_type = 'ACT'
      AND workertype = 'DIRECT'
      AND status = 'P'
      AND employee_type = 'Contract'
      AND category_type = 'BRAID'
  `;

  db.query(query1, (error, results1) => {
    if (error) {
      console.error(error);
      res.status(500).json({ error: 'Internal Server Error' });
      return;
    }

    db.query(query2, (err, results2) => {
      if (err) {
        console.error(err);
        res.status(500).json({ error: 'Internal Server Error' });
        return;
      }

      const employeeCount1 = results1[0].employee_count;
      const employeeCount2 = results2[0].employee_count;
      const totalEmployeeCount = employeeCount1 + employeeCount2;

      res.json({ totalEmployeeCount });
    });
  });
});

// API endpoint for braid_daywise_active_employees_contract_absent
app.get('/braid_daywise_active_employees_contract_absent', (req, res) => {
  const query1 = `
    SELECT COUNT(*) AS employee_count
    FROM geopos_employees
    WHERE passive_type = 'ACT'
      AND workertype = 'DIRECT'
      AND status = 'A'
      AND employee_type = 'Contract'
      AND category_type = 'BRAID'
  `;

  const query2 = `
    SELECT COUNT(*) AS employee_count
    FROM employees_ota
    WHERE passive_type = 'ACT'
      AND workertype = 'DIRECT'
      AND status = 'A'
      AND employee_type = 'Contract'
      AND category_type = 'BRAID'
  `;

  db.query(query1, (error, results1) => {
    if (error) {
      console.error(error);
      res.status(500).json({ error: 'Internal Server Error' });
      return;
    }

    db.query(query2, (err, results2) => {
      if (err) {
        console.error(err);
        res.status(500).json({ error: 'Internal Server Error' });
        return;
      }

      const employeeCount1 = results1[0].employee_count;
      const employeeCount2 = results2[0].employee_count;
      const totalEmployeeCount = employeeCount1 + employeeCount2;

      res.json({ totalEmployeeCount });
    });
  });
});

// API endpoint for braid_daywise_active_employees_casual
app.get('/braid_daywise_active_employees_casual', (req, res) => {
  const query1 = `
    SELECT COUNT(*) AS employee_count
    FROM geopos_employees
    WHERE passive_type = 'ACT'
      AND workertype = 'DIRECT'
      AND employee_type = 'Casual'
      AND category_type = 'BRAID'
  `;

  const query2 = `
    SELECT COUNT(*) AS employee_count
    FROM employees_ota
    WHERE passive_type = 'ACT'
      AND workertype = 'DIRECT'
      AND employee_type = 'Casual'
      AND category_type = 'BRAID'
  `;

  db.query(query1, (error, results1) => {
    if (error) {
      console.error(error);
      res.status(500).json({ error: 'Internal Server Error' });
      return;
    }

    db.query(query2, (err, results2) => {
      if (err) {
        console.error(err);
        res.status(500).json({ error: 'Internal Server Error' });
        return;
      }

      const employeeCount1 = results1[0].employee_count;
      const employeeCount2 = results2[0].employee_count;
      const totalEmployeeCount = employeeCount1 + employeeCount2;

      res.json({ totalEmployeeCount });
    });
  });
});

// API endpoint for braid_daywise_active_employees_casual_present
app.get('/braid_daywise_active_employees_casual_present', (req, res) => {
  const query1 = `
    SELECT COUNT(*) AS employee_count
    FROM geopos_employees
    WHERE passive_type = 'ACT'
      AND workertype = 'DIRECT'
      AND status = 'P'
      AND employee_type = 'Casual'
      AND category_type = 'BRAID'
  `;

  const query2 = `
    SELECT COUNT(*) AS employee_count
    FROM employees_ota
    WHERE passive_type = 'ACT'
      AND workertype = 'DIRECT'
      AND status = 'P'
      AND employee_type = 'Casual'
      AND category_type = 'BRAID'
  `;

  db.query(query1, (error, results1) => {
    if (error) {
      console.error(error);
      res.status(500).json({ error: 'Internal Server Error' });
      return;
    }

    db.query(query2, (err, results2) => {
      if (err) {
        console.error(err);
        res.status(500).json({ error: 'Internal Server Error' });
        return;
      }

      const employeeCount1 = results1[0].employee_count;
      const employeeCount2 = results2[0].employee_count;
      const totalEmployeeCount = employeeCount1 + employeeCount2;

      res.json({ totalEmployeeCount });
    });
  });
});


// API endpoint for braid_daywise_active_employees_casual_absent
app.get('/braid_daywise_active_employees_casual_absent', (req, res) => {
  // Use a parameterized query to avoid SQL injection
  const query1 = `
    SELECT COUNT(*) AS employee_count
    FROM geopos_employees
    WHERE passive_type = 'ACT'
      AND workertype = 'DIRECT'
      AND status = 'A'
      AND employee_type = 'Casual'
      AND category_type = 'BRAID'
  `;

  const query2 = `
    SELECT COUNT(*) AS employee_count
    FROM employees_ota
    WHERE passive_type = 'ACT'
      AND workertype = 'DIRECT'
      AND status = 'A'
      AND employee_type = 'Casual'
      AND category_type = 'BRAID'
  `;

  // Execute the queries using the connection pool
  db.query(query1, (error, results1) => {
    if (error) {
      console.error(error);
      res.status(500).json({ error: 'Internal Server Error' });
      return;
    }

    db.query(query2, (err, results2) => {
      if (err) {
        console.error(err);
        res.status(500).json({ error: 'Internal Server Error' });
        return;
      }

      // Extract the counts from the results
      const employeeCount1 = results1[0].employee_count;
      const employeeCount2 = results2[0].employee_count;

      // Calculate the total employee count and send it as the API response
      const totalEmployeeCount = employeeCount1 + employeeCount2;
      res.json({ totalEmployeeCount });
    });
  });
});

//API endpoint for braid_daywise_active_employees_outsourcing
app.get('/braid_daywise_active_employees_outsourcing', (req, res) => {
  // Use a parameterized query to avoid SQL injection
  const query1 = `
    SELECT COUNT(*) AS employee_count
    FROM geopos_employees
    WHERE passive_type = 'ACT'
      AND workertype = 'DIRECT'
      AND employee_type = 'Outsourcing'
      AND category_type = 'BRAID'
  `;

  const query2 = `
    SELECT COUNT(*) AS employee_count
    FROM employees_ota
    WHERE passive_type = 'ACT'
      AND workertype = 'DIRECT'
      AND employee_type = 'Outsourcing'
      AND category_type = 'BRAID'
  `;

  // Execute the queries using the connection pool
  db.query(query1, (error, results1) => {
    if (error) {
      console.error(error);
      res.status(500).json({ error: 'Internal Server Error' });
      return;
    }

    db.query(query2, (err, results2) => {
      if (err) {
        console.error(err);
        res.status(500).json({ error: 'Internal Server Error' });
        return;
      }

      // Extract the counts from the results
      const employeeCount1 = results1[0].employee_count;
      const employeeCount2 = results2[0].employee_count;

      // Calculate the total employee count and send it as the API response
      const totalEmployeeCount = employeeCount1 + employeeCount2;
      res.json({ totalEmployeeCount });
    });
  });
});

// API endpoint for braid_daywise_active_employees_outsourcing_present
app.get('/braid_daywise_active_employees_outsourcing_present', (req, res) => {
  // Use a parameterized query to avoid SQL injection
  const query1 = `
    SELECT COUNT(*) AS employee_count
    FROM geopos_employees
    WHERE passive_type = 'ACT'
      AND workertype = 'DIRECT'
      AND status = 'P'
      AND employee_type = 'Outsourcing'
      AND category_type = 'BRAID'
  `;

  const query2 = `
    SELECT COUNT(*) AS employee_count
    FROM employees_ota
    WHERE passive_type = 'ACT'
      AND workertype = 'DIRECT'
      AND status = 'P'
      AND employee_type = 'Outsourcing'
      AND category_type = 'BRAID'
  `;

  // Execute the queries using the connection pool
  db.query(query1, (error, results1) => {
    if (error) {
      console.error(error);
      res.status(500).json({ error: 'Internal Server Error' });
      return;
    }

    db.query(query2, (err, results2) => {
      if (err) {
        console.error(err);
        res.status(500).json({ error: 'Internal Server Error' });
        return;
      }

      // Extract the counts from the results
      const employeeCount1 = results1[0].employee_count;
      const employeeCount2 = results2[0].employee_count;

      // Calculate the total employee count and send it as the API response
      const totalEmployeeCount = employeeCount1 + employeeCount2;
      res.json({ totalEmployeeCount });
    });
  });
});

//API endpoint for braid_daywise_active_employees_outsourcing_absent
app.get('/braid_daywise_active_employees_outsourcing_absent', (req, res) => {
  // Use a parameterized query to avoid SQL injection
  const query1 = `
    SELECT COUNT(*) AS employee_count
    FROM geopos_employees
    WHERE passive_type = 'ACT'
      AND workertype = 'DIRECT'
      AND status = 'A'
      AND employee_type = 'Outsourcing'
      AND category_type = 'BRAID'
  `;

  const query2 = `
    SELECT COUNT(*) AS employee_count
    FROM employees_ota
    WHERE passive_type = 'ACT'
      AND workertype = 'DIRECT'
      AND status = 'A'
      AND employee_type = 'Outsourcing'
      AND category_type = 'BRAID'
  `;

  // Execute the queries using the connection pool
  db.query(query1, (error, results1) => {
    if (error) {
      console.error(error);
      res.status(500).json({ error: 'Internal Server Error' });
      return;
    }

    db.query(query2, (err, results2) => {
      if (err) {
        console.error(err);
        res.status(500).json({ error: 'Internal Server Error' });
        return;
      }

      // Extract the counts from the results
      const employeeCount1 = results1[0].employee_count;
      const employeeCount2 = results2[0].employee_count;

      // Calculate the total employee count and send it as the API response
      const totalEmployeeCount = employeeCount1 + employeeCount2;
      res.json({ totalEmployeeCount });
    });
  });
});




// API endpoint for nbraid_daywise_active_employess_staff
app.get('/nbraid_daywise_active_employees_staff', (req, res) => {
  // Use a parameterized query to avoid SQL injection
  const query1 = `
    SELECT COUNT(*) AS employee_count
    FROM geopos_employees
    WHERE passive_type = 'ACT'
      AND workertype = 'DIRECT'
      AND employee_type = 'Staff'
      AND category_type = 'NBRAID'
  `;

  const query2 = `
    SELECT COUNT(*) AS employee_count
    FROM employees_ota
    WHERE passive_type = 'ACT'
      AND workertype = 'DIRECT'
      AND employee_type = 'Staff'
      AND category_type = 'NBRAID'
  `;

  // Execute the queries using the connection pool
  db.query(query1, (error, results1) => {
    if (error) {
      console.error(error);
      res.status(500).json({ error: 'Internal Server Error' });
      return;
    }

    db.query(query2, (err, results2) => {
      if (err) {
        console.error(err);
        res.status(500).json({ error: 'Internal Server Error' });
        return;
      }

      // Extract the counts from the results
      const employeeCount1 = results1[0].employee_count;
      const employeeCount2 = results2[0].employee_count;

      // Calculate the total employee count and send it as the API response
      const totalEmployeeCount = employeeCount1 + employeeCount2;
      res.json({ totalEmployeeCount });
    });
  });
});

// API endpoint for nbraid_daywise_active_employess_staff_present
app.get('/nbraid_daywise_active_employees_staff_present', (req, res) => {
  // Use a parameterized query to avoid SQL injection
  const query1 = `
    SELECT COUNT(*) AS employee_count
    FROM geopos_employees
    WHERE passive_type = 'ACT'
      AND workertype = 'DIRECT'
      AND status = 'P'
      AND employee_type = 'Staff'
      AND category_type = 'NBRAID'
  `;

  const query2 = `
    SELECT COUNT(*) AS employee_count
    FROM employees_ota
    WHERE passive_type = 'ACT'
      AND workertype = 'DIRECT'
      AND status = 'P'
      AND employee_type = 'Staff'
      AND category_type = 'NBRAID'
  `;

  // Execute the queries using the connection pool
  db.query(query1, (error, results1) => {
    if (error) {
      console.error(error);
      res.status(500).json({ error: 'Internal Server Error' });
      return;
    }

    db.query(query2, (err, results2) => {
      if (err) {
        console.error(err);
        res.status(500).json({ error: 'Internal Server Error' });
        return;
      }

      // Extract the counts from the results
      const employeeCount1 = results1[0].employee_count;
      const employeeCount2 = results2[0].employee_count;

      // Calculate the total employee count and send it as the API response
      const totalEmployeeCount = employeeCount1 + employeeCount2;
      res.json({ totalEmployeeCount });
    });
  });
});

//API endpoint for nbraid_daywise_active_employess_staff_absent
app.get('/nbraid_daywise_active_employees_staff_absent', (req, res) => {
  // Use a parameterized query to avoid SQL injection
  const query1 = `
    SELECT COUNT(*) AS employee_count
    FROM geopos_employees
    WHERE passive_type = 'ACT'
      AND workertype = 'DIRECT'
      AND status = 'A'
      AND employee_type = 'Staff'
      AND category_type = 'NBRAID'
  `;

  const query2 = `
    SELECT COUNT(*) AS employee_count
    FROM employees_ota
    WHERE passive_type = 'ACT'
      AND workertype = 'DIRECT'
      AND status = 'A'
      AND employee_type = 'Staff'
      AND category_type = 'NBRAID'
  `;

  // Execute the queries using the connection pool
  db.query(query1, (error, results1) => {
    if (error) {
      console.error(error);
      res.status(500).json({ error: 'Internal Server Error' });
      return;
    }

    db.query(query2, (err, results2) => {
      if (err) {
        console.error(err);
        res.status(500).json({ error: 'Internal Server Error' });
        return;
      }

      // Extract the counts from the results
      const employeeCount1 = results1[0].employee_count;
      const employeeCount2 = results2[0].employee_count;

      // Calculate the total employee count and send it as the API response
      const totalEmployeeCount = employeeCount1 + employeeCount2;
      res.json({ totalEmployeeCount });
    });
  });
});

//  API endpoint for nbraid_daywise_active_employess_contract
app.get('/nbraid_daywise_active_employees_contract', (req, res) => {
  // Use a parameterized query to avoid SQL injection
  const query1 = `
    SELECT COUNT(*) AS employee_count
    FROM geopos_employees
    WHERE passive_type = 'ACT'
      AND workertype = 'DIRECT'
      AND employee_type = 'Contract'
      AND category_type = 'NBRAID'
  `;

  const query2 = `
    SELECT COUNT(*) AS employee_count
    FROM employees_ota
    WHERE passive_type = 'ACT'
      AND workertype = 'DIRECT'
      AND employee_type = 'Contract'
      AND category_type = 'NBRAID'
  `;

  // Execute the queries using the connection pool
  db.query(query1, (error, results1) => {
    if (error) {
      console.error(error);
      res.status(500).json({ error: 'Internal Server Error' });
      return;
    }

    db.query(query2, (err, results2) => {
      if (err) {
        console.error(err);
        res.status(500).json({ error: 'Internal Server Error' });
        return;
      }

      // Extract the counts from the results
      const employeeCount1 = results1[0].employee_count;
      const employeeCount2 = results2[0].employee_count;

      // Calculate the total employee count and send it as the API response
      const totalEmployeeCount = employeeCount1 + employeeCount2;
      res.json({ totalEmployeeCount });
    });
  });
});

// API endpoint for nbraid_daywise_active_employees_contract_present
app.get('/nbraid_daywise_active_employees_contract_present', (req, res) => {
  // Use a parameterized query to avoid SQL injection
  const query1 = `
    SELECT COUNT(*) AS employee_count
    FROM geopos_employees
    WHERE passive_type = 'ACT'
      AND workertype = 'DIRECT'
      AND status = 'P'
      AND employee_type = 'Contract'
      AND category_type = 'NBRAID'
  `;

  const query2 = `
    SELECT COUNT(*) AS employee_count
    FROM employees_ota
    WHERE passive_type = 'ACT'
      AND workertype = 'DIRECT'
      AND status = 'P'
      AND employee_type = 'Contract'
      AND category_type = 'NBRAID'
  `;

  // Execute the queries using the connection pool
  db.query(query1, (error, results1) => {
    if (error) {
      console.error(error);
      res.status(500).json({ error: 'Internal Server Error' });
      return;
    }

    db.query(query2, (err, results2) => {
      if (err) {
        console.error(err);
        res.status(500).json({ error: 'Internal Server Error' });
        return;
      }

      // Extract the counts from the results
      const employeeCount1 = results1[0].employee_count;
      const employeeCount2 = results2[0].employee_count;

      // Calculate the total employee count and send it as the API response
      const totalEmployeeCount = employeeCount1 + employeeCount2;
      res.json({ totalEmployeeCount });
    });
  });
});

// API endpoint for nbraid_daywise_active_employess_contract_absent
app.get('/nbraid_daywise_active_employees_contract_absent', (req, res) => {
  // Use a parameterized query to avoid SQL injection
  const query1 = `
    SELECT COUNT(*) AS employee_count
    FROM geopos_employees
    WHERE passive_type = 'ACT'
      AND workertype = 'DIRECT'
      AND status = 'A'
      AND employee_type = 'Contract'
      AND category_type = 'NBRAID'
  `;

  const query2 = `
    SELECT COUNT(*) AS employee_count
    FROM employees_ota
    WHERE passive_type = 'ACT'
      AND workertype = 'DIRECT'
      AND status = 'A'
      AND employee_type = 'Contract'
      AND category_type = 'NBRAID'
  `;

  // Execute the queries using the connection pool
  db.query(query1, (error, results1) => {
    if (error) {
      console.error(error);
      res.status(500).json({ error: 'Internal Server Error' });
      return;
    }

    db.query(query2, (err, results2) => {
      if (err) {
        console.error(err);
        res.status(500).json({ error: 'Internal Server Error' });
        return;
      }

      // Extract the counts from the results
      const employeeCount1 = results1[0].employee_count;
      const employeeCount2 = results2[0].employee_count;

      // Calculate the total employee count and send it as the API response
      const totalEmployeeCount = employeeCount1 + employeeCount2;
      res.json({ totalEmployeeCount });
    });
  });
});



//  API endpoint for nbraid_daywise_active_employess_casual
app.get('/nbraid_daywise_active_employees_casual', (req, res) => {
  // Use a parameterized query to avoid SQL injection
  const query1 = `
    SELECT COUNT(*) AS employee_count
    FROM geopos_employees
    WHERE passive_type = 'ACT'
      AND workertype = 'DIRECT'
      AND employee_type = 'Casual'
      AND category_type = 'NBRAID'
  `;

  const query2 = `
    SELECT COUNT(*) AS employee_count
    FROM employees_ota
    WHERE passive_type = 'ACT'
      AND workertype = 'DIRECT'
      AND employee_type = 'Casual'
      AND category_type = 'NBRAID'
  `;

  // Execute the queries using the connection pool
  db.query(query1, (error, results1) => {
    if (error) {
      console.error(error);
      res.status(500).json({ error: 'Internal Server Error' });
      return;
    }

    db.query(query2, (err, results2) => {
      if (err) {
        console.error(err);
        res.status(500).json({ error: 'Internal Server Error' });
        return;
      }

      // Extract the counts from the results
      const employeeCount1 = results1[0].employee_count;
      const employeeCount2 = results2[0].employee_count;

      // Calculate the total employee count and send it as the API response
      const totalEmployeeCount = employeeCount1 + employeeCount2;
      res.json({ totalEmployeeCount });
    });
  });
});


// Define your API endpoint for nbraid_daywise_active_employees_casual_present
app.get('/nbraid_daywise_active_employees_casual_present', (req, res) => {
  // Use a parameterized query to avoid SQL injection
  const query1 = `
    SELECT COUNT(*) AS employee_count
    FROM geopos_employees
    WHERE passive_type = 'ACT'
      AND workertype = 'DIRECT'
      AND status = 'P'
      AND employee_type = 'Casual'
      AND category_type = 'NBRAID'
  `;

  const query2 = `
    SELECT COUNT(*) AS employee_count
    FROM employees_ota
    WHERE passive_type = 'ACT'
      AND workertype = 'DIRECT'
      AND status = 'P'
      AND employee_type = 'Casual'
      AND category_type = 'NBRAID'
  `;

  // Execute the queries using the connection pool
  db.query(query1, (error, results1) => {
    if (error) {
      console.error(error);
      res.status(500).json({ error: 'Internal Server Error' });
      return;
    }

    db.query(query2, (err, results2) => {
      if (err) {
        console.error(err);
        res.status(500).json({ error: 'Internal Server Error' });
        return;
      }

      // Extract the counts from the results
      const employeeCount1 = results1[0].employee_count;
      const employeeCount2 = results2[0].employee_count;

      // Calculate the total employee count and send it as the API response
      const totalEmployeeCount = employeeCount1 + employeeCount2;
      res.json({ totalEmployeeCount });
    });
  });
});

// Define your API endpoint for nbraid_daywise_active_employees_casual_absent
app.get('/nbraid_daywise_active_employees_casual_absent', (req, res) => {
  // Use a parameterized query to avoid SQL injection
  const query1 = `
    SELECT COUNT(*) AS employee_count
    FROM geopos_employees
    WHERE passive_type = 'ACT'
      AND workertype = 'DIRECT'
      AND status = 'A'
      AND employee_type = 'Casual'
      AND category_type = 'NBRAID'
  `;

  const query2 = `
    SELECT COUNT(*) AS employee_count
    FROM employees_ota
    WHERE passive_type = 'ACT'
      AND workertype = 'DIRECT'
      AND status = 'A'
      AND employee_type = 'Casual'
      AND category_type = 'NBRAID'
  `;

  // Execute the queries using the connection pool
  db.query(query1, (error, results1) => {
    if (error) {
      console.error(error);
      res.status(500).json({ error: 'Internal Server Error' });
      return;
    }

    db.query(query2, (err, results2) => {
      if (err) {
        console.error(err);
        res.status(500).json({ error: 'Internal Server Error' });
        return;
      }

      // Extract the counts from the results
      const employeeCount1 = results1[0].employee_count;
      const employeeCount2 = results2[0].employee_count;

      // Calculate the total employee count and send it as the API response
      const totalEmployeeCount = employeeCount1 + employeeCount2;
      res.json({ totalEmployeeCount });
    });
  });
});


// API endpoint for nbraid_daywise_active_employess_outsourcing
app.get('/nbraid_daywise_active_employees_outsourcing', (req, res) => {
  // Use a parameterized query to avoid SQL injection
  const query1 = `
    SELECT COUNT(*) AS employee_count
    FROM geopos_employees
    WHERE passive_type = 'ACT'
      AND workertype = 'DIRECT'
      AND employee_type = 'Outsourcing'
      AND category_type = 'NBRAID'
  `;

  const query2 = `
    SELECT COUNT(*) AS employee_count
    FROM employees_ota
    WHERE passive_type = 'ACT'
      AND workertype = 'DIRECT'
      AND employee_type = 'Outsourcing'
      AND category_type = 'NBRAID'
  `;

  // Execute the queries using the connection pool
  db.query(query1, (error, results1) => {
    if (error) {
      console.error(error);
      res.status(500).json({ error: 'Internal Server Error' });
      return;
    }

    db.query(query2, (err, results2) => {
      if (err) {
        console.error(err);
        res.status(500).json({ error: 'Internal Server Error' });
        return;
      }

      // Extract the counts from the results
      const employeeCount1 = results1[0].employee_count;
      const employeeCount2 = results2[0].employee_count;

      // Calculate the total employee count and send it as the API response
      const totalEmployeeCount = employeeCount1 + employeeCount2;
      res.json({ totalEmployeeCount });
    });
  });
});

// Define your API endpoint for nbraid_daywise_active_employees_outsourcing_present
app.get('/nbraid_daywise_active_employees_outsourcing_present', (req, res) => {
  // Use a parameterized query to avoid SQL injection
  const query1 = `
    SELECT COUNT(*) AS employee_count
    FROM geopos_employees
    WHERE passive_type = 'ACT'
      AND workertype = 'DIRECT'
      AND status = 'P'
      AND employee_type = 'Outsourcing'
      AND category_type = 'NBRAID'
  `;

  const query2 = `
    SELECT COUNT(*) AS employee_count
    FROM employees_ota
    WHERE passive_type = 'ACT'
      AND workertype = 'DIRECT'
      AND status = 'P'
      AND employee_type = 'Outsourcing'
      AND category_type = 'NBRAID'
  `;

  // Execute the queries using the connection pool
  db.query(query1, (error, results1) => {
    if (error) {
      console.error(error);
      res.status(500).json({ error: 'Internal Server Error' });
      return;
    }

    db.query(query2, (err, results2) => {
      if (err) {
        console.error(err);
        res.status(500).json({ error: 'Internal Server Error' });
        return;
      }

      // Extract the counts from the results
      const employeeCount1 = results1[0].employee_count;
      const employeeCount2 = results2[0].employee_count;

      // Calculate the total employee count and send it as the API response
      const totalEmployeeCount = employeeCount1 + employeeCount2;
      res.json({ totalEmployeeCount });
    });
  });
});

// Define your API endpoint for nbraid_daywise_active_employees_outsourcing_absent
app.get('/nbraid_daywise_active_employees_outsourcing_absent', (req, res) => {
  // Use a parameterized query to avoid SQL injection
  const query1 = `
    SELECT COUNT(*) AS employee_count
    FROM geopos_employees
    WHERE passive_type = 'ACT'
      AND workertype = 'DIRECT'
      AND status = 'A'
      AND employee_type = 'Outsourcing'
      AND category_type = 'NBRAID'
  `;

  const query2 = `
    SELECT COUNT(*) AS employee_count
    FROM employees_ota
    WHERE passive_type = 'ACT'
      AND workertype = 'DIRECT'
      AND status = 'A'
      AND employee_type = 'Outsourcing'
      AND category_type = 'NBRAID'
  `;

  // Execute the queries using the connection pool
  db.query(query1, (error, results1) => {
    if (error) {
      console.error(error);
      res.status(500).json({ error: 'Internal Server Error' });
      return;
    }

    db.query(query2, (err, results2) => {
      if (err) {
        console.error(err);
        res.status(500).json({ error: 'Internal Server Error' });
        return;
      }

      // Extract the counts from the results
      const employeeCount1 = results1[0].employee_count;
      const employeeCount2 = results2[0].employee_count;

      // Calculate the total employee count and send it as the API response
      const totalEmployeeCount = employeeCount1 + employeeCount2;
      res.json({ totalEmployeeCount });
    });
  });
});

// API endpoint for indirect_ikeja
app.get('/fetchindirectikeja', (req, res) => {
 
// Query to get the latest date from geopos_employees
  const latestDateQuery = 'SELECT date FROM geopos_employees ORDER BY id ASC LIMIT 1';

  // Execute the query using the connection pool
  db.query(latestDateQuery, (error, results) => {
    if (error) {
      console.error(error);
      res.status(500).json({ error: 'Internal Server Error' });
      return;
    }

    // Extract the date from the results
    const dt = results[0].date;

    // Use a parameterized query to avoid SQL injection
    const query = `
      SELECT COUNT(*) AS count
      FROM geopos_employees
      WHERE passive_type = 'ACT'
        AND workertype = 'INDIRECT'
        AND status = 'P'
        AND date = ?
    `;

    // Execute the main query using the connection pool
    db.query(query, [dt], (err, results) => {
      if (err) {
        console.error(err);
        res.status(500).json({ error: 'Internal Server Error' });
        return;
      }

      const totalCount = results[0].count;
      console.log('Total Count:', totalCount);
      res.send(results);
    });
  });
});

// API endpoint for indirect_ota
app.get('/fetchindirectota', (req, res) => {
  
  // Query to get the latest date from employees_ota
  const latestDateQuery = 'SELECT date FROM employees_ota ORDER BY id ASC LIMIT 1';

  // Execute the query using the connection pool
  db.query(latestDateQuery, (error, results) => {
    if (error) {
      console.error(error);
      res.status(500).json({ error: 'Internal Server Error' });
      return;
    }

    // Extract the date from the results
    const dt = results[0].date;

    // Use a parameterized query to avoid SQL injection
    const query = `
      SELECT COUNT(*) AS count
      FROM employees_ota
      WHERE passive_type = 'ACT'
        AND workertype = 'INDIRECT'
        AND status = 'P'
        AND date = ?
    `;

    // Execute the main query using the connection pool
    db.query(query, [dt], (err, results) => {
      if (err) {
        console.error(err);
        res.status(500).json({ error: 'Internal Server Error' });
        return;
      }

      const totalCount = results[0].count;
      console.log('Total Count:', totalCount);
      res.send(results);

      
    });
  });
});

// API endpoint for attrition_braid
app.get('/fetchattritionbraid', (req, res) => {
  // Get the current month and year
  const date = new Date().toLocaleDateString('en-GB', { timeZone: 'Africa/Lagos' });
  const parts = date.split('/');
  const formattedDay = parts[0].padStart(2, '0');
  const formattedMonth = parts[1].padStart(2, '0');
  const year = parts[2];
  const date1 = `${formattedDay}-${formattedMonth}-${year}`;
  const mon = `${formattedMonth}-${year}`;

  // Use a parameterized query to avoid SQL injection
  const query = `SELECT COUNT(*) AS count FROM geopos_employees_attrition WHERE SUBSTRING(exitdate, 4) = ?`;

  // Execute the query using the connection pool
  db.query(query, [mon], (error, results) => {
    if (error) {
      console.error(error);
      res.status(500).json({ error: 'Internal Server Error' });
      return;
    }

    const totalCount = results[0].count;
    console.log('Total Count:', totalCount);
    res.send(results);

   
  });
});

// API endpoint to get attrition_nbraid
app.get('/fetchattritionNbraid', (req, res) => {
  // Get the current month and year
  const date = new Date().toLocaleDateString('en-GB', { timeZone: 'Africa/Lagos' });
  const parts = date.split('/');
  const formattedDay = parts[0].padStart(2, '0');
  const formattedMonth = parts[1].padStart(2, '0');
  const year = parts[2];
  const date1 = `${formattedDay}-${formattedMonth}-${year}`;
  const mon = `${formattedMonth}-${year}`;

  // Use a parameterized query to avoid SQL injection
  const query = `SELECT COUNT(*) AS count FROM employees_ota_attrition WHERE SUBSTRING(exitdate, 4) = ?`;

  // Execute the query using the connection pool
  db.query(query, [mon], (error, results) => {
    if (error) {
      console.error(error);
      res.status(500).json({ error: 'Internal Server Error' });
      return;
    }

    const totalCount = results[0].count;
    console.log('Total Count:', totalCount);
    res.send(results);
  });
});



//--------------------------Attendance And Attrition Dashboard----------------------------------/

//----------------------------------Operator Login--------------------------------------------------//
//braid employeetimesheet
//add
app.get('/employee_detailso/:id', (req, res) => {
  const id = req.params.id;

  // Perform the database query
  const query = `
    SELECT *
    FROM operator_assign_ikeja
    WHERE operator_id = ? AND category_type = 'BRAID';
  `;

  db.query(query, [id], (err, results) => {
    if (err) {
      console.error('Error executing MySQL query:', err);
      res.status(500).json({ error: 'Internal Server Error' });
    } else {
      res.json(results);
    }
  });
});

// Define the API endpoint
app.get('/employee_detailso_nb/:id', (req, res) => {
  const id = req.params.id;

  // Perform the database query
  const query = `
    SELECT *
    FROM operator_assign
    WHERE operator_id = ? AND category_type = 'BRAID';
  `;

  db.query(query, [id], (err, results) => {
    if (err) {
      console.error('Error executing MySQL query:', err);
      res.status(500).json({ error: 'Internal Server Error' });
    } else {
      res.json(results);
    }
  });
});

// Define the API endpoint
app.get('/employee_details_nbraid/:id', (req, res) => {
  const id = req.params.id;

  // Perform the database query
  const query = `
    SELECT employees_ota.*, geopos_users.email, geopos_users.loc, geopos_users.roleid
    FROM employees_ota
    LEFT JOIN geopos_users ON employees_ota.entryid = geopos_users.entryid
    WHERE geopos_users.id = ? AND geopos_users.production_type = 'ota' AND geopos_users.banned = '0';
  `;

  db.query(query, [id], (err, result) => {
    if (err) {
      console.error('Error executing MySQL query:', err);
      res.status(500).json({ error: 'Internal Server Error' });
    } else {
      if (result.length > 0) {
        res.json(result[0]); // Assuming you want to return the first row if there are multiple matches
      } else {
        res.status(404).json({ error: 'Employee not found' });
      }
    }
  });
});

// Define the API endpoint
app.get('/employee_details/:id', (req, res) => {
  const id = req.params.id;

  // Perform the database query
  const query = `
    SELECT geopos_employees.*, geopos_users.email, geopos_users.loc, geopos_users.roleid
    FROM geopos_employees
    LEFT JOIN geopos_users ON geopos_employees.entryid = geopos_users.entryid
    WHERE geopos_users.id = ? AND geopos_users.production_type = 'ikeja' AND geopos_users.banned = '0';
  `;

  db.query(query, [id], (err, result) => {
    if (err) {
      console.error('Error executing MySQL query:', err);
      res.status(500).json({ error: 'Internal Server Error' });
    } else {
      if (result.length > 0) {
        const employeeData = result[0];

        
      const response = {
        timesheet: employeeData,
      };

        res.json(response);
      } else {
        res.status(404).json({ error: 'Employee not found' });
      }
    }
  });
});

//get sections for operator login
app.post('/getsectionsforaddemployeeoplogin', (req, res) => {
  let zone, shift, machine, cat, color;
  if (req.body) {
    cat = req.body.product_name;
    color = req.body.color_description;
    zone = req.body.zone;
    shift = req.body.shift;
    machine = req.body.machine1 + ',';
  }
  
  console.log('cat:', cat);
  console.log('Zone:', zone);
  console.log('Shift:', shift);
  console.log('Machine:', machine); 

  const date = new Date().toLocaleDateString('en-GB', { timeZone: 'Africa/Lagos' });
  const parts = date.split('/');
  const formattedDay = parts[0].padStart(2, '0');
  const formattedMonth = parts[1].padStart(2, '0');
  const year = parts[2];
  const date1 = `${formattedDay}-${formattedMonth}-${year}`;

  const query = 'SELECT * FROM item_section_ota WHERE item_id = ?';

  site = 'ikeja';
  ctype = 'BRAID';

  db.query(query, [cat], (error, results) => {
    if (error) {
      console.error('Error in initial query:', error);
      return res.status(500).json({ error: 'Internal Server Error' });
    }

    let output = '';
    let absent = '';
    let resolvedPromises = [];

    const processResults = (row, querya, querye) => {
      return new Promise((resolve, reject) => {
        db.query(querya, (errora, resultsa) => {
          if (errora) return reject(errora);

          resultsa.forEach(rowa => {
            absent += rowa.entryid + ',';
          });

          db.query(querye, (errore, resultse) => {
            if (errore) return reject(errore);

            //console.log('Result of querye:', resultse);

            const sectionQuery = `SELECT * FROM section WHERE id = ${row.section_id}`;
            db.query(sectionQuery, (errorSection, resultSection) => {
              if (errorSection) return reject(errorSection);

              const section = resultSection[0].section_name;
              const target = row.target;

              resultse.forEach(roww => {
              // Add section_name and target to the current row
              roww.section_name = resultSection[0].section_name;
              roww.target = row.target;

              // Add the modified row to the output array
              output += JSON.stringify(roww, null, 2);
              });

              resolve();
            });
          });
        });
      });
    };

    const sendResponseIfDone = () => {
      if (resolvedPromises.length === results.length) {
        const dataArray = {
          pr: output.replace(/\n/g, ''),
          ab: absent
        };
        //console.log('Sending response:', dataArray);
        res.json(dataArray);
      }
    };

    const promises = results.map(row => {
      let wherea, where, querya, querye;

      if (site === 'ota' && ctype =='BRAID') {
        wherea = `roleid != 3 AND zone='${zone}' AND shift='${shift}' AND machine LIKE '%${machine}%' AND status='A' AND workertype='DIRECT'`;
        where = `roleid != 3 AND zone='${zone}' AND shift='${shift}' AND machine LIKE '%${machine}%' AND status='P' AND workertype='DIRECT'`;
        querya = `SELECT * FROM employees_ota WHERE ${wherea} AND section_id = ${row.section_id}`;
        querye = `SELECT * FROM employees_ota WHERE ${where} AND section_id = ${row.section_id}`;
      } else if (site === 'ikeja' && ctype =='BRAID') {
        wherea = `roleid != 3 AND zone='${zone}' AND shift='${shift}' AND machine LIKE '%${machine}%' AND status='A' AND workertype='DIRECT'`;
        where = `roleid != 3 AND zone='${zone}' AND shift='${shift}' AND machine LIKE '%${machine}%' AND status='P' AND workertype='DIRECT'`;
        querya = `SELECT * FROM geopos_employees WHERE ${wherea} AND section_id = ${row.section_id}`;
        querye = `SELECT * FROM geopos_employees WHERE ${where} AND section_id = ${row.section_id}`;
      }

      return processResults(row, querya, querye)
        .then(() => {
          resolvedPromises.push(row); // Assuming each promise represents a row
        })
        .catch(error => {
          //console.error('Error processing results:', error);
          res.status(500).json({ error: 'Internal Server Error' });
        });
    });

    Promise.all(promises)
      .then(() => sendResponseIfDone())
      .catch(error => {
        //console.error('Error in Promise.all:', error);
        res.status(500).json({ error: 'Internal Server Error' });
      });
  });
});

//insert employee timesheet data for operator login
app.post('/insertemployeetimesheetfilterdataoplogin', (req, res) => {
  const receivedData = req.body;
  console.log('Received Form Data:', receivedData);

  const formDataToSend = receivedData[0];
  const { zone, machinec, shift, fdate } = formDataToSend;
  
  const date1 = fdate;
  const fdParts = date1.split('-');
  const fd = `${fdParts[2]}-${fdParts[1]}-${fdParts[0]}`;

  const dateObj = new Date(date1);
  const day = dateObj.getDate().toString().padStart(2, '0');
  const month = (dateObj.getMonth() + 1).toString().padStart(2, '0');
  const year = dateObj.getFullYear();

  const date = `${day}-${month}-${year}`;
  const date2 = `${month}-${year}`;

  const fd2 = Math.floor(new Date(date1).getTime() / 1000);


var dayy1 = fd2;

const originalDate = new Date(fdate);

const year1 = originalDate.getFullYear();
const month1 = String(originalDate.getMonth() + 1).padStart(2, '0');
const day1 = String(originalDate.getDate()).padStart(2, '0');
const hour = '12';
const minute = '00';
const second = '00';

const date3 = `${year1}-${month1}-${day1} ${hour}:${minute}:${second}`;

console.log('Date:', date);
console.log('date2:', date2);
console.log('dayy1:', dayy1);
console.log('date3:', date3);

 /* const dayy1 = '1700524800';
  const date2 = '11-2023';
  const date3 = '2023-11-21 12:00:00';*/

  const tableRowsData = receivedData.slice(1);

  const machineCondition = `machine LIKE '%${machinec}%'`;
  const whereConditionIndirect = `zone='${zone}' AND shift='${shift}' AND ${machineCondition} AND workertype='INDIRECT' AND status='P'`;
  const whereConditionDirect = `zone='${zone}' AND shift='${shift}' AND ${machineCondition} AND workertype='DIRECT' AND status='P'`;

  const queryIndirect = `SELECT * FROM geopos_employees WHERE ${whereConditionIndirect}`;
  const queryDirect = `SELECT * FROM geopos_employees WHERE ${whereConditionDirect}`;

  db.query(queryIndirect, (err, resultIndirect) => {
    if (err) throw err;

    let ire = 0;
    resultIndirect.forEach((ws) => {
      ire += parseFloat(ws.emp_count);
    });

    const roundedIre = parseFloat(ire.toFixed(4));
    console.log('roundedIre:', roundedIre); // Log the value of ire here

    db.query(queryDirect, (err, resultDirect) => {
      if (err) throw err;

      let dre = 0;
      resultDirect.forEach((ws1) => {
        dre += parseFloat(ws1.emp_count);
      });

      const roundeddre = parseFloat(dre.toFixed(4));
      console.log('roundeddre:', roundeddre); // Log the value of ire here

      const combinedData = {
        dataArray: [
          {
            ...formDataToSend,
            indirectCount: roundedIre,
            directCount: roundeddre,
            date,
            dayy1,
            date2,
            date3,
          },
          ...tableRowsData,
        ],
        dataArray1: tableRowsData,
      };

      // Call the function to perform MySQL operations
      performMySQLOperationsoplogin(combinedData, (mysqlErr, mysqlResult) => {
        if (mysqlErr) {
          console.error('MySQL operation failed:', mysqlErr);
      
          res.status(500).json({
            error: 'MySQL operation failed.',
            errorMessage: mysqlErr.message // Include the error message from mysqlErr
          });
        } else {
          res.json({ success: 'MySQL operation successful.', successMessage: mysqlResult });
        }
      });
    });
  });
});


function performMySQLOperationsoplogin(combinedData, callback) {
  // Log dataArray to the console
 // console.log('Received combinedData:', combinedData);

  const { emp_id, shift, item, color_id, zone, machine, machinec, hr_start, hr_end, fiber, fg_output, waste1, waste2, waste3, waste_weight, date, temp0, temp1, temp2, temp3, temp4, temp5, site, indirectCount, directCount, dayy1, date2, date3 } = combinedData.dataArray[0];

  const data = {
    emp_id: emp_id,
    shift: shift,
    item: item,
    color_id: color_id,
    zone: zone,
    machine: machine,
    hr_start: hr_start,
    hr_end: hr_end,
    fiber: fiber,
    fg_output: fg_output,
    waste1: waste1,
    waste2: waste2,
    waste3: waste3,
    waste_weight: waste_weight,
    date: date,
    timestamp: dayy1,
    datetime: date3,
    month: date2,
    iemp_count: indirectCount,
    demp_count: directCount,
    upper: temp0,
    lower: temp1,
    perheating: temp2,
    machine_speed: temp3,
    tension: temp4,
    spreading: temp5,
    site: site,
  };

  /* const { emp_ids, worker_names, section, target, section_id, completes } = combinedData.dataArray1;
  const empIdsArray = emp_ids.split(',').map(id => id.trim()); */

  const selectQuery = `SELECT * FROM geopos_operator WHERE hr_start = '${hr_start}' AND zone = '${zone}' AND machine = '${machine}' AND date = '${date}'`;

  console.log('selectQuery:', selectQuery);

  db.query(selectQuery, (selectError, selectResults) => {
    if (selectError) {
      res.json({ status: 'Error', message: 'Database error' });
    } else {
      const numRows = selectResults.length;
      console.log('selectResults:', selectResults);
      console.log('numRows:', numRows);

      if (numRows > 0) {
        const errorMessage = `Sorry, you have already entered ${hr_start} start hour for ${zone} and ${machine} on ${date}`;
        console.log('Error Message:', errorMessage);
        const errorResponse = {
          status: 'Error',
          message: errorMessage,
        };
       // Sending the error response to the client
         return callback(errorResponse);
      } else {
        const insertQuery = 'INSERT INTO geopos_operator SET ?';

        db.query(insertQuery, data, (insertError, insertResults) => {
          if (insertError) {
            res.json({ status: 'Error', message: 'Failed to insert data' });
          }
          else {
            const opid = insertResults.insertId;
            console.log('opid:', opid);
            const dataArray = combinedData.dataArray1;

              for (let i = 0; i < dataArray.length; i++) {
                const { emp_ids, worker_names, section, target, section_id, completes } = dataArray[i];
                const empIdsArray = emp_ids.split(',').map(id => id.trim());
                
                console.log('Emp IDs:', emp_ids);
                console.log('Worker Names:', worker_names);
                console.log('Section:', section);
                console.log('Target:', target);
                console.log('Section ID:', section_id);
                console.log('Completes:', completes);
              
              if (section) {
                const selectSectionQuery = 'SELECT * FROM geopos_operator ORDER BY id DESC LIMIT 1';

                db.query(selectSectionQuery, (selectSectionError, selectSectionResults) => {
                  const lastOperatorId = selectSectionResults[0].id;
                  console.log('lastOperatorId:', lastOperatorId);

                  //console.log('empIdsArray:', empIdsArray);

                  empIdsArray.forEach((emid, index) => {
                    const comp = completes;
                    console.log(`Before data1 construction (Index ${index}):`, worker_names, section_id, target);

                    const data1 = {
                      empid: emid,
                      opmanual_id: `${lastOperatorId},`,
                      section_id: section_id,
                      emp: worker_names,
                      target: target,
                      complete: `${comp},`,
                      date,
                      timestamp: dayy1,
                    };

                    console.log(`data1 (Index ${index}):`, data1);

                    const selectOperatorSectionQuery = 'SELECT * FROM operator_section WHERE empid = ? AND date = ?';
                    const selectOperatorSectionValues = [emid, date];

                    db.query(
                      selectOperatorSectionQuery,
                      selectOperatorSectionValues,
                      (selectOSQueryError, selectOSQueryResults) => {
                        const numOSRows = selectOSQueryResults.length;

                        if (numOSRows > 0) {
                          const cid = selectOSQueryResults[0].id;
                          const op = `${selectOSQueryResults[0].opmanual_id}${opid},`;
                          const cm = `${selectOSQueryResults[0].complete}${comp},`;

                          const updateOperatorSectionQuery =
                            'UPDATE operator_section SET opmanual_id = ?, complete = ? WHERE id = ?';
                          const updateOperatorSectionValues = [op, cm, cid];

                          db.query(
                            updateOperatorSectionQuery,
                            updateOperatorSectionValues,
                            (updateOSError) => {
                              if (updateOSError) {
                                console.error(updateOSError);
                              }
                            }
                          );
                        } else {
                          const insertOperatorSectionQuery = 'INSERT INTO operator_section SET ?';

                          db.query(
                            insertOperatorSectionQuery,
                            data1,
                            (insertOSQueryError) => {
                              if (insertOSQueryError) {
                                console.error(insertOSQueryError);
                              }
                            }
                          );
                        }
                      }
                    );
                  });
                });
              }
            } 
            // Send success message to the client
            const successMessage = 'Details added successfully!';
            return callback(null, successMessage);
          }
        });
      }
    }
  });
}

// Get the default employee data for current date
app.get('/getdefaultemployeetimesheetdatabraidoplogin/:userid', (req, res) => {
  const roleid = 3;
  const { userid } = req.params;

  const date = new Date().toLocaleDateString('en-GB', { timeZone: 'Africa/Lagos' });
  const parts = date.split('/');
  const formattedDay = parts[0].padStart(2, '0');
  const formattedMonth = parts[1].padStart(2, '0');
  const year = parts[2];
  const date1 = `${formattedDay}-${formattedMonth}-${year}`;

  console.log('Received data:');
  console.log('Date:', date1);
  console.log('userid:', userid);

  let query;

  if (roleid === 5) {
    const query1 = `
      SELECT geopos_operator.*, geopos_employees.name, geopos_employees.entryid, geopos_employees.workertype, item_masterr.item_description, color_master.color_name
      FROM geopos_operator
      LEFT JOIN geopos_employees ON geopos_employees.id = geopos_operator.emp_id
      LEFT JOIN item_masterr ON geopos_operator.item = item_masterr.id
      LEFT JOIN color_master ON geopos_operator.color_id = color_master.id
      WHERE geopos_operator.date = ? AND geopos_operator.site = 'ikeja'
    `;

    const query2 = `
      SELECT geopos_operator.*, employees_ota.name, employees_ota.entryid, employees_ota.workertype, item_masterr.item_description, color_master.color_name
      FROM geopos_operator
      LEFT JOIN employees_ota ON employees_ota.id = geopos_operator.emp_id
      LEFT JOIN item_masterr ON geopos_operator.item = item_masterr.id
      LEFT JOIN color_master ON geopos_operator.color_id = color_master.id
      WHERE geopos_operator.date = ? AND geopos_operator.site = 'ota'
    `;

    query = `${query1} UNION ${query2}`;
  } else {
    const id2 = userid;

    db.query('SELECT * FROM geopos_users WHERE id = ?', [id2], (err, userData) => {
      if (err) {
        console.error('Error querying the database:', err);
        res.status(500).json({ error: 'Internal Server Error' });
        return;
      }

      const site = userData[0].production_type;
      const ctype = userData[0].category_type;

      console.log('site:', site);
      console.log('ctype:', ctype);

      if (site === 'ikeja' && ctype === 'BRAID') {
        const userQuery = `
          SELECT geopos_employees.*
          FROM geopos_employees
          LEFT JOIN geopos_users ON geopos_employees.entryid = geopos_users.entryid
          WHERE geopos_users.id = ?;
        `;

        db.query(userQuery, [id2], (err, rows) => {
          if (err) {
            console.error('Error querying the database:', err);
            res.status(500).json({ error: 'Internal Server Error' });
            return;
          }

          const id = rows[0].id;
          const query = `
            SELECT geopos_operator.*, geopos_employees.name, geopos_employees.entryid, geopos_employees.workertype, item_masterr.item_description, color_master.color_name
            FROM geopos_operator
            LEFT JOIN geopos_employees ON geopos_employees.id = geopos_operator.emp_id
            LEFT JOIN item_masterr ON item_masterr.id = geopos_operator.item
            LEFT JOIN color_master ON color_master.id = geopos_operator.color_id
            WHERE geopos_operator.date = ? AND geopos_operator.emp_id = ?
            ORDER BY id DESC
            LIMIT 1
          `;

          db.query(query, [date1, id], (err, results) => {
            if (err) {
              console.error('Error executing SQL query:', err);
              res.status(500).json({ error: 'Internal server error' });
            } else {
              const data = {
                timesheet: results,
              };
              res.json(data);
            }
          });
        });
      }

      if (site === 'ota' && ctype === 'BRAID') {
        db.query(
          'SELECT employees_ota.* FROM employees_ota ' +
            'LEFT JOIN geopos_users ON employees_ota.entryid = geopos_users.entryid ' +
            'WHERE geopos_users.id = ?',
          [id2],
          (err, result) => {
            if (err) {
              console.error('Error querying the database:', err);
              res.status(500).json({ error: 'Internal Server Error' });
              return;
            }

            const id = result[0].id;
            const query = `
              SELECT geopos_operator.*, employees_ota.name, employees_ota.entryid, employees_ota.workertype, item_masterr.item_description, color_master.color_name
              FROM geopos_operator
              LEFT JOIN employees_ota ON employees_ota.id = geopos_operator.emp_id
              LEFT JOIN item_masterr ON item_masterr.id = geopos_operator.item
              LEFT JOIN color_master ON color_master.id = geopos_operator.color_id
              WHERE geopos_operator.date = ? AND geopos_operator.emp_id = ?
              ORDER BY id DESC
              LIMIT 1
            `;

            db.query(query, [date1, id], (err, results) => {
              if (err) {
                console.error('Error executing SQL query:', err);
                res.status(500).json({ error: 'Internal server error' });
              } else {
                const data = {
                  timesheet: results,
                };
                res.json(data);
              }
            });
          }
        );
      }
    });
  }

});


//----------------------------------Operator Login--------------------------------------------------//

//in page double click update cells
app.post('/updatetimesheet1', (req, res) => {
  // The JSON data sent from the client will be available in req.body
  const dataReceived = req.body;
  // Access the 'id' from the received data
  const id = dataReceived.id;
  const field = dataReceived.field;
  let value = dataReceived.value;
  if (value === '' || value === null || value === undefined) {
    value = 0;
    console.log('Value is empty, null, or undefined');
  }
  console.log('id:', id);
  console.log('field:', field);
  console.log('value:', value);

  const query = `UPDATE worker_timesheet set ${field}=${value} where id=${id}`;
  console.log(query);
  db.query(query, function (err, result) {
    if (err) {
      console.log(err);
      res.status(500).json({ error: 'An error occurred while updating the user.' });
    } else {
      console.log(result);
      res.json({ message: 'updated successfully.' });
    }
  });
});

app.post('/updatetimesheet', (req, res) => {
  // The JSON data sent from the client will be available in req.body
  const dataReceived = req.body;
  // Access the 'id' from the received data
  const id = dataReceived.id;
  const field = dataReceived.field;
  let value = dataReceived.value;
  
  // Parse value to an integer
  value = parseInt(value, 10);

  // Check if value is NaN after parsing, then set it to 0
  if (isNaN(value)) {
      value = 0;
      console.log('Value is empty, null, undefined, or not a number');
  }
  
  const target = dataReceived.totalTargetForAllHours;
  const actualtarget = dataReceived.totalActualTargetForAllHours;
  let hourColumnsCount = dataReceived.hourColumnsCount;
  
  console.log('id:', id);
  console.log('field:', field);
  console.log('value:', value);
  console.log('hourColumnsCount:', hourColumnsCount);
  console.log('target:', target);
  console.log('actualtarget:', actualtarget);

  // Declare newTarget variable
  let newTarget;

  console.log('Before calculation - value:', value, 'target:', target, 'actualtarget:', actualtarget);
  if (value > 0) {
      hourColumnsCount++;
      newTarget = parseInt(target, 10) + parseInt(actualtarget, 10); // Increase target if value > 0
      console.log('Increasing target:', newTarget);
  } else if (value === 0) {
      hourColumnsCount--;
      newTarget = parseInt(target, 10) - parseInt(actualtarget, 10); // Adjust target based on actualtarget when value = 0
      console.log('Decreasing target:', newTarget);
  } else {
      console.log('Value is neither greater than 0 nor equal to 0');
  }
  console.log('After calculation - newTarget:', newTarget, 'hourColumnsCount:', hourColumnsCount);
  
  const query = `UPDATE worker_timesheet SET ${field}=${value}, target=${newTarget} WHERE id=${id}`;
  console.log(query);
  db.query(query, function (err, result) {
      if (err) {
          console.log(err);
          res.status(500).json({ error: 'An error occurred while updating the user.' });
      } else {
          console.log(result);
          res.json({ message: 'updated successfully.' });
      }
  });
});

//Performance eff individual Report 
app.get('/report/nbraid/getEmployeesikeja', (req, res) => {
  db.query('SELECT * FROM worker_timesheet WHERE site="ikeja" GROUP BY entry_id ORDER BY worker ASC', (err, result) => {
    if (err) {
      console.error('Error executing MySQL query:', err);
      res.status(500).send('Internal Server Error');
      return;
    }
    res.send(result);
  });
});

app.get('/report/nbraid/getEmployeesota', (req, res) => {
  db.query('SELECT * FROM worker_timesheet WHERE site="ota" GROUP BY entry_id ORDER BY worker ASC', (err, result) => {
    if (err) {
      console.error('Error executing MySQL query:', err);
      res.status(500).send('Internal Server Error');
      return;
    }
    res.send(result);
  });
});


//Get assign operator worker list
app.get('/get_assigned_zone_machine/:userid', (req, res) => {
  const { userid } = req.params;
  const { ptype, ctype } = req.query;

  console.log('Received request with the following parameters:');
  console.log('userid:', userid);
  console.log('ptype:', ptype);
  console.log('ctype:', ctype); 

  let query;

  if (ptype === 'ikeja' && ctype === 'BRAID') {
    query = `
      SELECT *
      FROM operator_assign_ikeja
      WHERE operator_id = ? AND category_type = 'BRAID';
    `;
  } else if (ptype === 'ikeja' && ctype === 'NBRAID') {
    // Define query for ikeja and NBRAID
    query = `
    SELECT *
    FROM operator_assign_ikeja
    WHERE operator_id = ? AND category_type = 'NBRAID';
  `;
  } else if (ptype === 'ota' && ctype === 'BRAID') {
    // Define query for otherType and otherCategory
    
    query = `
    SELECT operator_assign.shift,operator_assign.line,section.section_name FROM operator_assign  LEFT JOIN section ON operator_assign.section = section.id WHERE name_id=? AND category_type = 'BRAID'
    `;
  } else {
    // Default query if no specific conditions match
    query = `
    SELECT operator_assign.shift,operator_assign.line,section.section_name FROM operator_assign  LEFT JOIN section ON operator_assign.section = section.id WHERE name_id=? AND category_type = 'NBRAID'
    `;
  }

  // Execute the constructed query
  db.query(query, [userid], (err, results) => {
    if (err) {
      console.error('Error executing query:', err);
      res.status(500).json({ error: 'Internal Server Error' });
    } else {
      console.log('results:', results);
      res.json(results);
    }
  });
});

//Performance eff individual Report 
app.get('/report/nbraid/getEmployeesikeja', (req, res) => {
  db.query('SELECT * FROM worker_timesheet WHERE site="ikeja" GROUP BY entry_id ORDER BY worker ASC', (err, result) => {
    if (err) {
      console.error('Error executing MySQL query:', err);
      res.status(500).send('Internal Server Error');
      return;
    }
    res.send(result);
  });
});

//---------------------------------Get Attendance----------------------------------------//
const conConfig1 = {
  host: '197.255.216.211',
  user: 'lorna',
  password: 'lorna123',
  database: 'access'
};
const con1 = mysql.createConnection(conConfig1);
con1.connect(err => {
  if (err) {
    //console.error('Could not connect to first database:', err);
    process.exit(1);
  }
  //console.log('Connected to the first database');
});

const conConfig2 = {
  host: '197.255.216.212',
  user: 'lorna', // Provide the correct username for the second database
  password: 'lorna123', // Provide the correct password for the second database
  database: 'access',
};

const con2 = mysql.createConnection(conConfig2);
con2.connect(err => {
  if (err) {
    //console.error('Could not connect to second database:', err);
    process.exit(1);
  }
  //console.log('Connected to the second database');
});

//get attendance for lorna and ril
app.get('/getattendance', async (req, res) => {
  try {
    const timezone = 'Africa/Lagos';
    const currentDate = new Date();
    const formatter = new Intl.DateTimeFormat('en-GB', { timeZone: timezone });
    const formattedDate0 = formatter.formatToParts(currentDate).reduce((acc, part) => {
      if (part.type === 'year' || part.type === 'month' || part.type === 'day') {
        acc += part.value;
      }
      return acc;
    }, '');
    const formattedDate1 = `${formattedDate0.substring(4, 8)}${formattedDate0.substring(2, 4)}${formattedDate0.substring(0, 2)}`;
    const formatDateDMY = (date) => {
      const day = date.getDate().toString().padStart(2, '0');
      const month = (date.getMonth() + 1).toString().padStart(2, '0');
      const year = date.getFullYear();
      return `${day}-${month}-${year}`;
    };
    const formattedDate = formatDateDMY(currentDate);
    const unixTimestamp = currentDate.getTime();

    console.log(formattedDate1);
    console.log(formattedDate);
    console.log(unixTimestamp);

    const [rows] = await queryDatabase(db, `SELECT * FROM employees_ota ORDER BY id ASC LIMIT 1`);
    const erow = rows;
    console.log("erow:", erow);

    if (erow && erow.date !== formattedDate) {
      const updateQuery = `UPDATE employees_ota SET passive_type='RS', status='A', date='${formattedDate}'`;
      await queryDatabase(db, updateQuery);
    }

    // Perform operations on the second database (tuser table)
    const tuserQuery = "SELECT * FROM tuser WHERE PassiveType='ACT' AND dept LIKE 'Ota_%'";
    const tuserResult = await queryDatabase(con1, tuserQuery);

    for (const row of tuserResult) {
      let emp_type = '';

      if (row.idno === 'A - LNL STAFF' || row.idno === 'E - GNL STAFF') {
        emp_type = 'Staff';
      } else if (row.idno === 'M - GNL/LNL CON' || row.idno === 'C - LNL CONTRACT' || row.idno === 'I - GNL CONTRACT') {
        emp_type = 'Contract';
      } else if (row.idno === 'P - FACTORY CASUAL') {
        emp_type = 'Casual';
      } else if (row.idno === 'OUTSOURCING') {
        emp_type = 'Outsourcing';
      }

      const regDate = new Date(row.reg_date.replace(/(\d{4})(\d{2})(\d{2})(\d{2})(\d{2})/, '$1-$2-$3T$4:$5:00'));
      const day = regDate.getDate().toString().padStart(2, '0');
      const month = (regDate.getMonth() + 1).toString().padStart(2, '0');
      const year = regDate.getFullYear();
      const rdate = `${day}-${month}-${year}`;
      //console.log('rdate:', rdate);

      const geoposQuery = `SELECT * FROM employees_ota WHERE entryid='${row.id}'`;
      const geoposResult = await queryDatabase(db, geoposQuery);

      if (geoposResult.length > 0) {
        const updateQuery = `UPDATE employees_ota SET employee_type='${emp_type}', passive_type='${row.PassiveType}', joindate='${rdate}', dept='${row.dept}', name='${row.name}', new_staff='LORNA', staff='LORNA' WHERE entryid='${row.id}'`;
        await queryDatabase(db, updateQuery);
      } else {
        const insertQuery = `INSERT INTO employees_ota (entryid, name, passive_type, workertype, joindate, dept, roleid, staff, category_type, employee_type) VALUES('${row.id}', '${row.name}', '${row.PassiveType}', 'DIRECT', '${rdate}' , '${row.dept}', '1','LORNA','NBRAID', '${emp_type}')`;
        await queryDatabase(db, insertQuery);
      }
    }

     // Perform operations  for ril
     const tuserQuery1 = "SELECT * FROM tuser WHERE PassiveType='ACT' ";
     const tuserResult1 = await queryDatabase(con2, tuserQuery1);
 
     for (const rowr of tuserResult1) {
      const regDate = new Date(rowr.reg_date.replace(/(\d{4})(\d{2})(\d{2})(\d{2})(\d{2})/, '$1-$2-$3T$4:$5:00'));
      const day = regDate.getDate().toString().padStart(2, '0');
      const month = (regDate.getMonth() + 1).toString().padStart(2, '0');
      const year = regDate.getFullYear();
      const rdate = `${day}-${month}-${year}`;
    
      const geoposQuery1 = `SELECT * FROM employees_ota WHERE entryid='${rowr.id}'`;
      const geoposResult1 = await queryDatabase(db, geoposQuery1);
    
      if (geoposResult1.length > 0) {
        const updateQuery3 = `UPDATE employees_ota SET employee_type='Outsourcing', passive_type='${rowr.PassiveType}', joindate='${rdate}', dept='${rowr.dept}', name='${rowr.name}', new_staff='RIL', staff='RIL' WHERE entryid='${rowr.id}'`;
        await queryDatabase(db, updateQuery3);
      } else {
        const insertQuery3 = `INSERT INTO employees_ota (entryid, name, passive_type, workertype, joindate, dept, roleid, staff, category_type, employee_type) VALUES('${rowr.id}', '${rowr.name}', '${rowr.PassiveType}', 'DIRECT', '${rdate}' , '${rowr.dept}', '1','RIL','NBRAID', 'Outsourcing')`;
        await queryDatabase(db, insertQuery3);
      }
    }
    
         

    const attendanceQuery = `SELECT * FROM attendancemigrate WHERE dept LIKE '%OTA%'`;
    const attendanceResult = await queryDatabase(con1, attendanceQuery);

    for (const rowx of attendanceResult) {
      const updateQuery = `UPDATE employees_ota SET status='P', date='${formattedDate}' WHERE entryid='${rowx.id}'`;
      await queryDatabase(db, updateQuery);
    }

    const attendanceQuery1 = `SELECT * FROM attendancemigrate WHERE company LIKE '%OTA%'`;
    const attendanceResult1 = await queryDatabase(con2, attendanceQuery1);

    for (const rowxr of attendanceResult1) {
      const updateQuery1 = `UPDATE employees_ota SET status='P', date='${formattedDate}' WHERE entryid='${rowxr.id}'`;
      await queryDatabase(db, updateQuery1);
    }

    
    res.json("Yes");
  } catch (error) {
    console.error('Error:', error.message);
    res.json("No");
  } finally {
    con1.end();
  }
});
function queryDatabase(connection, sql) {
  return new Promise((resolve, reject) => {
    connection.query(sql, (err, result) => {
      if (err) {
        reject(err);
      } else {
        resolve(result);
      }
    });
  });
}



//get attendance for ikeja
 app.get('/getattendanceikeja', async (req, res) => {
  try {
    const timezone = 'Africa/Lagos';
    const currentDate = new Date();
    const formatter = new Intl.DateTimeFormat('en-GB', { timeZone: timezone });
    const formattedDate0 = formatter.formatToParts(currentDate).reduce((acc, part) => {
      if (part.type === 'year' || part.type === 'month' || part.type === 'day') {
        acc += part.value;
      }
      return acc;
    }, '');
    const formattedDate1 = `${formattedDate0.substring(4, 8)}${formattedDate0.substring(2, 4)}${formattedDate0.substring(0, 2)}`;
    const formatDateDMY = (date) => {
      const day = date.getDate().toString().padStart(2, '0');
      const month = (date.getMonth() + 1).toString().padStart(2, '0');
      const year = date.getFullYear();
      return `${day}-${month}-${year}`;
    };
    const formattedDate = formatDateDMY(currentDate);
    const unixTimestamp = currentDate.getTime();

    console.log(formattedDate1);
    console.log(formattedDate);
    console.log(unixTimestamp);

    const [rows] = await queryDatabase(db, `SELECT * FROM geopos_employees ORDER BY id ASC LIMIT 1`);
    const erow = rows;
    console.log("erow:", erow);

    if (erow && erow.date !== formattedDate) {
      const updateQuery = `UPDATE geopos_employees SET passive_type='RS', status='A', date='${formattedDate}'`;
      await queryDatabase(db, updateQuery);
    }

    // Perform operations on the second database (tuser table)
    const tuserQuery = "SELECT * FROM tuser WHERE PassiveType='ACT' AND dept LIKE 'Braid_%'";
    const tuserResult = await queryDatabase(con1, tuserQuery);

    for (const row of tuserResult) {
      let emp_type = '';

      if (row.idno === 'A - LNL STAFF' || row.idno === 'E - GNL STAFF') {
        emp_type = 'Staff';
      } else if (row.idno === 'M - GNL/LNL CON' || row.idno === 'C - LNL CONTRACT' || row.idno === 'I - GNL CONTRACT') {
        emp_type = 'Contract';
      } else if (row.idno === 'P - FACTORY CASUAL') {
        emp_type = 'Casual';
      } else if (row.idno === 'OUTSOURCING') {
        emp_type = 'Outsourcing';
      }

      const geoposQuery = `SELECT * FROM geopos_employees WHERE entryid='${row.id}'`;
      const geoposResult = await queryDatabase(db, geoposQuery);

      if (geoposResult.length > 0) {
        const updateQuery = `UPDATE geopos_employees SET employee_type='${emp_type}', passive_type='${row.PassiveType}', dept='${row.dept}' WHERE entryid='${row.id}'`;
        await queryDatabase(db, updateQuery);
      } else {
        const insertQuery = `INSERT INTO geopos_employees (entryid, name, passive_type, dept, roleid, category_type, employee_type) VALUES('${row.id}', '${row.name}', '${row.PassiveType}', '${row.dept}', '1', 'BRAID', '${emp_type}')`;
        await queryDatabase(db, insertQuery);
      }
    }

    const attendanceQuery = `SELECT * FROM attendancemigrate WHERE dept LIKE '%braid%'`;
    const attendanceResult = await queryDatabase(con1, attendanceQuery);

    for (const rowx of attendanceResult) {
      const updateQuery = `UPDATE geopos_employees SET status='P', date='${formattedDate}' WHERE entryid='${rowx.id}'`;
      await queryDatabase(db, updateQuery);
    }

    
    res.json("Yes");
  } catch (error) {
    console.error('Error:', error.message);
    res.json("No");
  } finally {
    con1.end();
  }
});


//Performance eff individual Report 
app.get('/report/nbraid/getEmployeesikeja', (req, res) => {
  db.query('SELECT * FROM worker_timesheet WHERE site="ikeja" GROUP BY entry_id ORDER BY worker ASC', (err, result) => {
    if (err) {
      console.error('Error executing MySQL query:', err);
      res.status(500).send('Internal Server Error');
      return;
    }
    res.send(result);
  });
});


/**********************************Get Attendance*********************************************/

 app.listen(4000);
console.log("Server Started : http://192.168.29.60:4000"); 

